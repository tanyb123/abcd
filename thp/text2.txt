// src/api/attendanceService.js

import {
  doc,
  getDoc,
  setDoc,
  updateDoc,
  serverTimestamp,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';

/**
 * Utility to get YYYY-MM-DD formatted date string in local timezone.
 * @param {Date} [dateObj]
 */
const formatDate = (dateObj = new Date()) => {
  const year = dateObj.getFullYear();
  const month = String(dateObj.getMonth() + 1).padStart(2, '0');
  const day = String(dateObj.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};

/**
 * Build document reference for a user & date (defaults to today)
 */
const attendanceDocRef = (userId, dateStr = formatDate()) =>
  doc(db, 'attendance', `${userId}_${dateStr}`);

/**
 * Fetch today (or specific date) attendance for a user
 * @param {string} userId
 * @param {string} [dateStr] formatted YYYY-MM-DD
 */
export const getAttendance = async (userId, dateStr = formatDate()) => {
  const ref = attendanceDocRef(userId, dateStr);
  const snap = await getDoc(ref);
  if (snap.exists()) {
    return { id: snap.id, ...snap.data() };
  }
  return null;
};

/**
 * Clock in: set clockIn timestamp if not already set.
 * Returns updated attendance document.
 */
export const clockIn = async (userId, timestamp = new Date()) => {
  const dateStr = formatDate(timestamp);
  const ref = attendanceDocRef(userId, dateStr);
  const data = {
    userId,
    date: dateStr,
    clockIn: timestamp,
    updatedAt: serverTimestamp(),
  };

  const existing = await getDoc(ref);
  if (existing.exists()) {
    // Only set clockIn if not yet recorded
    if (!existing.data().clockIn) {
      await updateDoc(ref, data);
    }
  } else {
    data.createdAt = serverTimestamp();
    await setDoc(ref, data);
  }
  return (await getDoc(ref)).data();
};

/**
 * Clock out: set clockOut timestamp.
 */
export const clockOut = async (userId, timestamp = new Date()) => {
  const dateStr = formatDate(timestamp);
  const ref = attendanceDocRef(userId, dateStr);
  const data = {
    clockOut: timestamp,
    updatedAt: serverTimestamp(),
  };
  const existing = await getDoc(ref);
  if (existing.exists()) {
    await updateDoc(ref, data);
  } else {
    // In case user forget to clock in, create new doc
    await setDoc(ref, {
      userId,
      date: dateStr,
      clockOut: timestamp,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
    });
  }
  return (await getDoc(ref)).data();
};

/**
 * Add / update overtime hours (floating number of hours)
 */
export const addOvertime = async (userId, hours, timestamp = new Date()) => {
  const dateStr = formatDate(timestamp);
  const ref = attendanceDocRef(userId, dateStr);
  const existing = await getDoc(ref);
  if (existing.exists()) {
    await updateDoc(ref, {
      overtime: hours,
      updatedAt: serverTimestamp(),
    });
  } else {
    await setDoc(ref, {
      userId,
      date: dateStr,
      overtime: hours,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
    });
  }
  return (await getDoc(ref)).data();
};

/**
 * Mark presence boolean for the day (mass attendance)
 */
export const setPresence = async (
  userId,
  present = true,
  timestamp = new Date()
) => {
  const dateStr = formatDate(timestamp);
  const ref = attendanceDocRef(userId, dateStr);
  const existing = await getDoc(ref);
  if (existing.exists()) {
    await updateDoc(ref, {
      present,
      updatedAt: serverTimestamp(),
    });
  } else {
    await setDoc(ref, {
      userId,
      date: dateStr,
      present,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
    });
  }
  return (await getDoc(ref)).data();
};

/**
 * Utility to determine current status for UI
 * Returns: 'none' | 'clocked_in' | 'clocked_out'
 */
export const getAttendanceStatus = (attendanceDoc) => {
  if (!attendanceDoc) return 'none';
  if (attendanceDoc.clockIn && !attendanceDoc.clockOut) return 'clocked_in';
  if (attendanceDoc.clockIn && attendanceDoc.clockOut) return 'clocked_out';
  return 'none';
};

//src/api/customerService.js
import {
  collection,
  addDoc,
  updateDoc,
  deleteDoc,
  doc,
  query,
  orderBy,
  getDocs,
  getDoc,
  where,
  serverTimestamp,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';

/**
 * Tạo khách hàng mới
 * @param {Object} customerData - Dữ liệu khách hàng
 * @param {string} userId - ID của người dùng tạo khách hàng
 * @returns {Promise<Object>} - Khách hàng đã tạo kèm ID
 */
export const createCustomer = async (customerData, userId) => {
  try {
    const docRef = await addDoc(collection(db, 'customers'), {
      ...customerData,
      createdAt: serverTimestamp(),
      createdBy: userId,
      updatedAt: serverTimestamp(),
    });

    return {
      id: docRef.id,
      ...customerData,
    };
  } catch (error) {
    throw error;
  }
};

/**
 * Lấy tất cả khách hàng
 * @returns {Promise<Array>} - Mảng khách hàng
 */
export const getCustomers = async () => {
  try {
    const customersRef = collection(db, 'customers');
    const q = query(customersRef, orderBy('createdAt', 'desc'));
    const querySnapshot = await getDocs(q);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    throw error;
  }
};

/**
 * Lấy khách hàng theo ID
 * @param {string} customerId - ID khách hàng
 * @returns {Promise<Object|null>} - Dữ liệu khách hàng hoặc null nếu không tìm thấy
 */
export const getCustomerById = async (customerId) => {
  try {
    const customerRef = doc(db, 'customers', customerId);
    const customerSnapshot = await getDoc(customerRef);

    if (customerSnapshot.exists()) {
      return {
        id: customerSnapshot.id,
        ...customerSnapshot.data(),
      };
    } else {
      return null;
    }
  } catch (error) {
    throw error;
  }
};

/**
 * Cập nhật thông tin khách hàng
 * @param {string} customerId - ID khách hàng
 * @param {Object} customerData - Dữ liệu khách hàng cập nhật
 * @param {string} userId - ID của người dùng cập nhật khách hàng
 * @returns {Promise<void>}
 */
export const updateCustomer = async (customerId, customerData, userId) => {
  try {
    const customerRef = doc(db, 'customers', customerId);
    await updateDoc(customerRef, {
      ...customerData,
      updatedAt: serverTimestamp(),
      updatedBy: userId,
    });
  } catch (error) {
    throw error;
  }
};

/**
 * Xóa khách hàng
 * @param {string} customerId - ID khách hàng
 * @returns {Promise<void>}
 */
export const deleteCustomer = async (customerId) => {
  try {
    const customerRef = doc(db, 'customers', customerId);
    await deleteDoc(customerRef);
  } catch (error) {
    throw error;
  }
};

/**
 * Tìm kiếm khách hàng theo tên hoặc người liên hệ
 * @param {string} searchTerm - Từ khóa tìm kiếm
 * @returns {Promise<Array>} - Mảng khách hàng phù hợp
 */
export const searchCustomers = async (searchTerm) => {
  try {
    const customersRef = collection(db, 'customers');
    const nameQuery = query(
      customersRef,
      where('name', '>=', searchTerm),
      where('name', '<=', searchTerm + '\uf8ff')
    );
    const contactQuery = query(
      customersRef,
      where('contactPerson', '>=', searchTerm),
      where('contactPerson', '<=', searchTerm + '\uf8ff')
    );

    const [nameSnapshot, contactSnapshot] = await Promise.all([
      getDocs(nameQuery),
      getDocs(contactQuery),
    ]);

    // Kết hợp kết quả và loại bỏ trùng lặp
    const results = new Map();

    nameSnapshot.docs.forEach((doc) => {
      results.set(doc.id, { id: doc.id, ...doc.data() });
    });

    contactSnapshot.docs.forEach((doc) => {
      if (!results.has(doc.id)) {
        results.set(doc.id, { id: doc.id, ...doc.data() });
      }
    });

    return Array.from(results.values());
  } catch (error) {
    throw error;
  }
};

/**
 * Lấy khách hàng theo loại
 * @param {string} type - Loại khách hàng (potential, regular, vip)
 * @returns {Promise<Array>} - Mảng khách hàng thuộc loại đã chỉ định
 */
export const getCustomersByType = async (type) => {
  try {
    const customersRef = collection(db, 'customers');
    const q = query(
      customersRef,
      where('type', '==', type),
      orderBy('createdAt', 'desc')
    );

    const querySnapshot = await getDocs(q);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    throw error;
  }
};

//src/api/googleDriveService.js
import axios from 'axios';
import * as XLSX from 'xlsx';
import * as FileSystem from 'expo-file-system';

/**
 * Lấy danh sách file từ Google Drive
 * @param {string} accessToken - Token xác thực Google
 * @param {string} folderId - ID thư mục cần lấy (tùy chọn)
 * @returns {Promise<Array>} - Mảng các file/thư mục
 */
export const listFiles = async (accessToken, folderId = null) => {
  try {
    let url = 'https://www.googleapis.com/drive/v3/files';
    let params = {
      fields: 'files(id, name, mimeType, modifiedTime, size)',
      orderBy: 'modifiedTime desc',
    };

    // Nếu có folderId, lọc theo thư mục
    if (folderId) {
      params.q = `'${folderId}' in parents and trashed = false`;
    } else {
      params.q = 'trashed = false';
    }

    const response = await axios.get(url, {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
      },
      params,
    });

    return response.data.files;
  } catch (error) {
    console.error('Lỗi khi lấy danh sách file từ Google Drive:', error);
    throw error;
  }
};

/**
 * Tìm kiếm file trên Google Drive
 * @param {string} accessToken - Token xác thực Google
 * @param {string} query - Từ khóa tìm kiếm
 * @returns {Promise<Array>} - Mảng các file phù hợp
 */
export const searchFiles = async (accessToken, query) => {
  try {
    const url = 'https://www.googleapis.com/drive/v3/files';
    const params = {
      q: `name contains '${query}' and trashed = false`,
      fields: 'files(id, name, mimeType, modifiedTime, size)',
      orderBy: 'modifiedTime desc',
    };

    const response = await axios.get(url, {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
      },
      params,
    });

    return response.data.files;
  } catch (error) {
    console.error('Lỗi khi tìm kiếm file trên Google Drive:', error);
    throw error;
  }
};

/**
 * Tải nội dung file từ Google Drive
 * @param {string} accessToken - Token xác thực Google
 * @param {string} fileId - ID của file cần tải
 * @returns {Promise<Object>} - Dữ liệu file
 */
export const downloadFile = async (accessToken, fileId) => {
  try {
    // Đầu tiên lấy thông tin file để biết định dạng
    const fileInfoUrl = `https://www.googleapis.com/drive/v3/files/${fileId}?fields=name,mimeType`;
    const fileInfoResponse = await axios.get(fileInfoUrl, {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
    });

    const { name, mimeType } = fileInfoResponse.data;

    // Tải nội dung file
    const downloadUrl = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`;
    const response = await axios.get(downloadUrl, {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
      responseType: 'arraybuffer',
    });

    return {
      name,
      mimeType,
      data: response.data,
    };
  } catch (error) {
    console.error('Lỗi khi tải file từ Google Drive:', error);
    throw error;
  }
};

/**
 * Tải lên file lên Google Drive
 * @param {string} accessToken - Token xác thực Google
 * @param {File|Blob} file - File cần tải lên
 * @param {string} folderId - ID thư mục đích (tùy chọn)
 * @returns {Promise<Object>} - Thông tin file đã tải lên
 */
export const uploadFile = async (accessToken, file, folderId = null) => {
  try {
    const metadata = {
      name: file.name,
      mimeType: file.type,
    };

    // Nếu có folderId, đặt file vào thư mục đó
    if (folderId) {
      metadata.parents = [folderId];
    }

    // Tạo form data để tải lên
    const form = new FormData();
    form.append(
      'metadata',
      new Blob([JSON.stringify(metadata)], { type: 'application/json' })
    );
    form.append('file', file);

    // Tải lên file
    const response = await axios.post(
      'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart',
      form,
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          'Content-Type': 'multipart/form-data',
        },
      }
    );

    return response.data;
  } catch (error) {
    console.error('Lỗi khi tải file lên Google Drive:', error);
    throw error;
  }
};

/**
 * Đọc nội dung file Excel từ Google Drive
 * @param {string} accessToken - Token xác thực Google
 * @param {string} fileId - ID của file Excel
 * @returns {Promise<Object>} - Dữ liệu đã xử lý từ file Excel
 */
export const readExcelFile = async (accessToken, fileId) => {
  try {
    // Tải file từ Google Drive
    const file = await downloadFile(accessToken, fileId);

    // Kiểm tra xem file có phải là Excel không
    const isExcel =
      file.mimeType.includes('spreadsheet') ||
      file.mimeType.includes('excel') ||
      file.name.endsWith('.xlsx') ||
      file.name.endsWith('.xls');

    if (!isExcel) {
      throw new Error('File không phải là Excel');
    }

    // Xử lý file Excel với thư viện xlsx
    const data = new Uint8Array(file.data);
    const workbook = XLSX.read(data, { type: 'array' });

    // Lấy sheet đầu tiên
    const firstSheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[firstSheetName];

    // Chuyển đổi dữ liệu sang dạng JSON
    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

    // Nếu có nhiều sheet, lấy tất cả
    const allSheets = {};
    workbook.SheetNames.forEach((sheetName) => {
      const sheet = workbook.Sheets[sheetName];
      allSheets[sheetName] = XLSX.utils.sheet_to_json(sheet, { header: 1 });
    });

    return {
      fileName: file.name,
      firstSheet: jsonData,
      allSheets: allSheets,
      sheetNames: workbook.SheetNames,
    };
  } catch (error) {
    console.error('Lỗi khi đọc file Excel từ Google Drive:', error);
    throw error;
  }
};

/**
 * Lưu file Excel tạm thời vào bộ nhớ thiết bị
 * @param {string} accessToken - Token xác thực Google
 * @param {string} fileId - ID của file Excel
 * @returns {Promise<string>} - Đường dẫn đến file đã lưu
 */
export const saveExcelFileLocally = async (accessToken, fileId) => {
  try {
    // Tải file từ Google Drive
    const file = await downloadFile(accessToken, fileId);

    // Tạo tên file tạm thời
    const tempFilePath = `${FileSystem.cacheDirectory}${file.name}`;

    // Chuyển đổi dữ liệu thành base64 để lưu với FileSystem
    const base64Data = Buffer.from(file.data).toString('base64');

    // Lưu file vào bộ nhớ tạm
    await FileSystem.writeAsStringAsync(tempFilePath, base64Data, {
      encoding: FileSystem.EncodingType.Base64,
    });

    return tempFilePath;
  } catch (error) {
    console.error('Lỗi khi lưu file Excel vào bộ nhớ tạm:', error);
    throw error;
  }
};

/**
 * Tạo thư mục mới trên Google Drive
 * @param {string} accessToken - Token xác thực Google
 * @param {string} folderName - Tên thư mục
 * @param {string} parentFolderId - ID thư mục cha (tùy chọn)
 * @returns {Promise<Object>} - Thông tin thư mục đã tạo
 */
export const createFolder = async (
  accessToken,
  folderName,
  parentFolderId = null
) => {
  try {
    const metadata = {
      name: folderName,
      mimeType: 'application/vnd.google-apps.folder',
    };

    // Nếu có parentFolderId, đặt thư mục vào thư mục cha đó
    if (parentFolderId) {
      metadata.parents = [parentFolderId];
    }

    const response = await axios.post(
      'https://www.googleapis.com/drive/v3/files',
      metadata,
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
        },
      }
    );

    return response.data;
  } catch (error) {
    console.error('Lỗi khi tạo thư mục trên Google Drive:', error);
    throw error;
  }
};

/**
 * Lấy file Excel mới nhất từ thư mục cụ thể và xử lý dữ liệu
 * @param {string} accessToken - Token xác thực Google
 * @param {string} folderId - ID thư mục cần lấy
 * @returns {Promise<Object>} - Dữ liệu đã xử lý từ file Excel mới nhất
 */
export const getLatestExcelFromFolder = async (accessToken, folderId) => {
  try {
    // Lấy danh sách các file trong thư mục, sắp xếp theo thời gian sửa đổi mới nhất
    const files = await listFiles(accessToken, folderId);

    // Lọc chỉ lấy các file Excel
    const excelFiles = files.filter(
      (file) =>
        file.mimeType.includes('spreadsheet') ||
        file.mimeType.includes('excel') ||
        file.name.endsWith('.xlsx') ||
        file.name.endsWith('.xls')
    );

    if (excelFiles.length === 0) {
      throw new Error('Không tìm thấy file Excel nào trong thư mục');
    }

    // Lấy file mới nhất (đã sắp xếp theo modifiedTime desc)
    const latestExcelFile = excelFiles[0];
    console.log('Đã tìm thấy file Excel mới nhất:', latestExcelFile.name);

    // Đọc và xử lý file Excel
    const excelData = await readExcelFile(accessToken, latestExcelFile.id);

    return {
      fileInfo: latestExcelFile,
      data: excelData,
    };
  } catch (error) {
    console.error('Lỗi khi lấy file Excel mới nhất:', error);
    throw error;
  }
};

/**
 * Phân tích dữ liệu từ file Excel công nợ
 * @param {Object} excelData - Dữ liệu Excel đã đọc
 * @returns {Object} - Dữ liệu công nợ đã phân tích
 */
export const processDebtExcelData = (excelData) => {
  try {
    const sheets = excelData.allSheets;
    const result = {
      totalAccountsPayable: 0,
      totalAccountsReceivable: 0,
      top5Payable: [],
      top5Receivable: [],
      lastUpdated: new Date(),
    };

    // Tìm sheet công nợ phải trả
    const payableSheet = findSheetByName(sheets, [
      'Phải Trả',
      'Phai Tra',
      'Accounts Payable',
      'Công Nợ Phải Trả',
    ]);
    if (payableSheet) {
      const payableData = processPayableSheet(payableSheet);
      result.totalAccountsPayable = payableData.total;
      result.top5Payable = payableData.top5;
    }

    // Tìm sheet công nợ phải thu
    const receivableSheet = findSheetByName(sheets, [
      'Phải Thu',
      'Phai Thu',
      'Accounts Receivable',
      'Công Nợ Phải Thu',
    ]);
    if (receivableSheet) {
      const receivableData = processReceivableSheet(receivableSheet);
      result.totalAccountsReceivable = receivableData.total;
      result.top5Receivable = receivableData.top5;
    }

    // Tính vị thế công nợ ròng
    result.netDebtPosition =
      result.totalAccountsReceivable - result.totalAccountsPayable;

    // Định dạng số tiền
    result.formattedTotals = {
      totalAccountsPayable: formatCurrency(result.totalAccountsPayable),
      totalAccountsReceivable: formatCurrency(result.totalAccountsReceivable),
      netDebtPosition: formatCurrency(result.netDebtPosition),
    };

    return result;
  } catch (error) {
    console.error('Lỗi khi phân tích dữ liệu Excel công nợ:', error);
    throw error;
  }
};

// Hàm trợ giúp tìm sheet theo tên
const findSheetByName = (sheets, possibleNames) => {
  for (const sheetName in sheets) {
    if (
      possibleNames.some((name) =>
        sheetName.toLowerCase().includes(name.toLowerCase())
      )
    ) {
      return sheets[sheetName];
    }
  }
  return null;
};

// Xử lý sheet công nợ phải trả
const processPayableSheet = (sheetData) => {
  // Tìm các cột chứa thông tin nhà cung cấp và số tiền
  const headerRow = sheetData.find((row) =>
    row.some(
      (cell) =>
        typeof cell === 'string' &&
        (cell.toLowerCase().includes('nhà cung cấp') ||
          cell.toLowerCase().includes('supplier') ||
          cell.toLowerCase().includes('tên'))
    )
  );

  if (!headerRow) return { total: 0, top5: [] };

  const supplierColIndex = headerRow.findIndex(
    (cell) =>
      typeof cell === 'string' &&
      (cell.toLowerCase().includes('nhà cung cấp') ||
        cell.toLowerCase().includes('supplier') ||
        cell.toLowerCase().includes('tên'))
  );

  const amountColIndex = headerRow.findIndex(
    (cell) =>
      typeof cell === 'string' &&
      (cell.toLowerCase().includes('số tiền') ||
        cell.toLowerCase().includes('amount') ||
        cell.toLowerCase().includes('còn nợ') ||
        cell.toLowerCase().includes('tổng'))
  );

  if (supplierColIndex === -1 || amountColIndex === -1) {
    return { total: 0, top5: [] };
  }

  // Lấy dữ liệu từ các hàng sau header
  const dataRows = sheetData.slice(sheetData.indexOf(headerRow) + 1);

  // Lọc các hàng có dữ liệu hợp lệ
  const validRows = dataRows.filter(
    (row) =>
      row[supplierColIndex] &&
      row[amountColIndex] &&
      !isNaN(parseFloat(row[amountColIndex]))
  );

  // Tính tổng
  const total = validRows.reduce(
    (sum, row) => sum + parseFloat(row[amountColIndex]),
    0
  );

  // Sắp xếp theo số tiền giảm dần và lấy top 5
  const sortedRows = [...validRows].sort(
    (a, b) => parseFloat(b[amountColIndex]) - parseFloat(a[amountColIndex])
  );

  const top5 = sortedRows.slice(0, 5).map((row) => ({
    supplier: row[supplierColIndex].toString(),
    amount: parseFloat(row[amountColIndex]),
    amountInMillions: parseFloat(
      (parseFloat(row[amountColIndex]) / 1000000).toFixed(1)
    ),
  }));

  return { total, top5 };
};

// Xử lý sheet công nợ phải thu (tương tự như phải trả)
const processReceivableSheet = (sheetData) => {
  // Tìm các cột chứa thông tin khách hàng và số tiền
  const headerRow = sheetData.find((row) =>
    row.some(
      (cell) =>
        typeof cell === 'string' &&
        (cell.toLowerCase().includes('khách hàng') ||
          cell.toLowerCase().includes('customer') ||
          cell.toLowerCase().includes('tên'))
    )
  );

  if (!headerRow) return { total: 0, top5: [] };

  const customerColIndex = headerRow.findIndex(
    (cell) =>
      typeof cell === 'string' &&
      (cell.toLowerCase().includes('khách hàng') ||
        cell.toLowerCase().includes('customer') ||
        cell.toLowerCase().includes('tên'))
  );

  const amountColIndex = headerRow.findIndex(
    (cell) =>
      typeof cell === 'string' &&
      (cell.toLowerCase().includes('số tiền') ||
        cell.toLowerCase().includes('amount') ||
        cell.toLowerCase().includes('còn nợ') ||
        cell.toLowerCase().includes('tổng'))
  );

  if (customerColIndex === -1 || amountColIndex === -1) {
    return { total: 0, top5: [] };
  }

  // Lấy dữ liệu từ các hàng sau header
  const dataRows = sheetData.slice(sheetData.indexOf(headerRow) + 1);

  // Lọc các hàng có dữ liệu hợp lệ
  const validRows = dataRows.filter(
    (row) =>
      row[customerColIndex] &&
      row[amountColIndex] &&
      !isNaN(parseFloat(row[amountColIndex]))
  );

  // Tính tổng
  const total = validRows.reduce(
    (sum, row) => sum + parseFloat(row[amountColIndex]),
    0
  );

  // Sắp xếp theo số tiền giảm dần và lấy top 5
  const sortedRows = [...validRows].sort(
    (a, b) => parseFloat(b[amountColIndex]) - parseFloat(a[amountColIndex])
  );

  const top5 = sortedRows.slice(0, 5).map((row) => ({
    customer: row[customerColIndex].toString(),
    amount: parseFloat(row[amountColIndex]),
    amountInMillions: parseFloat(
      (parseFloat(row[amountColIndex]) / 1000000).toFixed(1)
    ),
  }));

  return { total, top5 };
};

// Hàm định dạng tiền tệ
const formatCurrency = (amount) => {
  return new Intl.NumberFormat('vi-VN', {
    style: 'currency',
    currency: 'VND',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(amount);
};

export default {
  listFiles,
  searchFiles,
  downloadFile,
  uploadFile,
  readExcelFile,
  saveExcelFileLocally,
  createFolder,
  getLatestExcelFromFolder,
  processDebtExcelData,
};

import { firebase, functions } from '../config/firebaseConfig';
import { httpsCallable } from 'firebase/functions';
import { getDownloadURL, getStorage, ref, uploadBytes } from 'firebase/storage';
import googleDriveService from './googleDriveService';

/**
 * Service API để tương tác với Cloud Functions Inventory
 */
const InventoryService = {
  /**
   * Thêm vật tư mới
   * @param {Object} itemData - Thông tin vật tư
   * @returns {Promise<Object>}
   */
  async addInventoryItem(itemData) {
    try {
      const addInventoryItemFn = httpsCallable(functions, 'addInventoryItem');
      const result = await addInventoryItemFn(itemData);
      return result.data;
    } catch (error) {
      console.error('Lỗi thêm vật tư:', error);
      throw error;
    }
  },

  /**
   * Cập nhật thông tin vật tư
   * @param {string} itemId - ID vật tư
   * @param {Object} itemData - Thông tin cập nhật
   * @returns {Promise<Object>}
   */
  async updateInventoryItem(itemId, itemData) {
    try {
      const updateInventoryItemFn = httpsCallable(
        functions,
        'updateInventoryItem'
      );
      const result = await updateInventoryItemFn({
        itemId,
        itemData,
      });
      return result.data;
    } catch (error) {
      console.error('Lỗi cập nhật vật tư:', error);
      throw error;
    }
  },

  /**
   * Tạo giao dịch nhập/xuất kho
   * @param {Object} transactionData - Thông tin giao dịch
   * @returns {Promise<Object>}
   */
  async createTransaction(transactionData) {
    try {
      const createInventoryTransactionFn = httpsCallable(
        functions,
        'createInventoryTransaction'
      );
      const result = await createInventoryTransactionFn(transactionData);
      return result.data;
    } catch (error) {
      console.error('Lỗi tạo giao dịch kho:', error);
      throw error;
    }
  },

  /**
   * Lấy báo cáo tồn kho
   * @param {Object} filters - Bộ lọc báo cáo
   * @returns {Promise<Object>}
   */
  async getInventoryReport(filters = {}) {
    try {
      const getInventoryReportFn = httpsCallable(
        functions,
        'getInventoryReport'
      );
      const result = await getInventoryReportFn(filters);
      return result.data;
    } catch (error) {
      console.error('Lỗi lấy báo cáo tồn kho:', error);
      throw error;
    }
  },

  /**
   * Quản lý danh mục vật tư
   * @param {string} action - Hành động: 'add', 'update', 'delete'
   * @param {Object} categoryData - Thông tin danh mục
   * @param {string} categoryId - ID danh mục (cho update/delete)
   * @returns {Promise<Object>}
   */
  async manageCategory(action, categoryData, categoryId) {
    try {
      const manageCategoryFn = httpsCallable(
        functions,
        'manageInventoryCategory'
      );
      const result = await manageCategoryFn({
        action,
        categoryData,
        categoryId,
      });
      return result.data;
    } catch (error) {
      console.error('Lỗi quản lý danh mục:', error);
      throw error;
    }
  },

  /**
   * Lấy thống kê sử dụng vật tư theo dự án
   * @param {string} projectId - ID dự án
   * @param {string} startDate - Ngày bắt đầu (tùy chọn)
   * @param {string} endDate - Ngày kết thúc (tùy chọn)
   * @returns {Promise<Object>}
   */
  async getProjectMaterialUsage(projectId, startDate, endDate) {
    try {
      const getMaterialUsageFn = httpsCallable(
        functions,
        'getProjectMaterialUsage'
      );
      const result = await getMaterialUsageFn({
        projectId,
        startDate,
        endDate,
      });
      return result.data;
    } catch (error) {
      console.error('Lỗi lấy thống kê sử dụng vật tư:', error);
      throw error;
    }
  },

  /**
   * Upload hình ảnh vật tư
   * @param {string} itemId - ID vật tư
   * @param {Blob} imageBlob - Dữ liệu hình ảnh
   * @returns {Promise<string>} - URL hình ảnh
   */
  async uploadItemImage(itemId, imageBlob) {
    try {
      const storage = getStorage();
      const imageName = `inventory_items/${itemId}_${Date.now()}.jpg`;
      const storageRef = ref(storage, imageName);

      // Upload hình ảnh
      await uploadBytes(storageRef, imageBlob);

      // Lấy URL download
      const downloadUrl = await getDownloadURL(storageRef);

      // Cập nhật URL hình ảnh vào thông tin vật tư
      await this.updateInventoryItem(itemId, { imageUrl: downloadUrl });

      return downloadUrl;
    } catch (error) {
      console.error('Lỗi upload hình ảnh vật tư:', error);
      throw error;
    }
  },

  /**
   * Lấy danh sách giao dịch của một vật tư
   * @param {string} itemId - ID vật tư
   * @returns {Promise<Array>} - Danh sách giao dịch
   */
  async getItemTransactions(itemId) {
    try {
      const snapshot = await firebase
        .firestore()
        .collection('inventory_transactions')
        .where('itemId', '==', itemId)
        .orderBy('date', 'desc')
        .get();

      return snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));
    } catch (error) {
      console.error('Lỗi lấy giao dịch vật tư:', error);
      throw error;
    }
  },

  /**
   * Lấy thông tin chi tiết vật tư
   * @param {string} itemId - ID vật tư
   * @returns {Promise<Object>} - Thông tin vật tư
   */
  async getItemById(itemId) {
    try {
      const doc = await firebase
        .firestore()
        .collection('inventory')
        .doc(itemId)
        .get();

      if (!doc.exists) {
        throw new Error('Không tìm thấy vật tư');
      }

      return {
        id: doc.id,
        ...doc.data(),
      };
    } catch (error) {
      console.error('Lỗi lấy thông tin vật tư:', error);
      throw error;
    }
  },

  /**
   * Lấy thông tin chi tiết vật tư (alias cho getItemById)
   * @param {string} itemId - ID vật tư
   * @returns {Promise<Object>} - Thông tin vật tư
   */
  async getInventoryItemById(itemId) {
    return this.getItemById(itemId);
  },

  /**
   * Lấy danh sách tất cả vị trí kho
   * @returns {Promise<Array>} - Danh sách vị trí kho
   */
  async getAllLocations() {
    try {
      const snapshot = await firebase
        .firestore()
        .collection('inventory_locations')
        .where('isActive', '==', true)
        .get();

      return snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));
    } catch (error) {
      console.error('Lỗi lấy danh sách vị trí kho:', error);
      throw error;
    }
  },

  /**
   * Nhập vật tư từ file Excel mới nhất trong Google Drive folder
   * @param {string} accessToken - Google access token
   * @param {string} folderId - ID của folder chứa file Excel
   * @returns {Promise<Object>} - Kết quả nhập vật tư
   */
  async importInventoryFromDrive(accessToken, folderId) {
    try {
      // Lấy file Excel mới nhất từ folder
      const excelData = await googleDriveService.getLatestExcelFromFolder(
        accessToken,
        folderId
      );

      console.log('Đang xử lý file Excel:', excelData.fileInfo.name);

      // Xử lý dữ liệu từ sheet đầu tiên
      const sheetData = excelData.data.firstSheet;

      // Tìm hàng tiêu đề (thường là hàng đầu tiên)
      const headerRow = sheetData[0];

      if (!headerRow) {
        throw new Error('File Excel không có dữ liệu');
      }

      // Ánh xạ tên cột với các trường dữ liệu
      const columnMap = {
        code: findColumnIndex(headerRow, ['Mã vật tư', 'Mã', 'Code']),
        name: findColumnIndex(headerRow, ['Tên vật tư', 'Tên', 'Name']),
        description: findColumnIndex(headerRow, ['Mô tả', 'Description']),
        category: findColumnIndex(headerRow, ['Danh mục', 'Category']),
        unit: findColumnIndex(headerRow, ['Đơn vị tính', 'Unit']),
        stockQuantity: findColumnIndex(headerRow, ['Số lượng', 'Quantity']),
        minQuantity: findColumnIndex(headerRow, [
          'Số lượng tối thiểu',
          'Min Quantity',
        ]),
        price: findColumnIndex(headerRow, ['Đơn giá', 'Price']),
        material: findColumnIndex(headerRow, ['Vật liệu', 'Material']),
        weight: findColumnIndex(headerRow, ['Khối lượng', 'Weight']),
      };

      // Nếu không tìm thấy các cột bắt buộc
      if (columnMap.code === -1 || columnMap.name === -1) {
        throw new Error(
          'File Excel không đúng định dạng. Cần có cột Mã vật tư và Tên vật tư'
        );
      }

      // Kết quả
      const result = {
        total: 0,
        added: 0,
        updated: 0,
        skipped: 0,
        errors: [],
      };

      // Lấy danh sách danh mục để ánh xạ tên với ID
      const categoriesSnapshot = await firebase
        .firestore()
        .collection('inventory_categories')
        .get();
      const categoriesMap = {};
      categoriesSnapshot.docs.forEach((doc) => {
        const category = doc.data();
        categoriesMap[category.name.toLowerCase()] = doc.id;
      });

      // Xử lý từng hàng dữ liệu (bỏ qua hàng đầu tiên là tiêu đề)
      for (let i = 1; i < sheetData.length; i++) {
        const row = sheetData[i];

        // Bỏ qua hàng trống
        if (!row || row.length === 0) continue;

        // Nếu không có mã hoặc tên, bỏ qua
        if (!row[columnMap.code] || !row[columnMap.name]) {
          result.skipped++;
          continue;
        }

        try {
          // Chuẩn bị dữ liệu vật tư
          const itemData = {
            code: row[columnMap.code]?.toString() || '',
            name: row[columnMap.name]?.toString() || '',
          };

          // Thêm các trường tùy chọn nếu có
          if (columnMap.description !== -1 && row[columnMap.description]) {
            itemData.description = row[columnMap.description].toString();
          }

          // Xử lý danh mục
          if (columnMap.category !== -1 && row[columnMap.category]) {
            const categoryName = row[columnMap.category]
              .toString()
              .toLowerCase();
            if (categoriesMap[categoryName]) {
              itemData.categoryId = categoriesMap[categoryName];
            }
          }

          if (columnMap.unit !== -1 && row[columnMap.unit]) {
            itemData.unit = row[columnMap.unit].toString();
          }

          if (columnMap.stockQuantity !== -1 && row[columnMap.stockQuantity]) {
            const quantity = parseFloat(row[columnMap.stockQuantity]);
            if (!isNaN(quantity)) {
              itemData.stockQuantity = quantity;
            }
          }

          if (columnMap.minQuantity !== -1 && row[columnMap.minQuantity]) {
            const minQty = parseFloat(row[columnMap.minQuantity]);
            if (!isNaN(minQty)) {
              itemData.minQuantity = minQty;
            }
          }

          if (columnMap.price !== -1 && row[columnMap.price]) {
            const price = parseFloat(row[columnMap.price]);
            if (!isNaN(price)) {
              itemData.price = price;
            }
          }

          if (columnMap.material !== -1 && row[columnMap.material]) {
            itemData.material = row[columnMap.material].toString();
          }

          if (columnMap.weight !== -1 && row[columnMap.weight]) {
            const weight = parseFloat(row[columnMap.weight]);
            if (!isNaN(weight)) {
              itemData.weight = weight;
            }
          }

          // Tính tổng giá trị nếu có số lượng và đơn giá
          if (itemData.stockQuantity && itemData.price) {
            itemData.totalPrice = itemData.stockQuantity * itemData.price;
          }

          // Kiểm tra xem vật tư đã tồn tại chưa dựa vào mã
          const existingItemsSnapshot = await firebase
            .firestore()
            .collection('inventory')
            .where('code', '==', itemData.code)
            .get();

          if (!existingItemsSnapshot.empty) {
            // Cập nhật vật tư đã tồn tại
            const docId = existingItemsSnapshot.docs[0].id;
            await firebase
              .firestore()
              .collection('inventory')
              .doc(docId)
              .update({
                ...itemData,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
              });
            result.updated++;
          } else {
            // Thêm vật tư mới
            await firebase
              .firestore()
              .collection('inventory')
              .add({
                ...itemData,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
              });
            result.added++;
          }

          result.total++;
        } catch (err) {
          console.error(`Lỗi khi xử lý hàng ${i}:`, err);
          result.errors.push({
            row: i,
            message: err.message,
          });
          result.skipped++;
        }
      }

      return result;
    } catch (error) {
      console.error('Lỗi khi nhập vật tư từ Google Drive:', error);
      throw error;
    }
  },
};

/**
 * Tìm chỉ mục cột dựa vào danh sách tên có thể có
 * @param {Array} headerRow - Hàng tiêu đề
 * @param {Array} possibleNames - Danh sách tên có thể có
 * @returns {number} - Chỉ mục cột, -1 nếu không tìm thấy
 */
function findColumnIndex(headerRow, possibleNames) {
  for (let i = 0; i < headerRow.length; i++) {
    const cell = headerRow[i];
    if (cell && typeof cell === 'string') {
      const cellValue = cell.toLowerCase();
      if (
        possibleNames.some((name) => cellValue.includes(name.toLowerCase()))
      ) {
        return i;
      }
    }
  }
  return -1;
}

export default InventoryService;

// src/api/notificationService.js
import { db } from '../config/firebaseConfig';
import {
  collection,
  query,
  where,
  getDocs,
  orderBy,
  updateDoc,
  doc,
  limit,
} from 'firebase/firestore';

/**
 * Fetches notifications for a specific user, ordered by creation date.
 * @param {string} userId - The ID of the user.
 * @returns {Promise<Array>} A list of notifications.
 */
export const getUserNotifications = async (userId) => {
  if (!userId) return [];

  try {
    const q = query(
      collection(db, 'notifications'),
      where('userId', '==', userId),
      orderBy('createdAt', 'desc'),
      limit(30) // To avoid loading too many notifications at once
    );
    const snap = await getDocs(q);
    return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
  } catch (error) {
    console.error('Error fetching notifications:', error);
    return [];
  }
};

/**
 * Marks a specific notification as read.
 * @param {string} notificationId - The ID of the notification to update.
 * @returns {Promise<void>}
 */
export const markNotificationAsRead = async (notificationId) => {
  if (!notificationId) return;

  try {
    const ref = doc(db, 'notifications', notificationId);
    await updateDoc(ref, { read: true });
  } catch (error) {
    console.error('Error marking notification as read:', error);
  }
};

//src/api/projectService.js
import {
  collection,
  addDoc,
  updateDoc,
  deleteDoc,
  doc,
  query,
  orderBy,
  getDocs,
  getDoc,
  where,
  serverTimestamp,
  arrayUnion,
  runTransaction,
} from 'firebase/firestore';
import { db, functions } from '../config/firebaseConfig';
import { httpsCallable } from 'firebase/functions';
import { getCustomerById } from './customerService'; // Import getCustomerById

/**
 * Lấy tất cả dự án
 * @returns {Promise<Array>} - Mảng dự án
 */
export const getProjects = async () => {
  try {
    const projectsRef = collection(db, 'projects');
    const q = query(projectsRef, orderBy('createdAt', 'desc'));
    const querySnapshot = await getDocs(q);

    // Dữ liệu đã được denormalize, không cần query thêm
    const projects = querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));

    return projects;
  } catch (error) {
    throw error;
  }
};

/**
 * Lấy dự án theo ID kèm thông tin khách hàng
 * @param {string} projectId - ID dự án
 * @returns {Promise<Object|null>} - Dữ liệu dự án hoặc null nếu không tìm thấy
 */
export const getProjectById = async (projectId) => {
  try {
    const projectRef = doc(db, 'projects', projectId);
    const projectSnapshot = await getDoc(projectRef);

    if (projectSnapshot.exists()) {
      const projectData = {
        id: projectSnapshot.id,
        ...projectSnapshot.data(),
      };

      // Nếu dự án có customerId, lấy thông tin khách hàng
      if (projectData.customerId) {
        try {
          const customerRef = doc(db, 'customers', projectData.customerId);
          const customerSnapshot = await getDoc(customerRef);

          if (customerSnapshot.exists()) {
            const customerData = customerSnapshot.data();
            // Thêm thông tin khách hàng vào dự án
            return {
              ...projectData,
              customerName: customerData.name || 'Không xác định',
              customerContactPerson: customerData.contactPerson || '',
              customerEmail: customerData.email || '',
              customerPhone: customerData.phone || '',
              customerAddress: customerData.address || '',
              customerTaxCode: customerData.taxCode || '',
              customer: {
                id: projectData.customerId,
                ...customerData,
              },
            };
          }
        } catch (error) {
          console.error(
            `Lỗi khi lấy thông tin khách hàng cho dự án ${projectId}:`,
            error
          );
        }
      }

      // Trả về dự án gốc nếu không có customerId hoặc có lỗi
      return {
        ...projectData,
        customerName: 'Không xác định',
        customerContactPerson: '',
        customerEmail: '',
        customerPhone: '',
        customerAddress: '',
        customerTaxCode: '',
      };
    } else {
      return null;
    }
  } catch (error) {
    throw error;
  }
};

/**
 * Tạo dự án mới
 * @param {Object} projectData - Dữ liệu dự án
 * @param {string} userId - ID của người dùng tạo dự án
 * @returns {Promise<string>} - ID của dự án đã tạo
 */
export const createProject = async (projectData, userId) => {
  try {
    const projectToSave = { ...projectData };

    // Denormalization: Fetch and add customerName if customerId exists
    if (projectToSave.customerId) {
      const customer = await getCustomerById(projectToSave.customerId);
      if (customer) {
        projectToSave.customerName = customer.name;
      }
    }

    // Tạo cấu trúc tasks mặc định
    const defaultTasks = {
      quotation: { status: 'pending' },
      material_separation: { status: 'pending' },
      material_purchasing: {
        label: 'Mua vật tư & phụ kiện',
        status: 'pending',
      },
      material_cutting: { status: 'pending' },
      assembly: { status: 'pending' },
      painting: { status: 'pending' },
      shipping: { status: 'pending' },
      other: { name: '', status: 'pending' },
    };

    const docRef = await addDoc(collection(db, 'projects'), {
      ...projectToSave,
      tasks: defaultTasks, // Thêm cấu trúc tasks mặc định
      createdAt: serverTimestamp(),
      createdBy: userId,
      updatedAt: serverTimestamp(),
    });

    // Trả về ID của dự án vừa tạo
    return docRef.id;
  } catch (error) {
    throw error;
  }
};

/**
 * Cập nhật thông tin dự án
 * @param {string} projectId - ID dự án
 * @param {Object} projectData - Dữ liệu dự án cập nhật
 * @param {string} userId - ID của người dùng cập nhật dự án
 * @returns {Promise<void>}
 */
export const updateProject = async (projectId, projectData, userId) => {
  try {
    const projectToUpdate = { ...projectData };

    // Denormalization: If customerId is being updated, also update customerName
    if (projectToUpdate.customerId) {
      const customer = await getCustomerById(projectToUpdate.customerId);
      if (customer) {
        projectToUpdate.customerName = customer.name;
      } else {
        projectToUpdate.customerName = 'Không xác định'; // Handle case where customer might not be found
      }
    }

    const projectRef = doc(db, 'projects', projectId);
    await updateDoc(projectRef, {
      ...projectToUpdate,
      updatedAt: serverTimestamp(),
      updatedBy: userId,
    });
  } catch (error) {
    throw error;
  }
};

/**
 * Xóa dự án
 * @param {string} projectId - ID dự án
 * @returns {Promise<void>}
 */
export const deleteProject = async (projectId) => {
  try {
    const projectRef = doc(db, 'projects', projectId);
    await deleteDoc(projectRef);
  } catch (error) {
    console.error('Error deleting project:', error);
    throw new Error('Không thể xóa dự án. Vui lòng thử lại.');
  }
};

/**
 * Lấy dự án theo khách hàng
 * @param {string} customerId - ID khách hàng
 * @returns {Promise<Array>} - Mảng dự án thuộc khách hàng
 */
export const getProjectsByCustomer = async (customerId) => {
  try {
    const projectsRef = collection(db, 'projects');
    const q = query(
      projectsRef,
      where('customerId', '==', customerId),
      orderBy('createdAt', 'desc')
    );

    const querySnapshot = await getDocs(q);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    throw error;
  }
};

/**
 * Lấy dự án theo trạng thái
 * @param {string} status - Trạng thái dự án (pending, in-progress, completed, cancelled)
 * @returns {Promise<Array>} - Mảng dự án thuộc trạng thái đã chỉ định
 */
export const getProjectsByStatus = async (status) => {
  try {
    const projectsRef = collection(db, 'projects');
    const q = query(
      projectsRef,
      where('status', '==', status),
      orderBy('createdAt', 'desc')
    );

    const querySnapshot = await getDocs(q);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    throw error;
  }
};

/**
 * Tìm kiếm dự án theo tên
 * @param {string} searchTerm - Từ khóa tìm kiếm
 * @returns {Promise<Array>} - Mảng dự án phù hợp
 */
export const searchProjects = async (searchTerm) => {
  try {
    const projectsRef = collection(db, 'projects');
    const nameQuery = query(
      projectsRef,
      where('name', '>=', searchTerm),
      where('name', '<=', searchTerm + '\uf8ff')
    );

    const querySnapshot = await getDocs(nameQuery);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    throw error;
  }
};

/**
 * Updates the status of a specific task within a project.
 * This is a targeted update to ensure it passes security rules for non-admin users.
 * @param {string} projectId The ID of the project to update.
 * @param {string} taskKey The key of the task to update (e.g., 'material_separation').
 * @param {string} newStatus The new status for the task.
 */
export const updateTaskStatus = async (projectId, taskKey, newStatus) => {
  if (!projectId || !taskKey || !newStatus) {
    throw new Error('Cần có ID dự án, khóa công việc và trạng thái mới.');
  }
  try {
    const projectRef = doc(db, 'projects', projectId);
    // Construct the field path dynamically
    const fieldPath = `tasks.${taskKey}.status`;
    await updateDoc(projectRef, {
      [fieldPath]: newStatus,
    });
  } catch (error) {
    console.error('Error updating task status:', error);
    if (error.code === 'permission-denied') {
      throw new Error('Bạn không có quyền cập nhật trạng thái công việc này.');
    }
    throw new Error(
      'Không thể cập nhật trạng thái công việc. Vui lòng thử lại.'
    );
  }
};

/**
 * Cập nhật tên công việc "other"
 * @param {string} projectId - ID dự án
 * @param {string} taskName - Tên công việc khác
 * @param {string} userId - ID của người dùng cập nhật
 * @returns {Promise<void>}
 */
export const updateCustomTask = async (projectId, taskName, userId) => {
  try {
    const projectRef = doc(db, 'projects', projectId);
    const updatePath = `tasks.other.name`;

    await updateDoc(projectRef, {
      [updatePath]: taskName,
      updatedAt: serverTimestamp(),
      updatedBy: userId,
    });
  } catch (error) {
    throw error;
  }
};

/**
 * Updates the status of a specific workflow stage within a project.
 * This is a targeted update to ensure it passes security rules for non-admin users.
 * @param {string} projectId The ID of the project to update.
 * @param {string} stageId The ID of the stage to update.
 * @param {string} newStatus The new status for the stage.
 * @param {string} assignedToId The ID of the user assigned to the stage.
 */
export const updateWorkflowStageStatus = async (
  projectId,
  stageId,
  newStatus,
  assignedToId = null
) => {
  try {
    const projectRef = doc(db, 'projects', projectId);
    await updateDoc(projectRef, {
      workflowStages: arrayUnion(), // placeholder to trigger merge; we'll overwrite in transaction
    });
  } catch (e) {
    console.error('Direct update failed, fallback to transaction', e);
    await runTransaction(db, async (transaction) => {
      const ref = doc(db, 'projects', projectId);
      const snap = await transaction.get(ref);
      if (!snap.exists()) throw new Error('Project not found');
      const stages = snap.data().workflowStages || [];
      const idx = stages.findIndex((s) => s.stageId === stageId);
      if (idx === -1) throw new Error('Stage not found');
      stages[idx] = {
        ...stages[idx],
        status: newStatus,
        ...(assignedToId ? { assignedToId } : {}),
      };
      transaction.update(ref, { workflowStages: stages });
    });
  }
};

/**
 * Cập nhật chi tiết (status, notes, files) cho một công đoạn cụ thể
 * @param {string} projectId
 * @param {string} stageId
 * @param {Object} data - {status?, notes?, files?}
 */
export const updateStageDetails = async (projectId, stageId, data) => {
  try {
    const projectRef = doc(db, 'projects', projectId);

    await runTransaction(db, async (tx) => {
      const snap = await tx.get(projectRef);
      if (!snap.exists()) throw new Error('Project not found');
      const project = snap.data();
      const stages = project.workflowStages || [];
      const idx = stages.findIndex((s) => s.stageId === stageId);
      if (idx === -1) throw new Error('Stage not found');

      stages[idx] = {
        ...stages[idx],
        ...data, // status, notes, files
      };

      tx.update(projectRef, {
        workflowStages: stages,
        updatedAt: serverTimestamp(),
      });
    });
  } catch (error) {
    console.error('Error updating stage details:', error);
    throw new Error('Không thể cập nhật chi tiết công đoạn.');
  }
};

const ProjectService = {
  /**
   * Calls a cloud function to create folders for a project in Google Drive.
   * @param {string} projectId - The ID of the project.
   * @param {string} accessToken - The Google access token.
   * @returns {Promise<any>} The result from the cloud function.
   */
  async createProjectFolders(projectId, accessToken) {
    try {
      const createFolders = httpsCallable(functions, 'createProjectFolders');
      const result = await createFolders({ projectId, accessToken });
      return result.data;
    } catch (error) {
      console.error('Error creating project folders:', error);
      throw error;
    }
  },

  /**
   * Imports materials from a Google Sheet file in Drive.
   * @param {string} fileId - The ID of the Google Sheet file.
   * @param {string} projectId - The ID of the project to associate materials with.
   * @param {string} accessToken - The user's Google access token.
   * @returns {Promise<any>} The result from the cloud function.
   */
  async importMaterialsFromDrive(fileId, projectId, accessToken) {
    try {
      const importMaterials = httpsCallable(
        functions,
        'importMaterialsFromDrive'
      );
      const result = await importMaterials({ fileId, projectId, accessToken });
      return result.data;
    } catch (error) {
      console.error('Error importing materials from drive:', error);
      throw error;
    }
  },

  /**
   * Deletes a file from Google Drive using a cloud function.
   * @param {string} fileId - The ID of the file to delete.
   * @param {string} accessToken - The user's Google access token.
   * @returns {Promise<any>}
   */
  async deleteFileFromDrive(fileId, accessToken) {
    try {
      const deleteFile = httpsCallable(functions, 'deleteFileFromDrive');
      const result = await deleteFile({ fileId, accessToken });
      return result.data;
    } catch (error) {
      console.error('Error deleting file from drive:', error);
      throw error;
    }
  },

  /**
   * Triggers processing of a payable ledger from a Google Sheet.
   * @param {string} fileId - The ID of the Google Sheet.
   * @param {string} accessToken - The Google access token.
   * @returns {Promise<any>}
   */
  async processPayableLedgerFromDrive(fileId, accessToken) {
    try {
      const processLedger = httpsCallable(
        functions,
        'processPayableLedgerFromDrive'
      );
      const result = await processLedger({ fileId, accessToken });
      return result.data;
    } catch (error) {
      console.error('Error processing payable ledger:', error);
      throw error;
    }
  },
};

export default ProjectService;

// src/api/proposalService.js
import {
  collection,
  addDoc,
  getDocs,
  query,
  where,
  doc,
  updateDoc,
  serverTimestamp,
  orderBy,
  getDoc, // Add getDoc
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';

/**
 * Kiểm tra xem người dùng có quyền tạo đề xuất không
 * @param {string} role - Role của người dùng
 * @returns {boolean}
 */
export const canCreateProposal = (role) => {
  const allowedRoles = ['ky_su', 'pho_giam_doc', 'thuong_mai'];
  return allowedRoles.includes(role);
};

/**
 * Kiểm tra xem người dùng có quyền duyệt đề xuất không
 * @param {string} role - Role của người dùng
 * @returns {boolean}
 */
export const canApproveProposal = (role) => {
  const allowedRoles = ['giam_doc', 'thuong_mai'];
  return allowedRoles.includes(role);
};

/**
 * Tạo phiếu đề xuất vật tư mới
 * @param {Object} proposalData - {projectId, projectName, items:[], createdBy, proposalCode, requiredDate, priority, purpose, createdByName}
 * @returns {Promise<string>} id của phiếu đã tạo
 */
export const createProposal = async (proposalData) => {
  const dataToSave = {
    ...proposalData,
    status: 'pending',
    createdAt: serverTimestamp(),
  };
  const docRef = await addDoc(collection(db, 'purchase_proposals'), dataToSave);
  return docRef.id;
};

/**
 * Lấy danh sách đề xuất của 1 dự án
 * @param {string} projectId
 */
export const getProposalsByProject = async (projectId) => {
  const q = query(
    collection(db, 'purchase_proposals'),
    where('projectId', '==', projectId),
    orderBy('createdAt', 'desc')
  );
  const snap = await getDocs(q);
  return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
};

/**
 * Lấy danh sách đề xuất theo trạng thái
 * @param {string} status - 'pending', 'approved', 'rejected'
 */
export const getProposalsByStatus = async (status) => {
  try {
    // Thử truy vấn với orderBy
    const q = query(
      collection(db, 'purchase_proposals'),
      where('status', '==', status),
      orderBy('createdAt', 'desc')
    );
    const snap = await getDocs(q);
    return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
  } catch (error) {
    // Nếu lỗi do chưa có index, thử truy vấn không có orderBy
    if (
      error.code === 'failed-precondition' ||
      error.message.includes('index')
    ) {
      console.warn('Index error, trying without orderBy:', error.message);
      const q = query(
        collection(db, 'purchase_proposals'),
        where('status', '==', status)
      );
      const snap = await getDocs(q);
      return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
    } else {
      // Nếu là lỗi khác thì throw
      throw error;
    }
  }
};

/**
 * Cập nhật trạng thái phiếu (approved / rejected)
 * @param {string} proposalId
 * @param {'approved'|'rejected'} status
 * @param {string} approvedBy uid
 * @param {string} approvedByName tên người duyệt
 * @param {string} comment ghi chú khi duyệt/từ chối
 */
export const updateProposalStatus = async (
  proposalId,
  status,
  approvedBy,
  approvedByName,
  comment = ''
) => {
  const proposalRef = doc(db, 'purchase_proposals', proposalId);
  await updateDoc(proposalRef, {
    status,
    approvedBy,
    approvedByName,
    approvedAt: serverTimestamp(),
    comment,
  });

  // Create a notification for the creator
  if (status === 'approved' || status === 'rejected') {
    try {
      const proposalSnap = await getDoc(proposalRef);
      if (proposalSnap.exists()) {
        const proposalData = proposalSnap.data();
        if (proposalData.createdBy && proposalData.createdBy !== approvedBy) {
          const notificationMessage =
            status === 'approved'
              ? `Đề xuất "${
                  proposalData.proposalCode || 'Không có mã'
                }" đã được phê duyệt.`
              : `Đề xuất "${
                  proposalData.proposalCode || 'Không có mã'
                }" đã bị từ chối.`;

          const notificationData = {
            userId: proposalData.createdBy,
            message: notificationMessage,
            proposalId: proposalId,
            read: false,
            createdAt: serverTimestamp(),
            type:
              status === 'approved' ? 'PROPOSAL_APPROVED' : 'PROPOSAL_REJECTED',
            navLink: {
              screen: 'ProposalList',
            },
          };
          await addDoc(collection(db, 'notifications'), notificationData);
        }
      }
    } catch (error) {
      console.error('Failed to create notification:', error);
    }
  }
};

/**
 * Cập nhật giá vật tư trong phiếu đề xuất
 * @param {string} proposalId - ID của phiếu đề xuất
 * @param {Array} materials - Mảng vật tư với thông tin giá đã cập nhật
 * @returns {Promise<void>}
 */
export const updateProposalMaterialPrices = async (proposalId, materials) => {
  const ref = doc(db, 'purchase_proposals', proposalId);

  // Tính tổng giá trị đơn hàng
  let totalOrderValue = 0;
  materials.forEach((item) => {
    if (item.price && item.quantity) {
      const price = parseFloat(item.price);
      const quantity = parseFloat(item.quantity);
      if (!isNaN(price) && !isNaN(quantity)) {
        totalOrderValue += price * quantity;
      }
    }
  });

  await updateDoc(ref, {
    items: materials,
    hasPrices: true,
    totalValue: totalOrderValue,
    priceUpdatedAt: serverTimestamp(),
  });
};

// src/api/purchaseOrderService.js
import {
  collection,
  addDoc,
  getDocs,
  query,
  where,
  orderBy,
  serverTimestamp,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';
import { httpsCallable, getFunctions } from 'firebase/functions';

// Get Firebase Functions instance for asia-southeast1 region
const functionsInstance = getFunctions(undefined, 'asia-southeast1');

export const createPO = async (poData) => {
  const dataToSave = {
    ...poData,
    status: 'created',
    createdAt: serverTimestamp(),
  };
  const docRef = await addDoc(collection(db, 'purchase_orders'), dataToSave);
  return docRef.id;
};

export const getPOsByProject = async (projectId) => {
  const q = query(
    collection(db, 'purchase_orders'),
    where('projectId', '==', projectId),
    orderBy('createdAt', 'desc')
  );
  const snap = await getDocs(q);
  return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
};

export const getAllPOs = async () => {
  const snap = await getDocs(
    query(collection(db, 'purchase_orders'), orderBy('createdAt', 'desc'))
  );
  return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
};

/**
 * Saves PO receipt confirmation data to Firestore
 * This function assumes files have already been uploaded to Drive
 * @param {Object} params - Parameters
 * @param {string} params.poId - Purchase order ID
 * @param {string} params.projectId - Project ID
 * @param {Array} params.filesToSave - Array of file objects to save (with id, name, url)
 * @param {string} params.remarks - Optional remarks
 * @returns {Promise<Object>} - Result with success status
 */
export const savePOReceiptConfirmation = async ({
  poId,
  projectId,
  filesToSave,
  remarks = '',
}) => {
  const callable = httpsCallable(
    functionsInstance,
    'savePOReceiptConfirmation'
  );
  const res = await callable({ poId, projectId, filesToSave, remarks });
  return res.data;
};

//src/api/quotationService.js
import {
  collection,
  addDoc,
  updateDoc,
  doc,
  getDoc,
  getDocs,
  query,
  where,
  orderBy,
  serverTimestamp,
} from 'firebase/firestore';
// import { getStorage, ref, uploadString, getDownloadURL } from 'firebase/storage';
import { db } from '../config/firebaseConfig';
// import * as FileSystem from 'expo-file-system';

/**
 * Save quotation metadata to Firestore.
 * The PDF is assumed to be already created and stored by a cloud function.
 * @param {string} projectId - Project ID
 * @param {Object} quotationData - All quotation data, including pdfUrl and createdBy
 * @returns {Promise<Object>} - Saved quotation data with Firestore document ID
 */
export const saveQuotation = async (projectId, quotationData) => {
  try {
    console.log(
      'Saving quotation metadata to Firestore for project:',
      projectId
    );

    // Destructure and validate required fields from quotationData
    const { pdfUrl, createdBy } = quotationData;

    if (!projectId) {
      throw new Error('ProjectId không được để trống');
    }

    if (!pdfUrl) {
      throw new Error('PDF URL không được để trống');
    }

    if (!createdBy) {
      throw new Error('UserId (createdBy) không được để trống');
    }

    // 1. Save quotation data to Firestore
    const quotationRef = collection(db, `projects/${projectId}/quotations`);
    const docRef = await addDoc(quotationRef, {
      ...quotationData,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(), // Add updatedAt for consistency
    });

    console.log('Quotation metadata saved with ID:', docRef.id);

    // 2. Update project task status
    const projectRef = doc(db, 'projects', projectId);
    await updateDoc(projectRef, {
      'tasks.quotation.status': 'completed',
      'tasks.quotation.completedAt': serverTimestamp(),
      'tasks.quotation.completedBy': createdBy,
      updatedAt: serverTimestamp(),
      updatedBy: createdBy,
    });

    console.log('Project status updated.');

    return {
      id: docRef.id,
      ...quotationData,
    };
  } catch (error) {
    console.error('Error saving quotation metadata:', error);
    throw error;
  }
};

/**
 * Get all quotations for a specific project
 * @param {string} projectId - Project ID
 * @returns {Promise<Array>} - Array of quotations
 */
export const getQuotationsByProject = async (projectId) => {
  try {
    const quotationsRef = collection(db, `projects/${projectId}/quotations`);
    const q = query(quotationsRef, orderBy('createdAt', 'desc'));
    const querySnapshot = await getDocs(q);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    console.error('Error getting quotations:', error);
    throw error;
  }
};

/**
 * Get a specific quotation by ID
 * @param {string} projectId - Project ID
 * @param {string} quotationId - Quotation ID
 * @returns {Promise<Object|null>} - Quotation data or null if not found
 */
export const getQuotationById = async (projectId, quotationId) => {
  try {
    const quotationRef = doc(
      db,
      `projects/${projectId}/quotations`,
      quotationId
    );
    const quotationSnapshot = await getDoc(quotationRef);

    if (quotationSnapshot.exists()) {
      return {
        id: quotationSnapshot.id,
        ...quotationSnapshot.data(),
      };
    } else {
      return null;
    }
  } catch (error) {
    console.error('Error getting quotation by ID:', error);
    throw error;
  }
};

// src/api/supplierService.js
import { db } from '../config/firebaseConfig';
import {
  collection,
  doc,
  getDoc,
  getDocs,
  addDoc,
  updateDoc,
  deleteDoc,
  query,
  orderBy,
  where,
  serverTimestamp,
} from 'firebase/firestore';

// Lấy danh sách tất cả nhà cung cấp
export const getAllSuppliers = async () => {
  try {
    const suppliersRef = collection(db, 'suppliers');
    const q = query(suppliersRef, orderBy('name', 'asc'));
    const querySnapshot = await getDocs(q);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    console.error('Lỗi khi lấy danh sách nhà cung cấp:', error);
    throw error;
  }
};

// Lấy thông tin chi tiết của một nhà cung cấp
export const getSupplierById = async (supplierId) => {
  try {
    const supplierRef = doc(db, 'suppliers', supplierId);
    const supplierDoc = await getDoc(supplierRef);

    if (supplierDoc.exists()) {
      return {
        id: supplierDoc.id,
        ...supplierDoc.data(),
      };
    } else {
      throw new Error('Không tìm thấy nhà cung cấp');
    }
  } catch (error) {
    console.error('Lỗi khi lấy thông tin nhà cung cấp:', error);
    throw error;
  }
};

// Thêm nhà cung cấp mới
export const addSupplier = async (supplierData) => {
  try {
    const suppliersRef = collection(db, 'suppliers');

    // Thêm timestamp
    const supplierWithTimestamp = {
      ...supplierData,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
    };

    const docRef = await addDoc(suppliersRef, supplierWithTimestamp);
    return {
      id: docRef.id,
      ...supplierWithTimestamp,
    };
  } catch (error) {
    console.error('Lỗi khi thêm nhà cung cấp:', error);
    throw error;
  }
};

// Cập nhật thông tin nhà cung cấp
export const updateSupplier = async (supplierId, supplierData) => {
  try {
    const supplierRef = doc(db, 'suppliers', supplierId);

    // Thêm timestamp cập nhật
    const updatedData = {
      ...supplierData,
      updatedAt: serverTimestamp(),
    };

    await updateDoc(supplierRef, updatedData);
    return {
      id: supplierId,
      ...updatedData,
    };
  } catch (error) {
    console.error('Lỗi khi cập nhật nhà cung cấp:', error);
    throw error;
  }
};

// Xóa nhà cung cấp
export const deleteSupplier = async (supplierId) => {
  try {
    const supplierRef = doc(db, 'suppliers', supplierId);
    await deleteDoc(supplierRef);
    return true;
  } catch (error) {
    console.error('Lỗi khi xóa nhà cung cấp:', error);
    throw error;
  }
};

// Tìm kiếm nhà cung cấp theo tên
export const searchSuppliers = async (searchTerm) => {
  try {
    // Lưu ý: Firestore không hỗ trợ tìm kiếm full-text
    // Đây là cách đơn giản để tìm kiếm, có thể cần cải tiến sau
    const suppliersRef = collection(db, 'suppliers');
    const q = query(suppliersRef, orderBy('name'));
    const querySnapshot = await getDocs(q);

    const searchTermLower = searchTerm.toLowerCase();
    return querySnapshot.docs
      .map((doc) => ({ id: doc.id, ...doc.data() }))
      .filter(
        (supplier) =>
          supplier.name.toLowerCase().includes(searchTermLower) ||
          (supplier.contactName &&
            supplier.contactName.toLowerCase().includes(searchTermLower)) ||
          (supplier.phone && supplier.phone.includes(searchTerm))
      );
  } catch (error) {
    console.error('Lỗi khi tìm kiếm nhà cung cấp:', error);
    throw error;
  }
};

// Lấy danh sách nhà cung cấp theo danh mục vật tư
export const getSuppliersByCategory = async (category) => {
  try {
    const suppliersRef = collection(db, 'suppliers');
    const q = query(
      suppliersRef,
      where('categories', 'array-contains', category)
    );
    const querySnapshot = await getDocs(q);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    console.error('Lỗi khi lấy nhà cung cấp theo danh mục:', error);
    throw error;
  }
};

// Thêm đánh giá cho nhà cung cấp
export const addSupplierRating = async (supplierId, ratingData) => {
  try {
    const supplierRef = doc(db, 'suppliers', supplierId);
    const supplierDoc = await getDoc(supplierRef);

    if (!supplierDoc.exists()) {
      throw new Error('Không tìm thấy nhà cung cấp');
    }

    const supplierData = supplierDoc.data();
    const ratings = supplierData.ratings || [];

    // Thêm đánh giá mới với timestamp
    const newRating = {
      ...ratingData,
      createdAt: serverTimestamp(),
    };

    ratings.push(newRating);

    // Tính lại điểm đánh giá trung bình
    const totalRating = ratings.reduce((sum, r) => sum + r.rating, 0);
    const averageRating = totalRating / ratings.length;

    await updateDoc(supplierRef, {
      ratings,
      averageRating,
      updatedAt: serverTimestamp(),
    });

    return {
      ratings,
      averageRating,
    };
  } catch (error) {
    console.error('Lỗi khi thêm đánh giá nhà cung cấp:', error);
    throw error;
  }
};

import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { Card } from 'react-native-paper';
import StatusIndicator from './StatusIndicator';

/**
 * Component hiển thị thông tin vật tư trong kho dưới dạng card
 */
const InventoryItemCard = ({ item, onPress }) => {
  // Xác định trạng thái tồn kho
  const getStockStatus = () => {
    if (!item.minQuantity) return 'normal'; // Nếu không thiết lập mức tối thiểu

    if (item.stockQuantity <= 0) {
      return 'critical'; // Hết hàng
    } else if (item.stockQuantity <= item.minQuantity) {
      return 'warning'; // Dưới mức tối thiểu
    } else {
      return 'normal'; // Bình thường
    }
  };

  // Hiển thị trạng thái
  const renderStockStatus = () => {
    const status = getStockStatus();
    let statusText = 'Bình thường';

    if (status === 'critical') {
      statusText = 'Hết hàng';
    } else if (status === 'warning') {
      statusText = 'Dưới mức tối thiểu';
    }

    return <StatusIndicator status={status} text={statusText} />;
  };

  return (
    <TouchableOpacity onPress={() => onPress(item)}>
      <Card style={styles.card}>
        <Card.Content>
          <View style={styles.header}>
            <View style={styles.titleContainer}>
              <Text style={styles.title} numberOfLines={1}>
                {item.name}
              </Text>
              <Text style={styles.code}>Mã: {item.code}</Text>
            </View>
            {renderStockStatus()}
          </View>

          <View style={styles.detailsContainer}>
            <View style={styles.detailRow}>
              <Text style={styles.detailLabel}>Tồn kho:</Text>
              <Text style={styles.detailValue}>
                {item.stockQuantity} {item.unit}
              </Text>
            </View>

            {item.material && (
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Vật liệu:</Text>
                <Text style={styles.detailValue}>{item.material}</Text>
              </View>
            )}

            {item.weight > 0 && (
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Khối lượng:</Text>
                <Text style={styles.detailValue}>{item.weight} kg</Text>
              </View>
            )}

            {item.price > 0 && (
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Đơn giá:</Text>
                <Text style={styles.detailValue}>
                  {item.price.toLocaleString('vi-VN')} đ
                </Text>
              </View>
            )}
          </View>
        </Card.Content>
      </Card>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  card: {
    marginVertical: 8,
    marginHorizontal: 16,
    elevation: 2,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  code: {
    fontSize: 12,
    color: '#666',
  },
  detailsContainer: {
    marginTop: 5,
  },
  detailRow: {
    flexDirection: 'row',
    marginVertical: 2,
  },
  detailLabel: {
    width: 80,
    color: '#666',
  },
  detailValue: {
    flex: 1,
    fontWeight: '500',
  },
});

export default InventoryItemCard;

import React, { useState, useEffect, useCallback } from 'react';
import {
  Modal,
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  SectionList,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { collection, getDocs, addDoc } from 'firebase/firestore';
import { db } from '../config/firebaseConfig';

/**
 * ProcessPickerModal component
 * Props:
 *  - visible: boolean
 *  - onClose(): void  // close without saving
 *  - onConfirm(templates: ProcessTemplate[]): void // return chosen templates
 *  - existingStageKeys: string[] // list of process keys already in workflow
 */
const ProcessPickerModal = ({
  visible,
  onClose,
  onConfirm,
  existingStageKeys = [],
}) => {
  const [loading, setLoading] = useState(false);
  const [sections, setSections] = useState([]); // [{title, data: ProcessTemplate[]}]
  const [selectedIds, setSelectedIds] = useState(new Set());

  // Predefined templates to seed if collection is empty
  const DEFAULT_TEMPLATES = [
    // Tạo phôi & Cắt gọt
    {
      processKey: 'laser_plasma_cut',
      processName: 'Cắt Laser/Plasma',
      category: 'Tạo phôi & Cắt gọt',
    },
    {
      processKey: 'oxy_gas_cut',
      processName: 'Cắt Oxy-Gas',
      category: 'Tạo phôi & Cắt gọt',
    },
    {
      processKey: 'saw_cut',
      processName: 'Cắt bằng Máy cưa',
      category: 'Tạo phôi & Cắt gọt',
    },
    {
      processKey: 'punch',
      processName: 'Đột / Dập lỗ',
      category: 'Tạo phôi & Cắt gọt',
    },
    {
      processKey: 'turning',
      processName: 'Tiện (Turning)',
      category: 'Tạo phôi & Cắt gọt',
    },
    {
      processKey: 'milling',
      processName: 'Phay (Milling)',
      category: 'Tạo phôi & Cắt gọt',
    },
    {
      processKey: 'drill_tap',
      processName: 'Khoan / Ta-rô',
      category: 'Tạo phôi & Cắt gọt',
    },
    // Biến dạng
    {
      processKey: 'bending',
      processName: 'Chấn / Gấp (Bending)',
      category: 'Biến dạng',
    },
    {
      processKey: 'rolling',
      processName: 'Lốc / Uốn Tôn (Rolling)',
      category: 'Biến dạng',
    },
    {
      processKey: 'pressing',
      processName: 'Dập / Ép (Pressing)',
      category: 'Biến dạng',
    },
    // Lắp ráp & Hoàn thiện
    {
      processKey: 'fit_up',
      processName: 'Tổ hợp / Gá đặt (Fit-up)',
      category: 'Lắp ráp & Hoàn thiện',
    },
    {
      processKey: 'welding',
      processName: 'Hàn (Welding)',
      category: 'Lắp ráp & Hoàn thiện',
    },
    {
      processKey: 'grinding',
      processName: 'Mài / Xử lý bề mặt',
      category: 'Lắp ráp & Hoàn thiện',
    },
    {
      processKey: 'sand_blasting',
      processName: 'Phun cát / Phun bi',
      category: 'Lắp ráp & Hoàn thiện',
    },
    {
      processKey: 'painting',
      processName: 'Sơn (Painting)',
      category: 'Lắp ráp & Hoàn thiện',
    },
    {
      processKey: 'inox_polish',
      processName: 'Đánh bóng Inox',
      category: 'Lắp ráp & Hoàn thiện',
    },
    {
      processKey: 'qc_ndt',
      processName: 'Kiểm tra KCS / NDT',
      category: 'Lắp ráp & Hoàn thiện',
    },
    {
      processKey: 'pack_ship',
      processName: 'Đóng gói & Vận chuyển',
      category: 'Lắp ráp & Hoàn thiện',
    },
  ];

  const fetchTemplates = useCallback(async () => {
    try {
      setLoading(true);
      const snap = await getDocs(collection(db, 'process_templates'));
      const list = snap.docs.map((d) => ({ id: d.id, ...d.data() }));

      // Auto-seed if empty
      if (list.length === 0) {
        await Promise.all(
          DEFAULT_TEMPLATES.map((tpl) =>
            addDoc(collection(db, 'process_templates'), tpl)
          )
        );
        // Re-fetch after seeding
        return fetchTemplates();
      }

      // Group by category
      const grouped = list.reduce((acc, tpl) => {
        const key = tpl.category || 'Khác';
        if (!acc[key]) acc[key] = [];
        acc[key].push(tpl);
        return acc;
      }, {});
      const groupedSections = Object.keys(grouped).map((cat) => ({
        title: cat,
        data: grouped[cat],
      }));
      setSections(groupedSections);
    } catch (err) {
      console.error('Error loading process templates', err);
    } finally {
      setLoading(false);
    }
  }, []);

  // Fetch when opened
  useEffect(() => {
    if (visible) {
      fetchTemplates();
    } else {
      // reset selection when closing
      setSelectedIds(new Set());
    }
  }, [visible, fetchTemplates]);

  const toggleSelect = (template) => {
    const id = template.id;
    const disabled = existingStageKeys.includes(template.processKey);
    if (disabled) return; // ignore taps on already-added stages

    setSelectedIds((prev) => {
      const next = new Set(prev);
      if (next.has(id)) next.delete(id);
      else next.add(id);
      return next;
    });
  };

  const handleConfirm = () => {
    // flatten all sections to find selected templates
    const allTemplates = sections.flatMap((s) => s.data);
    const selected = allTemplates.filter((tpl) => selectedIds.has(tpl.id));
    onConfirm(selected);
    onClose();
  };

  const renderItem = ({ item }) => {
    const disabled = existingStageKeys.includes(item.processKey);
    const selected = disabled || selectedIds.has(item.id);
    const iconColor = disabled ? '#bbb' : selected ? '#4CAF50' : '#999';

    return (
      <TouchableOpacity
        style={[styles.itemRow, disabled && styles.disabledRow]}
        activeOpacity={disabled ? 1 : 0.6}
        onPress={() => toggleSelect(item)}
      >
        <Text style={[styles.itemText, disabled && styles.disabledText]}>
          {item.processName}
        </Text>
        {selected ? (
          <Ionicons name="checkbox" size={22} color={iconColor} />
        ) : (
          <Ionicons name="square-outline" size={22} color={iconColor} />
        )}
      </TouchableOpacity>
    );
  };

  const renderSectionHeader = ({ section: { title } }) => (
    <View style={styles.sectionHeader}>
      <Text style={styles.sectionHeaderText}>{title}</Text>
    </View>
  );

  return (
    <Modal
      visible={visible}
      animationType="slide"
      transparent
      onRequestClose={onClose}
    >
      <View style={styles.overlay}>
        <View style={styles.container}>
          <Text style={styles.title}>Chọn Công đoạn</Text>

          {loading ? (
            <View style={styles.loaderWrapper}>
              <ActivityIndicator size="large" color="#0066cc" />
            </View>
          ) : sections.length === 0 ||
            sections.every((s) => s.data.length === 0) ? (
            <View style={styles.emptyWrapper}>
              <Ionicons name="alert-circle-outline" size={40} color="#999" />
              <Text style={styles.emptyText}>Chưa có công đoạn nào.</Text>
            </View>
          ) : (
            <SectionList
              sections={sections}
              keyExtractor={(item) => item.id}
              renderItem={renderItem}
              renderSectionHeader={renderSectionHeader}
              stickySectionHeadersEnabled={false}
              contentContainerStyle={styles.listContent}
            />
          )}

          {/* Actions */}
          <View style={styles.actions}>
            <TouchableOpacity style={styles.cancelBtn} onPress={onClose}>
              <Text style={styles.btnText}>Hủy</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[
                styles.confirmBtn,
                { opacity: selectedIds.size ? 1 : 0.5 },
              ]}
              disabled={!selectedIds.size}
              onPress={handleConfirm}
            >
              <Text style={[styles.btnText, { color: '#fff' }]}>Thêm</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.4)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  container: {
    width: '90%',
    maxHeight: '80%',
    backgroundColor: '#fff',
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingBottom: 8,
    paddingTop: 12,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 12,
  },
  sectionHeader: {
    backgroundColor: '#f1f1f1',
    paddingVertical: 6,
    paddingHorizontal: 8,
    borderRadius: 6,
    marginTop: 8,
  },
  sectionHeaderText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
  },
  itemRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  itemText: {
    fontSize: 16,
    color: '#333',
    flex: 1,
  },
  listContent: {
    paddingBottom: 8,
  },
  loaderWrapper: {
    paddingVertical: 20,
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    marginTop: 12,
  },
  cancelBtn: {
    paddingVertical: 10,
    paddingHorizontal: 16,
    marginRight: 8,
  },
  confirmBtn: {
    backgroundColor: '#0066cc',
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 6,
  },
  btnText: {
    fontSize: 16,
  },
  emptyWrapper: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 20,
  },
  emptyText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
  },
  disabledRow: {
    backgroundColor: '#f4f4f4',
  },
  disabledText: {
    color: '#999',
  },
});

export default ProcessPickerModal;

//src/components/StatusIndicator.js
import React from 'react';
import { View, StyleSheet, Platform } from 'react-native';

/**
 * Component hiển thị trạng thái công việc dưới dạng hình tròn có màu sắc
 * @param {Object} props - Props của component
 * @param {string} props.status - Trạng thái công việc (pending, in_progress, completed)
 * @param {number} props.size - Kích thước của hình tròn (mặc định: 16)
 * @returns {React.Component} StatusIndicator component
 */
const StatusIndicator = ({ status, size = 16 }) => {
  // Xác định màu sắc dựa trên trạng thái
  const getStatusColor = () => {
    switch (status) {
      case 'completed':
        return '#4CAF50'; // Xanh lá
      case 'in_progress':
        return '#FFC107'; // Vàng
      case 'pending':
        return '#FF9800'; // Cam
      default:
        return '#9E9E9E'; // Xám
    }
  };

  return (
    <View
      style={[
        styles.indicator,
        {
          backgroundColor: getStatusColor(),
          width: size,
          height: size,
          borderRadius: size / 2,
        },
      ]}
    />
  );
};

const styles = StyleSheet.create({
  indicator: {
    // Đổ bóng cho iOS
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.3,
    shadowRadius: 2,
    // Đổ bóng cho Android
    elevation: 4,
    // Các style khác
    marginRight: 10,
    borderWidth: 1,
    borderColor: 'rgba(0,0,0,0.05)',
  },
});

export default StatusIndicator;

import React, { forwardRef } from 'react';
import { TextInput, StyleSheet, View, Text } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

/**
 * Component TextInput tùy chỉnh và nhất quán cho toàn bộ ứng dụng
 * @param {Object} props - Props của component
 * @param {string} props.label - Nhãn cho trường nhập liệu
 * @param {string} props.iconName - Tên biểu tượng Ionicons (tùy chọn)
 * @param {string} props.error - Thông báo lỗi (tùy chọn)
 * @param {Object} props.containerStyle - Style cho container (tùy chọn)
 * @param {Object} props.inputStyle - Style cho input (tùy chọn)
 * @param {boolean} props.required - Đánh dấu trường bắt buộc (tùy chọn)
 * @returns {React.Component} StyledTextInput component
 */
const StyledTextInput = forwardRef(
  (
    {
      label,
      iconName,
      error,
      containerStyle,
      inputStyle,
      required = false,
      ...props
    },
    ref
  ) => {
    return (
      <View style={[styles.container, containerStyle]}>
        {label && (
          <Text style={styles.label}>
            {label}
            {required && <Text style={styles.requiredMark}>*</Text>}
          </Text>
        )}

        <View
          style={[
            styles.inputContainer,
            error ? styles.inputContainerError : null,
          ]}
        >
          {iconName && (
            <Ionicons
              name={iconName}
              size={20}
              color="#666"
              style={styles.icon}
            />
          )}

          <TextInput
            ref={ref}
            style={[styles.input, inputStyle]}
            placeholderTextColor="#999"
            {...props}
          />

          {props.secureTextEntry !== undefined && (
            <View style={styles.rightIconContainer}>{props.rightIcon}</View>
          )}
        </View>

        {error && <Text style={styles.errorText}>{error}</Text>}
      </View>
    );
  }
);

const styles = StyleSheet.create({
  container: {
    marginBottom: 16,
  },
  label: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    marginBottom: 6,
  },
  requiredMark: {
    color: '#e74c3c',
    marginLeft: 4,
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    backgroundColor: '#f9f9f9',
    height: 50,
    paddingHorizontal: 12,
  },
  inputContainerError: {
    borderColor: '#e74c3c',
  },
  icon: {
    marginRight: 10,
  },
  input: {
    flex: 1,
    height: 50,
    fontSize: 16,
    color: '#333',
  },
  rightIconContainer: {
    paddingLeft: 8,
  },
  errorText: {
    color: '#e74c3c',
    fontSize: 12,
    marginTop: 4,
    marginLeft: 4,
  },
});

export default StyledTextInput;

import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Modal,
  TouchableOpacity,
  FlatList,
  ActivityIndicator,
  TextInput,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { getAllSuppliers } from '../api/supplierService';

const SupplierPickerModal = ({ visible, onClose, onSelect }) => {
  const [loading, setLoading] = useState(true);
  const [suppliers, setSuppliers] = useState([]);
  const [search, setSearch] = useState('');

  useEffect(() => {
    if (visible) {
      fetchSuppliers();
    }
  }, [visible]);

  const fetchSuppliers = async () => {
    setLoading(true);
    try {
      const data = await getAllSuppliers();
      setSuppliers(data);
    } catch (err) {
      console.error('Load suppliers error:', err);
    } finally {
      setLoading(false);
    }
  };

  const filtered = suppliers.filter((s) =>
    s.name.toLowerCase().includes(search.toLowerCase())
  );

  const renderItem = ({ item }) => (
    <TouchableOpacity
      style={styles.item}
      onPress={() => {
        onSelect(item);
        onClose();
      }}
    >
      <Text style={styles.name}>{item.name}</Text>
      {item.address ? <Text style={styles.sub}>{item.address}</Text> : null}
    </TouchableOpacity>
  );

  return (
    <Modal visible={visible} transparent animationType="slide">
      <View style={styles.overlay}>
        <View style={styles.container}>
          <View style={styles.header}>
            <Text style={styles.title}>Chọn nhà cung cấp</Text>
            <TouchableOpacity onPress={onClose}>
              <Ionicons name="close" size={24} color="#333" />
            </TouchableOpacity>
          </View>

          <View style={styles.searchBar}>
            <Ionicons name="search" size={18} color="#666" />
            <TextInput
              style={styles.searchInput}
              placeholder="Tìm kiếm..."
              value={search}
              onChangeText={setSearch}
            />
          </View>

          {loading ? (
            <ActivityIndicator size="large" color="#0066cc" />
          ) : (
            <FlatList
              data={filtered}
              keyExtractor={(item) => item.id}
              renderItem={renderItem}
              ItemSeparatorComponent={() => <View style={styles.separator} />}
            />
          )}
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.4)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  container: {
    width: '90%',
    maxHeight: '80%',
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  title: { fontSize: 18, fontWeight: 'bold', color: '#333' },
  searchBar: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 6,
    paddingHorizontal: 8,
    marginBottom: 12,
  },
  searchInput: { flex: 1, paddingVertical: 6, marginLeft: 6 },
  item: { paddingVertical: 10 },
  name: { fontSize: 16, fontWeight: '500', color: '#333' },
  sub: { fontSize: 12, color: '#666', marginTop: 2 },
  separator: { height: 1, backgroundColor: '#eee' },
});

export default SupplierPickerModal;

import React, { useContext } from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import { ThemeContext } from '../contexts/ThemeContext';

const TaskCard = ({ task, onPress }) => {
  const { theme } = useContext(ThemeContext);
  const styles = getStyles(theme);

  const getStatusColor = (status) => {
    switch (status) {
      case 'completed':
        return { bg: 'rgba(46, 204, 113, 0.2)', text: '#27AE60' };
      case 'in_progress':
        return { bg: 'rgba(52, 152, 219, 0.2)', text: '#2980B9' };
      case 'pending':
        return { bg: 'rgba(241, 196, 15, 0.2)', text: '#F39C12' };
      default:
        return { bg: theme.border, text: theme.textSecondary };
    }
  };

  const getStatusLabel = (status) => {
    switch (status) {
      case 'completed':
        return 'Hoàn thành';
      case 'in_progress':
        return 'Đang thực hiện';
      case 'pending':
        return 'Chờ xử lý';
      default:
        return 'Không xác định';
    }
  };

  const statusStyle = getStatusColor(task.status);

  return (
    <TouchableOpacity style={styles.card} onPress={onPress}>
      <View style={styles.cardHeader}>
        <Text style={styles.taskLabel}>{task.taskLabel}</Text>
        <View style={[styles.statusBadge, { backgroundColor: statusStyle.bg }]}>
          <Text style={[styles.statusText, { color: statusStyle.text }]}>
            {getStatusLabel(task.status)}
          </Text>
        </View>
      </View>
      <View style={styles.cardBody}>
        <Text style={styles.projectName}>Dự án: {task.projectName}</Text>
        <Text style={styles.assignedTo}>Phụ trách: {task.assignedToName}</Text>
      </View>
    </TouchableOpacity>
  );
};

const getStyles = (theme) =>
  StyleSheet.create({
    card: {
      backgroundColor: theme.card,
      padding: 16,
      borderRadius: 12,
      marginVertical: 8,
      borderWidth: 1,
      borderColor: theme.border,
      elevation: 2,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.05,
      shadowRadius: 2,
    },
    cardHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 4,
    },
    taskLabel: {
      fontSize: 17,
      fontWeight: 'bold',
      color: theme.text,
      flex: 1, // Allow text to wrap if long
    },
    statusBadge: {
      paddingHorizontal: 10,
      paddingVertical: 4,
      borderRadius: 12,
      marginLeft: 8,
    },
    statusText: {
      fontSize: 12,
      fontWeight: '600',
    },
    cardBody: {
      marginTop: 8,
    },
    projectName: {
      fontSize: 14,
      color: theme.textSecondary,
      marginBottom: 4,
    },
    assignedTo: {
      fontSize: 14,
      color: theme.textSecondary,
    },
  });

export default TaskCard;

//src/config/authConfig.js
// Cấu hình xác thực cho các dịch vụ bên ngoài
export const googleAuthConfig = {
  // Thay thế các giá trị này bằng Client ID thực tế của bạn
  iosClientId:
    '370615243912-o6d5f9a9l5vbui1o1gcnd5t0lbkru9is.apps.googleusercontent.com',
  androidClientId:
    '370615243912-v7btvdq1e1b4min5snq7av9jpoe7lr10.apps.googleusercontent.com',
  webClientId:
    '370615243912-fesvpqtf06r7ugj31ma1urmrii85m7at.apps.googleusercontent.com',
  offlineAccess: true,

  // Các scopes mặc định cho Google Drive
  driveScopes: [
    'https://www.googleapis.com/auth/drive.readonly',
    'https://www.googleapis.com/auth/drive.metadata.readonly',
  ],

  // Các scopes mặc định cho Google Sheets
  sheetsScopes: [
    'https://www.googleapis.com/auth/drive.readonly',
    'https://www.googleapis.com/auth/spreadsheets.readonly',
  ],
};

// Hàm helper để log chi tiết lỗi Google API
export const logGoogleApiError = (error, context = '') => {
  console.error(`Google API Error ${context ? `(${context})` : ''}:`, error);

  // Log thông tin chi tiết hơn nếu có
  if (error.response) {
    console.error('Error response:', {
      status: error.response.status,
      statusText: error.response.statusText,
      data: error.response.data,
    });
  }

  // Log thông tin request nếu có
  if (error.config) {
    console.error('Request config:', {
      url: error.config.url,
      method: error.config.method,
      headers: error.config.headers,
      params: error.config.params,
    });
  }

  return error;
};

//src/config/colors.js
export const lightTheme = {
  // Màu nền
  background: '#FFFFFF',
  backgroundSecondary: '#F8F8F8',
  card: '#FFFFFF',

  // Màu chữ
  text: '#333333',
  textSecondary: '#666666',
  textMuted: '#999999',

  // Màu thương hiệu và hành động
  primary: '#0066CC',
  primaryLight: '#E6F0FA',
  secondary: '#4CAF50',
  danger: '#E74C3C',
  warning: '#FF9800',
  info: '#2196F3',

  // Màu viền
  border: '#DDDDDD',
  borderLight: '#EEEEEE',

  // Màu trạng thái
  statusCompleted: '#4CAF50',
  statusInProgress: '#2196F3',
  statusPending: '#FF9800',
  statusCancelled: '#F44336',

  // Màu input
  inputBackground: '#F9F9F9',
  inputBorder: '#DDDDDD',
  inputPlaceholder: '#999999',

  // Màu khác
  divider: '#EEEEEE',
  shadow: '#000000',
  overlay: 'rgba(0, 0, 0, 0.5)',

  // Độ trong suốt
  opacity: {
    disabled: 0.5,
    hover: 0.8,
  },
};

export const darkTheme = {
  // Màu nền
  background: '#121212',
  backgroundSecondary: '#1E1E1E',
  card: '#242424',

  // Màu chữ
  text: '#FFFFFF',
  textSecondary: '#CCCCCC',
  textMuted: '#999999',

  // Màu thương hiệu và hành động
  primary: '#0B84FF',
  primaryLight: '#1C2A3A',
  secondary: '#4CAF50',
  danger: '#E74C3C',
  warning: '#FF9800',
  info: '#2196F3',

  // Màu viền
  border: '#444444',
  borderLight: '#333333',

  // Màu trạng thái
  statusCompleted: '#4CAF50',
  statusInProgress: '#2196F3',
  statusPending: '#FF9800',
  statusCancelled: '#F44336',

  // Màu input
  inputBackground: '#333333',
  inputBorder: '#444444',
  inputPlaceholder: '#777777',

  // Màu khác
  divider: '#333333',
  shadow: '#000000',
  overlay: 'rgba(0, 0, 0, 0.7)',

  // Độ trong suốt
  opacity: {
    disabled: 0.5,
    hover: 0.8,
  },
};

//src/config/firebaseConfig.js
// Import the required Firebase modules
import { initializeApp, getApps, getApp } from 'firebase/app';
import {
  initializeAuth,
  getReactNativePersistence,
  getAuth,
} from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';
import { getStorage } from 'firebase/storage';
import { getFunctions, connectFunctionsEmulator } from 'firebase/functions';
import AsyncStorage from '@react-native-async-storage/async-storage';
// Import Firebase compat to support legacy code that still uses the namespaced API (e.g., firebase.firestore())
import firebaseCompat from 'firebase/compat/app';
import 'firebase/compat/firestore';
import 'firebase/compat/auth';
import 'firebase/compat/storage';
import 'firebase/compat/functions';

// Firebase configuration object
const firebaseConfig = {
  apiKey: 'AIzaSyBYQoTM8YwjL4cq1TdF7dFz5U6Ss-wxb3A',
  authDomain: 'tanyb-fe4bf.firebaseapp.com',
  projectId: 'tanyb-fe4bf',
  storageBucket: 'tanyb-fe4bf.appspot.com',
  messagingSenderId: '370615243912',
  appId: '1:370615243912:web:f070ed1f8a20f4baaf7b3d',
  measurementId: 'G-DY64DPJJVQ',
};

let app;
let auth;

// Singleton pattern to avoid re-initialization
if (getApps().length < 1) {
  app = initializeApp(firebaseConfig);
  auth = initializeAuth(app, {
    persistence: getReactNativePersistence(AsyncStorage),
  });
} else {
  app = getApp();
  auth = getAuth(app);
}

const db = getFirestore(app);
const storage = getStorage(app);
const functions = getFunctions(app, 'asia-southeast1');

// (Tùy chọn) Nếu bạn dùng emulator để test local, hãy bỏ comment dòng dưới
// if (__DEV__) {
//   try {
//     connectFunctionsEmulator(functions, 'localhost', 5001);
//   } catch (e) {
//     console.warn('Functions emulator already connected?');
//   }
// }

console.log('Firebase services handled.');

// Initialize firebase compat (namespaced) app if not already initialized
if (!firebaseCompat.apps.length) {
  firebaseCompat.initializeApp(firebaseConfig);
}

// Firestore and other services are now accessible via firebaseCompat.firestore(), etc.

// Export the initialized services
export { auth, db, storage, functions, firebaseCompat as firebase };
export default app;

//src/contexts/AuthContext.js
import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
} from 'react';
import {
  onAuthStateChanged,
  signOut,
  signInWithEmailAndPassword,
  createUserWithEmailAndPassword,
  updateProfile,
  sendPasswordResetEmail,
} from 'firebase/auth';
import { doc, getDoc, setDoc, serverTimestamp } from 'firebase/firestore';
import { auth, db } from '../config/firebaseConfig';
import { Alert } from 'react-native';
import NetInfo from '@react-native-community/netinfo';
import { GoogleSignin } from '@react-native-google-signin/google-signin';

// Tạo context cho xác thực
const AuthContext = createContext();

// Provider component để cung cấp trạng thái xác thực cho toàn bộ ứng dụng
export const AuthProvider = ({ children }) => {
  // Các state cần thiết
  const [currentUser, setCurrentUser] = useState(null);
  const [userRole, setUserRole] = useState(null);
  const [loadingAuth, setLoadingAuth] = useState(true);
  const [error, setError] = useState(null);
  const [connectionStatus, setConnectionStatus] = useState('connected');
  const [isOffline, setIsOffline] = useState(false);

  // Theo dõi trạng thái kết nối mạng
  useEffect(() => {
    console.log('Setting up network listener...');
    const unsubscribeNetInfo = NetInfo.addEventListener((state) => {
      console.log(
        'Network status:',
        state.isConnected ? 'Connected' : 'Disconnected'
      );
      setIsOffline(!state.isConnected);
      setConnectionStatus(state.isConnected ? 'connected' : 'disconnected');
    });

    return () => {
      unsubscribeNetInfo();
    };
  }, []);

  // Hàm lấy thông tin người dùng từ Firestore
  const fetchUserData = useCallback(async (userAuth) => {
    if (!userAuth) return null;

    const userRef = doc(db, 'users', userAuth.uid);
    try {
      console.log('Fetching user data for:', userAuth.uid);
      const docSnap = await getDoc(userRef);

      if (docSnap.exists()) {
        console.log('User data found:', docSnap.data());
        return { uid: userAuth.uid, email: userAuth.email, ...docSnap.data() };
      } else {
        console.log('User document not found! Creating new one.');
        const newUser = {
          uid: userAuth.uid,
          email: userAuth.email,
          role: 'user',
          createdAt: serverTimestamp(),
          displayName: userAuth.displayName || userAuth.email.split('@')[0],
          photoURL: userAuth.photoURL || '',
        };
        await setDoc(userRef, newUser);
        console.log('New user document created.');
        return newUser;
      }
    } catch (err) {
      console.error('Error fetching/creating user document:', err);
      // Fallback offline data
      return {
        uid: userAuth.uid,
        email: userAuth.email,
        displayName: userAuth.displayName || userAuth.email.split('@')[0],
        role: 'user',
        isOfflineData: true,
      };
    }
  }, []);

  // Lắng nghe sự thay đổi trạng thái xác thực
  useEffect(() => {
    console.log('Setting up auth state listener...');

    // Kiểm tra xem auth đã được khởi tạo chưa
    if (!auth) {
      console.error('Auth instance is not initialized!');
      setLoadingAuth(false);
      setError('Authentication service is not available');
      return () => {};
    }

    const unsubscribe = onAuthStateChanged(auth, async (userAuth) => {
      console.log(
        'Auth state changed:',
        userAuth ? 'User logged in' : 'User logged out'
      );
      setLoadingAuth(true);

      try {
        if (userAuth) {
          const userData = await fetchUserData(userAuth);
          if (userData) {
            setCurrentUser(userData);
            setUserRole(userData.role || 'user');
          }
        } else {
          setCurrentUser(null);
          setUserRole(null);
        }
      } catch (err) {
        console.error('Error in auth state change:', err);
        setError('Authentication error occurred.');
      } finally {
        setLoadingAuth(false);
      }
    });

    return () => unsubscribe();
  }, [fetchUserData]);

  // Hàm đăng nhập
  const login = async (email, password) => {
    try {
      setLoadingAuth(true);
      setError(null);

      // Kiểm tra kết nối mạng
      const netInfo = await NetInfo.fetch();
      if (!netInfo.isConnected) {
        throw new Error('No internet connection');
      }

      await signInWithEmailAndPassword(auth, email, password);
      console.log('Login successful:', email);
      return true;
    } catch (error) {
      console.error('Login error:', error);
      let errorMessage = 'Login failed. Please check your credentials.';

      switch (error.code) {
        case 'auth/invalid-email':
          errorMessage = 'Invalid email address.';
          break;
        case 'auth/user-disabled':
          errorMessage = 'This account has been disabled.';
          break;
        case 'auth/user-not-found':
          errorMessage = 'No account found with this email.';
          break;
        case 'auth/wrong-password':
          errorMessage = 'Incorrect password.';
          break;
        case 'auth/too-many-requests':
          errorMessage = 'Too many failed attempts. Please try again later.';
          break;
        case 'auth/network-request-failed':
          errorMessage = 'Network error. Please check your connection.';
          break;
        default:
          if (
            error.message.includes('internet') ||
            error.message.includes('connection')
          ) {
            errorMessage = 'No internet connection. Please check your network.';
          }
          break;
      }

      setError(errorMessage);
      Alert.alert('Login Error', errorMessage);
      return false;
    } finally {
      setLoadingAuth(false);
    }
  };

  // Hàm đăng ký
  const register = async (email, password, displayName) => {
    try {
      setLoadingAuth(true);
      setError(null);

      const userCredential = await createUserWithEmailAndPassword(
        auth,
        email,
        password
      );

      if (displayName) {
        await updateProfile(userCredential.user, { displayName });
      }

      await setDoc(doc(db, 'users', userCredential.user.uid), {
        email,
        displayName: displayName || email.split('@')[0],
        role: 'user',
        createdAt: serverTimestamp(),
        photoURL: '',
      });

      console.log('Registration successful:', email);
      return true;
    } catch (error) {
      console.error('Registration error:', error);
      let errorMessage = 'Registration failed. Please try again.';

      switch (error.code) {
        case 'auth/email-already-in-use':
          errorMessage = 'This email is already registered.';
          break;
        case 'auth/invalid-email':
          errorMessage = 'Invalid email address.';
          break;
        case 'auth/weak-password':
          errorMessage =
            'Password is too weak. Please choose a stronger password.';
          break;
        case 'auth/network-request-failed':
          errorMessage = 'Network error. Please check your connection.';
          break;
      }

      setError(errorMessage);
      Alert.alert('Registration Error', errorMessage);
      return false;
    } finally {
      setLoadingAuth(false);
    }
  };

  // Hàm đăng xuất
  const logout = async () => {
    try {
      // Đăng xuất khỏi Google Sign-In trước
      if (await GoogleSignin.isSignedIn()) {
        await GoogleSignin.signOut();
        console.log('Google user signed out');
      }

      // Sau đó đăng xuất khỏi Firebase
      await signOut(auth);

      // Cập nhật state
      setCurrentUser(null);
      setUserRole(null);

      console.log('User logged out successfully from all services');
      return true;
    } catch (error) {
      console.error('Logout failed:', error);
      setError('Logout failed. Please try again.');
      Alert.alert('Error', 'Logout failed. Please try again.');
      return false;
    }
  };

  // Hàm quên mật khẩu
  const resetPassword = async (email) => {
    try {
      setLoadingAuth(true);
      setError(null);
      await sendPasswordResetEmail(auth, email);
      Alert.alert(
        'Password Reset Email Sent',
        'Please check your inbox and follow the instructions to reset your password.'
      );
      return true;
    } catch (error) {
      console.error('Password reset error:', error);
      let errorMessage =
        'Could not send password reset email. Please try again.';

      switch (error.code) {
        case 'auth/invalid-email':
          errorMessage = 'Invalid email address.';
          break;
        case 'auth/user-not-found':
          errorMessage = 'No account found with this email.';
          break;
      }

      setError(errorMessage);
      Alert.alert('Password Reset Error', errorMessage);
      return false;
    } finally {
      setLoadingAuth(false);
    }
  };

  // Giá trị context để cung cấp cho toàn bộ ứng dụng
  const value = {
    currentUser,
    userRole,
    user: currentUser,
    loadingAuth,
    error,
    isSignedIn: !!currentUser,
    login,
    logout,
    register,
    resetPassword,
    connectionStatus,
    isOffline,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

// Custom hook để sử dụng AuthContext
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export default AuthContext;

import React, { createContext, useState, useContext, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useColorScheme } from 'react-native';
import { lightTheme, darkTheme } from '../config/colors';

// Tạo context cho theme
const ThemeContext = createContext();

// Hook để sử dụng theme
export const useTheme = () => useContext(ThemeContext);

// Provider component
export const ThemeProvider = ({ children }) => {
  // Lấy theme hệ thống
  const systemColorScheme = useColorScheme();

  // State để lưu trạng thái dark mode
  const [isDarkMode, setIsDarkMode] = useState(false);

  // State để lưu trạng thái theo dõi hệ thống
  const [followSystem, setFollowSystem] = useState(true);

  // Lấy theme từ storage khi component mount
  useEffect(() => {
    const loadThemePreference = async () => {
      try {
        const storedIsDarkMode = await AsyncStorage.getItem('isDarkMode');
        const storedFollowSystem = await AsyncStorage.getItem('followSystem');

        if (storedFollowSystem !== null) {
          setFollowSystem(storedFollowSystem === 'true');
        }

        if (storedIsDarkMode !== null && !followSystem) {
          setIsDarkMode(storedIsDarkMode === 'true');
        } else if (followSystem) {
          setIsDarkMode(systemColorScheme === 'dark');
        }
      } catch (error) {
        console.log('Error loading theme preference:', error);
      }
    };

    loadThemePreference();
  }, [systemColorScheme]);

  // Cập nhật theme khi systemColorScheme thay đổi và followSystem = true
  useEffect(() => {
    if (followSystem) {
      setIsDarkMode(systemColorScheme === 'dark');
    }
  }, [systemColorScheme, followSystem]);

  // Hàm toggle dark mode
  const toggleTheme = async () => {
    try {
      const newValue = !isDarkMode;
      setIsDarkMode(newValue);
      await AsyncStorage.setItem('isDarkMode', String(newValue));

      // Khi người dùng chủ động thay đổi theme, tắt chế độ theo dõi hệ thống
      if (followSystem) {
        setFollowSystem(false);
        await AsyncStorage.setItem('followSystem', 'false');
      }
    } catch (error) {
      console.log('Error saving theme preference:', error);
    }
  };

  // Hàm toggle chế độ theo dõi hệ thống
  const toggleFollowSystem = async () => {
    try {
      const newValue = !followSystem;
      setFollowSystem(newValue);
      await AsyncStorage.setItem('followSystem', String(newValue));

      // Nếu bật chế độ theo dõi hệ thống, cập nhật theme theo hệ thống
      if (newValue) {
        const systemIsDark = systemColorScheme === 'dark';
        setIsDarkMode(systemIsDark);
        await AsyncStorage.setItem('isDarkMode', String(systemIsDark));
      }
    } catch (error) {
      console.log('Error saving system preference:', error);
    }
  };

  // Lấy theme hiện tại
  const theme = isDarkMode ? darkTheme : lightTheme;

  // Giá trị được cung cấp bởi context
  const value = {
    isDarkMode,
    theme,
    toggleTheme,
    followSystem,
    toggleFollowSystem,
  };

  return (
    <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>
  );
};

export default ThemeContext;

import { useState } from 'react';
import { Share, Alert, Linking } from 'react-native';
import { getFunctions, httpsCallable } from 'firebase/functions';

/**
 * Custom hook for generating contract documents.
 * This hook now handles generating a Google Doc and sharing its URL.
 * @param {Object} options - Configuration options
 * @returns {Object} - Functions and state for contract generation
 */
const useContractGenerator = ({
  projectId,
  customerData,
  materials,
  quotationData,
}) => {
  const [isLoading, setIsLoading] = useState(false);
  const [contractDocUrl, setContractDocUrl] = useState(null);

  /**
   * Format contract data for the template.
   */
  const formatContractData = () => {
    // Get today's date components for the contract
    const today = new Date();
    const day = today.getDate().toString();
    const month = (today.getMonth() + 1).toString();

    // Prepare contract data
    const contractData = {
      // Basic info
      companyName: customerData?.companyName || customerData?.name || '',
      customerAddress: customerData?.address || '',
      companyPhone: customerData?.phoneNumber || customerData?.phone || '',
      taxCode: customerData?.taxCode || '',
      day,
      month,
      deliveryTime: quotationData?.deliveryTime || '',

      // Pass the original materials array
      materials: materials || [],
    };

    return contractData;
  };

  /**
   * Generate contract document
   */
  const generateContract = async () => {
    setIsLoading(true);
    setContractDocUrl(null); // Reset on new generation

    try {
      // Format contract data
      const contractData = formatContractData();

      // Call cloud function to generate contract
      const functions = getFunctions();
      const generateContractFunc = httpsCallable(functions, 'generateContract');

      const result = await generateContractFunc({
        contractData,
        fileName: `Hop_dong_${
          customerData?.companyName || customerData?.name || 'khach_hang'
        }_${new Date().getTime()}`,
        projectId,
      });

      // The cloud function now returns docUrl and docId
      const { docUrl } = result.data;

      // Update state with the new Google Doc URL
      setContractDocUrl(docUrl);

      Alert.alert(
        'Thành công',
        'Đã tạo hợp đồng Google Docs thành công. Bạn có muốn chia sẻ liên kết không?',
        [
          { text: 'Để sau', style: 'cancel' },
          { text: 'Chia sẻ', onPress: () => shareContractDoc(docUrl) },
        ]
      );

      return { docUrl };
    } catch (error) {
      console.error('Error generating contract:', error);
      Alert.alert(
        'Lỗi',
        `Không thể tạo hợp đồng: ${error.message || 'Lỗi không xác định'}`
      );
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  /**
   * Share the Google Doc contract URL.
   * @param {string} docUrl - The URL of the Google Doc to share.
   */
  const shareContractDoc = async (docUrl) => {
    const urlToShare = docUrl || contractDocUrl;
    if (!urlToShare) {
      Alert.alert('Lỗi', 'Chưa có liên kết hợp đồng để chia sẻ.');
      return;
    }

    try {
      // Trước tiên, thử mở Google Docs trực tiếp để tận dụng giao diện chia sẻ có sẵn của Google
      const canOpenDoc = await Linking.canOpenURL(urlToShare);

      if (canOpenDoc) {
        // Mở trực tiếp Google Doc để người dùng chia sẻ từ giao diện Google
        await Linking.openURL(urlToShare);
        return;
      }

      // Nếu không thể mở trực tiếp, thì thực hiện chia sẻ URL như phương án dự phòng
      await Share.share({
        message: `Vui lòng xem hợp đồng tại đây: ${urlToShare}`,
        url: urlToShare,
        title: 'Chia sẻ Hợp đồng',
      });
    } catch (error) {
      console.error('Error sharing contract doc:', error);
      Alert.alert('Lỗi', 'Không thể chia sẻ hợp đồng: ' + error.message);
    }
  };

  return {
    isLoading,
    contractDocUrl,
    generateContract,
    shareContractDoc,
  };
};

export default useContractGenerator;

import { useState, useEffect, useCallback } from 'react';
import InventoryService from '../api/inventoryService';
import { firebase } from '../config/firebaseConfig';

/**
 * Hook quản lý các chức năng liên quan đến kho
 * @returns {Object} Các chức năng và dữ liệu kho
 */
const useInventory = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [inventoryItems, setInventoryItems] = useState([]);
  const [categories, setCategories] = useState([]);
  const [locations, setLocations] = useState([]);

  /**
   * Lấy danh sách vật tư từ Firestore
   */
  const fetchInventoryItems = useCallback(async (filters = {}) => {
    setLoading(true);
    setError(null);
    try {
      // Khởi tạo truy vấn
      let query = firebase.firestore().collection('inventory');

      // Áp dụng bộ lọc nếu có
      if (filters.categoryId) {
        query = query.where('categoryId', '==', filters.categoryId);
      }

      if (filters.locationId) {
        query = query.where('locationId', '==', filters.locationId);
      }

      // Thực hiện truy vấn
      const snapshot = await query.get();

      // Lấy dữ liệu từ kết quả
      const items = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));

      // Áp dụng bộ lọc tồn kho nếu có
      const filteredItems = filters.lowStock
        ? items.filter(
            (item) =>
              item.stockQuantity <= (item.minQuantity || 0) &&
              item.minQuantity > 0
          )
        : items;

      setInventoryItems(filteredItems);
    } catch (err) {
      console.error('Lỗi khi lấy danh sách vật tư:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, []);

  /**
   * Lấy danh sách danh mục vật tư
   */
  const fetchCategories = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const snapshot = await firebase
        .firestore()
        .collection('inventory_categories')
        .get();
      const fetchedCategories = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));
      setCategories(fetchedCategories);
    } catch (err) {
      console.error('Lỗi khi lấy danh mục vật tư:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, []);

  /**
   * Lấy danh sách các vị trí kho
   */
  const fetchLocations = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const locations = await InventoryService.getAllLocations();
      setLocations(locations);
    } catch (err) {
      console.error('Lỗi khi lấy vị trí kho:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, []);

  /**
   * Thêm vật tư mới
   * @param {Object} itemData - Thông tin vật tư
   * @returns {Promise<Object>} - Kết quả thao tác
   */
  const addInventoryItem = async (itemData) => {
    setLoading(true);
    setError(null);
    try {
      const result = await InventoryService.addInventoryItem(itemData);
      // Refresh danh sách nếu thành công
      await fetchInventoryItems();
      return result;
    } catch (err) {
      console.error('Lỗi khi thêm vật tư:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  /**
   * Cập nhật thông tin vật tư
   * @param {string} itemId - ID vật tư
   * @param {Object} itemData - Thông tin cập nhật
   * @returns {Promise<Object>} - Kết quả thao tác
   */
  const updateInventoryItem = async (itemId, itemData) => {
    setLoading(true);
    setError(null);
    try {
      const result = await InventoryService.updateInventoryItem(
        itemId,
        itemData
      );
      // Refresh danh sách nếu thành công
      await fetchInventoryItems();
      return result;
    } catch (err) {
      console.error('Lỗi khi cập nhật vật tư:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  /**
   * Tạo giao dịch nhập/xuất kho
   * @param {Object} transactionData - Thông tin giao dịch
   * @returns {Promise<Object>} - Kết quả thao tác
   */
  const createTransaction = async (transactionData) => {
    setLoading(true);
    setError(null);
    try {
      const result = await InventoryService.createTransaction(transactionData);
      // Refresh danh sách nếu thành công
      await fetchInventoryItems();
      return result;
    } catch (err) {
      console.error('Lỗi khi tạo giao dịch kho:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  /**
   * Lấy thống kê sử dụng vật tư theo dự án
   * @param {string} projectId - ID dự án
   * @param {Object} dateRange - Khoảng thời gian
   * @returns {Promise<Object>} - Kết quả thao tác
   */
  const getProjectMaterialUsage = async (projectId, dateRange = {}) => {
    setLoading(true);
    setError(null);
    try {
      return await InventoryService.getProjectMaterialUsage(
        projectId,
        dateRange.startDate,
        dateRange.endDate
      );
    } catch (err) {
      console.error('Lỗi khi lấy thống kê sử dụng vật tư:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  /**
   * Quản lý danh mục vật tư (thêm, sửa, xóa)
   * @param {string} action - Hành động: 'add', 'update', 'delete'
   * @param {Object} categoryData - Thông tin danh mục
   * @param {string} categoryId - ID danh mục (cho update/delete)
   * @returns {Promise<Object>} - Kết quả thao tác
   */
  const manageCategory = async (action, categoryData, categoryId) => {
    setLoading(true);
    setError(null);
    try {
      const result = await InventoryService.manageCategory(
        action,
        categoryData,
        categoryId
      );
      // Refresh danh mục nếu thành công
      await fetchCategories();
      return result;
    } catch (err) {
      console.error('Lỗi khi quản lý danh mục:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  /**
   * Lấy chi tiết vật tư
   * @param {string} itemId - ID vật tư
   * @returns {Promise<Object>} - Thông tin chi tiết vật tư
   */
  const getInventoryItemDetail = async (itemId) => {
    setLoading(true);
    setError(null);
    try {
      const itemDetail = await InventoryService.getItemById(itemId);
      const transactions = await InventoryService.getItemTransactions(itemId);

      // Nếu item có categoryId, lấy thông tin danh mục
      let category = null;
      if (itemDetail.categoryId) {
        const categoryDoc = await firebase
          .firestore()
          .collection('inventory_categories')
          .doc(itemDetail.categoryId)
          .get();

        if (categoryDoc.exists) {
          category = {
            id: categoryDoc.id,
            ...categoryDoc.data(),
          };
        }
      }

      return {
        ...itemDetail,
        category,
        transactions,
      };
    } catch (err) {
      console.error('Lỗi khi lấy chi tiết vật tư:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  /**
   * Nhập vật tư từ file Excel mới nhất trong Google Drive
   * @param {string} accessToken - Google access token
   * @param {string} folderId - ID của folder chứa file Excel
   * @returns {Promise<Object>} - Kết quả nhập vật tư
   */
  const importInventoryFromDrive = async (accessToken, folderId) => {
    setLoading(true);
    setError(null);
    try {
      const result = await InventoryService.importInventoryFromDrive(
        accessToken,
        folderId
      );
      // Refresh danh sách nếu thành công
      await fetchInventoryItems();
      return result;
    } catch (err) {
      console.error('Lỗi khi nhập vật tư từ Google Drive:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  /**
   * Tìm vật tư tương tự trong kho
   * @param {Object} criteria - Tiêu chí tìm kiếm (tên, mã, đơn vị...)
   * @returns {Promise<Array>} - Danh sách vật tư tương tự
   */
  const findSimilarItems = useCallback(
    async (criteria) => {
      setLoading(true);
      setError(null);
      try {
        // Nếu chưa có dữ liệu, tải danh sách vật tư
        if (inventoryItems.length === 0) {
          await fetchInventoryItems();
        }

        // Tìm kiếm theo tên
        if (criteria.name) {
          const nameWords = criteria.name
            .toLowerCase()
            .split(' ')
            .filter((word) => word.length > 2);

          const matchedItems = inventoryItems.filter((item) => {
            const itemNameLower = item.name.toLowerCase();

            // Kiểm tra tên vật tư có chứa từ khóa tìm kiếm không
            const nameMatch = nameWords.some((word) =>
              itemNameLower.includes(word)
            );

            // Kiểm tra đơn vị tính nếu có
            const unitMatch =
              !criteria.unit ||
              (item.unit &&
                item.unit.toLowerCase() === criteria.unit.toLowerCase());

            // Kiểm tra chất liệu nếu có
            const materialMatch =
              !criteria.material ||
              (item.material &&
                item.material
                  .toLowerCase()
                  .includes(criteria.material.toLowerCase()));

            // Kiểm tra danh mục nếu có
            const categoryMatch =
              !criteria.categoryId || item.categoryId === criteria.categoryId;

            return nameMatch && unitMatch && materialMatch && categoryMatch;
          });

          return matchedItems;
        }

        // Nếu tìm theo mã vật tư
        if (criteria.code) {
          const codeLower = criteria.code.toLowerCase();

          return inventoryItems.filter(
            (item) => item.code && item.code.toLowerCase().includes(codeLower)
          );
        }

        // Nếu không có tiêu chí cụ thể, trả về danh sách trống
        return [];
      } catch (err) {
        console.error('Lỗi khi tìm vật tư tương tự:', err);
        setError(err.message);
        return [];
      } finally {
        setLoading(false);
      }
    },
    [inventoryItems, fetchInventoryItems]
  );

  /**
   * Gán vật tư từ kho cho dự án
   * @param {string} inventoryItemId - ID vật tư trong kho
   * @param {string} projectId - ID dự án
   * @param {number} quantity - Số lượng cần gán
   * @param {Object} metadata - Thông tin bổ sung
   * @returns {Promise<Object>} - Kết quả thao tác
   */
  const assignInventoryItemToProject = async (
    inventoryItemId,
    projectId,
    quantity,
    metadata = {}
  ) => {
    setLoading(true);
    setError(null);
    try {
      // Tạo giao dịch xuất kho
      const transaction = {
        itemId: inventoryItemId,
        type: 'out',
        quantity,
        projectId,
        projectName: metadata.projectName || 'Dự án',
        reason: metadata.reason || 'Gán cho dự án',
        date: new Date(),
        createdBy: metadata.userId || 'unknown',
        createdByName: metadata.userName || 'Người dùng',
      };

      const result = await createTransaction(transaction);

      // Cập nhật lại danh sách vật tư
      await fetchInventoryItems();

      return result;
    } catch (err) {
      console.error('Lỗi khi gán vật tư cho dự án:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  // Sử dụng useEffect để khởi tạo dữ liệu khi cần
  useEffect(() => {
    fetchCategories();
    fetchLocations();
    // Không tự động lấy danh sách vật tư ở đây để tránh truy vấn không cần thiết
  }, [fetchCategories, fetchLocations]);

  return {
    loading,
    error,
    inventoryItems,
    categories,
    locations,
    fetchInventoryItems,
    fetchCategories,
    fetchLocations,
    addInventoryItem,
    updateInventoryItem,
    createTransaction,
    getProjectMaterialUsage,
    manageCategory,
    getInventoryItemDetail,
    importInventoryFromDrive,
    findSimilarItems,
    assignInventoryItemToProject,
  };
};

export default useInventory;

//src/hooks/useMaterialsProcessor.js
import { useState, useCallback } from 'react';
import { Alert } from 'react-native';
import {
  GoogleSignin,
  statusCodes,
} from '@react-native-google-signin/google-signin';
import { functions } from '../config/firebaseConfig'; // Import functions instance
import { httpsCallable } from 'firebase/functions'; // Import httpsCallable
import { getAuth } from 'firebase/auth'; // Thêm import getAuth

export const useMaterialsProcessor = (project) => {
  // State for materials data and table visibility
  const [materials, setMaterials] = useState([]);
  const [showMaterialsTable, setShowMaterialsTable] = useState(false);

  // State for Google Drive integration
  const [driveFiles, setDriveFiles] = useState([]);
  const [isPickerVisible, setIsPickerVisible] = useState(false);
  const [isLoadingFiles, setIsLoadingFiles] = useState(false);
  const [isGoogleDriveLoading, setIsGoogleDriveLoading] = useState(false);
  const [isProcessingFile, setIsProcessingFile] = useState(false); // State for processing

  const fetchGoogleDriveFiles = useCallback(async (token, folderId = null) => {
    setIsLoadingFiles(true);
    const baseUrl = 'https://www.googleapis.com/drive/v3/files';
    const params = new URLSearchParams();

    // Build query based on whether we have a specific folder ID or not
    let query =
      "mimeType='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' and trashed=false";
    if (folderId) {
      query = `'${folderId}' in parents and ${query}`;
    }

    params.append('q', query);
    params.append('orderBy', 'modifiedTime desc');
    params.append('fields', 'files(id, name, modifiedTime, iconLink)');
    const url = `${baseUrl}?${params.toString()}`;

    try {
      const response = await fetch(url, {
        headers: { Authorization: `Bearer ${token}` },
      });
      if (!response.ok) {
        throw new Error(`Google Drive API error: ${response.status}`);
      }
      const json = await response.json();
      return json.files || [];
    } catch (error) {
      console.error('Error in fetchGoogleDriveFiles:', error);
      Alert.alert('Lỗi', 'Không thể lấy danh sách file từ Google Drive.');
      throw error;
    } finally {
      setIsLoadingFiles(false);
    }
  }, []);

  const handleFileSelect = useCallback(async (driveFile, fileName) => {
    setIsPickerVisible(false);
    setIsProcessingFile(true);
    Alert.alert(
      'Đang xử lý...',
      `Hệ thống đang xử lý file "${fileName}". Vui lòng chờ.`
    );

    try {
      // 1. Lấy accessToken từ GoogleSignin
      const tokens = await GoogleSignin.getTokens();
      const { accessToken } = tokens;

      if (!accessToken) {
        throw new Error(
          'Không thể lấy được access token của Google. Vui lòng đăng nhập lại.'
        );
      }

      // 2. Gọi Cloud Function `importMaterialsFromDrive`
      const importMaterials = httpsCallable(
        functions,
        'importMaterialsFromDrive'
      );
      const result = await importMaterials({
        driveFileId: driveFile.id,
        accessToken,
      });

      // 3. Xử lý kết quả trả về
      const { materials: importedMaterials } = result.data;

      if (importedMaterials && importedMaterials.length > 0) {
        setMaterials(importedMaterials);
        setShowMaterialsTable(true);
        Alert.alert(
          'Nhập dữ liệu thành công',
          `Đã nhập ${importedMaterials.length} dòng dữ liệu từ file "${fileName}".`
        );
      } else {
        Alert.alert(
          'Không có dữ liệu',
          `Không tìm thấy dữ liệu vật tư hợp lệ trong file "${fileName}".`
        );
      }
    } catch (error) {
      console.error('Lỗi khi gọi importMaterialsFromDrive:', error);
      let errorMessage = error.message;
      if (error.code === 'functions/unauthenticated') {
        errorMessage =
          'Xác thực thất bại. Vui lòng đăng xuất và đăng nhập lại.';
      } else if (error.code === 'functions/permission-denied') {
        errorMessage =
          'Token truy cập Google Drive đã hết hạn. Vui lòng thử lại.';
      }
      Alert.alert('Lỗi xử lý file', `Chi tiết: ${errorMessage}`);
    } finally {
      setIsProcessingFile(false);
    }
  }, []);

  const handleImportFromGoogleDrive = useCallback(async () => {
    setIsGoogleDriveLoading(true);
    try {
      const isSignedIn = await GoogleSignin.isSignedIn();
      if (!isSignedIn) {
        await GoogleSignin.signIn();
      }
      const tokens = await GoogleSignin.getTokens();
      const accessToken = tokens.accessToken;
      if (!accessToken) {
        throw new Error('Không thể lấy được access token.');
      }

      // Check if we have project info with a Drive folder ID
      if (project && project.driveFolderId) {
        const files = await fetchGoogleDriveFiles(
          accessToken,
          project.driveFolderId
        );
        if (files && files.length > 0) {
          setDriveFiles(files);
          setIsPickerVisible(true);
        } else {
          Alert.alert(
            'Không tìm thấy file',
            'Không tìm thấy file Excel nào trong thư mục dự án này. Hãy tải file Excel vào thư mục dự án trên Google Drive trước.'
          );
        }
      } else {
        // Fallback to scanning all of Drive if no project folder ID
        Alert.alert(
          'Thông báo',
          'Thư mục Google Drive cho dự án này chưa được thiết lập. Hệ thống sẽ tìm trong toàn bộ Google Drive của bạn.'
        );
        const files = await fetchGoogleDriveFiles(accessToken);
        if (files && files.length > 0) {
          setDriveFiles(files);
          setIsPickerVisible(true);
        } else {
          Alert.alert(
            'Không tìm thấy file',
            'Không tìm thấy file Excel nào trong Google Drive của bạn.'
          );
        }
      }
    } catch (error) {
      console.error('Lỗi khi thao tác với Google Drive:', error);
      if (error.code !== statusCodes.SIGN_IN_CANCELLED) {
        Alert.alert('Lỗi', 'Đã xảy ra lỗi khi kết nối với Google Drive.');
      }
    } finally {
      setIsGoogleDriveLoading(false);
    }
  }, [fetchGoogleDriveFiles, project]);

  const handlePriceChange = useCallback((text, index) => {
    // Sử dụng callback form của setState để đảm bảo truy cập vào state mới nhất
    setMaterials((currentMaterials) => {
      const newMaterials = JSON.parse(JSON.stringify(currentMaterials));
      const item = newMaterials[index];
      const price = parseFloat(text) || 0;
      item.unitPrice = price;

      // Calculate total price based on whether weight exists
      const quantity = parseFloat(item.quantity || 0);
      const weight = parseFloat(item.weight || 0);

      if (weight > 0) {
        // If weight exists: totalPrice = quantity * weight * unitPrice
        item.totalPrice = quantity * weight * price;
      } else {
        // If no weight: totalPrice = quantity * unitPrice (for items with unit "bộ")
        item.totalPrice = quantity * price;
      }

      return newMaterials;
    });
  }, []); // Dependency rỗng vì chúng ta dùng callback form của setState

  const handleRequote = useCallback((quotation) => {
    if (quotation.materials && Array.isArray(quotation.materials)) {
      setMaterials(JSON.parse(JSON.stringify(quotation.materials)));
      setShowMaterialsTable(true);
      Alert.alert(
        'Tải thành công',
        `Đã tải lại dữ liệu từ báo giá ${quotation.quotationNumber}.`
      );
    } else {
      Alert.alert('Lỗi', 'Báo giá này không chứa dữ liệu vật tư để tải lại.');
    }
  }, []);

  // Process material data from Excel
  const processMaterialData = useCallback((rawData) => {
    if (!rawData || !Array.isArray(rawData)) {
      console.log('No materials data');
      return;
    }

    const processed = rawData.map((item) => {
      // Check if the item is a note
      if (item.isNote) {
        return {
          ...item,
          selected: false, // Add selected property for consistent handling
        };
      }

      // Extract essential data
      const quantity = parseFloat(item.quantity) || 0;
      const weight = parseFloat(item.weight || 0);
      const unitPrice = parseFloat(item.unitPrice || 0);

      // Calculate total price based on quantity, weight and unit price
      let totalPrice = 0;
      if (weight > 0) {
        totalPrice = quantity * weight * unitPrice;
      } else {
        totalPrice = quantity * unitPrice;
      }

      return {
        name: item.name || '',
        material: item.material || '',
        quyCach: item.quyCach || '',
        unit: item.unit || '',
        quantity,
        weight,
        unitPrice,
        totalPrice,
        selected: false, // Add selected property
        isNote: false, // Explicitly mark as not a note
      };
    });

    setMaterials(processed);
    setShowMaterialsTable(true);
  }, []);

  return {
    materials,
    setMaterials, // Export setMaterials
    showMaterialsTable,
    driveFiles,
    isPickerVisible,
    isLoadingFiles,
    isGoogleDriveLoading,
    isProcessingFile,
    handleImportFromGoogleDrive,
    handleFileSelect,
    handlePriceChange,
    handleRequote,
    setIsPickerVisible,
  };
};

import { useState } from 'react';
import { Alert } from 'react-native';
import { savePOReceiptConfirmation } from '../api/purchaseOrderService';
import { httpsCallable } from 'firebase/functions';
import { functions } from '../config/firebaseConfig';
import { GoogleSignin } from '@react-native-google-signin/google-signin';
import uuid from 'react-native-uuid';

const usePOReceipt = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [uploadProgress, setUploadProgress] = useState(0);

  // Upload a single file to Drive
  const uploadFile = async (projectId, file) => {
    try {
      console.log(
        `[POReceipt] Starting upload for file: ${file.fileName || 'unnamed'}`
      );

      // Lấy accessToken Google của người dùng
      console.log('[POReceipt] Getting Google access token');
      const tokens = await GoogleSignin.getTokens();
      const accessToken = tokens.accessToken;

      if (!accessToken) {
        console.error('[POReceipt] No access token available');
        throw new Error(
          'Phiên đăng nhập Google đã hết. Vui lòng đăng nhập lại.'
        );
      }
      console.log('[POReceipt] Got access token successfully');

      // Generate a unique filename
      const ext = (file.fileName || 'jpg').split('.').pop();
      const uniqueFileName = `PO_${uuid.v4()}.${ext}`;
      console.log(`[POReceipt] Generated filename: ${uniqueFileName}`);

      // Call the uploadFileToDrive Cloud Function
      console.log('[POReceipt] Calling uploadFileToDriveUser cloud function');
      const uploadFn = httpsCallable(functions, 'uploadFileToDriveUser');
      const result = await uploadFn({
        accessToken,
        projectId,
        fileName: uniqueFileName,
        mimeType: file.mimeType,
        base64Data: file.base64Data,
      });

      console.log(
        '[POReceipt] Cloud function response:',
        JSON.stringify(result.data)
      );

      if (!result.data.success) {
        console.error('[POReceipt] Upload failed:', result.data.message);
        throw new Error(result.data.message || 'Lỗi tải file lên server');
      }

      console.log(
        `[POReceipt] File uploaded successfully. FileID: ${result.data.fileId}, Link: ${result.data.webViewLink}`
      );
      return result.data;
    } catch (err) {
      console.error('[POReceipt] File upload error:', err);
      // Log detailed error information
      if (err.details) {
        console.error(
          '[POReceipt] Error details:',
          JSON.stringify(err.details)
        );
      }
      if (err.code) {
        console.error('[POReceipt] Error code:', err.code);
      }
      console.error('File upload error in hook:', err);
      // Ném lỗi ra ngoài để hàm confirmReceipt có thể bắt được
      throw err;
    }
  };

  // Main function to handle the entire PO receipt confirmation process
  const confirmReceipt = async ({ poId, projectId, files, remarks }) => {
    setLoading(true);
    setError(null);
    setUploadProgress(0);

    try {
      console.log(
        `[POReceipt] Starting confirmation process for PO: ${poId}, Project: ${projectId}`
      );
      console.log(`[POReceipt] Files to upload: ${files.length}`);

      // Step 1: Upload each file one by one
      const totalFiles = files.length;
      const uploadedFilesInfo = [];

      for (let i = 0; i < totalFiles; i++) {
        const fileToUpload = files[i];
        console.log(
          `Uploading file ${i + 1}/${totalFiles}:`,
          fileToUpload.fileName
        );
        const uploadResult = await uploadFile(projectId, fileToUpload);

        uploadedFilesInfo.push({
          id: uploadResult.fileId,
          name: uploadResult.fileName || fileToUpload.fileName,
          url: uploadResult.webViewLink,
          mimeType: uploadResult.mimeType,
          preview: uploadResult.thumbnailLink,
        });

        // Update progress
        setUploadProgress(((i + 1) / totalFiles) * 100);
      }

      // Step 2: Save the PO receipt confirmation data to Firestore
      console.log('All files uploaded. Saving confirmation to Firestore...');
      console.log(`[POReceipt] Files uploaded: ${uploadedFilesInfo.length}`);
      console.log(
        `[POReceipt] File details:`,
        JSON.stringify(uploadedFilesInfo)
      );

      const result = await savePOReceiptConfirmation({
        poId,
        projectId,
        filesToSave: uploadedFilesInfo,
        remarks,
      });

      console.log(`[POReceipt] PO receipt confirmation saved successfully`);
      console.log(`[POReceipt] Result:`, result);

      setLoading(false);
      setUploadProgress(0);
      return result;
    } catch (err) {
      console.error('Confirm receipt process failed:', err);
      console.error('[POReceipt] Error stack:', err.stack);
      const errorMessage =
        err.details?.message || err.message || 'Không thể xác nhận PO.';
      setError(errorMessage);
      Alert.alert('Lỗi', errorMessage);
      setLoading(false);
      setUploadProgress(0);
      // Không cần throw err nữa vì đã xử lý ở đây
    }
  };

  return { confirmReceipt, loading, error, uploadProgress };
};

export default usePOReceipt;

//src/hooks/useProjectDetails.js
import { useState, useEffect, useCallback } from 'react';
import { useFocusEffect } from '@react-navigation/native';
import { getProjectById } from '../api/projectService';

export const useProjectDetails = (projectId) => {
  const [project, setProject] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const fetchProjectData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await getProjectById(projectId);

      if (data) {
        setProject(data);
      } else {
        setError('Không tìm thấy thông tin dự án');
      }
    } catch (err) {
      console.error('Lỗi khi tải thông tin dự án:', err);
      setError('Không thể tải thông tin dự án. Vui lòng thử lại sau.');
    } finally {
      setLoading(false);
    }
  }, [projectId]);

  // Initial fetch when the component mounts
  useEffect(() => {
    if (projectId) {
      fetchProjectData();
    }
  }, [fetchProjectData, projectId]);

  // Re-fetch when the screen comes into focus
  useFocusEffect(
    useCallback(() => {
      if (projectId) {
        fetchProjectData();
      }
    }, [fetchProjectData, projectId])
  );

  return { project, loading, error, fetchProjectData };
};

// src/hooks/usePurchaseOrderGenerator.js
import { useState, useContext } from 'react';
import { httpsCallable, getFunctions } from 'firebase/functions';
import { Alert, Linking } from 'react-native';
import AuthContext from '../contexts/AuthContext';
import { GoogleSignin } from '@react-native-google-signin/google-signin';

const usePurchaseOrderGenerator = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const { currentUser } = useContext(AuthContext);

  /**
   * Generate a Purchase Order Excel file for a project
   *
   * @param {Object} poData - The purchase order data
   * @param {string} projectId - The ID of the project
   * @returns {Promise<Object>} - The response object with file URL
   */
  const generatePurchaseOrder = async (poData, projectId) => {
    setLoading(true);
    setError(null);

    try {
      // Ensure Google user is signed in and get accessToken
      const signedIn = await GoogleSignin.isSignedIn();
      if (!signedIn) {
        console.log('Google user not signed in, attempting to sign in...');
        await GoogleSignin.signIn();
      }

      console.log('Getting Google access token...');
      const { accessToken } = await GoogleSignin.getTokens();
      if (!accessToken) {
        throw new Error('Could not get Google access token.');
      }
      console.log('Access token obtained successfully');

      const formattedData = formatPOData(poData);
      console.log('Formatted PO data:', JSON.stringify(formattedData));

      const functions = getFunctions(undefined, 'asia-southeast1');
      const generateExcelPurchaseOrder = httpsCallable(
        functions,
        'generateExcelPurchaseOrder'
      );

      console.log('Calling Firebase function with projectId:', projectId);
      const result = await generateExcelPurchaseOrder({
        formattedData,
        projectId,
        accessToken, // Pass the Google OAuth token
      });

      console.log('Firebase function result:', JSON.stringify(result.data));

      if (result.data && result.data.success) {
        if (result.data.fileUrl) {
          await Linking.openURL(result.data.fileUrl);
        }
        setLoading(false);
        return result.data;
      } else {
        throw new Error(
          result.data?.message || 'Failed to generate Purchase Order'
        );
      }
    } catch (err) {
      console.error('Purchase Order generation error:', err);
      let errorMessage = 'Không thể tạo đơn đặt hàng.';

      if (err.message?.includes('unauthenticated')) {
        errorMessage =
          'Lỗi xác thực Google. Vui lòng đăng nhập lại và thử lại.';
        // Try to reset Google Sign-In
        try {
          await GoogleSignin.signOut();
          console.log('Google sign-out complete, user should re-authenticate');
        } catch (signOutErr) {
          console.error('Error signing out from Google:', signOutErr);
        }
      }

      setError(errorMessage);
      Alert.alert('Lỗi', errorMessage);
      setLoading(false);
      throw err;
    }
  };

  /**
   * Format the data for the PO generator
   *
   * @param {Object} data - The raw data to format
   * @returns {Object} - The formatted data
   */
  const formatPOData = (data) => {
    // Calculate the totals
    const subTotal = calculateSubTotal(data.materials);
    const vatPercentage = data.vatPercentage || 10;
    const vatAmount = (subTotal * vatPercentage) / 100;
    const grandTotal = subTotal + vatAmount;

    return {
      metadata: {
        projectName: data.projectName,
        supplierName: data.supplierName,
        supplierAddress: data.supplierAddress,
        supplierPhone: data.supplierPhone,
        supplierEmail: data.supplierEmail,
        supplierTaxCode: data.supplierTaxCode,
        supplierContactPerson: data.supplierContactPerson,
        poNumber: data.poNumber || `PO-${Date.now().toString().substr(-6)}`,
        poDate: data.poDate || new Date().toLocaleDateString('vi-VN'),
        deliveryTime: data.deliveryTime,
        paymentTerms: data.paymentTerms,
      },
      materials: data.materials.map((item, index) => ({
        no: index + 1,
        name: item.name || '',
        unit: item.unit || '',
        quantity: parseFloat(item.quantity) || 0,
        unitPrice: parseFloat(item.unitPrice) || 0,
        total:
          (parseFloat(item.quantity) || 0) * (parseFloat(item.unitPrice) || 0),
      })),
      summary: {
        subTotal,
        vatPercentage,
        vatAmount,
        grandTotal,
      },
    };
  };

  /**
   * Calculate the subtotal of all materials
   *
   * @param {Array} materials - List of material items
   * @returns {number} - The calculated subtotal
   */
  const calculateSubTotal = (materials) => {
    return materials.reduce((sum, item) => {
      const quantity = parseFloat(item.quantity) || 0;
      const unitPrice = parseFloat(item.unitPrice) || 0;
      return sum + quantity * unitPrice;
    }, 0);
  };

  return {
    generatePurchaseOrder,
    loading,
    error,
  };
};

export default usePurchaseOrderGenerator;

import { useState } from 'react';
import * as FileSystem from 'expo-file-system';
import * as Sharing from 'expo-sharing';
import { Alert } from 'react-native';
import { getFunctions, httpsCallable } from 'firebase/functions';
import { GoogleSignin } from '@react-native-google-signin/google-signin';
import { saveQuotation } from '../api/quotationService';

// Import hook quản lý kho
import useInventory from './useInventory';

/**
 * Custom hook for generating quotations in Excel format
 * @param {Object} options - Configuration options
 * @returns {Object} - Functions and state for quotation generation
 */
const useQuotationGenerator = ({ projectId, customerData, materials }) => {
  const [isLoading, setIsLoading] = useState(false);
  const [excelUrl, setExcelUrl] = useState(null);
  const [pdfUrl, setPdfUrl] = useState(null);
  const [isPdfLoading, setIsPdfLoading] = useState(false);

  // Trong hook useQuotationGenerator, thêm đoạn code sau
  const { inventoryItems, fetchInventoryItems } = useInventory();

  /**
   * Formats quotation data for Excel export according to the specified template
   * @param {Object} quotationData - All quotation data
   * @returns {Object} - Formatted data for Excel
   */
  const formatQuotationDataForExcel = (quotationData) => {
    const {
      quotationNumber,
      quotationDate,
      projectName,
      customerData = {},
      metadata = {},
      materials = [],
      subTotal,
      discountPercentage,
      discountAmount,
      vatPercentage,
      vatAmount,
      grandTotal,
      amountInWords,
      quoteValidity,
      deliveryTime,
    } = quotationData;

    // Build data structure matching the Excel template
    return {
      metadata: {
        // Header/company info
        companyName:
          'CÔNG TY TNHH SẢN XUẤT CƠ KHÍ THƯƠNG MẠI DỊCH VỤ TÂN HÒA PHÁT',
        companyAddress:
          'Số 7 Quốc lộ 1A, KP3B, Phường Thanh Lộc, Quận 12, TP.HCM',
        companyPhone: '0978.268.559',
        companyEmail: 'chomcauinoxtanhoaphat.com.vn',
        taxCode: '0315155409',

        // Customer info - Sử dụng metadata nếu có, không thì dùng customerData, không hiển thị N/A
        customerName: metadata?.customerName || customerData?.name || '',
        customerAddress:
          metadata?.customerAddress || customerData?.address || '',
        customerPhone: metadata?.customerPhone || customerData?.phone || '',
        customerEmail: metadata?.customerEmail || customerData?.email || '',
        customerTaxCode:
          metadata?.customerTaxCode || customerData?.taxCode || '',
        customerContactPerson:
          metadata?.customerContactPerson || customerData?.contactPerson || '',

        // Quotation info
        quotationNumber,
        quotationDate: new Date(quotationDate).toLocaleDateString('vi-VN'),
        projectName,
        quoteValidity,
        deliveryTime,
      },

      // Materials will be added from row 8 onwards
      materials: materials.map((item, index) => {
        // Handle note rows differently. If isNote flag is already true OR
        // unit & quantity are both empty/zero and material field empty, treat as note.
        const startsWithPlus = (item.name || '').trim().startsWith('+');
        const nameIsNote = (item.name || '').toUpperCase().includes('GHI CHÚ');
        const inferredNote =
          item.isNote ||
          nameIsNote ||
          startsWithPlus ||
          ((!item.unit || item.unit === '') &&
            (!item.material || item.material === '') &&
            (item.quantity === null ||
              item.quantity === undefined ||
              item.quantity === 0));
        if (inferredNote) {
          return {
            isNote: true,
            no: null, // No sequence number for notes
            name: item.name || '',
            material: '', // No material for notes
            unit: '', // No unit for notes
            quantity: null, // No quantity for notes
            unitPrice: null,
            total: null,
            weight: null,
          };
        }

        const weight = item.weight ?? 0;
        const inputUnitPrice = item.unitPrice || item.price || 0;

        // Nếu không có trọng lượng (báo giá thủ công) -> dùng đơn giá trực tiếp
        const calculatedUnitPrice =
          weight && weight > 0 ? weight * inputUnitPrice : inputUnitPrice;

        const quantity = item.quantity || 0;
        const totalPrice = quantity * calculatedUnitPrice;

        return {
          isNote: false,
          no: item.no || index + 1,
          name: item.name || '',
          material: item.material || item.type || '',
          unit: item.unit || '',
          quantity: quantity,
          unitPrice: calculatedUnitPrice, // Đơn giá đã được tính = đơn giá/kg * khối lượng
          total: totalPrice || item.totalPrice || item.total || 0,
          weight: weight, // Thêm trường weight để Cloud Function có thể sử dụng nếu cần
        };
      }),

      // Summary data
      summary: {
        subTotal,
        discountPercentage: discountPercentage || 0,
        discountAmount: discountAmount || 0,
        vatPercentage: vatPercentage || 0,
        vatAmount: vatAmount || 0,
        grandTotal: grandTotal || 0,
        amountInWords: amountInWords || 'Không đồng',
      },
    };
  };

  /**
   * Generate and save a quotation in Excel format
   * @param {Object} quotationData - Complete quotation data
   * @returns {Promise<string>} URL to the generated Excel file
   */
  const generateExcelQuotation = async (quotationData) => {
    try {
      setIsLoading(true);

      // Format the data for Excel export
      const formattedData = formatQuotationDataForExcel(quotationData);

      // Ensure we have a Google access token
      const signedIn = await GoogleSignin.isSignedIn();
      if (!signedIn) {
        await GoogleSignin.signIn();
      }
      const { accessToken } = await GoogleSignin.getTokens();
      if (!accessToken) {
        throw new Error('Không thể lấy Google access token');
      }

      // Call cloud function to generate Excel file (with user token)
      const functions = getFunctions(undefined, 'asia-southeast1');
      const generateExcelFunc = httpsCallable(
        functions,
        'generateExcelQuotation'
      );
      const result = await generateExcelFunc({
        formattedData,
        projectId,
        accessToken,
      });

      // Get the Excel file URL
      const { excelUrl, spreadsheetId } = result.data;
      setExcelUrl(excelUrl);

      // Automatically convert to PDF
      const pdfUrl = await convertExcelToPdf(
        spreadsheetId,
        quotationData.quotationNumber
      );

      // Save quotation metadata to Firestore with both URLs
      await saveQuotation(projectId, {
        ...quotationData,
        excelUrl,
        pdfUrl: pdfUrl || excelUrl, // Using the PDF URL if available, otherwise Excel URL
        createdBy: quotationData.createdBy,
      });

      return { excelUrl, pdfUrl, spreadsheetId };
    } catch (error) {
      console.error('Error generating Excel quotation:', error);
      Alert.alert('Lỗi', 'Không thể tạo báo giá Excel: ' + error.message);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  /**
   * Convert Excel to PDF using the new Cloud Function
   * @param {string} spreadsheetId - ID of the Google Sheet to convert
   * @param {string} fileName - Name for the generated PDF file
   * @returns {Promise<string>} URL to the generated PDF file
   */
  const convertExcelToPdf = async (spreadsheetId, fileName) => {
    if (!spreadsheetId) {
      console.error('Missing spreadsheetId for PDF conversion');
      return null;
    }

    try {
      setIsPdfLoading(true);

      // Get Google access token
      const { accessToken } = await GoogleSignin.getTokens();

      // Call the new cloud function to export sheet to PDF
      const functions = getFunctions(); // us-central1 default
      const exportToPdfFunc = httpsCallable(functions, 'exportSheetToPdf');

      const result = await exportToPdfFunc({
        spreadsheetId,
        fileName,
        projectId,
        accessToken,
      });

      // Get the PDF file URL
      const { pdfUrl } = result.data;
      setPdfUrl(pdfUrl);

      return pdfUrl;
    } catch (error) {
      console.error('Error converting Excel to PDF:', error);
      Alert.alert(
        'Thông báo',
        'Đã tạo báo giá Excel thành công, nhưng không thể chuyển đổi sang PDF. Bạn vẫn có thể chia sẻ file Excel.'
      );
      return null;
    } finally {
      setIsPdfLoading(false);
    }
  };

  /**
   * Share the generated Excel file
   */
  const shareExcelQuotation = async () => {
    try {
      if (!excelUrl) {
        Alert.alert('Lỗi', 'Chưa có file báo giá Excel để chia sẻ.');
        return;
      }

      const fileUri = `${FileSystem.documentDirectory}quotation.xlsx`;
      const downloadResult = await FileSystem.downloadAsync(excelUrl, fileUri);

      if (downloadResult.status === 200) {
        await Sharing.shareAsync(fileUri);
      } else {
        Alert.alert('Lỗi', 'Không thể tải file báo giá Excel.');
      }
    } catch (error) {
      console.error('Error sharing Excel quotation:', error);
      Alert.alert('Lỗi', 'Không thể chia sẻ báo giá Excel: ' + error.message);
    }
  };

  /**
   * Share the generated PDF file
   */
  const sharePdfQuotation = async () => {
    try {
      if (!pdfUrl) {
        Alert.alert('Lỗi', 'Chưa có file báo giá PDF để chia sẻ.');
        return;
      }

      const fileUri = `${FileSystem.documentDirectory}quotation.pdf`;
      const downloadResult = await FileSystem.downloadAsync(pdfUrl, fileUri);

      if (downloadResult.status === 200) {
        await Sharing.shareAsync(fileUri, {
          mimeType: 'application/pdf',
          UTI: 'com.adobe.pdf',
        });
      } else {
        Alert.alert('Lỗi', 'Không thể tải file báo giá PDF.');
      }
    } catch (error) {
      console.error('Error sharing PDF quotation:', error);
      Alert.alert('Lỗi', 'Không thể chia sẻ báo giá PDF: ' + error.message);
    }
  };

  // Thêm hàm tìm kiếm vật tư từ kho
  const searchInventoryItems = async (keyword) => {
    if (!inventoryItems.length) {
      await fetchInventoryItems();
    }

    if (!keyword) return [];

    const normalizedKeyword = keyword.toLowerCase().trim();
    return inventoryItems.filter(
      (item) =>
        item.name?.toLowerCase().includes(normalizedKeyword) ||
        item.code?.toLowerCase().includes(normalizedKeyword) ||
        item.material?.toLowerCase().includes(normalizedKeyword)
    );
  };

  // Thêm hàm áp dụng vật tư từ kho vào báo giá
  const applyInventoryItemToQuotation = (item) => {
    if (!item) return;

    const newMaterial = {
      name: item.name,
      material: item.material || '',
      unit: item.unit || '',
      quantity: 1,
      unitPrice: item.price || 0,
      weight: item.weight || 0,
      total: 1 * (item.price || 0),
    };

    // Assuming 'materials' state is managed by the parent component or passed as a prop
    // For now, we'll just add it to the current materials array for display
    // In a real app, you'd update the 'materials' prop or state
    // setMaterials(prevMaterials => [...prevMaterials, newMaterial]); // This line would cause an error if 'materials' is not a state variable
    // calculateTotals([...materials, newMaterial]); // This line would cause an error if 'materials' is not a state variable
  };

  return {
    generateExcelQuotation,
    convertExcelToPdf,
    shareExcelQuotation,
    sharePdfQuotation,
    isLoading,
    isPdfLoading,
    excelUrl,
    pdfUrl,
    searchInventoryItems,
    applyInventoryItemToQuotation,
    inventoryItems,
  };
};

export default useQuotationGenerator;

/**
 * Màn hình danh sách vật liệu
 */

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const MaterialListScreen = ({ navigation }) => {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Danh sách vật liệu</Text>
      <Text style={styles.subtitle}>Màn hình đang được phát triển</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
});

export default MaterialListScreen;

import React from 'react';
import { Text, View, TouchableOpacity } from 'react-native';
import {
  NavigationContainer,
  DefaultTheme,
  DarkTheme,
} from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Ionicons } from '@expo/vector-icons';
import { useAuth } from '../contexts/AuthContext';
import { useTheme } from '../contexts/ThemeContext';

// Import các màn hình
import LoginScreen from '../screens/LoginScreen';
import HomeScreen from '../screens/HomeScreen';
import CustomerManagementScreen from '../screens/CustomerManagementScreen';
import CustomerDetailScreen from '../screens/CustomerDetailScreen';
import AddCustomerScreen from '../screens/AddCustomerScreen';
import EditCustomerScreen from '../screens/EditCustomerScreen';

// Import các màn hình quản lý dự án
import ProjectManagementScreen from '../screens/ProjectManagementScreen';
import ProjectDetailScreen from '../screens/ProjectDetailScreen';
import AddProjectScreen from '../screens/AddProjectScreen';
import EditProjectScreen from '../screens/EditProjectScreen';
import FinalizeQuotationScreen from '../screens/FinalizeQuotationScreen';
import QuotationScreen from '../screens/QuotationScreen';
import ManualQuotationScreen from '../screens/ManualQuotationScreen';
import StageDetailScreen from '../screens/StageDetailScreen';
import MaterialPurchaseScreen from '../screens/MaterialPurchaseScreen';
import CreateProposalScreen from '../screens/CreateProposalScreen';
import ProposalListScreen from '../screens/ProposalListScreen';
import CreatePOScreen from '../screens/CreatePOScreen';
import POListScreen from '../screens/POListScreen';

// Import màn hình tài khoản
import AccountScreen from '../screens/AccountScreen';

// Import màn hình báo cáo công việc
import TaskReportScreen from '../screens/TaskReportScreen';
import TaskDetailScreen from '../screens/TaskDetailScreen';
import AttendanceScreen from '../screens/AttendanceScreen';
import UserManagementScreen from '../screens/UserManagementScreen';

// Import màn hình dashboard cho giám đốc
import DirectorDashboardScreen from '../screens/DirectorDashboardScreen';
import DebtDashboard from '../screens/DebtDashboard';
import NotificationsScreen from '../screens/NotificationsScreen'; // Import NotificationsScreen

// Import các màn hình quản lý nhà cung cấp
import SupplierManagementScreen from '../screens/SupplierManagementScreen';
import AddSupplierScreen from '../screens/AddSupplierScreen';
import EditSupplierScreen from '../screens/EditSupplierScreen';
import SupplierDetailScreen from '../screens/SupplierDetailScreen';
import ConfirmPOReceiptScreen from '../screens/ConfirmPOReceiptScreen';

// Import màn hình quản lý kho
import InventoryScreen from '../screens/InventoryScreen';
import AddInventoryItemScreen from '../screens/AddInventoryItemScreen';
import EditInventoryItemScreen from '../screens/EditInventoryItemScreen';
import InventoryItemDetailScreen from '../screens/InventoryItemDetailScreen';
import InventoryTransactionScreen from '../screens/InventoryTransactionScreen';
import InventoryReportScreen from '../screens/InventoryReportScreen';

// Tạo Stack Navigator cho quản lý dự án
const ProjectStack = createNativeStackNavigator();

const ProjectStackNavigator = () => {
  const { theme } = useTheme();

  return (
    <ProjectStack.Navigator
      screenOptions={{
        headerShown: true,
        headerStyle: {
          backgroundColor: theme.background,
        },
        headerTitleStyle: {
          color: theme.text,
        },
        headerTintColor: theme.text,
        contentStyle: { backgroundColor: theme.background },
      }}
    >
      <ProjectStack.Screen
        name="ProjectManagement"
        component={ProjectManagementScreen}
        options={({ navigation }) => ({
          title: 'Quản lý Dự án',
          headerRight: () => (
            <TouchableOpacity
              onPress={() => navigation.navigate('AddProject')}
              style={{
                marginRight: 15,
                backgroundColor: theme.primary,
                width: 36,
                height: 36,
                borderRadius: 18,
                justifyContent: 'center',
                alignItems: 'center',
              }}
            >
              <Ionicons name="add" size={24} color="#fff" />
            </TouchableOpacity>
          ),
        })}
      />
      <ProjectStack.Screen
        name="ProjectDetail"
        component={ProjectDetailScreen}
        options={{ headerShown: false }}
      />
      <ProjectStack.Screen
        name="AddProject"
        component={AddProjectScreen}
        options={{ title: 'Thêm Dự án Mới', headerRight: null }}
      />
      <ProjectStack.Screen
        name="EditProject"
        component={EditProjectScreen}
        options={{ title: 'Chỉnh sửa Dự án', headerRight: null }}
      />
      <ProjectStack.Screen
        name="Quotation"
        component={QuotationScreen}
        options={{ headerShown: false }}
      />
      <ProjectStack.Screen
        name="ManualQuotation"
        component={ManualQuotationScreen}
        options={{ title: 'Báo giá Thủ công' }}
      />
      <ProjectStack.Screen
        name="FinalizeQuotation"
        component={FinalizeQuotationScreen}
        options={{ title: 'Hoàn tất Báo giá', headerRight: null }}
      />
      <ProjectStack.Screen
        name="StageDetail"
        component={StageDetailScreen}
        options={{ title: 'Chi tiết Công đoạn' }}
      />
      <ProjectStack.Screen
        name="MaterialPurchase"
        component={MaterialPurchaseScreen}
        options={{ title: 'Quản lý Mua Vật Tư' }}
      />
      <ProjectStack.Screen
        name="CreateProposal"
        component={CreateProposalScreen}
        options={{ title: 'Tạo Đề Xuất' }}
      />
      <ProjectStack.Screen
        name="CreatePO"
        component={CreatePOScreen}
        options={{ title: 'Tạo PO' }}
      />
      <ProjectStack.Screen
        name="ProposalList"
        component={ProposalListScreen}
        options={{ title: 'Duyệt Đề Xuất' }}
      />
      <ProjectStack.Screen
        name="POList"
        component={POListScreen}
        options={{ title: 'Đơn đặt hàng' }}
      />
    </ProjectStack.Navigator>
  );
};

// Tạo Stack Navigator cho quản lý kho
const InventoryStack = createNativeStackNavigator();

const InventoryStackNavigator = () => {
  const { theme } = useTheme();

  return (
    <InventoryStack.Navigator
      initialRouteName="InventoryMain"
      screenOptions={{
        headerShown: true,
        headerStyle: {
          backgroundColor: theme.background,
        },
        headerTitleStyle: {
          color: theme.text,
        },
        headerTintColor: theme.text,
        contentStyle: { backgroundColor: theme.background },
      }}
    >
      <InventoryStack.Screen
        name="InventoryMain"
        component={InventoryScreen}
        options={({ navigation }) => ({
          title: 'Quản lý Kho',
          headerRight: () => (
            <TouchableOpacity
              onPress={() => navigation.navigate('AddInventoryItem')}
              style={{
                marginRight: 15,
                backgroundColor: theme.primary,
                width: 36,
                height: 36,
                borderRadius: 18,
                justifyContent: 'center',
                alignItems: 'center',
              }}
            >
              <Ionicons name="add" size={24} color="#fff" />
            </TouchableOpacity>
          ),
        })}
      />
      <InventoryStack.Screen
        name="AddInventoryItem"
        component={AddInventoryItemScreen}
        options={({ navigation }) => ({
          title: 'Thêm Vật Tư Mới',
          headerLeft: () => (
            <TouchableOpacity
              onPress={() => navigation.navigate('InventoryMain')}
              style={{ marginLeft: 10 }}
            >
              <Ionicons name="arrow-back" size={24} color={theme.text} />
            </TouchableOpacity>
          ),
        })}
      />
      <InventoryStack.Screen
        name="EditInventoryItem"
        component={EditInventoryItemScreen}
        options={({ navigation }) => ({
          title: 'Chỉnh sửa Vật Tư',
          headerLeft: () => (
            <TouchableOpacity
              onPress={() => navigation.navigate('InventoryMain')}
              style={{ marginLeft: 10 }}
            >
              <Ionicons name="arrow-back" size={24} color={theme.text} />
            </TouchableOpacity>
          ),
        })}
      />
      <InventoryStack.Screen
        name="InventoryItemDetail"
        component={InventoryItemDetailScreen}
        options={({ navigation }) => ({
          title: 'Chi Tiết Vật Tư',
          headerLeft: () => (
            <TouchableOpacity
              onPress={() => navigation.navigate('InventoryMain')}
              style={{ marginLeft: 10 }}
            >
              <Ionicons name="arrow-back" size={24} color={theme.text} />
            </TouchableOpacity>
          ),
        })}
      />
      <InventoryStack.Screen
        name="InventoryTransaction"
        component={InventoryTransactionScreen}
        options={({ navigation }) => ({
          title: 'Giao Dịch Kho',
          headerLeft: () => (
            <TouchableOpacity
              onPress={() => navigation.navigate('InventoryMain')}
              style={{ marginLeft: 10 }}
            >
              <Ionicons name="arrow-back" size={24} color={theme.text} />
            </TouchableOpacity>
          ),
        })}
      />
      <InventoryStack.Screen
        name="InventoryReport"
        component={InventoryReportScreen}
        options={({ navigation }) => ({
          title: 'Báo Cáo Kho',
          headerLeft: () => (
            <TouchableOpacity
              onPress={() => navigation.navigate('InventoryMain')}
              style={{ marginLeft: 10 }}
            >
              <Ionicons name="arrow-back" size={24} color={theme.text} />
            </TouchableOpacity>
          ),
        })}
      />
    </InventoryStack.Navigator>
  );
};

// Tạo Tab Navigator
const Tab = createBottomTabNavigator();

const MainTabNavigator = () => {
  const { theme } = useTheme();
  const { user } = useAuth();

  // Check if user has director role - support both English and Vietnamese role names
  const isDirector = ['director', 'Giám đốc', 'giam_doc'].includes(user?.role);
  const canManageAttendance = ['pho_giam_doc'].includes(user?.role);
  const canManageUsers = ['admin', 'giam_doc'].includes(user?.role);
  // Kiểm tra quyền truy cập vào module kho
  const canAccessInventory = ['thuong_mai', 'ky_su', 'ke_toan'].includes(
    user?.role
  );

  console.log(
    'User role:',
    user?.role,
    'Is Director:',
    isDirector,
    'Can Access Inventory:',
    canAccessInventory
  );

  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName;

          if (route.name === 'Home') {
            iconName = focused ? 'home' : 'home-outline';
          } else if (route.name === 'Customers') {
            iconName = focused ? 'people' : 'people-outline';
          } else if (route.name === 'Projects') {
            iconName = focused ? 'briefcase' : 'briefcase-outline';
          } else if (route.name === 'Inventory') {
            iconName = focused ? 'cube' : 'cube-outline';
          } else if (route.name === 'Tasks') {
            iconName = focused ? 'file-tray-full' : 'file-tray-full-outline';
          } else if (route.name === 'Attendance') {
            iconName = focused ? 'checkbox' : 'square-outline';
          } else if (route.name === 'UserManagement') {
            iconName = focused ? 'people' : 'people-outline';
          } else if (route.name === 'Account') {
            iconName = focused ? 'person-circle' : 'person-circle-outline';
          } else if (route.name === 'Dashboard') {
            iconName = focused ? 'stats-chart' : 'stats-chart-outline';
          } else if (route.name === 'Inventory') {
            iconName = focused ? 'cube' : 'cube-outline';
          }

          return <Ionicons name={iconName} size={size} color={color} />;
        },
        tabBarActiveTintColor: theme.primary,
        tabBarInactiveTintColor: theme.textMuted,
        headerShown: true,
        headerStyle: {
          backgroundColor: theme.background,
        },
        headerTitleStyle: {
          color: theme.text,
        },
        tabBarStyle: {
          backgroundColor: theme.background,
          borderTopColor: theme.border,
        },
        contentStyle: {
          backgroundColor: theme.background,
        },
      })}
    >
      {isDirector ? (
        // Director sees Dashboard as first tab
        <Tab.Screen
          name="Dashboard"
          component={DirectorDashboardScreen}
          options={{ title: 'Tổng Quan' }}
        />
      ) : (
        // Other users see Home as first tab
        <Tab.Screen
          name="Home"
          component={HomeScreen}
          options={{ title: 'Trang Chủ' }}
        />
      )}
      <Tab.Screen
        name="Customers"
        component={CustomerManagementScreen}
        options={{ title: 'Khách Hàng', headerShown: false }}
      />
      <Tab.Screen
        name="Projects"
        component={ProjectStackNavigator}
        options={{
          title: 'Dự Án',
          headerShown: false,
        }}
      />
      {!canManageAttendance && (
        <Tab.Screen
          name="Tasks"
          component={TaskReportScreen}
          options={{ title: 'Báo cáo', headerShown: false }}
        />
      )}

      {canManageUsers && (
        <Tab.Screen
          name="UserManagement"
          component={UserManagementScreen}
          options={{ title: 'Nhân viên' }}
        />
      )}

      {canManageAttendance && (
        <Tab.Screen
          name="Attendance"
          component={AttendanceScreen}
          options={{ title: 'Chấm Công' }}
        />
      )}

      {canAccessInventory && (
        <Tab.Screen
          name="Inventory"
          component={InventoryStackNavigator}
          options={{ title: 'Kho Vật Tư', headerShown: false }}
        />
      )}

      <Tab.Screen
        name="Account"
        component={AccountScreen}
        options={{ title: 'Tài khoản' }}
      />
    </Tab.Navigator>
  );
};

// Tạo Stack Navigator cho luồng xác thực và các màn hình khác
const Stack = createNativeStackNavigator();

const AppNavigator = () => {
  // Sử dụng trạng thái đăng nhập từ AuthContext
  const { isSignedIn, loadingAuth } = useAuth();
  const { theme, isDarkMode } = useTheme();

  // Tạo theme cho NavigationContainer dựa trên theme hiện tại
  const navigationTheme = {
    ...(isDarkMode ? DarkTheme : DefaultTheme),
    colors: {
      ...(isDarkMode ? DarkTheme.colors : DefaultTheme.colors),
      primary: theme.primary,
      background: theme.background,
      card: theme.card,
      text: theme.text,
      border: theme.border,
      notification: theme.primary,
    },
  };

  // Hiển thị màn hình loading nếu đang kiểm tra trạng thái đăng nhập
  if (loadingAuth) {
    return (
      <View
        style={{
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
          backgroundColor: theme.background,
        }}
      >
        <Text style={{ color: theme.text }}>Đang tải...</Text>
      </View>
    );
  }

  return (
    <NavigationContainer theme={navigationTheme}>
      <Stack.Navigator
        screenOptions={{
          contentStyle: { backgroundColor: theme.background },
        }}
      >
        {isSignedIn ? (
          // Người dùng đã đăng nhập
          <>
            <Stack.Screen
              name="Main"
              component={MainTabNavigator}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="CustomerDetail"
              component={CustomerDetailScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="AddCustomer"
              component={AddCustomerScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="EditCustomer"
              component={EditCustomerScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="ProjectDetail"
              component={ProjectDetailScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="TaskDetail"
              component={TaskDetailScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="AddProject"
              component={AddProjectScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="EditProject"
              component={EditProjectScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="FinalizeQuotation"
              component={FinalizeQuotationScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="Quotation"
              component={QuotationScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="StageDetail"
              component={StageDetailScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="DebtDashboard"
              component={DebtDashboard}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="ProposalList"
              component={ProposalListScreen}
              options={{
                title: 'Duyệt Đề Xuất',
                headerStyle: {
                  backgroundColor: theme.background,
                },
                headerTintColor: theme.text,
                headerTitleStyle: {
                  color: theme.text,
                },
              }}
            />
            <Stack.Screen
              name="DirectorDashboard"
              component={DirectorDashboardScreen}
              options={{ title: 'Trang của giám đốc' }}
            />
            <Stack.Screen
              name="Notifications"
              component={NotificationsScreen}
              options={{ title: 'Thông báo' }}
            />

            {/* Thêm các màn hình quản lý nhà cung cấp */}
            <Stack.Screen
              name="SupplierManagement"
              component={SupplierManagementScreen}
            />
            <Stack.Screen name="AddSupplier" component={AddSupplierScreen} />
            <Stack.Screen name="EditSupplier" component={EditSupplierScreen} />
            <Stack.Screen
              name="SupplierDetail"
              component={SupplierDetailScreen}
            />
            <Stack.Screen
              name="ConfirmPOReceipt"
              component={ConfirmPOReceiptScreen}
              options={{ title: 'Xác nhận giao hàng', headerShown: true }}
            />

            {/* Thêm các màn hình quản lý kho */}
            <Stack.Screen name="Inventory" component={InventoryScreen} />
            <Stack.Screen
              name="AddInventoryItem"
              component={AddInventoryItemScreen}
            />
            <Stack.Screen
              name="EditInventoryItem"
              component={EditInventoryItemScreen}
            />
            <Stack.Screen
              name="InventoryItemDetail"
              component={InventoryItemDetailScreen}
            />
            <Stack.Screen
              name="InventoryTransaction"
              component={InventoryTransactionScreen}
            />
            <Stack.Screen
              name="InventoryReport"
              component={InventoryReportScreen}
            />
          </>
        ) : (
          // Người dùng chưa đăng nhập
          <Stack.Screen
            name="Login"
            component={LoginScreen}
            options={{ headerShown: false }}
          />
        )}
      </Stack.Navigator>
    </NavigationContainer>
  );
};

export default AppNavigator;

//src/screens/AccountScreen.js
import React, { useContext, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Switch,
  ScrollView,
  Alert,
  LayoutAnimation,
  UIManager,
  Platform,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { useAuth } from '../contexts/AuthContext';
import { useTheme } from '../contexts/ThemeContext';
import {
  GoogleSignin,
  statusCodes,
} from '@react-native-google-signin/google-signin';

if (
  Platform.OS === 'android' &&
  UIManager.setLayoutAnimationEnabledExperimental
) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

const SettingItem = ({
  icon,
  title,
  value,
  onPress,
  type = 'chevron',
  color,
}) => {
  const { theme } = useTheme();

  return (
    <TouchableOpacity
      style={[styles.settingItem, { borderBottomColor: theme.border }]}
      onPress={onPress}
      disabled={type === 'switch'}
    >
      <View style={styles.settingLeft}>
        <Ionicons
          name={icon}
          size={22}
          color={color || theme.text}
          style={styles.settingIcon}
        />
        <Text style={[styles.settingTitle, { color: theme.text }]}>
          {title}
        </Text>
      </View>

      <View style={styles.settingRight}>
        {type === 'switch' && (
          <Switch
            value={value}
            onValueChange={onPress}
            trackColor={{ false: theme.border, true: theme.primary }}
            thumbColor={value ? '#fff' : '#f4f3f4'}
          />
        )}
        {type === 'value' && (
          <Text style={[styles.settingValue, { color: theme.textSecondary }]}>
            {value}
          </Text>
        )}
        {type === 'chevron' && (
          <Ionicons name="chevron-forward" size={20} color={theme.textMuted} />
        )}
      </View>
    </TouchableOpacity>
  );
};

// Helper function to map role keys to display labels
const getRoleLabel = (role) => {
  switch (role) {
    case 'admin':
      return 'Quản trị viên';
    case 'giam_doc':
      return 'Giám đốc';
    case 'pho_giam_doc':
      return 'Phó Giám đốc';
    case 'quan_ly':
      return 'Quản lý';
    case 'ky_su':
      return 'Kỹ sư';
    case 'ke_toan':
      return 'Kế toán';
    case 'thuong_mai':
      return 'Thương mại';
    case 'cong_nhan':
      return 'Công nhân';
    case 'user':
      return 'Người dùng';
    default:
      return 'Không xác định';
  }
};

// Helper function to get style based on role
const getRoleStyle = (role) => {
  switch (role) {
    case 'giam_doc':
      return { backgroundColor: '#FFD700', textColor: '#8C6D00' };
    case 'pho_giam_doc':
      return { backgroundColor: '#E6E6FA', textColor: '#483D8B' };
    case 'ky_su':
      return {
        backgroundColor: 'rgba(0, 102, 204, 0.2)',
        textColor: '#0066cc',
      };
    case 'ke_toan':
      return {
        backgroundColor: 'rgba(46, 204, 113, 0.2)',
        textColor: '#27AE60',
      };
    case 'thuong_mai':
      return {
        backgroundColor: 'rgba(243, 156, 18, 0.2)',
        textColor: '#D35400',
      };
    case 'cong_nhan':
      return { backgroundColor: '#f0f0f0', textColor: '#555' };
    case 'admin':
    case 'quan_ly':
    case 'user':
    default:
      return {
        backgroundColor: 'rgba(108, 122, 137, 0.2)',
        textColor: '#6C7A89',
      };
  }
};

const AccountScreen = ({ navigation }) => {
  const { logout, currentUser, userRole } = useAuth();
  const { theme, isDarkMode, toggleTheme, followSystem, toggleFollowSystem } =
    useTheme();

  useEffect(() => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
  }, []);

  const handleLogout = () => {
    Alert.alert(
      'Xác nhận đăng xuất',
      'Bạn có chắc chắn muốn đăng xuất không?',
      [
        {
          text: 'Hủy',
          style: 'cancel',
        },
        {
          text: 'Đăng xuất',
          onPress: () => logout(),
          style: 'destructive',
        },
      ],
      { cancelable: true }
    );
  };

  const switchGoogleAccount = async () => {
    try {
      // Ngắt kết nối tài khoản Google hiện tại
      await GoogleSignin.revokeAccess();
      await GoogleSignin.signOut();

      Alert.alert(
        'Đã ngắt kết nối',
        'Tài khoản Google đã được ngắt kết nối. Bạn có thể kết nối lại khi cần thiết trong màn hình chi tiết dự án.'
      );
    } catch (error) {
      if (error.code === statusCodes.SIGN_IN_REQUIRED) {
        // This error is expected after a sign-out or if the user isn't signed in.
        // We can safely ignore it.
        console.log(
          'User is not signed in, which is expected after revokeAccess.'
        );
        Alert.alert(
          'Đã ngắt kết nối',
          'Tài khoản Google đã được ngắt kết nối thành công.'
        );
      } else {
        // For any other unexpected errors, show an alert to the user.
        console.error('Lỗi khi chuyển tài khoản Google:', error);
        Alert.alert(
          'Lỗi',
          'Không thể ngắt kết nối tài khoản Google. Vui lòng thử lại.'
        );
      }
    }
  };

  // Get dynamic style for role badge
  const roleStyle = getRoleStyle(currentUser?.role);

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <ScrollView
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.scrollViewContent}
      >
        {/* Header */}
        <View style={styles.header}>
          <View style={[styles.profileCard, { backgroundColor: theme.card }]}>
            <View
              style={[
                styles.avatarContainer,
                { backgroundColor: theme.primaryLight },
              ]}
            >
              <Text style={[styles.avatarText, { color: theme.primary }]}>
                {currentUser?.displayName
                  ? currentUser.displayName[0].toUpperCase()
                  : currentUser?.email
                  ? currentUser.email[0].toUpperCase()
                  : 'U'}
              </Text>
            </View>
            <View style={styles.userInfoContainer}>
              <Text style={[styles.nameText, { color: theme.text }]}>
                {currentUser?.displayName || 'Tên Người Dùng'}
              </Text>
              <View
                style={[
                  styles.roleBadge,
                  { backgroundColor: roleStyle.backgroundColor },
                ]}
              >
                <Text
                  style={[styles.roleBadgeText, { color: roleStyle.textColor }]}
                >
                  {getRoleLabel(currentUser?.role)}
                </Text>
              </View>
            </View>
          </View>
        </View>

        {/* Settings Groups */}
        <View style={[styles.settingsGroup, { backgroundColor: theme.card }]}>
          <Text style={[styles.groupTitle, { color: theme.textSecondary }]}>
            Giao diện
          </Text>
          <SettingItem
            icon="contrast-outline"
            title="Chế độ tối"
            value={isDarkMode}
            onPress={toggleTheme}
            type="switch"
          />
          <SettingItem
            icon="phone-portrait-outline"
            title="Theo hệ thống"
            value={followSystem}
            onPress={toggleFollowSystem}
            type="switch"
          />
        </View>

        <View style={[styles.settingsGroup, { backgroundColor: theme.card }]}>
          <Text style={[styles.groupTitle, { color: theme.textSecondary }]}>
            Tài khoản
          </Text>
          <SettingItem
            icon="person-outline"
            title="Thông tin cá nhân"
            onPress={() => Alert.alert('Tính năng đang phát triển')}
          />
          <SettingItem
            icon="key-outline"
            title="Đổi mật khẩu"
            onPress={() => Alert.alert('Tính năng đang phát triển')}
          />
          <SettingItem
            icon="swap-horizontal-outline"
            title="Chuyển tài khoản Google"
            onPress={switchGoogleAccount}
            color="#4285F4"
          />
          {(userRole === 'giam_doc' || userRole === 'admin') && (
            <SettingItem
              icon="people-outline"
              title="Quản lý nhân viên"
              onPress={() => navigation.navigate('UserManagement')}
              color={theme.primary}
            />
          )}
        </View>

        <View style={[styles.settingsGroup, { backgroundColor: theme.card }]}>
          <Text style={[styles.groupTitle, { color: theme.textSecondary }]}>
            Ứng dụng
          </Text>
          <SettingItem
            icon="information-circle-outline"
            title="Thông tin ứng dụng"
            value="1.0.0"
            type="value"
            onPress={() => {}}
          />
          <SettingItem
            icon="help-circle-outline"
            title="Trợ giúp & Hỗ trợ"
            onPress={() => {}}
          />
        </View>

        {/* Logout Button */}
        <TouchableOpacity
          style={[styles.logoutButton, { backgroundColor: theme.danger }]}
          onPress={handleLogout}
        >
          <Ionicons
            name="log-out-outline"
            size={20}
            color="#fff"
            style={styles.logoutIcon}
          />
          <Text style={styles.logoutText}>Đăng xuất</Text>
        </TouchableOpacity>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  scrollViewContent: {
    paddingVertical: 16,
  },
  header: {
    paddingHorizontal: 16,
    marginBottom: 24,
  },
  profileCard: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderRadius: 16,
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  avatarContainer: {
    width: 72,
    height: 72,
    borderRadius: 36,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 16,
  },
  avatarText: {
    fontSize: 30,
    fontWeight: 'bold',
  },
  userInfoContainer: {
    flex: 1,
    justifyContent: 'center',
  },
  nameText: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 8,
    marginLeft: 2,
  },
  roleBadge: {
    alignSelf: 'flex-start',
    paddingVertical: 4,
    paddingHorizontal: 12,
    borderRadius: 12,
  },
  roleBadgeText: {
    fontSize: 12,
    fontWeight: '600',
  },
  settingsGroup: {
    marginHorizontal: 16,
    marginVertical: 8,
    borderRadius: 12,
    overflow: 'hidden',
  },
  groupTitle: {
    fontSize: 14,
    fontWeight: '600',
    textTransform: 'uppercase',
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 8,
  },
  settingItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 14,
    paddingHorizontal: 16,
    borderBottomWidth: 0.5,
  },
  settingLeft: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  settingIcon: {
    marginRight: 12,
  },
  settingTitle: {
    fontSize: 16,
  },
  settingRight: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  settingValue: {
    fontSize: 16,
    marginRight: 8,
  },
  logoutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginHorizontal: 16,
    marginTop: 24,
    paddingVertical: 14,
    borderRadius: 12,
  },
  logoutIcon: {
    marginRight: 8,
  },
  logoutText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '500',
  },
});

export default AccountScreen;

//src/screens/AddCustomerScreen.js
import React, { useState, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
  Keyboard,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { createCustomer } from '../api/customerService';
import { useAuth } from '../contexts/AuthContext';
import { SafeAreaView } from 'react-native-safe-area-context';
import StyledTextInput from '../components/StyledTextInput';

const AddCustomerScreen = ({ navigation }) => {
  const { currentUser } = useAuth();
  const [isLoading, setIsLoading] = useState(false);
  const [formData, setFormData] = useState({
    name: '',
    contactPerson: '',
    phone: '',
    email: '',
    address: '',
    type: 'regular', // mặc định là khách hàng thường xuyên
    taxCode: '',
  });

  // Refs cho các input để điều hướng focus
  const contactPersonRef = useRef(null);
  const phoneRef = useRef(null);
  const emailRef = useRef(null);
  const addressRef = useRef(null);
  const taxCodeRef = useRef(null);

  // Cập nhật giá trị form
  const handleChange = (field, value) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));
  };

  // Kiểm tra form hợp lệ
  const validateForm = () => {
    if (!formData.name.trim()) {
      Alert.alert('Lỗi', 'Vui lòng nhập tên khách hàng');
      return false;
    }

    if (!formData.contactPerson.trim()) {
      Alert.alert('Lỗi', 'Vui lòng nhập tên người liên hệ');
      return false;
    }

    if (formData.email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
      Alert.alert('Lỗi', 'Email không hợp lệ');
      return false;
    }

    return true;
  };

  // Xử lý lưu khách hàng
  const handleSave = async () => {
    if (!validateForm()) {
      return;
    }

    Keyboard.dismiss();
    setIsLoading(true);

    try {
      // Gọi API tạo khách hàng mới
      await createCustomer(formData, currentUser?.uid);

      Alert.alert('Thành công', 'Đã thêm khách hàng mới thành công', [
        {
          text: 'OK',
          onPress: () => navigation.goBack(),
        },
      ]);
    } catch (error) {
      if (error.code === 'permission-denied') {
        Alert.alert(
          'Lỗi quyền',
          'Bạn không có đủ quyền để thực hiện hành động này.'
        );
      } else {
        console.error('Lỗi khi thêm khách hàng:', error);
        Alert.alert('Lỗi', 'Không thể thêm khách hàng. Vui lòng thử lại sau.');
      }
    } finally {
      setIsLoading(false);
    }
  };

  // Xử lý thay đổi loại khách hàng
  const handleSelectType = (type) => {
    handleChange('type', type);
  };

  return (
    <SafeAreaView style={styles.safeArea}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.container}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 0 : 20}
      >
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
          >
            <Ionicons name="arrow-back" size={24} color="#333" />
          </TouchableOpacity>
          <Text style={styles.headerTitle}>Thêm khách hàng mới</Text>
          <View style={styles.placeholder} />
        </View>

        <ScrollView
          style={styles.formContainer}
          contentContainerStyle={styles.formContent}
          keyboardShouldPersistTaps="handled"
          showsVerticalScrollIndicator={false}
        >
          <StyledTextInput
            label="Tên công ty / Tổ chức"
            value={formData.name}
            onChangeText={(text) => handleChange('name', text)}
            placeholder="Nhập tên công ty hoặc tổ chức"
            required={true}
            returnKeyType="next"
            blurOnSubmit={false}
            onSubmitEditing={() => contactPersonRef.current.focus()}
          />

          <StyledTextInput
            ref={contactPersonRef}
            label="Người liên hệ"
            value={formData.contactPerson}
            onChangeText={(text) => handleChange('contactPerson', text)}
            placeholder="Nhập tên người liên hệ"
            required={true}
            returnKeyType="next"
            blurOnSubmit={false}
            onSubmitEditing={() => phoneRef.current.focus()}
          />

          <StyledTextInput
            ref={phoneRef}
            label="Số điện thoại"
            value={formData.phone}
            onChangeText={(text) => handleChange('phone', text)}
            placeholder="Nhập số điện thoại"
            keyboardType="phone-pad"
            returnKeyType="next"
            blurOnSubmit={false}
            onSubmitEditing={() => emailRef.current.focus()}
          />

          <StyledTextInput
            ref={emailRef}
            label="Email"
            value={formData.email}
            onChangeText={(text) => handleChange('email', text)}
            placeholder="Nhập địa chỉ email"
            keyboardType="email-address"
            autoCapitalize="none"
            returnKeyType="next"
            blurOnSubmit={false}
            onSubmitEditing={() => addressRef.current.focus()}
          />

          <StyledTextInput
            ref={addressRef}
            label="Địa chỉ"
            value={formData.address}
            onChangeText={(text) => handleChange('address', text)}
            placeholder="Nhập địa chỉ"
            multiline
            numberOfLines={3}
            inputStyle={styles.textArea}
            returnKeyType="next"
            blurOnSubmit={false}
            onSubmitEditing={() => taxCodeRef.current.focus()}
          />

          <StyledTextInput
            ref={taxCodeRef}
            label="Mã số thuế"
            value={formData.taxCode}
            onChangeText={(text) => handleChange('taxCode', text)}
            placeholder="Nhập mã số thuế"
            returnKeyType="done"
          />

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Loại khách hàng</Text>
            <View style={styles.typeButtonsContainer}>
              <TouchableOpacity
                style={[
                  styles.typeButton,
                  formData.type === 'potential' && styles.selectedTypeButton,
                ]}
                onPress={() => handleSelectType('potential')}
              >
                <Text
                  style={[
                    styles.typeButtonText,
                    formData.type === 'potential' &&
                      styles.selectedTypeButtonText,
                  ]}
                >
                  Tiềm năng
                </Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.typeButton,
                  formData.type === 'regular' && styles.selectedTypeButton,
                ]}
                onPress={() => handleSelectType('regular')}
              >
                <Text
                  style={[
                    styles.typeButtonText,
                    formData.type === 'regular' &&
                      styles.selectedTypeButtonText,
                  ]}
                >
                  Thường xuyên
                </Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.typeButton,
                  formData.type === 'vip' && styles.selectedTypeButton,
                ]}
                onPress={() => handleSelectType('vip')}
              >
                <Text
                  style={[
                    styles.typeButtonText,
                    formData.type === 'vip' && styles.selectedTypeButtonText,
                  ]}
                >
                  VIP
                </Text>
              </TouchableOpacity>
            </View>
          </View>

          <TouchableOpacity
            style={styles.saveButton}
            onPress={handleSave}
            disabled={isLoading}
          >
            {isLoading ? (
              <ActivityIndicator color="#fff" size="small" />
            ) : (
              <>
                <Ionicons
                  name="save-outline"
                  size={20}
                  color="#fff"
                  style={styles.saveIcon}
                />
                <Text style={styles.saveButtonText}>Lưu khách hàng</Text>
              </>
            )}
          </TouchableOpacity>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  placeholder: {
    width: 24,
  },
  formContainer: {
    flex: 1,
  },
  formContent: {
    padding: 16,
  },
  inputGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    marginBottom: 6,
  },
  required: {
    color: '#e74c3c',
  },
  textArea: {
    height: 100,
    textAlignVertical: 'top',
    paddingTop: 12,
  },
  typeButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  typeButton: {
    flex: 1,
    backgroundColor: '#f0f0f0',
    paddingVertical: 12,
    paddingHorizontal: 8,
    borderRadius: 6,
    alignItems: 'center',
    marginHorizontal: 4,
  },
  selectedTypeButton: {
    backgroundColor: '#0066cc',
  },
  typeButtonText: {
    color: '#333',
    fontWeight: '500',
  },
  selectedTypeButtonText: {
    color: '#fff',
  },
  saveButton: {
    backgroundColor: '#0066cc',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    borderRadius: 8,
    marginTop: 20,
    marginBottom: 30,
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  saveIcon: {
    marginRight: 8,
  },
});

export default AddCustomerScreen;

import React, { useState, useEffect } from 'react';
import {
  View,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  Image,
  Alert,
  Platform,
} from 'react-native';
import {
  TextInput,
  Button,
  Text,
  Appbar,
  HelperText,
  Divider,
  Dialog,
  Portal,
  List,
} from 'react-native-paper';
import { useNavigation } from '@react-navigation/native';
import * as ImagePicker from 'expo-image-picker';
import InventoryService from '../api/inventoryService';
import { firebase } from '../config/firebaseConfig';
import useInventory from '../hooks/useInventory';

const AddInventoryItemScreen = () => {
  const navigation = useNavigation();
  const { addInventoryItem } = useInventory();

  // State cho form thêm vật tư
  const [formData, setFormData] = useState({
    name: '',
    code: '',
    description: '',
    categoryId: '',
    unit: '',
    stockQuantity: 0,
    minQuantity: 0,
    price: 0,
    weight: 0,
    material: '',
    totalPrice: 0,
  });
  const [image, setImage] = useState(null);
  const [imageBlob, setImageBlob] = useState(null);
  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState({});
  const [categories, setCategories] = useState([]);
  const [selectedCategory, setSelectedCategory] = useState(null);
  const [categoryDialogVisible, setCategoryDialogVisible] = useState(false);
  const [units] = useState([
    'cái',
    'bộ',
    'tấm',
    'kg',
    'mét',
    'm2',
    'cuộn',
    'lít',
    'lon',
  ]);
  const [unitDialogVisible, setUnitDialogVisible] = useState(false);

  // Load danh sách danh mục khi màn hình được mount
  useEffect(() => {
    fetchCategories();
    requestPermissions();
  }, []);

  // Hàm lấy danh sách danh mục từ Firestore
  const fetchCategories = async () => {
    try {
      const snapshot = await firebase
        .firestore()
        .collection('inventory_categories')
        .get();
      const fetchedCategories = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));
      setCategories(fetchedCategories);
    } catch (error) {
      console.error('Lỗi khi lấy danh mục:', error);
      Alert.alert('Lỗi', 'Không thể lấy danh sách danh mục');
    }
  };

  // Yêu cầu quyền truy cập camera và thư viện ảnh
  const requestPermissions = async () => {
    if (Platform.OS !== 'web') {
      const { status: cameraStatus } =
        await ImagePicker.requestCameraPermissionsAsync();
      const { status: libraryStatus } =
        await ImagePicker.requestMediaLibraryPermissionsAsync();

      if (cameraStatus !== 'granted' || libraryStatus !== 'granted') {
        Alert.alert(
          'Cần quyền truy cập',
          'Bạn cần cấp quyền để sử dụng camera và thư viện ảnh.'
        );
      }
    }
  };

  // Xử lý thay đổi giá trị các trường
  const handleChange = (field, value) => {
    // Xử lý cho trường số
    if (['stockQuantity', 'minQuantity', 'price', 'weight'].includes(field)) {
      const numericValue = parseFloat(value.replace(/[^0-9.]/g, ''));
      const updatedValue = isNaN(numericValue) ? 0 : numericValue;

      const updatedFormData = {
        ...formData,
        [field]: updatedValue,
      };

      // Tính toán lại giá trị totalPrice nếu thay đổi số lượng hoặc đơn giá
      if (field === 'stockQuantity' || field === 'price') {
        updatedFormData.totalPrice =
          updatedFormData.stockQuantity * updatedFormData.price;
      }

      setFormData(updatedFormData);
    } else {
      setFormData({
        ...formData,
        [field]: value,
      });
    }

    // Xóa lỗi khi người dùng điền lại
    if (errors[field]) {
      setErrors({
        ...errors,
        [field]: null,
      });
    }
  };

  // Chọn danh mục
  const handleCategorySelect = (category) => {
    setSelectedCategory(category);
    setFormData({
      ...formData,
      categoryId: category.id,
    });
    setCategoryDialogVisible(false);

    // Xóa lỗi danh mục nếu có
    if (errors.categoryId) {
      setErrors({
        ...errors,
        categoryId: null,
      });
    }
  };

  // Chọn đơn vị tính
  const handleUnitSelect = (unit) => {
    setFormData({
      ...formData,
      unit,
    });
    setUnitDialogVisible(false);

    // Xóa lỗi đơn vị nếu có
    if (errors.unit) {
      setErrors({
        ...errors,
        unit: null,
      });
    }
  };

  // Chọn ảnh từ thư viện
  const pickImage = async () => {
    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        aspect: [4, 3],
        quality: 0.8,
      });

      if (!result.canceled && result.assets && result.assets[0]) {
        const imageUri = result.assets[0].uri;
        setImage(imageUri);

        // Chuyển ảnh thành blob để upload
        const response = await fetch(imageUri);
        const blob = await response.blob();
        setImageBlob(blob);
      }
    } catch (error) {
      console.error('Lỗi khi chọn ảnh:', error);
      Alert.alert('Lỗi', 'Không thể chọn ảnh');
    }
  };

  // Chụp ảnh từ camera
  const takePhoto = async () => {
    try {
      const result = await ImagePicker.launchCameraAsync({
        allowsEditing: true,
        aspect: [4, 3],
        quality: 0.8,
      });

      if (!result.canceled && result.assets && result.assets[0]) {
        const imageUri = result.assets[0].uri;
        setImage(imageUri);

        // Chuyển ảnh thành blob để upload
        const response = await fetch(imageUri);
        const blob = await response.blob();
        setImageBlob(blob);
      }
    } catch (error) {
      console.error('Lỗi khi chụp ảnh:', error);
      Alert.alert('Lỗi', 'Không thể chụp ảnh');
    }
  };

  // Kiểm tra form trước khi lưu
  const validateForm = () => {
    const newErrors = {};

    if (!formData.name.trim()) {
      newErrors.name = 'Vui lòng nhập tên vật tư';
    }

    if (!formData.code.trim()) {
      newErrors.code = 'Vui lòng nhập mã vật tư';
    }

    if (!formData.categoryId) {
      newErrors.categoryId = 'Vui lòng chọn danh mục';
    }

    if (!formData.unit.trim()) {
      newErrors.unit = 'Vui lòng chọn đơn vị tính';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Lưu vật tư mới
  const handleSave = async () => {
    if (!validateForm()) return;

    setLoading(true);

    try {
      // Thêm vật tư mới sử dụng useInventory hook để đảm bảo refresh
      const result = await addInventoryItem(formData);

      // Nếu có hình ảnh, upload và cập nhật URL
      if (imageBlob && result.id) {
        await InventoryService.uploadItemImage(result.id, imageBlob);
      }

      Alert.alert('Thành công', 'Đã thêm vật tư mới vào kho', [
        { text: 'OK', onPress: () => navigation.goBack() },
      ]);
    } catch (error) {
      console.error('Lỗi khi lưu vật tư:', error);
      Alert.alert('Lỗi', error.message || 'Không thể lưu vật tư');
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={styles.container}>
      <Appbar.Header>
        <Appbar.BackAction onPress={() => navigation.goBack()} />
        <Appbar.Content title="Thêm vật tư mới" />
      </Appbar.Header>

      <ScrollView style={styles.scrollView}>
        {/* Thông tin cơ bản */}
        <Text style={styles.sectionTitle}>Thông tin cơ bản</Text>

        <TextInput
          label="Tên vật tư *"
          value={formData.name}
          onChangeText={(text) => handleChange('name', text)}
          style={styles.input}
          error={!!errors.name}
        />
        {errors.name && <HelperText type="error">{errors.name}</HelperText>}

        <TextInput
          label="Mã vật tư *"
          value={formData.code}
          onChangeText={(text) => handleChange('code', text)}
          style={styles.input}
          error={!!errors.code}
        />
        {errors.code && <HelperText type="error">{errors.code}</HelperText>}

        <TouchableOpacity
          onPress={() => setCategoryDialogVisible(true)}
          style={styles.input}
        >
          <TextInput
            label="Danh mục *"
            value={selectedCategory ? selectedCategory.name : ''}
            editable={false}
            right={<TextInput.Icon icon="menu-down" />}
            error={!!errors.categoryId}
          />
        </TouchableOpacity>
        {errors.categoryId && (
          <HelperText type="error">{errors.categoryId}</HelperText>
        )}

        <TouchableOpacity
          onPress={() => setUnitDialogVisible(true)}
          style={styles.input}
        >
          <TextInput
            label="Đơn vị tính *"
            value={formData.unit}
            editable={false}
            right={<TextInput.Icon icon="menu-down" />}
            error={!!errors.unit}
          />
        </TouchableOpacity>
        {errors.unit && <HelperText type="error">{errors.unit}</HelperText>}

        <TextInput
          label="Mô tả"
          value={formData.description}
          onChangeText={(text) => handleChange('description', text)}
          multiline
          numberOfLines={3}
          style={styles.input}
        />

        <Divider style={styles.divider} />

        {/* Thông tin số lượng và đơn giá */}
        <Text style={styles.sectionTitle}>Thông tin số lượng và đơn giá</Text>

        <TextInput
          label="Số lượng ban đầu"
          value={formData.stockQuantity.toString()}
          onChangeText={(text) => handleChange('stockQuantity', text)}
          keyboardType="numeric"
          style={styles.input}
        />

        <TextInput
          label="Số lượng tồn tối thiểu"
          value={formData.minQuantity.toString()}
          onChangeText={(text) => handleChange('minQuantity', text)}
          keyboardType="numeric"
          style={styles.input}
        />

        <TextInput
          label={`Đơn giá (VNĐ/${formData.unit || 'đơn vị'})`}
          value={formData.price.toString()}
          onChangeText={(text) => handleChange('price', text)}
          keyboardType="numeric"
          style={styles.input}
        />

        <View style={styles.totalPriceContainer}>
          <Text style={styles.totalPriceLabel}>Tổng giá trị:</Text>
          <Text style={styles.totalPriceValue}>
            {(formData.totalPrice || 0).toLocaleString('vi-VN')} VNĐ
          </Text>
        </View>

        <Divider style={styles.divider} />

        {/* Thông tin bổ sung */}
        <Text style={styles.sectionTitle}>Thông tin bổ sung</Text>

        <TextInput
          label="Vật liệu"
          value={formData.material}
          onChangeText={(text) => handleChange('material', text)}
          style={styles.input}
        />

        <TextInput
          label="Khối lượng (kg)"
          value={formData.weight.toString()}
          onChangeText={(text) => handleChange('weight', text)}
          keyboardType="numeric"
          style={styles.input}
        />

        {/* Phần upload hình ảnh */}
        <Text style={styles.sectionTitle}>Hình ảnh vật tư</Text>

        <View style={styles.imageContainer}>
          {image ? (
            <Image source={{ uri: image }} style={styles.image} />
          ) : (
            <View style={styles.imagePlaceholder}>
              <Text style={styles.placeholderText}>Chưa có ảnh</Text>
            </View>
          )}

          <View style={styles.imageButtons}>
            <Button
              mode="contained"
              onPress={pickImage}
              style={styles.imageButton}
            >
              Chọn ảnh
            </Button>
            <Button
              mode="outlined"
              onPress={takePhoto}
              style={styles.imageButton}
            >
              Chụp ảnh
            </Button>
          </View>
        </View>

        {/* Nút lưu */}
        <Button
          mode="contained"
          onPress={handleSave}
          style={styles.saveButton}
          loading={loading}
          disabled={loading}
        >
          Lưu vật tư
        </Button>
      </ScrollView>

      {/* Dialog chọn danh mục */}
      <Portal>
        <Dialog
          visible={categoryDialogVisible}
          onDismiss={() => setCategoryDialogVisible(false)}
        >
          <Dialog.Title>Chọn danh mục</Dialog.Title>
          <Dialog.Content>
            <ScrollView style={{ maxHeight: 300 }}>
              {categories.map((category) => (
                <List.Item
                  key={category.id}
                  title={category.name}
                  description={category.description}
                  onPress={() => handleCategorySelect(category)}
                />
              ))}
            </ScrollView>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setCategoryDialogVisible(false)}>
              Đóng
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* Dialog chọn đơn vị tính */}
      <Portal>
        <Dialog
          visible={unitDialogVisible}
          onDismiss={() => setUnitDialogVisible(false)}
        >
          <Dialog.Title>Chọn đơn vị tính</Dialog.Title>
          <Dialog.Content>
            <ScrollView style={{ maxHeight: 300 }}>
              {units.map((unit) => (
                <List.Item
                  key={unit}
                  title={unit}
                  onPress={() => handleUnitSelect(unit)}
                />
              ))}
            </ScrollView>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setUnitDialogVisible(false)}>Đóng</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollView: {
    flex: 1,
    padding: 16,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginVertical: 12,
  },
  input: {
    marginBottom: 8,
    backgroundColor: 'white',
  },
  divider: {
    marginVertical: 16,
  },
  imageContainer: {
    marginVertical: 10,
    alignItems: 'center',
  },
  image: {
    width: '100%',
    height: 200,
    borderRadius: 8,
    marginBottom: 10,
  },
  imagePlaceholder: {
    width: '100%',
    height: 200,
    borderRadius: 8,
    backgroundColor: '#e0e0e0',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 10,
  },
  placeholderText: {
    color: '#757575',
  },
  imageButtons: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    width: '100%',
  },
  imageButton: {
    flex: 1,
    marginHorizontal: 5,
  },
  saveButton: {
    marginVertical: 24,
    paddingVertical: 6,
    backgroundColor: '#3f51b5',
  },
  totalPriceContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    backgroundColor: '#f0f0f0',
    borderRadius: 8,
    marginBottom: 16,
  },
  totalPriceLabel: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  totalPriceValue: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#3f51b5',
  },
});

export default AddInventoryItemScreen;

//src/screens/AddProjectScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
  Modal,
  FlatList,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import DateTimePicker from '@react-native-community/datetimepicker';
import { createProject } from '../api/projectService';
import { getCustomers } from '../api/customerService';
import { useAuth } from '../contexts/AuthContext';
import { functions } from '../config/firebaseConfig';
import { httpsCallable } from 'firebase/functions';

const AddProjectScreen = ({ navigation }) => {
  const { currentUser } = useAuth();
  const [isLoading, setIsLoading] = useState(false);
  const [customers, setCustomers] = useState([]);
  const [loadingCustomers, setLoadingCustomers] = useState(true);
  const [customerModalVisible, setCustomerModalVisible] = useState(false);
  const [customerSearchQuery, setCustomerSearchQuery] = useState('');
  const [filteredCustomers, setFilteredCustomers] = useState([]);

  // Thêm state cho date picker
  const [showStartDatePicker, setShowStartDatePicker] = useState(false);
  const [showEndDatePicker, setShowEndDatePicker] = useState(false);

  const [formData, setFormData] = useState({
    name: '',
    description: '',
    customerId: '',
    customerName: '',
    status: 'pending',
    startDate: null,
    endDate: null,
    durationInDays: '',
    location: 'workshop', // 'workshop' (tại xưởng) hoặc 'site' (tại công trình)
    budget: '',
    notes: '',
  });

  // Lấy danh sách khách hàng khi màn hình được tải
  useEffect(() => {
    const fetchCustomers = async () => {
      try {
        setLoadingCustomers(true);
        const data = await getCustomers();
        setCustomers(data);
        setFilteredCustomers(data);
      } catch (error) {
        console.error('Lỗi khi lấy danh sách khách hàng:', error);
        Alert.alert('Lỗi', 'Không thể tải danh sách khách hàng');
      } finally {
        setLoadingCustomers(false);
      }
    };

    fetchCustomers();
  }, []);

  // Lọc danh sách khách hàng khi từ khóa tìm kiếm thay đổi
  useEffect(() => {
    if (!customerSearchQuery.trim()) {
      setFilteredCustomers(customers);
      return;
    }

    const query = customerSearchQuery.toLowerCase().trim();
    const filtered = customers.filter((customer) => {
      const name = (customer.name || '').toLowerCase();
      const contact = (customer.contactPerson || '').toLowerCase();
      const email = (customer.email || '').toLowerCase();

      return (
        name.includes(query) || contact.includes(query) || email.includes(query)
      );
    });

    setFilteredCustomers(filtered);
  }, [customerSearchQuery, customers]);

  // Cập nhật giá trị form
  const handleChange = (field, value) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));
  };

  // Xử lý khi chọn ngày bắt đầu
  const handleStartDateChange = (event, selectedDate) => {
    setShowStartDatePicker(false);
    if (selectedDate) {
      handleChange('startDate', selectedDate);

      // Tự động tính ngày kết thúc nếu có số ngày thi công
      if (formData.durationInDays) {
        const endDate = new Date(selectedDate);
        endDate.setDate(endDate.getDate() + Number(formData.durationInDays));
        handleChange('endDate', endDate);
      }
    }
  };

  // Xử lý khi nhập số ngày thi công
  const handleDurationChange = (text) => {
    handleChange('durationInDays', text);

    // Tự động tính ngày kết thúc nếu có ngày bắt đầu
    if (formData.startDate && text) {
      const endDate = new Date(formData.startDate);
      endDate.setDate(endDate.getDate() + Number(text));
      handleChange('endDate', endDate);
    }
  };

  // Xử lý khi chọn vị trí
  const handleLocationChange = (location) => {
    handleChange('location', location);
  };

  // Định dạng ngày để hiển thị
  const formatDate = (date) => {
    if (!date) return '';
    return date.toLocaleDateString('vi-VN');
  };

  // Kiểm tra form hợp lệ
  const validateForm = () => {
    if (!formData.name.trim()) {
      Alert.alert('Lỗi', 'Vui lòng nhập tên dự án');
      return false;
    }

    return true;
  };

  // Xử lý lưu dự án
  const handleSave = async () => {
    if (!validateForm()) {
      return;
    }

    setIsLoading(true);

    try {
      // Chuẩn bị dữ liệu để lưu
      const projectData = {
        ...formData,
        budget: formData.budget ? Number(formData.budget) : null,
        durationInDays: formData.durationInDays
          ? Number(formData.durationInDays)
          : null,
      };

      // Gọi API tạo dự án mới
      const projectId = await createProject(projectData, currentUser?.uid);

      // Sau khi tạo dự án thành công, gọi hàm tạo folder
      if (projectId) {
        try {
          const createFoldersFn = httpsCallable(
            functions,
            'createProjectFolders'
          );
          await createFoldersFn({ projectId });
        } catch (folderError) {
          // Log lỗi nhưng không chặn người dùng
          console.error('Lỗi khi tạo thư mục dự án trên Drive:', folderError);
          Alert.alert(
            'Tạo dự án thành công',
            'Dự án đã được tạo, nhưng có lỗi xảy ra khi tạo thư mục trên Google Drive. Bạn có thể thử lại sau.'
          );
        }
      }

      Alert.alert(
        'Thành công',
        'Đã thêm dự án mới và tạo thư mục thành công!',
        [
          {
            text: 'OK',
            onPress: () => navigation.goBack(),
          },
        ]
      );
    } catch (error) {
      if (error.code === 'permission-denied') {
        Alert.alert(
          'Lỗi quyền',
          'Bạn không có đủ quyền để thực hiện hành động này.'
        );
      } else {
        console.error('Lỗi khi thêm dự án:', error);
        Alert.alert('Lỗi', 'Không thể thêm dự án. Vui lòng thử lại sau.');
      }
    } finally {
      setIsLoading(false);
    }
  };

  // Xử lý thay đổi trạng thái dự án
  const handleSelectStatus = (status) => {
    handleChange('status', status);
  };

  // Xử lý mở modal chọn khách hàng
  const handleOpenCustomerModal = () => {
    setCustomerModalVisible(true);
  };

  // Xử lý đóng modal chọn khách hàng
  const handleCloseCustomerModal = () => {
    setCustomerModalVisible(false);
    setCustomerSearchQuery('');
  };

  // Xử lý khi chọn khách hàng
  const handleSelectCustomer = (customer) => {
    setFormData((prev) => ({
      ...prev,
      customerId: customer.id,
      customerName: customer.name,
    }));
    handleCloseCustomerModal();
  };

  // Xử lý khi tìm kiếm khách hàng
  const handleSearchCustomer = (text) => {
    setCustomerSearchQuery(text);
  };

  // Xử lý khi xóa khách hàng đã chọn
  const handleClearCustomer = () => {
    setFormData((prev) => ({
      ...prev,
      customerId: '',
      customerName: '',
    }));
  };

  // Render một item trong danh sách khách hàng
  const renderCustomerItem = ({ item }) => (
    <TouchableOpacity
      style={styles.customerItem}
      onPress={() => handleSelectCustomer(item)}
    >
      <View>
        <Text style={styles.customerName}>{item.name}</Text>
        {item.contactPerson && (
          <Text style={styles.customerDetail}>
            Người liên hệ: {item.contactPerson}
          </Text>
        )}
        {item.email && (
          <Text style={styles.customerDetail}>Email: {item.email}</Text>
        )}
      </View>
      <Ionicons name="chevron-forward" size={20} color="#999" />
    </TouchableOpacity>
  );

  return (
    <KeyboardAvoidingView
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      style={styles.container}
    >
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Thêm dự án mới</Text>
        <View style={styles.placeholder} />
      </View>

      <ScrollView
        style={styles.formContainer}
        contentContainerStyle={styles.formContent}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.inputGroup}>
          <Text style={styles.label}>
            Tên dự án <Text style={styles.required}>*</Text>
          </Text>
          <TextInput
            style={styles.input}
            value={formData.name}
            onChangeText={(text) => handleChange('name', text)}
            placeholder="Nhập tên dự án"
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>Mô tả</Text>
          <TextInput
            style={[styles.input, styles.textArea]}
            value={formData.description}
            onChangeText={(text) => handleChange('description', text)}
            placeholder="Nhập mô tả dự án"
            multiline
            numberOfLines={3}
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>Khách hàng</Text>
          {formData.customerName ? (
            <View style={styles.selectedCustomerContainer}>
              <View style={styles.selectedCustomer}>
                <Ionicons name="business-outline" size={20} color="#0066cc" />
                <Text style={styles.selectedCustomerText}>
                  {formData.customerName}
                </Text>
              </View>
              <TouchableOpacity
                style={styles.clearCustomerButton}
                onPress={handleClearCustomer}
              >
                <Ionicons name="close-circle" size={20} color="#999" />
              </TouchableOpacity>
            </View>
          ) : (
            <TouchableOpacity
              style={styles.customerSelectButton}
              onPress={handleOpenCustomerModal}
            >
              <Ionicons name="add-circle-outline" size={20} color="#0066cc" />
              <Text style={styles.customerSelectButtonText}>
                Chọn khách hàng
              </Text>
            </TouchableOpacity>
          )}
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>Trạng thái</Text>
          <View style={styles.statusButtonsContainer}>
            <TouchableOpacity
              style={[
                styles.statusButton,
                formData.status === 'pending' && styles.selectedStatusButton,
              ]}
              onPress={() => handleSelectStatus('pending')}
            >
              <Text
                style={[
                  styles.statusButtonText,
                  formData.status === 'pending' &&
                    styles.selectedStatusButtonText,
                ]}
              >
                Chờ xử lý
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.statusButton,
                formData.status === 'in-progress' &&
                  styles.selectedStatusButton,
              ]}
              onPress={() => handleSelectStatus('in-progress')}
            >
              <Text
                style={[
                  styles.statusButtonText,
                  formData.status === 'in-progress' &&
                    styles.selectedStatusButtonText,
                ]}
              >
                Đang thực hiện
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.statusButton,
                formData.status === 'completed' && styles.selectedStatusButton,
              ]}
              onPress={() => handleSelectStatus('completed')}
            >
              <Text
                style={[
                  styles.statusButtonText,
                  formData.status === 'completed' &&
                    styles.selectedStatusButtonText,
                ]}
              >
                Hoàn thành
              </Text>
            </TouchableOpacity>
          </View>

          <View style={[styles.statusButtonsContainer, { marginTop: 8 }]}>
            <TouchableOpacity
              style={[
                styles.statusButton,
                formData.status === 'cancelled' && styles.selectedStatusButton,
              ]}
              onPress={() => handleSelectStatus('cancelled')}
            >
              <Text
                style={[
                  styles.statusButtonText,
                  formData.status === 'cancelled' &&
                    styles.selectedStatusButtonText,
                ]}
              >
                Đã hủy
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        {/* Thêm trường ngày bắt đầu */}
        <View style={styles.inputGroup}>
          <Text style={styles.label}>Ngày bắt đầu</Text>
          <TouchableOpacity
            style={styles.dateButton}
            onPress={() => setShowStartDatePicker(true)}
          >
            <Ionicons name="calendar-outline" size={20} color="#0066cc" />
            <Text style={styles.dateButtonText}>
              {formData.startDate
                ? formatDate(formData.startDate)
                : 'Chọn ngày bắt đầu'}
            </Text>
          </TouchableOpacity>
          {showStartDatePicker && (
            <DateTimePicker
              value={formData.startDate || new Date()}
              mode="date"
              display="default"
              onChange={handleStartDateChange}
            />
          )}
        </View>

        {/* Thêm trường số ngày thi công */}
        <View style={styles.inputGroup}>
          <Text style={styles.label}>Số ngày thi công</Text>
          <TextInput
            style={styles.input}
            value={formData.durationInDays}
            onChangeText={handleDurationChange}
            placeholder="Nhập số ngày thi công"
            keyboardType="numeric"
          />
        </View>

        {/* Hiển thị ngày kết thúc (chỉ đọc) */}
        <View style={styles.inputGroup}>
          <Text style={styles.label}>Ngày kết thúc (tự động tính)</Text>
          <View style={styles.readOnlyField}>
            <Ionicons name="calendar-outline" size={20} color="#666" />
            <Text style={styles.readOnlyText}>
              {formData.endDate
                ? formatDate(formData.endDate)
                : 'Chưa xác định'}
            </Text>
          </View>
        </View>

        {/* Thêm trường vị trí */}
        <View style={styles.inputGroup}>
          <Text style={styles.label}>Vị trí thi công</Text>
          <View style={styles.locationButtonsContainer}>
            <TouchableOpacity
              style={[
                styles.locationButton,
                formData.location === 'workshop' &&
                  styles.selectedLocationButton,
              ]}
              onPress={() => handleLocationChange('workshop')}
            >
              <Text
                style={[
                  styles.locationButtonText,
                  formData.location === 'workshop' &&
                    styles.selectedLocationButtonText,
                ]}
              >
                Tại xưởng
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.locationButton,
                formData.location === 'site' && styles.selectedLocationButton,
              ]}
              onPress={() => handleLocationChange('site')}
            >
              <Text
                style={[
                  styles.locationButtonText,
                  formData.location === 'site' &&
                    styles.selectedLocationButtonText,
                ]}
              >
                Tại công trình
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>Ngân sách</Text>
          <TextInput
            style={styles.input}
            value={formData.budget}
            onChangeText={(text) => handleChange('budget', text)}
            placeholder="Nhập ngân sách dự án"
            keyboardType="numeric"
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>Ghi chú</Text>
          <TextInput
            style={[styles.input, styles.textArea]}
            value={formData.notes}
            onChangeText={(text) => handleChange('notes', text)}
            placeholder="Nhập ghi chú"
            multiline
            numberOfLines={3}
          />
        </View>
      </ScrollView>

      <View style={styles.footer}>
        <TouchableOpacity
          style={styles.saveButton}
          onPress={handleSave}
          disabled={isLoading}
        >
          {isLoading ? (
            <ActivityIndicator color="#fff" size="small" />
          ) : (
            <>
              <Ionicons name="save-outline" size={20} color="#fff" />
              <Text style={styles.saveButtonText}>Lưu dự án</Text>
            </>
          )}
        </TouchableOpacity>
      </View>

      {/* Modal chọn khách hàng */}
      <Modal
        visible={customerModalVisible}
        animationType="slide"
        transparent={true}
        onRequestClose={handleCloseCustomerModal}
      >
        <View style={styles.modalContainer}>
          <View style={styles.modalContent}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Chọn khách hàng</Text>
              <TouchableOpacity
                style={styles.closeButton}
                onPress={handleCloseCustomerModal}
              >
                <Ionicons name="close" size={24} color="#333" />
              </TouchableOpacity>
            </View>

            <View style={styles.searchContainer}>
              <Ionicons
                name="search"
                size={20}
                color="#999"
                style={styles.searchIcon}
              />
              <TextInput
                style={styles.searchInput}
                placeholder="Tìm kiếm khách hàng..."
                value={customerSearchQuery}
                onChangeText={handleSearchCustomer}
              />
              {customerSearchQuery.length > 0 && (
                <TouchableOpacity
                  onPress={() => setCustomerSearchQuery('')}
                  style={styles.clearSearchButton}
                >
                  <Ionicons name="close-circle" size={18} color="#999" />
                </TouchableOpacity>
              )}
            </View>

            {loadingCustomers ? (
              <View style={styles.loadingContainer}>
                <ActivityIndicator size="large" color="#0066cc" />
                <Text style={styles.loadingText}>
                  Đang tải danh sách khách hàng...
                </Text>
              </View>
            ) : (
              <FlatList
                data={filteredCustomers}
                keyExtractor={(item) => item.id}
                renderItem={renderCustomerItem}
                contentContainerStyle={styles.customersList}
                ListEmptyComponent={() => (
                  <View style={styles.emptyListContainer}>
                    <Ionicons name="search-outline" size={40} color="#ccc" />
                    <Text style={styles.emptyListText}>
                      Không tìm thấy khách hàng phù hợp
                    </Text>
                  </View>
                )}
              />
            )}
          </View>
        </View>
      </Modal>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  placeholder: {
    width: 24,
  },
  formContainer: {
    flex: 1,
  },
  formContent: {
    padding: 16,
  },
  inputGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    marginBottom: 6,
    color: '#333',
  },
  required: {
    color: '#e74c3c',
  },
  input: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    color: '#333',
  },
  textArea: {
    minHeight: 80,
    textAlignVertical: 'top',
  },
  statusButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  statusButton: {
    flex: 1,
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 8,
    borderRadius: 8,
    marginHorizontal: 4,
    alignItems: 'center',
  },
  selectedStatusButton: {
    backgroundColor: '#0066cc',
  },
  statusButtonText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '500',
  },
  selectedStatusButtonText: {
    color: '#fff',
  },
  // Thêm style cho các trường mới
  dateButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
  },
  dateButtonText: {
    fontSize: 16,
    color: '#333',
    marginLeft: 8,
  },
  locationButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  locationButton: {
    flex: 1,
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 8,
    borderRadius: 8,
    marginHorizontal: 4,
    alignItems: 'center',
  },
  selectedLocationButton: {
    backgroundColor: '#0066cc',
  },
  locationButtonText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '500',
  },
  selectedLocationButtonText: {
    color: '#fff',
  },
  customerSelectButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
  },
  customerSelectButtonText: {
    fontSize: 16,
    color: '#0066cc',
    marginLeft: 8,
  },
  selectedCustomerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
  },
  selectedCustomer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  selectedCustomerText: {
    fontSize: 16,
    color: '#333',
    marginLeft: 8,
  },
  clearCustomerButton: {
    padding: 4,
  },
  footer: {
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  saveButton: {
    backgroundColor: '#0066cc',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    borderRadius: 8,
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  modalContainer: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: '#fff',
    borderTopLeftRadius: 16,
    borderTopRightRadius: 16,
    height: '80%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  closeButton: {
    padding: 4,
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    margin: 16,
    borderRadius: 8,
    paddingHorizontal: 12,
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    height: 40,
    fontSize: 16,
  },
  clearSearchButton: {
    padding: 4,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
  },
  customersList: {
    padding: 16,
    paddingTop: 0,
  },
  customerItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#f9f9f9',
    padding: 12,
    borderRadius: 8,
    marginBottom: 8,
  },
  customerName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 2,
  },
  customerDetail: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  emptyListContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 40,
  },
  emptyListText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  readOnlyField: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
  },
  readOnlyText: {
    fontSize: 16,
    color: '#666',
    marginLeft: 8,
  },
});

export default AddProjectScreen;

// src/screens/AddSupplierScreen.js
import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  ScrollView,
  Alert,
  ActivityIndicator,
  SafeAreaView,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { addSupplier } from '../api/supplierService';
import { useAuth } from '../contexts/AuthContext';

const MATERIAL_CATEGORIES = [
  'Thép tấm',
  'Nhôm',
  'Nước',
  'Sơn',
  'Khí hàn',
  'Vật liệu hoàn thiện',
  'Sắt',
  'Inox',
  'Ống',
  'Thép hình',
  'Long đền',
  'Phụ kiện',
  'Dụng cụ hàn',
  'Thiết bị đo đạc',
  'Khác',
];

const AddSupplierScreen = ({ navigation }) => {
  const { currentUser } = useAuth();
  const [formData, setFormData] = useState({
    name: '',
    contactName: '',
    phone: '',
    email: '',
    address: '',
    taxCode: '',
    bankAccount: '',
    bankName: '',
    description: '',
    categories: [],
    verified: false,
    createdBy: currentUser?.uid || '',
    createdByName: currentUser?.displayName || currentUser?.email || '',
  });
  const [errors, setErrors] = useState({});
  const [saving, setSaving] = useState(false);

  const handleChange = (field, value) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));

    // Clear error when field is edited
    if (errors[field]) {
      setErrors((prev) => ({
        ...prev,
        [field]: null,
      }));
    }
  };

  const toggleCategory = (category) => {
    setFormData((prev) => {
      const updatedCategories = [...prev.categories];

      if (updatedCategories.includes(category)) {
        // Remove category if already selected
        return {
          ...prev,
          categories: updatedCategories.filter((c) => c !== category),
        };
      } else {
        // Add category if not selected
        return {
          ...prev,
          categories: [...updatedCategories, category],
        };
      }
    });
  };

  const validateForm = () => {
    const newErrors = {};

    if (!formData.name.trim()) {
      newErrors.name = 'Vui lòng nhập tên nhà cung cấp';
    }

    if (formData.phone && !/^[0-9]{10,11}$/.test(formData.phone.trim())) {
      newErrors.phone = 'Số điện thoại không hợp lệ';
    }

    if (formData.email && !/\S+@\S+\.\S+/.test(formData.email.trim())) {
      newErrors.email = 'Email không hợp lệ';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async () => {
    if (!validateForm()) {
      Alert.alert('Lỗi', 'Vui lòng kiểm tra lại thông tin nhập');
      return;
    }

    setSaving(true);
    try {
      await addSupplier(formData);
      Alert.alert('Thành công', 'Đã thêm nhà cung cấp mới', [
        { text: 'OK', onPress: () => navigation.goBack() },
      ]);
    } catch (error) {
      console.error('Lỗi khi thêm nhà cung cấp:', error);
      Alert.alert('Lỗi', 'Không thể thêm nhà cung cấp. Vui lòng thử lại sau.');
    } finally {
      setSaving(false);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={{ flex: 1 }}
      >
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
          >
            <Ionicons name="arrow-back" size={24} color="#333" />
          </TouchableOpacity>
          <Text style={styles.headerTitle}>Thêm nhà cung cấp mới</Text>
          <View style={{ width: 24 }} />
        </View>

        <ScrollView style={styles.content}>
          <View style={styles.formGroup}>
            <Text style={styles.label}>
              Tên nhà cung cấp <Text style={styles.required}>*</Text>
            </Text>
            <TextInput
              style={[styles.input, errors.name && styles.inputError]}
              value={formData.name}
              onChangeText={(text) => handleChange('name', text)}
              placeholder="Nhập tên nhà cung cấp"
            />
            {errors.name && <Text style={styles.errorText}>{errors.name}</Text>}
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Người liên hệ</Text>
            <TextInput
              style={styles.input}
              value={formData.contactName}
              onChangeText={(text) => handleChange('contactName', text)}
              placeholder="Nhập tên người liên hệ"
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Số điện thoại</Text>
            <TextInput
              style={[styles.input, errors.phone && styles.inputError]}
              value={formData.phone}
              onChangeText={(text) => handleChange('phone', text)}
              placeholder="Nhập số điện thoại"
              keyboardType="phone-pad"
            />
            {errors.phone && (
              <Text style={styles.errorText}>{errors.phone}</Text>
            )}
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Email</Text>
            <TextInput
              style={[styles.input, errors.email && styles.inputError]}
              value={formData.email}
              onChangeText={(text) => handleChange('email', text)}
              placeholder="Nhập địa chỉ email"
              keyboardType="email-address"
              autoCapitalize="none"
            />
            {errors.email && (
              <Text style={styles.errorText}>{errors.email}</Text>
            )}
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Địa chỉ</Text>
            <TextInput
              style={styles.input}
              value={formData.address}
              onChangeText={(text) => handleChange('address', text)}
              placeholder="Nhập địa chỉ"
              multiline
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Mã số thuế</Text>
            <TextInput
              style={styles.input}
              value={formData.taxCode}
              onChangeText={(text) => handleChange('taxCode', text)}
              placeholder="Nhập mã số thuế"
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Tài khoản ngân hàng</Text>
            <TextInput
              style={styles.input}
              value={formData.bankAccount}
              onChangeText={(text) => handleChange('bankAccount', text)}
              placeholder="Nhập số tài khoản"
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Tên ngân hàng</Text>
            <TextInput
              style={styles.input}
              value={formData.bankName}
              onChangeText={(text) => handleChange('bankName', text)}
              placeholder="Nhập tên ngân hàng"
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Danh mục vật tư cung cấp</Text>
            <View style={styles.categoriesContainer}>
              {MATERIAL_CATEGORIES.map((category, index) => (
                <TouchableOpacity
                  key={index}
                  style={[
                    styles.categoryTag,
                    formData.categories.includes(category) &&
                      styles.categoryTagSelected,
                  ]}
                  onPress={() => toggleCategory(category)}
                >
                  <Text
                    style={[
                      styles.categoryText,
                      formData.categories.includes(category) &&
                        styles.categoryTextSelected,
                    ]}
                  >
                    {category}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Mô tả</Text>
            <TextInput
              style={[styles.input, styles.textArea]}
              value={formData.description}
              onChangeText={(text) => handleChange('description', text)}
              placeholder="Nhập mô tả về nhà cung cấp"
              multiline
              numberOfLines={4}
              textAlignVertical="top"
            />
          </View>

          <View style={styles.verifiedContainer}>
            <TouchableOpacity
              style={styles.checkboxContainer}
              onPress={() => handleChange('verified', !formData.verified)}
            >
              <View
                style={[
                  styles.checkbox,
                  formData.verified && styles.checkboxChecked,
                ]}
              >
                {formData.verified && (
                  <Ionicons name="checkmark" size={16} color="#fff" />
                )}
              </View>
              <Text style={styles.checkboxLabel}>Đã xác minh</Text>
            </TouchableOpacity>
          </View>

          <TouchableOpacity
            style={styles.saveButton}
            onPress={handleSubmit}
            disabled={saving}
          >
            {saving ? (
              <ActivityIndicator color="#fff" size="small" />
            ) : (
              <Text style={styles.saveButtonText}>Lưu nhà cung cấp</Text>
            )}
          </TouchableOpacity>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  content: {
    flex: 1,
    padding: 16,
  },
  formGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    color: '#333',
    marginBottom: 6,
  },
  required: {
    color: 'red',
  },
  input: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    fontSize: 16,
  },
  inputError: {
    borderColor: 'red',
  },
  errorText: {
    color: 'red',
    fontSize: 12,
    marginTop: 4,
  },
  textArea: {
    minHeight: 100,
    textAlignVertical: 'top',
  },
  categoriesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginTop: 8,
  },
  categoryTag: {
    backgroundColor: '#f0f0f0',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 16,
    marginRight: 8,
    marginBottom: 8,
  },
  categoryTagSelected: {
    backgroundColor: '#e6f2ff',
    borderWidth: 1,
    borderColor: '#0066cc',
  },
  categoryText: {
    fontSize: 14,
    color: '#666',
  },
  categoryTextSelected: {
    color: '#0066cc',
    fontWeight: '500',
  },
  verifiedContainer: {
    marginBottom: 24,
  },
  checkboxContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  checkbox: {
    width: 20,
    height: 20,
    borderRadius: 4,
    borderWidth: 1,
    borderColor: '#999',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 8,
  },
  checkboxChecked: {
    backgroundColor: '#0066cc',
    borderColor: '#0066cc',
  },
  checkboxLabel: {
    fontSize: 16,
    color: '#333',
  },
  saveButton: {
    backgroundColor: '#0066cc',
    paddingVertical: 14,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 30,
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
});

export default AddSupplierScreen;

// src/screens/AttendanceScreen.js
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  ActivityIndicator,
  Modal,
  TextInput,
  Alert,
  SafeAreaView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { db } from '../config/firebaseConfig';
import {
  collection,
  getDocs,
  addDoc,
  query,
  orderBy,
  serverTimestamp,
  deleteDoc,
  doc,
} from 'firebase/firestore';
import {
  setPresence,
  getAttendance,
  addOvertime,
} from '../api/attendanceService';
import DateTimePicker from '@react-native-community/datetimepicker';

const AttendanceScreen = () => {
  const { theme } = useTheme();
  const [employees, setEmployees] = useState([]);
  const [loading, setLoading] = useState(true);
  const [savingId, setSavingId] = useState(null);
  const [attMap, setAttMap] = useState({}); // uid -> attendance doc
  const [showAddModal, setShowAddModal] = useState(false);
  const [newName, setNewName] = useState('');
  const [newEmail, setNewEmail] = useState('');
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [showOvertimeModal, setShowOvertimeModal] = useState(false);
  const [overtimeHours, setOvertimeHours] = useState('');
  const [selectedEmployee, setSelectedEmployee] = useState(null);

  // Add default overtime hours
  const DEFAULT_OVERTIME_HOURS = 2.5; // Default 2.5 hours (20:30)

  // Format date for display
  const formatDisplayDate = (date) => {
    return date.toLocaleDateString('vi-VN', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
    });
  };

  // Format date for document ID
  const formatDateForDoc = (date) => {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  };

  const fetchEmployees = async () => {
    setLoading(true);
    try {
      const usersRef = collection(db, 'users');
      const q = query(usersRef, orderBy('displayName', 'asc'));
      const snap = await getDocs(q);
      const list = snap.docs.map((d) => ({ uid: d.id, ...d.data() }));
      setEmployees(list);
      await fetchAttendanceForDate(selectedDate);
    } catch (err) {
      console.error('Load employees err', err);
      Alert.alert('Lỗi', 'Không thể tải danh sách nhân viên');
      setLoading(false);
    }
  };

  const fetchAttendanceForDate = async (date) => {
    setLoading(true);
    try {
      if (!employees.length) return;

      // Format date to YYYY-MM-DD for attendance lookup
      const dateStr = formatDateForDoc(date);

      // load attendance info
      const dateFetchPromises = employees.map((emp) =>
        getAttendance(emp.uid, dateStr)
      );
      const results = await Promise.all(dateFetchPromises);
      const map = {};
      results.forEach((doc) => {
        if (doc) map[doc.userId] = doc;
      });
      setAttMap(map);
    } catch (err) {
      console.error('Load attendance err', err);
      Alert.alert('Lỗi', 'Không thể tải dữ liệu chấm công');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchEmployees();
  }, []);

  useEffect(() => {
    if (employees.length > 0) {
      fetchAttendanceForDate(selectedDate);
    }
  }, [selectedDate, employees.length]);

  const togglePresent = async (emp) => {
    try {
      setSavingId(emp.uid);
      const current = attMap[emp.uid]?.present || false;
      const updated = await setPresence(emp.uid, !current, selectedDate);
      setAttMap((prev) => ({ ...prev, [emp.uid]: updated }));
    } catch (err) {
      console.error(err);
      Alert.alert('Lỗi', 'Không thể cập nhật');
    } finally {
      setSavingId(null);
    }
  };

  const handleDateChange = (event, date) => {
    setShowDatePicker(false);
    if (date) {
      setSelectedDate(date);
    }
  };

  // Add delete employee function
  const deleteEmployee = async (emp) => {
    try {
      setSavingId(emp.uid);
      await deleteDoc(doc(db, 'users', emp.uid));
      setEmployees((prev) => prev.filter((e) => e.uid !== emp.uid));
      Alert.alert('Thành công', 'Đã xóa nhân viên');
    } catch (err) {
      console.error(err);
      Alert.alert('Lỗi', 'Không thể xóa nhân viên');
    } finally {
      setSavingId(null);
    }
  };

  // Improve markAllPresent to be more efficient
  const markAllPresent = async () => {
    try {
      // Use a temporary state to show loading indicators on each row
      const tempIds = employees.map((e) => e.uid);
      setSavingId('all'); // Special marker for "all saving"
      const promises = employees.map((emp) =>
        setPresence(emp.uid, true, selectedDate)
      );
      await Promise.all(promises);

      // Update local state without full reload
      const newAttMap = { ...attMap };
      employees.forEach((emp) => {
        const uid = emp.uid;
        if (newAttMap[uid]) {
          newAttMap[uid].present = true;
        } else {
          newAttMap[uid] = {
            userId: uid,
            present: true,
            date: formatDateForDoc(selectedDate),
          };
        }
      });
      setAttMap(newAttMap);
      setSavingId(null);
    } catch (err) {
      console.error(err);
      Alert.alert('Lỗi', 'Không thể cập nhật tất cả');
      setSavingId(null);
    }
  };

  // Add markAllOvertime function
  const markAllOvertime = async () => {
    try {
      setSavingId('all');
      const promises = employees.map((emp) =>
        addOvertime(emp.uid, DEFAULT_OVERTIME_HOURS, selectedDate)
      );
      await Promise.all(promises);

      // Update local state
      const newAttMap = { ...attMap };
      employees.forEach((emp) => {
        const uid = emp.uid;
        if (newAttMap[uid]) {
          newAttMap[uid].overtime = DEFAULT_OVERTIME_HOURS;
        } else {
          newAttMap[uid] = {
            userId: uid,
            overtime: DEFAULT_OVERTIME_HOURS,
            date: formatDateForDoc(selectedDate),
          };
        }
      });
      setAttMap(newAttMap);
      setSavingId(null);
    } catch (err) {
      console.error(err);
      Alert.alert('Lỗi', 'Không thể cập nhật tăng ca');
      setSavingId(null);
    }
  };

  // Add a function to toggle overtime directly
  const toggleOvertime = async (emp) => {
    try {
      setSavingId(emp.uid);
      const current = attMap[emp.uid]?.overtime || 0;
      const newValue = current > 0 ? 0 : DEFAULT_OVERTIME_HOURS;
      const updated = await addOvertime(emp.uid, newValue, selectedDate);
      setAttMap((prev) => ({ ...prev, [emp.uid]: updated }));
    } catch (err) {
      console.error(err);
      Alert.alert('Lỗi', 'Không thể cập nhật tăng ca');
    } finally {
      setSavingId(null);
    }
  };

  const handleAddOvertime = async () => {
    if (!selectedEmployee) return;

    const hours = parseFloat(overtimeHours);
    if (isNaN(hours) || hours < 0) {
      Alert.alert('Lỗi', 'Vui lòng nhập số giờ hợp lệ');
      return;
    }

    try {
      setSavingId(selectedEmployee.uid);
      await addOvertime(selectedEmployee.uid, hours, selectedDate);
      setShowOvertimeModal(false);
      setOvertimeHours('');
      setSelectedEmployee(null);
      await fetchAttendanceForDate(selectedDate);
    } catch (err) {
      console.error(err);
      Alert.alert('Lỗi', 'Không thể thêm giờ tăng ca');
    } finally {
      setSavingId(null);
    }
  };

  const openOvertimeModal = (emp) => {
    setSelectedEmployee(emp);
    setOvertimeHours('');
    setShowOvertimeModal(true);
  };

  const renderItem = ({ item }) => {
    const attendance = attMap[item.uid];
    const present = attendance?.present;
    const overtime = attendance?.overtime || 0;
    const isSaving = savingId === item.uid || savingId === 'all';

    return (
      <View
        style={[
          styles.row,
          { backgroundColor: theme.card, marginBottom: 8, borderRadius: 8 },
        ]}
      >
        <View style={styles.employeeInfo}>
          <Text
            style={[styles.nameText, { color: theme.text }]}
            numberOfLines={1}
            ellipsizeMode="tail"
          >
            {item.displayName || item.email || item.uid}
          </Text>
          <Text style={[styles.roleText, { color: theme.textSecondary }]}>
            {item.role ? getRoleLabel(item.role) : 'Nhân viên'}
          </Text>
        </View>

        {overtime > 0 && (
          <TouchableOpacity
            style={styles.overtimeBadge}
            onPress={() => openOvertimeModal(item)}
          >
            <Ionicons
              name="time"
              size={12}
              color="#8B7500"
              style={{ marginRight: 4 }}
            />
            <Text style={styles.overtimeText}>
              {overtime === 2.5 ? '20:30' : `+${overtime}h`}
            </Text>
          </TouchableOpacity>
        )}

        <View style={styles.attendanceActions}>
          <TouchableOpacity
            onPress={() => togglePresent(item)}
            disabled={isSaving}
            style={styles.checkButton}
          >
            {isSaving ? (
              <ActivityIndicator size="small" color={theme.primary} />
            ) : (
              <Ionicons
                name={present ? 'checkbox' : 'square-outline'}
                size={24}
                color={present ? theme.primary : theme.textMuted}
              />
            )}
          </TouchableOpacity>

          <View style={styles.overtimeActionContainer}>
            <TouchableOpacity
              onPress={() => toggleOvertime(item)}
              disabled={isSaving}
              style={styles.checkButtonOvertime}
            >
              {isSaving ? (
                <ActivityIndicator
                  size="small"
                  color={theme.success || '#4CAF50'}
                />
              ) : (
                <Ionicons
                  name={overtime > 0 ? 'checkbox' : 'square-outline'}
                  size={24}
                  color={
                    overtime > 0 ? theme.success || '#4CAF50' : theme.textMuted
                  }
                />
              )}
            </TouchableOpacity>
          </View>
        </View>
      </View>
    );
  };

  const addEmployee = async () => {
    if (!newName.trim()) {
      Alert.alert('Thiếu tên');
      return;
    }
    try {
      const usersRef = collection(db, 'users');
      await addDoc(usersRef, {
        displayName: newName,
        email: newEmail.trim() || '',
        role: 'cong_nhan',
        createdAt: serverTimestamp(),
      });
      setShowAddModal(false);
      setNewName('');
      setNewEmail('');
      fetchEmployees();
    } catch (err) {
      console.error(err);
      Alert.alert('Lỗi', 'Không thể thêm nhân viên');
    }
  };

  // Helper function to format overtime display
  const formatOvertimeForDisplay = (hours) => {
    return `+${hours}h`;
  };

  // Helper function to map role keys to display labels
  const getRoleLabel = (role) => {
    switch (role) {
      case 'admin':
        return 'Quản trị viên';
      case 'giam_doc':
        return 'Giám đốc';
      case 'pho_giam_doc':
        return 'Phó Giám đốc';
      case 'quan_ly':
        return 'Quản lý';
      case 'ky_su':
        return 'Kỹ sư';
      case 'ke_toan':
        return 'Kế toán';
      case 'thuong_mai':
        return 'Thương mại';
      case 'cong_nhan':
        return 'Công nhân';
      case 'user':
        return 'Người dùng';
      default:
        return 'Không xác định';
    }
  };

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      {/* Header */}
      <View style={[styles.header, { backgroundColor: theme.card }]}>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Chấm Công & Tăng Ca
        </Text>

        <TouchableOpacity
          style={[styles.dateButton, { borderColor: theme.border }]}
          onPress={() => setShowDatePicker(true)}
        >
          <Ionicons name="calendar-outline" size={18} color={theme.primary} />
          <Text style={[styles.dateText, { color: theme.text }]}>
            {formatDisplayDate(selectedDate)}
          </Text>
          <Ionicons name="chevron-down" size={16} color={theme.textMuted} />
        </TouchableOpacity>
      </View>

      {/* Action buttons */}
      <View style={styles.actionBar}>
        <TouchableOpacity
          style={[
            styles.actionButton,
            { backgroundColor: theme.secondary || '#FF9500' },
          ]}
          onPress={markAllPresent}
          disabled={savingId === 'all'}
        >
          {savingId === 'all' ? (
            <ActivityIndicator size="small" color="#fff" />
          ) : (
            <>
              <Ionicons
                name="checkbox"
                size={18}
                color="#fff"
                style={styles.actionIcon}
              />
              <Text style={styles.actionText}>Chấm Công Tất Cả</Text>
            </>
          )}
        </TouchableOpacity>
      </View>

      {/* Employee list */}
      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
            Đang tải dữ liệu...
          </Text>
        </View>
      ) : (
        <FlatList
          data={employees}
          keyExtractor={(item) => item.uid}
          renderItem={renderItem}
          ListHeaderComponent={
            <>
              <View style={styles.listHeaderContainer}>
                <Text style={[styles.listHeaderLabel, { flex: 1 }]}>
                  Tên nhân viên
                </Text>
                <Text
                  style={[
                    styles.listHeaderLabel,
                    {
                      width: 80,
                      textAlign: 'center',
                      transform: [{ translateX: 3 }],
                    },
                  ]}
                >
                  Chấm công
                </Text>
                <Text
                  style={[
                    styles.listHeaderLabel,
                    {
                      width: 80,
                      textAlign: 'center',
                      transform: [{ translateX: 6 }],
                    },
                  ]}
                >
                  Tăng ca
                </Text>
              </View>
              <View
                style={[styles.divider, { backgroundColor: theme.border }]}
              />
            </>
          }
          contentContainerStyle={styles.listContent}
          ListEmptyComponent={
            <View style={styles.emptyContainer}>
              <Ionicons name="people" size={40} color={theme.textMuted} />
              <Text style={[styles.emptyText, { color: theme.textMuted }]}>
                Chưa có nhân viên nào
              </Text>
            </View>
          }
        />
      )}

      {/* Add employee button */}
      <TouchableOpacity
        style={[styles.fab, { backgroundColor: theme.primary }]}
        onPress={() => setShowAddModal(true)}
      >
        <Ionicons name="person-add" size={24} color="#fff" />
      </TouchableOpacity>

      {/* Date picker */}
      {showDatePicker && (
        <DateTimePicker
          value={selectedDate}
          mode="date"
          display={Platform.OS === 'ios' ? 'spinner' : 'default'}
          onChange={handleDateChange}
        />
      )}

      {/* Add employee modal */}
      <Modal visible={showAddModal} transparent animationType="slide">
        <View style={styles.modalBackdrop}>
          <View style={[styles.modalContent, { backgroundColor: theme.card }]}>
            <Text style={[styles.modalTitle, { color: theme.text }]}>
              Thêm nhân viên
            </Text>
            <TextInput
              placeholder="Tên"
              value={newName}
              onChangeText={setNewName}
              style={[
                styles.input,
                { borderColor: theme.border, color: theme.text },
              ]}
              placeholderTextColor={theme.textMuted}
            />
            <TextInput
              placeholder="Email (tuỳ chọn)"
              value={newEmail}
              onChangeText={setNewEmail}
              style={[
                styles.input,
                { borderColor: theme.border, color: theme.text },
              ]}
              placeholderTextColor={theme.textMuted}
            />
            <View style={styles.modalActions}>
              <TouchableOpacity
                onPress={() => setShowAddModal(false)}
                style={[styles.modalButton, styles.cancelButton]}
              >
                <Text style={{ color: theme.text }}>Huỷ</Text>
              </TouchableOpacity>
              <TouchableOpacity
                onPress={addEmployee}
                style={[
                  styles.modalButton,
                  styles.saveButton,
                  { backgroundColor: theme.primary },
                ]}
              >
                <Text style={styles.saveButtonText}>Lưu</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Overtime modal */}
      <Modal visible={showOvertimeModal} transparent animationType="slide">
        <View style={styles.modalBackdrop}>
          <View style={[styles.modalContent, { backgroundColor: theme.card }]}>
            <Text style={[styles.modalTitle, { color: theme.text }]}>
              Thêm giờ tăng ca
            </Text>
            <Text
              style={[
                styles.overtimeEmployeeName,
                { color: theme.textSecondary },
              ]}
            >
              {selectedEmployee?.displayName || ''}
            </Text>

            <TextInput
              placeholder="Số giờ tăng ca"
              value={overtimeHours}
              onChangeText={setOvertimeHours}
              keyboardType="decimal-pad"
              style={[
                styles.input,
                { borderColor: theme.border, color: theme.text },
              ]}
              placeholderTextColor={theme.textMuted}
            />

            <View style={styles.modalActions}>
              <TouchableOpacity
                onPress={() => setShowOvertimeModal(false)}
                style={[styles.modalButton, styles.cancelButton]}
              >
                <Text style={{ color: theme.text }}>Huỷ</Text>
              </TouchableOpacity>
              <TouchableOpacity
                onPress={handleAddOvertime}
                style={[
                  styles.modalButton,
                  styles.saveButton,
                  { backgroundColor: theme.primary },
                ]}
              >
                <Text style={styles.saveButtonText}>Lưu</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    elevation: 2,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  dateButton: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 6,
  },
  dateText: {
    marginHorizontal: 8,
    fontSize: 14,
  },
  actionBar: {
    flexDirection: 'row',
    padding: 12,
    justifyContent: 'space-around',
    gap: 10,
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    flex: 1,
    justifyContent: 'center',
  },
  actionIcon: {
    marginRight: 6,
  },
  actionText: {
    color: '#fff',
    fontWeight: '600',
  },
  divider: {
    height: 1,
    width: '100%',
    marginTop: 8,
  },
  listHeaderContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingTop: 8,
    alignItems: 'center',
  },
  listHeaderLabel: {
    fontWeight: '600',
    fontSize: 14,
  },
  listContent: {
    padding: 12,
  },
  row: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 12,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  employeeInfo: {
    flex: 1,
    marginRight: 4,
  },
  nameText: {
    fontSize: 16,
    fontWeight: '500',
  },
  roleText: {
    fontSize: 12,
    marginTop: 2,
    flexBasis: '100%',
  },
  attendanceActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  overtimeActionContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    width: 80,
    justifyContent: 'center',
  },
  overtimeBadge: {
    backgroundColor: '#FFD700',
    borderRadius: 12,
    paddingHorizontal: 8,
    paddingVertical: 4,
    marginLeft: 4,
    flexDirection: 'row',
    alignItems: 'center',
  },
  overtimeText: {
    color: '#8B7500',
    fontSize: 12,
    fontWeight: 'bold',
  },
  checkButton: {
    width: 80,
    alignItems: 'center',
  },
  checkButtonOvertime: {
    paddingHorizontal: 8,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 12,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 40,
  },
  emptyText: {
    marginTop: 12,
    fontSize: 16,
  },
  fab: {
    position: 'absolute',
    bottom: 20,
    right: 20,
    width: 56,
    height: 56,
    borderRadius: 28,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  modalBackdrop: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    width: '85%',
    borderRadius: 12,
    padding: 20,
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  overtimeEmployeeName: {
    marginBottom: 12,
    fontSize: 16,
  },
  input: {
    borderWidth: 1,
    borderRadius: 8,
    padding: 12,
    marginBottom: 16,
    fontSize: 16,
  },
  modalActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    marginTop: 8,
  },
  modalButton: {
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 8,
    marginLeft: 12,
  },
  cancelButton: {
    backgroundColor: 'transparent',
  },
  saveButton: {
    minWidth: 80,
    alignItems: 'center',
  },
  saveButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
});

export default AttendanceScreen;

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  Image,
  Alert,
  TextInput,
  ActivityIndicator,
  ScrollView,
  ProgressBarAndroid,
  Platform,
  ProgressViewIOS,
  Linking,
} from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import * as ImagePicker from 'expo-image-picker';
import * as FileSystem from 'expo-file-system';
import usePOReceipt from '../hooks/usePOReceipt';
import uuid from 'react-native-uuid';

const ConfirmPOReceiptScreen = () => {
  const route = useRoute();
  const navigation = useNavigation();
  const { po } = route.params || {};

  const { confirmReceipt, loading, uploadProgress } = usePOReceipt();

  const [files, setFiles] = useState([]);
  const [remarks, setRemarks] = useState('');
  const [saving, setSaving] = useState(false);

  if (!po) {
    return (
      <View style={styles.centered}>
        <Text>Không tìm thấy thông tin PO.</Text>
      </View>
    );
  }

  // Hàm đơn giản để thêm file vào state
  const addFileToState = (asset) => {
    if (!asset || !asset.uri) {
      Alert.alert('Lỗi', 'Tập tin không hợp lệ.');
      return;
    }

    const tempId = uuid.v4();
    const fileInfo = {
      id: tempId, // ID tạm thời
      uri: asset.uri,
      name: asset.fileName || `image_${tempId}.jpg`,
      mimeType: asset.mimeType || 'image/jpeg',
    };

    setFiles((prev) => [...prev, fileInfo]);
  };

  const pickFile = async () => {
    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
    if (status !== 'granted') {
      Alert.alert('Lỗi', 'Cần quyền truy cập thư viện ảnh.');
      return;
    }

    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      quality: 0.7,
      allowsMultipleSelection: true,
    });

    if (!result.canceled && result.assets) {
      result.assets.forEach(addFileToState);
    }
  };

  // Capture photo directly using camera
  const takePhoto = async () => {
    const { status } = await ImagePicker.requestCameraPermissionsAsync();
    if (status !== 'granted') {
      Alert.alert('Lỗi', 'Cần quyền truy cập camera.');
      return;
    }

    const result = await ImagePicker.launchCameraAsync({ quality: 0.7 });

    if (!result.canceled) {
      addFileToState(result.assets[0]);
    }
  };

  const removeFile = (file) => {
    Alert.alert('Xác nhận', 'Xóa ảnh này?', [
      { text: 'Hủy', style: 'cancel' },
      {
        text: 'Xóa',
        style: 'destructive',
        onPress: () => {
          setFiles((prev) => prev.filter((f) => f.uri !== file.uri));
        },
      },
    ]);
  };

  const viewFile = (file) => {
    if (file.url) {
      Linking.openURL(file.url).catch(() =>
        Alert.alert('Lỗi', 'Không thể mở tệp.')
      );
    }
  };

  const handleConfirm = async () => {
    if (files.length === 0) {
      Alert.alert('Thiếu ảnh', 'Vui lòng chọn ít nhất một ảnh để xác nhận.');
      return;
    }

    setSaving(true);
    try {
      console.log('[ConfirmPOScreen] Starting confirmation process');
      console.log('[ConfirmPOScreen] Files count:', files.length);
      // Chuẩn bị mảng file để upload
      const filesToUpload = await Promise.all(
        files.map(async (file, index) => {
          console.log(
            `[ConfirmPOScreen] Processing file ${index + 1}/${files.length}: ${
              file.name
            }`
          );
          // Đọc base64 cho mỗi file
          const base64Data = await FileSystem.readAsStringAsync(file.uri, {
            encoding: FileSystem.EncodingType.Base64,
          });
          console.log(
            `[ConfirmPOScreen] File ${index + 1} base64 data length: ${
              base64Data.length
            }`
          );
          return {
            base64Data,
            fileName: file.name,
            mimeType: file.mimeType || 'image/jpeg',
          };
        })
      );

      console.log(
        '[ConfirmPOScreen] All files prepared, calling confirmReceipt'
      );
      console.log('[ConfirmPOScreen] PO ID:', po.id);
      console.log('[ConfirmPOScreen] Project ID:', po.projectId);

      const result = await confirmReceipt({
        poId: po.id,
        projectId: po.projectId,
        files: filesToUpload,
        remarks,
      });

      console.log('[ConfirmPOScreen] Confirmation successful');

      // Show success message with inventory update info
      Alert.alert(
        'Thành công',
        'Đã xác nhận nhận hàng thành công. Vật tư đã được tự động thêm vào kho.',
        [
          {
            text: 'OK',
            onPress: () => navigation.goBack(),
          },
        ]
      );
    } catch (e) {
      console.error('[ConfirmPOScreen] Confirmation error:', e);
      // Lỗi đã được xử lý và hiển thị bởi hook, không cần làm gì thêm ở đây.
      console.log(
        'Handle confirm caught an error, but it should have been handled by the hook.'
      );
    } finally {
      setSaving(false);
    }
  };

  const renderMaterial = ({ item, index }) => (
    <View style={styles.materialRow}>
      <Text style={{ flex: 1 }}>
        {index + 1}. {item.name}
      </Text>
      <Text style={{ width: 80, textAlign: 'right' }}>
        {item.quantity} {item.unit}
      </Text>
    </View>
  );

  return (
    <ScrollView style={styles.container}>
      <Text style={styles.title}>PO: {po.poNumber || po.id}</Text>
      <Text style={styles.label}>Nhà cung cấp: {po.supplierName}</Text>
      <Text style={styles.label}>
        Ngày tạo:{' '}
        {po.createdAt?.seconds
          ? new Date(po.createdAt.seconds * 1000).toLocaleDateString('vi-VN')
          : ''}
      </Text>

      <Text style={[styles.sectionTitle, { marginTop: 12 }]}>Vật tư</Text>
      <FlatList
        data={po.materials || []}
        keyExtractor={(_, idx) => idx.toString()}
        renderItem={renderMaterial}
        scrollEnabled={false}
      />

      {/* Thêm thông báo về tự động cập nhật kho */}
      <View style={styles.autoUpdateNote}>
        <Ionicons name="information-circle-outline" size={20} color="#0066cc" />
        <Text style={styles.autoUpdateText}>
          Vật tư sẽ được tự động thêm vào kho khi xác nhận nhận hàng
        </Text>
      </View>

      <Text style={[styles.sectionTitle, { marginTop: 12 }]}>Ảnh xác nhận</Text>

      {loading && uploadProgress > 0 && (
        <View style={styles.progressContainer}>
          {Platform.OS === 'android' ? (
            <ProgressBarAndroid
              styleAttr="Horizontal"
              indeterminate={false}
              progress={uploadProgress / 100}
              style={styles.progressBar}
            />
          ) : (
            <ProgressViewIOS
              progress={uploadProgress / 100}
              style={styles.progressBar}
            />
          )}
          <Text style={styles.progressText}>
            Đang tải lên... {Math.round(uploadProgress)}%
          </Text>
        </View>
      )}

      <View style={styles.imagesContainer}>
        {files.map((file, idx) => (
          <View key={idx} style={styles.fileContainer}>
            <TouchableOpacity
              style={styles.fileThumb}
              onPress={() => viewFile(file)}
            >
              <Image source={{ uri: file.uri }} style={styles.imageThumb} />
              {file.isUploading && (
                <View style={styles.uploadingOverlay}>
                  <ActivityIndicator color="#fff" size="small" />
                </View>
              )}
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.removeBtn}
              onPress={() => removeFile(file)}
            >
              <Ionicons name="close-circle" size={20} color="#ff4444" />
            </TouchableOpacity>
          </View>
        ))}
        <TouchableOpacity style={styles.addImage} onPress={pickFile}>
          <Ionicons name="add" size={28} color="#777" />
        </TouchableOpacity>

        <TouchableOpacity style={styles.addImage} onPress={takePhoto}>
          <Ionicons name="camera" size={26} color="#777" />
        </TouchableOpacity>
      </View>

      <Text style={[styles.sectionTitle, { marginTop: 12 }]}>Ghi chú</Text>
      <TextInput
        style={styles.remarksInput}
        placeholder="Ghi chú thêm..."
        value={remarks}
        onChangeText={setRemarks}
        multiline
      />

      <TouchableOpacity
        style={[styles.confirmBtn, (loading || saving) && { opacity: 0.7 }]}
        onPress={handleConfirm}
        disabled={loading || saving}
      >
        {loading || saving ? (
          <ActivityIndicator color="#fff" />
        ) : (
          <Ionicons name="checkmark-circle-outline" size={20} color="#fff" />
        )}
        <Text style={styles.confirmText}>Xác nhận và cập nhật kho</Text>
      </TouchableOpacity>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, padding: 16, backgroundColor: '#fff' },
  centered: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  title: { fontSize: 18, fontWeight: 'bold' },
  label: { fontSize: 14, marginTop: 4 },
  sectionTitle: { fontSize: 16, fontWeight: '600' },
  materialRow: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    paddingVertical: 6,
  },
  autoUpdateNote: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#e3f2fd',
    padding: 10,
    borderRadius: 6,
    marginTop: 10,
  },
  autoUpdateText: {
    color: '#0066cc',
    fontSize: 14,
    marginLeft: 8,
  },
  imagesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginTop: 8,
  },
  fileContainer: {
    position: 'relative',
    marginRight: 8,
    marginBottom: 8,
  },
  fileThumb: {
    width: 80,
    height: 80,
    borderRadius: 4,
    overflow: 'hidden',
  },
  imageThumb: {
    width: 80,
    height: 80,
    borderRadius: 4,
  },
  uploadingOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0,0,0,0.4)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  removeBtn: {
    position: 'absolute',
    top: -8,
    right: -8,
    backgroundColor: '#fff',
    borderRadius: 10,
    elevation: 2,
    shadowColor: '#000',
    shadowOpacity: 0.2,
    shadowOffset: { width: 0, height: 1 },
    shadowRadius: 2,
  },
  addImage: {
    width: 80,
    height: 80,
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 4,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 8,
    marginRight: 8,
  },
  remarksInput: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 4,
    padding: 8,
    minHeight: 80,
    textAlignVertical: 'top',
    marginTop: 4,
  },
  progressContainer: {
    marginVertical: 10,
  },
  progressBar: {
    height: 6,
    marginBottom: 4,
  },
  progressText: {
    fontSize: 12,
    color: '#666',
    textAlign: 'center',
  },
  confirmBtn: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#28a745',
    paddingVertical: 12,
    borderRadius: 6,
    marginTop: 20,
  },
  confirmText: {
    color: '#fff',
    fontSize: 16,
    marginLeft: 8,
    fontWeight: '600',
  },
});

export default ConfirmPOReceiptScreen;

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  TextInput,
  Alert,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRoute, useNavigation } from '@react-navigation/native';
import SupplierPickerModal from '../components/SupplierPickerModal';
import usePurchaseOrderGenerator from '../hooks/usePurchaseOrderGenerator';

/**
 * CreatePOScreen
 * This is a simplified screen that pre-populates the material list coming
 * from route.params (passed from ProposalListScreen → navigate('CreatePO', params)).
 * For now we only allow editing quantity / price; supplier info can be added later.
 */
const CreatePOScreen = () => {
  const route = useRoute();
  const navigation = useNavigation();

  // Supplier state & modal visibility
  const [showSupplierModal, setShowSupplierModal] = useState(false);
  const [supplier, setSupplier] = useState(null);

  // New state for PO info
  const [poNumber, setPoNumber] = useState('');
  const [proposalNumber, setProposalNumber] = useState('');
  const [deliveryTime, setDeliveryTime] = useState('');

  // VAT percentage
  const [vatPercentage, setVatPercentage] = useState(10);

  // Purchase order generator hook
  const { generatePurchaseOrder, loading } = usePurchaseOrderGenerator();

  const {
    projectName = '',
    projectId = '',
    materials: initMaterials = [],
  } = route.params || {};

  const [materials, setMaterials] = useState(
    initMaterials.length > 0
      ? initMaterials.map((m) => ({
          ...m,
          quantity: m.quantity?.toString() || '',
          unitPrice: m.unitPrice?.toString() || '',
        }))
      : [
          {
            name: '',
            specs: '',
            unit: '',
            quantity: '',
            unitPrice: '',
          },
        ]
  );

  const handleMaterialChange = (index, field, value) => {
    const updated = [...materials];
    updated[index] = { ...updated[index], [field]: value };
    setMaterials(updated);
  };

  const handleAddMaterial = () => {
    setMaterials([
      ...materials,
      { name: '', specs: '', unit: '', quantity: '', unitPrice: '' },
    ]);
  };

  const handleRemoveMaterial = (index) => {
    if (materials.length === 1) return;
    const updated = [...materials];
    updated.splice(index, 1);
    setMaterials(updated);
  };

  const subtotal = materials.reduce((sum, item) => {
    const qty = parseFloat(item.quantity) || 0;
    const price = parseFloat(item.unitPrice) || 0;
    return sum + qty * price;
  }, 0);

  const vatAmount = (subtotal * vatPercentage) / 100;
  const grandTotal = subtotal + vatAmount;

  const handleGeneratePO = async () => {
    if (!supplier) {
      Alert.alert('Thiếu thông tin', 'Vui lòng chọn Nhà cung cấp');
      return;
    }

    console.log('Starting PO generation for project ID:', projectId);

    const poData = {
      projectName,
      supplierName: supplier.name,
      supplierAddress: supplier.address || '',
      supplierPhone: supplier.phone || '',
      supplierEmail: supplier.email || '',
      supplierTaxCode: supplier.taxCode || '',
      materials,
      vatPercentage,
      // Add new fields
      poNumber,
      proposalNumber,
      deliveryTime,
    };

    try {
      console.log(
        'Calling generatePurchaseOrder with data:',
        JSON.stringify({
          projectId,
          supplierName: supplier.name,
          materialsCount: materials.length,
        })
      );

      const result = await generatePurchaseOrder(poData, projectId);
      console.log('PO generation successful, result:', result);
      Alert.alert('Thành công', 'Đã tạo đơn đặt hàng');
      navigation.goBack();
    } catch (err) {
      console.error('Error in handleGeneratePO:', err);
      // error is already handled in the hook
    }
  };

  return (
    <ScrollView style={styles.container}>
      <SupplierPickerModal
        visible={showSupplierModal}
        onClose={() => setShowSupplierModal(false)}
        onSelect={(sup) => {
          setSupplier(sup);
        }}
      />
      <Text style={styles.title}>Tạo PO cho dự án: {projectName}</Text>

      {/* Supplier selection */}
      <View style={styles.supplierGroup}>
        <Text style={styles.label}>Nhà cung cấp</Text>
        <TouchableOpacity
          style={styles.selectButton}
          onPress={() => setShowSupplierModal(true)}
        >
          <Text style={styles.selectText}>
            {supplier ? supplier.name : 'Chọn nhà cung cấp'}
          </Text>
        </TouchableOpacity>
        {supplier && (
          <View style={{ marginTop: 4 }}>
            {supplier.address ? (
              <Text style={styles.supplierInfo}>{supplier.address}</Text>
            ) : null}
            {supplier.phone ? (
              <Text style={styles.supplierInfo}>ĐT: {supplier.phone}</Text>
            ) : null}
          </View>
        )}
      </View>

      {/* PO Info Inputs */}
      <View style={styles.inputGroup}>
        <Text style={styles.label}>Số đơn đặt hàng</Text>
        <TextInput
          style={styles.inputField}
          placeholder="Nhập số ĐĐH (ví dụ: PO-001)"
          value={poNumber}
          onChangeText={setPoNumber}
        />
      </View>
      <View style={styles.inputGroup}>
        <Text style={styles.label}>Số đề xuất</Text>
        <TextInput
          style={styles.inputField}
          placeholder="Nhập số đề xuất được duyệt"
          value={proposalNumber}
          onChangeText={setProposalNumber}
        />
      </View>
      <View style={styles.inputGroup}>
        <Text style={styles.label}>Thời gian giao hàng</Text>
        <TextInput
          style={styles.inputField}
          placeholder="Nhập thời gian giao hàng (ví dụ: 3-5 ngày)"
          value={deliveryTime}
          onChangeText={setDeliveryTime}
        />
      </View>

      {/* Materials list */}
      <View style={styles.sectionHeader}>
        <Text style={styles.sectionHeaderText}>Danh sách vật tư</Text>
        <TouchableOpacity onPress={handleAddMaterial} style={styles.addBtn}>
          <Ionicons name="add-circle" size={22} color="#4CAF50" />
        </TouchableOpacity>
      </View>

      {materials.map((mat, idx) => {
        const total = (
          (parseFloat(mat.quantity) || 0) * (parseFloat(mat.unitPrice) || 0)
        ).toLocaleString('vi-VN');
        return (
          <View key={idx} style={styles.row}>
            <TextInput
              style={[styles.input, { flex: 3 }]}
              placeholder="Tên vật tư"
              value={mat.name}
              onChangeText={(t) => handleMaterialChange(idx, 'name', t)}
            />
            <TextInput
              style={[styles.input, { flex: 1 }]}
              placeholder="SL"
              keyboardType="numeric"
              value={mat.quantity}
              onChangeText={(t) => handleMaterialChange(idx, 'quantity', t)}
            />
            <TextInput
              style={[styles.input, { flex: 2 }]}
              placeholder="Đơn giá"
              keyboardType="numeric"
              value={mat.unitPrice}
              onChangeText={(t) => handleMaterialChange(idx, 'unitPrice', t)}
            />
            <Text style={[styles.total, { flex: 2 }]}>{total}</Text>
            <TouchableOpacity onPress={() => handleRemoveMaterial(idx)}>
              <Ionicons name="trash-outline" size={18} color="red" />
            </TouchableOpacity>
          </View>
        );
      })}

      {/* Summary */}
      <View style={{ marginTop: 12 }}>
        <Text style={styles.summary}>
          Tạm tính: {subtotal.toLocaleString('vi-VN')} VND
        </Text>
        <View
          style={{ flexDirection: 'row', alignItems: 'center', marginTop: 6 }}
        >
          <Text style={styles.summary}>VAT (%) :</Text>
          <TextInput
            style={[styles.input, { width: 60, marginLeft: 6 }]}
            keyboardType="numeric"
            value={vatPercentage.toString()}
            onChangeText={(v) => setVatPercentage(parseFloat(v) || 0)}
          />
          <Text style={[styles.summary, { marginLeft: 6 }]}>
            {' '}
            = {vatAmount.toLocaleString('vi-VN')} VND
          </Text>
        </View>
        <Text style={styles.summary}>
          Tổng cộng: {grandTotal.toLocaleString('vi-VN')} VND
        </Text>
      </View>

      <TouchableOpacity
        style={styles.button}
        onPress={handleGeneratePO}
        disabled={loading}
      >
        <Ionicons name="document-text-outline" size={20} color="#fff" />
        <Text style={styles.buttonText}>Tạo đơn đặt hàng</Text>
      </TouchableOpacity>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, padding: 16, backgroundColor: '#fff' },
  title: { fontSize: 18, fontWeight: 'bold', marginBottom: 12 },
  sectionHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
    marginTop: 16,
  },
  sectionHeaderText: { fontSize: 16, fontWeight: '600', flex: 1 },
  addBtn: { padding: 4 },
  row: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
    paddingVertical: 2,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 6,
    borderRadius: 4,
    marginHorizontal: 2,
  },
  total: {
    textAlign: 'right',
    paddingHorizontal: 4,
    fontWeight: '500',
  },
  summary: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
  },
  button: {
    marginTop: 20,
    backgroundColor: '#4CAF50',
    padding: 14,
    borderRadius: 8,
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'center',
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    marginBottom: 4,
    color: '#444',
  },
  supplierGroup: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 12,
    borderRadius: 8,
    marginBottom: 12,
  },
  selectButton: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 12,
    borderRadius: 4,
  },
  selectText: { fontSize: 16 },
  supplierInfo: { fontSize: 13, color: '#666' },
  inputGroup: {
    marginBottom: 12,
  },
  inputField: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 12,
    borderRadius: 4,
    fontSize: 16,
  },
});

export default CreatePOScreen;

// src/screens/CreateProposalScreen.js
import React, { useState } from 'react';
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
  Alert,
  StyleSheet,
  TextInput,
  ScrollView,
  Platform,
} from 'react-native';
import { createProposal, canCreateProposal } from '../api/proposalService';
import { useAuth } from '../contexts/AuthContext';
import DateTimePicker from '@react-native-community/datetimepicker';
import { Ionicons } from '@expo/vector-icons';

const CreateProposalScreen = ({ route, navigation }) => {
  const { projectId, projectName, selectedItems } = route.params;
  const { currentUser } = useAuth();
  const [saving, setSaving] = useState(false);

  // Các trường mới
  const [proposalNumber, setProposalNumber] = useState('');
  const [requiredDate, setRequiredDate] = useState(new Date());
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [priority, setPriority] = useState('normal'); // 'normal' hoặc 'urgent'
  const [purpose, setPurpose] = useState('');

  // Kiểm tra quyền tạo đề xuất
  if (!canCreateProposal(currentUser?.role)) {
    Alert.alert('Không có quyền', 'Bạn không có quyền tạo đề xuất mua vật tư');
    navigation.goBack();
  }

  const handleDateChange = (event, selectedDate) => {
    setShowDatePicker(Platform.OS === 'ios');
    if (selectedDate) {
      setRequiredDate(selectedDate);
    }
  };

  const handleSubmit = async () => {
    // Validate
    if (!proposalNumber.trim()) {
      return Alert.alert('Thiếu thông tin', 'Vui lòng nhập số đề xuất');
    }

    if (!purpose.trim()) {
      return Alert.alert('Thiếu thông tin', 'Vui lòng nhập mục đích sử dụng');
    }

    const proposalCode = `THP/KT/25/${proposalNumber}`;

    setSaving(true);
    try {
      await createProposal({
        projectId,
        projectName,
        items: selectedItems,
        createdBy: currentUser.uid,
        createdByName: currentUser.displayName || currentUser.email,
        proposalCode,
        requiredDate,
        priority,
        purpose,
      });
      Alert.alert('Thành công', 'Đã gửi đề xuất.');
      navigation.goBack();
    } catch (err) {
      Alert.alert('Lỗi', err.message);
    } finally {
      setSaving(false);
    }
  };

  const renderItem = ({ item }) => (
    <View style={styles.row}>
      <Text style={styles.name}>{item.name}</Text>
      <Text style={styles.qty}>{item.quantity}</Text>
      <Text style={styles.unit}>{item.unit}</Text>
    </View>
  );

  return (
    <ScrollView style={styles.container}>
      <Text style={styles.title}>Đề xuất mua vật tư - {projectName}</Text>

      {/* Form thông tin đề xuất */}
      <View style={styles.formSection}>
        <Text style={styles.sectionTitle}>Thông tin đề xuất</Text>

        <View style={styles.formGroup}>
          <Text style={styles.label}>Mã đề xuất</Text>
          <View style={styles.codeInputContainer}>
            <Text style={styles.codePrefix}>THP/KT/25/</Text>
            <TextInput
              style={styles.codeInput}
              value={proposalNumber}
              onChangeText={setProposalNumber}
              placeholder="Nhập số"
              keyboardType="numeric"
            />
          </View>
        </View>

        <View style={styles.formGroup}>
          <Text style={styles.label}>Ngày cần cung cấp</Text>
          <TouchableOpacity
            style={styles.dateButton}
            onPress={() => setShowDatePicker(true)}
          >
            <Text style={styles.dateText}>
              {requiredDate.toLocaleDateString('vi-VN')}
            </Text>
            <Ionicons name="calendar-outline" size={20} color="#666" />
          </TouchableOpacity>
          {showDatePicker && (
            <DateTimePicker
              value={requiredDate}
              mode="date"
              display={Platform.OS === 'ios' ? 'spinner' : 'default'}
              onChange={handleDateChange}
              minimumDate={new Date()}
            />
          )}
        </View>

        <View style={styles.formGroup}>
          <Text style={styles.label}>Mức độ ưu tiên</Text>
          <View style={styles.priorityContainer}>
            <TouchableOpacity
              style={[
                styles.priorityButton,
                priority === 'normal' && styles.priorityButtonActive,
              ]}
              onPress={() => setPriority('normal')}
            >
              <Text
                style={[
                  styles.priorityText,
                  priority === 'normal' && styles.priorityTextActive,
                ]}
              >
                Bình thường
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.priorityButton,
                priority === 'urgent' && styles.priorityButtonActive,
                priority === 'urgent' && { backgroundColor: '#ffebee' },
              ]}
              onPress={() => setPriority('urgent')}
            >
              <Text
                style={[
                  styles.priorityText,
                  priority === 'urgent' && styles.priorityTextActive,
                  priority === 'urgent' && { color: '#d32f2f' },
                ]}
              >
                Gấp
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.formGroup}>
          <Text style={styles.label}>Mục đích sử dụng</Text>
          <TextInput
            style={styles.purposeInput}
            value={purpose}
            onChangeText={setPurpose}
            placeholder="Nhập mục đích sử dụng vật tư"
            multiline
            numberOfLines={3}
          />
        </View>
      </View>

      {/* Danh sách vật tư */}
      <View style={styles.materialsSection}>
        <Text style={styles.sectionTitle}>
          Danh sách vật tư ({selectedItems.length})
        </Text>
        <View style={styles.tableHeader}>
          <Text style={[styles.headerText, { flex: 3 }]}>Tên vật tư</Text>
          <Text style={[styles.headerText, { flex: 1, textAlign: 'center' }]}>
            SL
          </Text>
          <Text style={[styles.headerText, { flex: 1, textAlign: 'center' }]}>
            ĐVT
          </Text>
        </View>
        <FlatList
          data={selectedItems}
          keyExtractor={(i, idx) => idx.toString()}
          renderItem={renderItem}
          nestedScrollEnabled
          style={{ maxHeight: 300 }}
        />
      </View>

      <TouchableOpacity
        style={styles.submitBtn}
        onPress={handleSubmit}
        disabled={saving}
      >
        <Text style={styles.btnText}>
          {saving ? 'Đang gửi...' : 'Gửi Duyệt'}
        </Text>
      </TouchableOpacity>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: '#f5f5f5',
  },
  title: {
    fontSize: 18,
    fontWeight: '700',
    marginBottom: 16,
  },
  formSection: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  materialsSection: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 12,
    color: '#333',
  },
  formGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    marginBottom: 8,
    color: '#555',
  },
  codeInputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 4,
    overflow: 'hidden',
  },
  codePrefix: {
    backgroundColor: '#f0f0f0',
    paddingHorizontal: 8,
    paddingVertical: 10,
    fontSize: 14,
  },
  codeInput: {
    flex: 1,
    paddingHorizontal: 8,
    paddingVertical: 8,
    fontSize: 14,
  },
  dateButton: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 4,
    padding: 10,
  },
  dateText: {
    fontSize: 14,
  },
  priorityContainer: {
    flexDirection: 'row',
    gap: 12,
  },
  priorityButton: {
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 4,
    borderWidth: 1,
    borderColor: '#ddd',
    backgroundColor: '#f9f9f9',
  },
  priorityButtonActive: {
    borderColor: '#0066cc',
    backgroundColor: '#e6f2ff',
  },
  priorityText: {
    color: '#666',
  },
  priorityTextActive: {
    color: '#0066cc',
    fontWeight: '500',
  },
  purposeInput: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 4,
    padding: 10,
    fontSize: 14,
    textAlignVertical: 'top',
    minHeight: 80,
  },
  tableHeader: {
    flexDirection: 'row',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    marginBottom: 4,
  },
  headerText: {
    fontWeight: '600',
    fontSize: 14,
    color: '#555',
  },
  row: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderColor: '#eee',
  },
  name: { flex: 3 },
  qty: { flex: 1, textAlign: 'center' },
  unit: { flex: 1, textAlign: 'center' },
  submitBtn: {
    backgroundColor: '#0066cc',
    padding: 14,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 8,
    marginBottom: 20,
  },
  btnText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 16,
  },
});

export default CreateProposalScreen;

//src/screens/CustomerDetailScreen.js
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  Share,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { getCustomerById, deleteCustomer } from '../api/customerService';
import { useFocusEffect } from '@react-navigation/native';

const CustomerDetailScreen = ({ route, navigation }) => {
  const { customerId } = route.params;
  const [customer, setCustomer] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isDeleting, setIsDeleting] = useState(false);

  // Hàm lấy dữ liệu khách hàng
  const fetchCustomerData = async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await getCustomerById(customerId);

      if (data) {
        setCustomer(data);
      } else {
        setError('Không tìm thấy thông tin khách hàng');
      }
    } catch (err) {
      console.error('Lỗi khi tải thông tin khách hàng:', err);
      setError('Không thể tải thông tin khách hàng. Vui lòng thử lại sau.');
    } finally {
      setLoading(false);
    }
  };

  // Lấy dữ liệu khách hàng khi màn hình được tải
  useEffect(() => {
    fetchCustomerData();
  }, [customerId]);

  // Làm mới dữ liệu khi màn hình được focus (quay lại sau khi chỉnh sửa)
  useFocusEffect(
    useCallback(() => {
      fetchCustomerData();
    }, [customerId])
  );

  // Lấy nhãn hiển thị cho loại khách hàng
  const getTypeLabel = (type) => {
    switch (type) {
      case 'vip':
        return 'VIP';
      case 'potential':
        return 'Tiềm năng';
      case 'regular':
        return 'Thường xuyên';
      default:
        return type || 'Chưa phân loại';
    }
  };

  // Lấy màu cho loại khách hàng
  const getTypeColor = (type) => {
    switch (type) {
      case 'vip':
        return '#4CAF50'; // xanh lá
      case 'potential':
        return '#FF9800'; // cam
      default:
        return '#9E9E9E'; // xám
    }
  };

  // Xử lý chia sẻ thông tin khách hàng
  const handleShare = async () => {
    if (!customer) return;

    try {
      const message = `
Thông tin khách hàng:
Tên: ${customer.name || 'Không có'}
Người liên hệ: ${customer.contactPerson || 'Không có'}
Điện thoại: ${customer.phone || 'Không có'}
Email: ${customer.email || 'Không có'}
Địa chỉ: ${customer.address || 'Không có'}
Loại khách hàng: ${getTypeLabel(customer.type)}
      `;

      await Share.share({
        message,
        title: `Thông tin khách hàng: ${customer.name}`,
      });
    } catch (error) {
      Alert.alert('Lỗi', 'Không thể chia sẻ thông tin khách hàng');
    }
  };

  // Xử lý chỉnh sửa khách hàng
  const handleEdit = () => {
    navigation.navigate('EditCustomer', { customer });
  };

  // Xử lý xóa khách hàng
  const handleDelete = () => {
    Alert.alert(
      'Xác nhận xóa',
      'Bạn có chắc chắn muốn xóa khách hàng này không?',
      [
        { text: 'Hủy', style: 'cancel' },
        {
          text: 'Xóa',
          style: 'destructive',
          onPress: async () => {
            try {
              setIsDeleting(true);
              await deleteCustomer(customer.id);
              Alert.alert('Thành công', 'Đã xóa khách hàng thành công', [
                {
                  text: 'OK',
                  onPress: () => navigation.goBack(),
                },
              ]);
            } catch (error) {
              if (error.code === 'permission-denied') {
                Alert.alert(
                  'Lỗi quyền',
                  'Bạn không có đủ quyền để thực hiện hành động này.'
                );
              } else {
                console.error('Lỗi khi xóa khách hàng:', error);
                Alert.alert(
                  'Lỗi',
                  'Không thể xóa khách hàng. Vui lòng thử lại sau.'
                );
              }
              setIsDeleting(false);
            }
          },
        },
      ]
    );
  };

  // Hiển thị khi đang tải dữ liệu
  if (loading) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color="#0066cc" />
        <Text style={styles.loadingText}>Đang tải thông tin khách hàng...</Text>
      </View>
    );
  }

  // Hiển thị khi có lỗi
  if (error) {
    return (
      <View style={styles.centerContainer}>
        <Ionicons name="alert-circle-outline" size={50} color="#FF3B30" />
        <Text style={styles.errorText}>{error}</Text>
        <TouchableOpacity
          style={styles.retryButton}
          onPress={() => navigation.goBack()}
        >
          <Text style={styles.retryButtonText}>Quay lại</Text>
        </TouchableOpacity>
      </View>
    );
  }

  // Hiển thị khi không tìm thấy khách hàng
  if (!customer) {
    return (
      <View style={styles.centerContainer}>
        <Ionicons name="person-outline" size={50} color="#999" />
        <Text style={styles.errorText}>
          Không tìm thấy thông tin khách hàng
        </Text>
        <TouchableOpacity
          style={styles.retryButton}
          onPress={() => navigation.goBack()}
        >
          <Text style={styles.retryButtonText}>Quay lại</Text>
        </TouchableOpacity>
      </View>
    );
  }

  // Định dạng ngày tháng
  const formatDate = (timestamp) => {
    if (!timestamp) return 'Không có';

    const date = new Date(timestamp.seconds * 1000);
    return date.toLocaleDateString('vi-VN', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Chi tiết khách hàng</Text>
        <TouchableOpacity style={styles.shareButton} onPress={handleShare}>
          <Ionicons name="share-outline" size={24} color="#333" />
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.contentContainer}>
        <View style={styles.customerHeader}>
          <View style={styles.customerNameContainer}>
            <Text style={styles.customerName}>
              {customer.name || 'Chưa có tên'}
            </Text>
            <View
              style={[
                styles.customerTypeTag,
                { borderColor: getTypeColor(customer.type) },
              ]}
            >
              <Text
                style={[
                  styles.customerTypeText,
                  { color: getTypeColor(customer.type) },
                ]}
              >
                {getTypeLabel(customer.type)}
              </Text>
            </View>
          </View>
        </View>

        <View style={styles.infoSection}>
          <View style={styles.infoItem}>
            <Text style={styles.infoLabel}>Người liên hệ</Text>
            <Text style={styles.infoValue}>
              {customer.contactPerson || 'Chưa có thông tin'}
            </Text>
          </View>

          <View style={styles.infoItem}>
            <Text style={styles.infoLabel}>Số điện thoại</Text>
            <View style={styles.infoValueWithIcon}>
              <Text style={styles.infoValue}>
                {customer.phone || 'Chưa có thông tin'}
              </Text>
              {customer.phone && (
                <TouchableOpacity style={styles.actionIcon}>
                  <Ionicons name="call-outline" size={20} color="#0066cc" />
                </TouchableOpacity>
              )}
            </View>
          </View>

          <View style={styles.infoItem}>
            <Text style={styles.infoLabel}>Email</Text>
            <View style={styles.infoValueWithIcon}>
              <Text style={styles.infoValue}>
                {customer.email || 'Chưa có thông tin'}
              </Text>
              {customer.email && (
                <TouchableOpacity style={styles.actionIcon}>
                  <Ionicons name="mail-outline" size={20} color="#0066cc" />
                </TouchableOpacity>
              )}
            </View>
          </View>

          <View style={styles.infoItem}>
            <Text style={styles.infoLabel}>Địa chỉ</Text>
            <Text style={styles.infoValue}>
              {customer.address || 'Chưa có thông tin'}
            </Text>
          </View>

          <View style={styles.infoItem}>
            <Text style={styles.infoLabel}>Mã số thuế</Text>
            <Text style={styles.infoValue}>
              {customer.taxCode || 'Chưa có thông tin'}
            </Text>
          </View>
        </View>

        <View style={styles.metaSection}>
          <Text style={styles.metaSectionTitle}>Thông tin bổ sung</Text>

          <View style={styles.metaItem}>
            <Text style={styles.metaLabel}>Ngày tạo</Text>
            <Text style={styles.metaValue}>
              {formatDate(customer.createdAt)}
            </Text>
          </View>

          <View style={styles.metaItem}>
            <Text style={styles.metaLabel}>Cập nhật lần cuối</Text>
            <Text style={styles.metaValue}>
              {formatDate(customer.updatedAt)}
            </Text>
          </View>
        </View>
      </ScrollView>

      <View style={styles.footer}>
        <View style={styles.buttonContainer}>
          <TouchableOpacity
            style={styles.deleteButton}
            onPress={handleDelete}
            disabled={isDeleting}
          >
            {isDeleting ? (
              <ActivityIndicator color="#fff" size="small" />
            ) : (
              <>
                <Ionicons name="trash-outline" size={20} color="#fff" />
                <Text style={styles.deleteButtonText}>Xóa</Text>
              </>
            )}
          </TouchableOpacity>

          <TouchableOpacity style={styles.editButton} onPress={handleEdit}>
            <Ionicons name="create-outline" size={20} color="#fff" />
            <Text style={styles.editButtonText}>Chỉnh sửa</Text>
          </TouchableOpacity>
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
  },
  errorText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  retryButton: {
    marginTop: 16,
    backgroundColor: '#0066cc',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 6,
  },
  retryButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '500',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  shareButton: {
    padding: 4,
  },
  contentContainer: {
    flex: 1,
  },
  customerHeader: {
    backgroundColor: '#fff',
    padding: 16,
    marginBottom: 12,
  },
  customerNameContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  customerName: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#333',
    flex: 1,
  },
  customerTypeTag: {
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 10,
    paddingVertical: 3,
  },
  customerTypeText: {
    fontSize: 12,
    fontWeight: '500',
  },
  infoSection: {
    backgroundColor: '#fff',
    padding: 16,
    marginBottom: 12,
  },
  infoItem: {
    marginBottom: 16,
  },
  infoLabel: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
  },
  infoValue: {
    fontSize: 16,
    color: '#333',
  },
  infoValueWithIcon: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  actionIcon: {
    padding: 4,
  },
  metaSection: {
    backgroundColor: '#fff',
    padding: 16,
    marginBottom: 20,
  },
  metaSectionTitle: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    marginBottom: 12,
  },
  metaItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  metaLabel: {
    fontSize: 14,
    color: '#666',
  },
  metaValue: {
    fontSize: 14,
    color: '#333',
  },
  footer: {
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  editButton: {
    backgroundColor: '#0066cc',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    borderRadius: 8,
    flex: 3,
    marginLeft: 10,
  },
  editButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  deleteButton: {
    backgroundColor: '#e74c3c',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    borderRadius: 8,
    flex: 1,
  },
  deleteButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
});

export default CustomerDetailScreen;

//src/screens/CustomerManagementScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  FlatList,
  StyleSheet,
  ActivityIndicator,
  Pressable,
  TouchableOpacity,
  SafeAreaView,
  StatusBar,
  TextInput,
  LayoutAnimation,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { getCustomers } from '../api/customerService';
import { useTheme } from '../contexts/ThemeContext';

// Component hiển thị từng khách hàng trong danh sách
const CustomerListItem = ({ customer, onPress }) => {
  const { theme } = useTheme();
  // Xác định loại khách hàng để hiển thị màu sắc phù hợp
  const getTypeColor = (type) => {
    switch (type) {
      case 'vip':
        return '#4CAF50'; // xanh lá
      case 'potential':
        return '#FF9800'; // cam
      default:
        return theme.textMuted; // Sử dụng màu từ theme
    }
  };

  // Lấy nhãn hiển thị cho loại khách hàng
  const getTypeLabel = (type) => {
    switch (type) {
      case 'vip':
        return 'VIP';
      case 'potential':
        return 'Tiềm năng';
      case 'regular':
        return 'Thường xuyên';
      default:
        return type || 'Chưa phân loại';
    }
  };

  return (
    <Pressable
      style={({ pressed }) => [
        styles.customerCard,
        { backgroundColor: theme.card },
        pressed && styles.cardPressed,
      ]}
      onPress={() => onPress(customer)}
    >
      <View style={styles.customerInfo}>
        <Text style={[styles.customerName, { color: theme.text }]}>
          {customer.name || 'Chưa có tên'}
        </Text>

        <View style={styles.contactRow}>
          <Ionicons
            name="person-outline"
            size={14}
            color={theme.textSecondary}
          />
          <Text style={[styles.contactText, { color: theme.textSecondary }]}>
            {customer.contactPerson || 'Chưa có người liên hệ'}
          </Text>
        </View>

        {customer.email && (
          <View style={styles.contactRow}>
            <Ionicons
              name="mail-outline"
              size={14}
              color={theme.textSecondary}
            />
            <Text style={[styles.contactText, { color: theme.textSecondary }]}>
              {customer.email}
            </Text>
          </View>
        )}

        {customer.phone && (
          <View style={styles.contactRow}>
            <Ionicons
              name="call-outline"
              size={14}
              color={theme.textSecondary}
            />
            <Text style={[styles.contactText, { color: theme.textSecondary }]}>
              {customer.phone}
            </Text>
          </View>
        )}
      </View>

      <View style={styles.customerTypeContainer}>
        <View
          style={[
            styles.customerTypeTag,
            { borderColor: getTypeColor(customer.type) },
          ]}
        >
          <Text
            style={[
              styles.customerTypeText,
              { color: getTypeColor(customer.type) },
            ]}
          >
            {getTypeLabel(customer.type)}
          </Text>
        </View>
      </View>
    </Pressable>
  );
};

const CustomerManagementScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const [customers, setCustomers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [refreshing, setRefreshing] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [filteredCustomers, setFilteredCustomers] = useState([]);

  // Hàm tải danh sách khách hàng
  const loadCustomers = async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await getCustomers();

      // Thêm animation khi cập nhật danh sách
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);

      setCustomers(data);
      setFilteredCustomers(data); // Khởi tạo danh sách lọc ban đầu
    } catch (err) {
      console.error('Lỗi khi tải danh sách khách hàng:', err);
      setError('Không thể tải danh sách khách hàng. Vui lòng thử lại sau.');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  // Tải dữ liệu khi màn hình được mở
  useEffect(() => {
    loadCustomers();

    // Thêm listener để làm mới danh sách khi quay lại từ màn hình khác
    const unsubscribe = navigation.addListener('focus', () => {
      loadCustomers();
    });

    return unsubscribe;
  }, [navigation]);

  // Lọc danh sách khách hàng theo từ khóa tìm kiếm
  useEffect(() => {
    if (!searchQuery.trim()) {
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
      setFilteredCustomers(customers);
      return;
    }

    const query = searchQuery.toLowerCase().trim();
    const filtered = customers.filter((customer) => {
      const name = (customer.name || '').toLowerCase();
      const contactPerson = (customer.contactPerson || '').toLowerCase();
      const email = (customer.email || '').toLowerCase();
      const phone = (customer.phone || '').toLowerCase();

      return (
        name.includes(query) ||
        contactPerson.includes(query) ||
        email.includes(query) ||
        phone.includes(query)
      );
    });

    // Thêm animation khi cập nhật kết quả tìm kiếm
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);

    setFilteredCustomers(filtered);
  }, [searchQuery, customers]);

  // Xử lý khi người dùng kéo để làm mới
  const handleRefresh = () => {
    setRefreshing(true);
    loadCustomers();
  };

  // Xử lý khi người dùng nhấn vào một khách hàng
  const handleCustomerPress = (customer) => {
    navigation.navigate('CustomerDetail', { customerId: customer.id });
  };

  // Xử lý khi người dùng muốn thêm khách hàng mới
  const handleAddCustomer = () => {
    navigation.navigate('AddCustomer');
  };

  // Xử lý khi người dùng nhập từ khóa tìm kiếm
  const handleSearch = (text) => {
    setSearchQuery(text);
  };

  // Xử lý khi người dùng muốn xóa từ khóa tìm kiếm
  const handleClearSearch = () => {
    setSearchQuery('');
  };

  // Hiển thị khi đang tải dữ liệu
  if (loading && !refreshing) {
    return (
      <View
        style={[styles.centerContainer, { backgroundColor: theme.background }]}
      >
        <ActivityIndicator size="large" color={theme.primary} />
        <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
          Đang tải danh sách khách hàng...
        </Text>
      </View>
    );
  }

  // Hiển thị khi có lỗi
  if (error) {
    return (
      <View
        style={[styles.centerContainer, { backgroundColor: theme.background }]}
      >
        <Ionicons name="alert-circle-outline" size={50} color={theme.danger} />
        <Text style={[styles.errorText, { color: theme.text }]}>{error}</Text>
        <TouchableOpacity
          style={[styles.retryButton, { backgroundColor: theme.primary }]}
          onPress={loadCustomers}
        >
          <Text style={styles.retryButtonText}>Thử lại</Text>
        </TouchableOpacity>
      </View>
    );
  }

  // Hiển thị khi không có khách hàng
  if (customers.length === 0) {
    return (
      <SafeAreaView
        style={[styles.container, { backgroundColor: theme.background }]}
      >
        <View style={[styles.header, { borderBottomColor: theme.border }]}>
          <Text style={[styles.headerTitle, { color: theme.text }]}>
            Quản lý Khách hàng
          </Text>
          <TouchableOpacity
            style={[styles.addButton, { backgroundColor: theme.primary }]}
            onPress={handleAddCustomer}
          >
            <Ionicons name="add" size={24} color="#fff" />
          </TouchableOpacity>
        </View>

        <View
          style={[
            styles.centerContainer,
            { backgroundColor: theme.background },
          ]}
        >
          <Ionicons name="people-outline" size={60} color={theme.textMuted} />
          <Text style={[styles.emptyText, { color: theme.textSecondary }]}>
            Chưa có khách hàng nào
          </Text>
          <TouchableOpacity
            style={[
              styles.addCustomerButton,
              { backgroundColor: theme.primary },
            ]}
            onPress={handleAddCustomer}
          >
            <Text style={styles.addCustomerButtonText}>
              Thêm khách hàng mới
            </Text>
          </TouchableOpacity>
        </View>
      </SafeAreaView>
    );
  }

  // Hiển thị danh sách khách hàng
  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <StatusBar
        barStyle={theme.dark ? 'light-content' : 'dark-content'}
        backgroundColor={theme.background}
      />

      <View style={[styles.header, { borderBottomColor: theme.border }]}>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Quản lý Khách hàng
        </Text>
        <TouchableOpacity
          style={[styles.addButton, { backgroundColor: theme.primary }]}
          onPress={handleAddCustomer}
        >
          <Ionicons name="add" size={24} color="#fff" />
        </TouchableOpacity>
      </View>

      <View
        style={[
          styles.searchContainer,
          { backgroundColor: theme.card, borderColor: theme.border },
        ]}
      >
        <Ionicons
          name="search"
          size={20}
          color={theme.textMuted}
          style={styles.searchIcon}
        />
        <TextInput
          style={[styles.searchInput, { color: theme.text }]}
          placeholder="Tìm kiếm khách hàng..."
          placeholderTextColor={theme.textMuted}
          value={searchQuery}
          onChangeText={handleSearch}
        />
        {searchQuery.length > 0 && (
          <TouchableOpacity onPress={handleClearSearch}>
            <Ionicons name="close-circle" size={20} color={theme.textMuted} />
          </TouchableOpacity>
        )}
      </View>

      {filteredCustomers.length === 0 && searchQuery ? (
        <View style={styles.emptyResultContainer}>
          <Ionicons name="search-outline" size={50} color="#CCCCCC" />
          <Text style={styles.emptyResultText}>
            Không tìm thấy khách hàng phù hợp
          </Text>
          <TouchableOpacity
            onPress={handleClearSearch}
            style={styles.tryAgainButton}
          >
            <Text style={styles.tryAgainButtonText}>Xóa tìm kiếm</Text>
          </TouchableOpacity>
        </View>
      ) : (
        <FlatList
          data={filteredCustomers}
          keyExtractor={(item) => item.id}
          renderItem={({ item }) => (
            <CustomerListItem customer={item} onPress={handleCustomerPress} />
          )}
          contentContainerStyle={styles.listContainer}
          showsVerticalScrollIndicator={false}
          refreshing={refreshing}
          onRefresh={handleRefresh}
          initialNumToRender={10}
          maxToRenderPerBatch={10}
          windowSize={10}
          ListEmptyComponent={
            !searchQuery ? (
              <View style={styles.emptyContainer}>
                <Ionicons name="people-outline" size={60} color="#CCCCCC" />
                <Text style={styles.emptyText}>Chưa có khách hàng nào</Text>
                <TouchableOpacity
                  style={styles.addCustomerButton}
                  onPress={handleAddCustomer}
                >
                  <Text style={styles.addCustomerButtonText}>
                    Thêm khách hàng mới
                  </Text>
                </TouchableOpacity>
              </View>
            ) : null
          }
        />
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
    backgroundColor: '#fff',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: 'bold',
  },
  addButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginHorizontal: 16,
    marginTop: 16,
    marginBottom: 8,
    paddingHorizontal: 12,
    borderWidth: 1,
    borderRadius: 12,
    backgroundColor: '#fff',
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    height: 44,
    fontSize: 16,
  },
  listContainer: {
    paddingHorizontal: 16,
  },
  customerCard: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    padding: 16,
    marginVertical: 8,
    borderRadius: 12,
    backgroundColor: '#ffffff',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
  },
  cardPressed: {
    transform: [{ scale: 0.98 }],
    opacity: 0.9,
  },
  customerInfo: {
    flex: 1,
    marginRight: 10,
  },
  customerName: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  contactRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
  },
  contactText: {
    marginLeft: 6,
    fontSize: 14,
  },
  customerTypeContainer: {
    marginLeft: 12,
  },
  customerTypeTag: {
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  customerTypeText: {
    fontSize: 12,
    fontWeight: '500',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
    color: '#666',
  },
  errorText: {
    marginTop: 10,
    fontSize: 16,
    color: '#333',
    textAlign: 'center',
    marginBottom: 20,
  },
  retryButton: {
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
    minHeight: 300,
  },
  emptyText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  addCustomerButton: {
    marginTop: 16,
    backgroundColor: '#0066cc',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 6,
  },
  addCustomerButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '500',
  },
  emptyResultContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  emptyResultText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  tryAgainButton: {
    marginTop: 16,
    backgroundColor: '#f0f0f0',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 6,
  },
  tryAgainButtonText: {
    color: '#333',
    fontSize: 16,
    fontWeight: '500',
  },
});

export default CustomerManagementScreen;

import React, { useState, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Dimensions,
  RefreshControl,
  Alert,
} from 'react-native';
import { useFocusEffect } from '@react-navigation/native';
import { doc, getDoc } from 'firebase/firestore';
import { db } from '../config/firebaseConfig';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import { Ionicons } from '@expo/vector-icons';
import { BarChart } from 'react-native-chart-kit';
import { getFunctions, httpsCallable } from 'firebase/functions';

// ID thư mục Google Drive chứa file Excel công nợ
const DEBT_FOLDER_ID = '1Ci_BHZx0-Uhv2xg5IzwLPn05yPAUXOOU';

const screenWidth = Dimensions.get('window').width;

const DebtDashboard = ({ navigation }) => {
  const { theme } = useTheme();
  const { currentUser } = useAuth();
  const [dashboardData, setDashboardData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [error, setError] = useState(null);
  const [processingExcel, setProcessingExcel] = useState(false);

  // Hàm lấy dữ liệu tổng quan từ Firestore
  const fetchDashboardData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const dashboardRef = doc(db, 'summaries', 'directorDashboard');
      const dashboardSnap = await getDoc(dashboardRef);

      if (dashboardSnap.exists()) {
        const data = dashboardSnap.data();
        setDashboardData(data);
      } else {
        // Nếu không có dữ liệu, thử gọi cloud function để xử lý
        await fetchLatestExcelData();
      }
    } catch (err) {
      console.error('Error fetching dashboard data:', err);
      setError('Lỗi khi tải dữ liệu tổng quan.');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  }, []);

  // Hàm gọi Cloud Function để xử lý file Excel mới nhất
  const fetchLatestExcelData = async () => {
    try {
      setProcessingExcel(true);
      setError(null);

      // Gọi cloud function triggerExcelProcessing
      const functions = getFunctions(undefined, 'asia-southeast1');
      const triggerExcel = httpsCallable(functions, 'triggerExcelProcessing');

      const result = await triggerExcel();
      console.log('Kết quả xử lý Excel:', result.data);

      if (result.data && result.data.success) {
        // Lấy dữ liệu mới từ Firestore
        const dashboardRef = doc(db, 'summaries', 'directorDashboard');
        const dashboardSnap = await getDoc(dashboardRef);

        if (dashboardSnap.exists()) {
          const data = dashboardSnap.data();
          setDashboardData(data);
        }

        Alert.alert(
          'Cập nhật thành công',
          `Đã cập nhật dữ liệu từ file: ${result.data.fileName}`
        );
      } else {
        throw new Error('Không nhận được dữ liệu từ cloud function');
      }
    } catch (err) {
      console.error('Lỗi khi xử lý file Excel:', err);
      setError(`Lỗi khi xử lý file Excel: ${err.message}`);
      Alert.alert('Lỗi', `Không thể xử lý file Excel: ${err.message}`);
    } finally {
      setProcessingExcel(false);
      setRefreshing(false);
    }
  };

  const onRefresh = useCallback(() => {
    setRefreshing(true);
    fetchLatestExcelData();
  }, []);

  useFocusEffect(
    useCallback(() => {
      fetchDashboardData();
    }, [fetchDashboardData])
  );

  const formatDate = (timestamp) => {
    if (!timestamp) return 'Không có dữ liệu';

    const date = timestamp.toDate ? timestamp.toDate() : timestamp;
    return new Intl.DateTimeFormat('vi-VN', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    }).format(date);
  };

  const formatCurrency = (amount) => {
    if (amount === undefined || amount === null) return '0 ₫';

    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(amount);
  };

  if (loading && !refreshing) {
    return (
      <View style={[styles.container, { backgroundColor: theme.background }]}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.text }]}>
            Đang tải dữ liệu công nợ...
          </Text>
        </View>
      </View>
    );
  }

  const chartConfig = {
    backgroundGradientFrom: theme.card,
    backgroundGradientTo: theme.card,
    color: (opacity = 1) => `rgba(26, 255, 146, ${opacity})`,
    strokeWidth: 2,
    barPercentage: 0.7,
    useShadowColorFromDataset: false,
    decimalPlaces: 1,
  };

  const getPayableChartData = () => {
    // Dữ liệu mới không có top5Payable, nên trả về dữ liệu mẫu
    return {
      labels: ['Không có dữ liệu chi tiết'],
      datasets: [
        {
          data: [
            dashboardData?.totalPayable
              ? dashboardData.totalPayable / 1000000
              : 0,
          ],
        },
      ],
    };
  };

  const getReceivableChartData = () => {
    // Dữ liệu mới không có top5Receivable, nên trả về dữ liệu mẫu
    return {
      labels: ['Không có dữ liệu chi tiết'],
      datasets: [
        {
          data: [
            dashboardData?.totalReceivable
              ? dashboardData.totalReceivable / 1000000
              : 0,
          ],
        },
      ],
    };
  };

  return (
    <ScrollView
      style={[styles.container, { backgroundColor: theme.background }]}
      refreshControl={
        <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
      }
    >
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={theme.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Báo Cáo Công Nợ
        </Text>
        <TouchableOpacity
          style={styles.refreshButton}
          onPress={fetchLatestExcelData}
          disabled={processingExcel || refreshing}
        >
          {processingExcel ? (
            <ActivityIndicator size="small" color={theme.primary} />
          ) : (
            <Ionicons name="refresh-outline" size={24} color={theme.text} />
          )}
        </TouchableOpacity>
      </View>

      {error ? (
        <View style={styles.errorContainer}>
          <Ionicons name="alert-circle-outline" size={48} color={theme.error} />
          <Text style={[styles.errorText, { color: theme.error }]}>
            {error}
          </Text>
          <TouchableOpacity
            style={[styles.retryButton, { backgroundColor: theme.primary }]}
            onPress={fetchLatestExcelData}
          >
            <Text style={styles.retryButtonText}>Thử lại</Text>
          </TouchableOpacity>
        </View>
      ) : (
        <>
          <View style={styles.kpiContainer}>
            <View
              style={[
                styles.kpiCard,
                { backgroundColor: '#d9534f' }, // Red for payables
              ]}
            >
              <Text style={styles.kpiLabel}>Tổng Nợ Phải Trả</Text>
              <Text style={styles.kpiValue}>
                {dashboardData?.formattedTotals?.totalPayable ||
                  formatCurrency(dashboardData?.totalPayable)}
              </Text>
            </View>

            <View
              style={[
                styles.kpiCard,
                { backgroundColor: '#5cb85c' }, // Green for receivables
              ]}
            >
              <Text style={styles.kpiLabel}>Tổng Nợ Phải Thu</Text>
              <Text style={styles.kpiValue}>
                {dashboardData?.formattedTotals?.totalReceivable ||
                  formatCurrency(dashboardData?.totalReceivable)}
              </Text>
            </View>

            <View
              style={[
                styles.kpiCard,
                {
                  backgroundColor:
                    (dashboardData?.netPosition || 0) >= 0
                      ? '#5cb85c' // Green for positive
                      : '#d9534f', // Red for negative
                },
              ]}
            >
              <Text style={styles.kpiLabel}>Vị Thế Công Nợ Ròng</Text>
              <Text style={styles.kpiValue}>
                {dashboardData?.formattedTotals?.netPosition ||
                  formatCurrency(dashboardData?.netPosition)}
              </Text>
            </View>

            <View style={[styles.kpiCard, { backgroundColor: theme.card }]}>
              <Text style={[styles.kpiLabel, { color: theme.textSecondary }]}>
                Cập nhật lần cuối
              </Text>
              <Text style={[styles.lastUpdatedValue, { color: theme.text }]}>
                {dashboardData?.lastUpdated
                  ? formatDate(dashboardData.lastUpdated)
                  : 'Chưa có dữ liệu'}
              </Text>
              {dashboardData?.fileName && (
                <Text style={[styles.fileNameText, { color: theme.textMuted }]}>
                  {dashboardData.fileName}
                </Text>
              )}
            </View>
          </View>

          <View style={styles.chartSection}>
            <Text style={[styles.chartTitle, { color: theme.text }]}>
              Top 5 Công Nợ Phải Trả (Triệu VNĐ)
            </Text>
            <View style={styles.chartContainer}>
              <BarChart
                data={getPayableChartData()}
                width={screenWidth - 32}
                height={220}
                chartConfig={chartConfig}
                verticalLabelRotation={30}
                showValuesOnTopOfBars={true}
                fromZero={true}
                style={styles.chart}
              />
            </View>
          </View>

          <View style={styles.chartSection}>
            <Text style={[styles.chartTitle, { color: theme.text }]}>
              Top 5 Khách Hàng Nợ Nhiều Nhất (Triệu VNĐ)
            </Text>
            <View style={styles.chartContainer}>
              <BarChart
                data={getReceivableChartData()}
                width={screenWidth - 32}
                height={220}
                chartConfig={{
                  ...chartConfig,
                  color: (opacity = 1) => `rgba(54, 162, 235, ${opacity})`,
                }}
                verticalLabelRotation={30}
                showValuesOnTopOfBars={true}
                fromZero={true}
                style={styles.chart}
              />
            </View>
          </View>
        </>
      )}
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 16,
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    flex: 1,
    textAlign: 'center',
  },
  backButton: {
    padding: 8,
  },
  refreshButton: {
    padding: 8,
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
    marginTop: 50,
  },
  errorText: {
    fontSize: 16,
    textAlign: 'center',
    marginVertical: 20,
  },
  retryButton: {
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 8,
  },
  retryButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  kpiContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    marginBottom: 16,
  },
  kpiCard: {
    width: '48%',
    padding: 16,
    borderRadius: 12,
    marginBottom: 16,
    alignItems: 'center',
    justifyContent: 'center',
  },
  kpiLabel: {
    color: 'white',
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 8,
    textAlign: 'center',
  },
  kpiValue: {
    color: 'white',
    fontSize: 20,
    fontWeight: 'bold',
    textAlign: 'center',
  },
  lastUpdatedValue: {
    fontSize: 14,
    fontWeight: '500',
    textAlign: 'center',
  },
  chartSection: {
    marginVertical: 16,
    paddingHorizontal: 16,
  },
  chartTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  chartContainer: {
    alignItems: 'center',
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 8,
  },
  chart: {
    borderRadius: 12,
    marginVertical: 8,
  },
  fileNameText: {
    fontSize: 12,
    marginTop: 4,
    textAlign: 'center',
  },
});

export default DebtDashboard;

import React, { useState, useEffect, useLayoutEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  FlatList,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useNavigation, useFocusEffect } from '@react-navigation/native';
import { useAuth } from '../contexts/AuthContext';
import { useTheme } from '../contexts/ThemeContext';
import {
  getProposalsByStatus,
  canApproveProposal,
} from '../api/proposalService';

const DirectorDashboardScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const { currentUser } = useAuth();
  const [loading, setLoading] = useState(true);
  const [pendingProposals, setPendingProposals] = useState([]);
  const [canApprove, setCanApprove] = useState(false);

  useLayoutEffect(() => {
    navigation.setOptions({
      headerRight: () => (
        <TouchableOpacity
          onPress={() => navigation.navigate('Notifications')}
          style={{ marginRight: 16 }}
        >
          <Ionicons name="notifications-outline" size={24} color="#333" />
        </TouchableOpacity>
      ),
    });
  }, [navigation]);

  // Thêm useFocusEffect để tải lại dữ liệu khi màn hình được focus
  useFocusEffect(
    React.useCallback(() => {
      loadData();
    }, [])
  );

  const loadData = async () => {
    setLoading(true);
    try {
      // Kiểm tra quyền duyệt đề xuất
      const hasApprovalPermission = canApproveProposal(currentUser?.role);
      setCanApprove(hasApprovalPermission);

      // Nếu có quyền duyệt, tải danh sách đề xuất chờ duyệt
      if (hasApprovalPermission) {
        try {
          const proposals = await getProposalsByStatus('pending');
          console.log('Loaded pending proposals:', proposals.length);
          setPendingProposals(proposals);
        } catch (error) {
          console.error('Error loading proposals:', error);
          // Vẫn set canApprove để hiển thị UI
        }
      }
    } catch (error) {
      console.error('Error loading data:', error);
    } finally {
      setLoading(false);
    }
  };

  const formatDate = (timestamp) => {
    if (!timestamp) return 'N/A';
    try {
      if (timestamp.toDate) {
        return timestamp.toDate().toLocaleDateString('vi-VN');
      } else if (timestamp instanceof Date) {
        return timestamp.toLocaleDateString('vi-VN');
      }
      return 'N/A';
    } catch (e) {
      return 'N/A';
    }
  };

  const getPriorityColor = (priority) => {
    switch (priority) {
      case 'urgent':
        return '#FF3B30';
      case 'normal':
        return '#007AFF';
      default:
        return '#007AFF';
    }
  };

  const renderProposalItem = ({ item }) => {
    // Choose icon and color based on priority
    let iconName = 'document-text';
    let iconColor = '#4E8AF4'; // New color for default items

    if (item.priority === 'urgent') {
      iconName = 'alert-circle';
      iconColor = '#FF3B30';
    }

    return (
      <TouchableOpacity
        style={[styles.proposalItem, { backgroundColor: theme.card }]}
        onPress={() => navigation.navigate('ProposalList')}
      >
        <View style={styles.proposalIconContainer}>
          <Ionicons name={iconName} size={24} color={iconColor} />
        </View>
        <View style={styles.proposalContent}>
          <Text
            style={[styles.proposalCode, { color: theme.text }]}
            numberOfLines={1}
          >
            {item.proposalCode}
          </Text>
          <Text
            style={[styles.projectName, { color: theme.textSecondary }]}
            numberOfLines={1}
          >
            {item.projectName}
          </Text>
          <Text
            style={[
              styles.requiredDate,
              {
                color:
                  item.priority === 'urgent' ? '#FF3B30' : theme.textSecondary,
              },
            ]}
          >
            Cần: {formatDate(item.requiredDate)} • {item.items?.length || 0} vật
            tư
          </Text>
        </View>
        <Ionicons name="chevron-forward" size={20} color={theme.textMuted} />
      </TouchableOpacity>
    );
  };

  // Helper functions for status and priority
  const getStatusColor = (status) => {
    switch (status) {
      case 'approved':
        return '#34C759';
      case 'rejected':
        return '#FF3B30';
      case 'pending':
      default:
        return '#FF9500';
    }
  };

  const getStatusLabel = (status) => {
    switch (status) {
      case 'approved':
        return 'Đã duyệt';
      case 'rejected':
        return 'Từ chối';
      case 'pending':
      default:
        return 'Chờ duyệt';
    }
  };

  return (
    <ScrollView
      style={[styles.container, { backgroundColor: theme.background }]}
      contentContainerStyle={styles.contentContainer}
    >
      <Text style={[styles.screenTitle, { color: theme.text }]}>
        Bảng điều khiển Giám đốc
      </Text>

      {/* Nút truy cập màn hình công nợ */}
      <TouchableOpacity
        style={[styles.debtButton, { backgroundColor: theme.primary }]}
        onPress={() => navigation.navigate('DebtDashboard')}
      >
        <Ionicons name="cash-outline" size={24} color="white" />
        <Text style={styles.debtButtonText}>Xem báo cáo công nợ</Text>
      </TouchableOpacity>

      {/* Phần đề xuất chờ duyệt */}
      {canApprove && (
        <View style={styles.section}>
          <View style={styles.sectionHeader}>
            <View style={styles.sectionTitleContainer}>
              <Ionicons
                name="file-tray-stacked-outline"
                size={22}
                color={theme.primary}
                style={styles.sectionIcon}
              />
              <Text style={[styles.sectionTitle, { color: theme.text }]}>
                Đề xuất chờ duyệt
              </Text>
            </View>
            <TouchableOpacity
              style={styles.viewAllButton}
              onPress={() => navigation.navigate('ProposalList')}
            >
              <Text style={[styles.viewAllText, { color: theme.primary }]}>
                Xem tất cả
              </Text>
              <Ionicons
                name="chevron-forward"
                size={16}
                color={theme.primary}
              />
            </TouchableOpacity>
          </View>

          {loading ? (
            <ActivityIndicator
              size="large"
              color={theme.primary}
              style={styles.loader}
            />
          ) : pendingProposals.length > 0 ? (
            <View
              style={[styles.proposalsContainer, { borderColor: theme.border }]}
            >
              <FlatList
                data={pendingProposals}
                renderItem={renderProposalItem}
                keyExtractor={(item) => item.id}
                style={styles.proposalsList}
                scrollEnabled={true}
                nestedScrollEnabled={true}
                showsVerticalScrollIndicator={true}
                ListFooterComponent={
                  pendingProposals.length > 3 ? (
                    <TouchableOpacity
                      style={[
                        styles.moreButton,
                        { backgroundColor: theme.backgroundLight },
                      ]}
                      onPress={() => navigation.navigate('ProposalList')}
                    >
                      <Text
                        style={[
                          styles.moreButtonText,
                          { color: theme.primary },
                        ]}
                      >
                        Xem thêm {pendingProposals.length - 3} đề xuất
                      </Text>
                    </TouchableOpacity>
                  ) : null
                }
              />
            </View>
          ) : (
            <View style={[styles.emptyState, { backgroundColor: theme.card }]}>
              <Ionicons
                name="checkmark-circle"
                size={40}
                color={theme.success || '#4CAF50'}
              />
              <Text style={[styles.emptyText, { color: theme.textSecondary }]}>
                Không có đề xuất nào chờ duyệt
              </Text>
            </View>
          )}
        </View>
      )}

      {/* Các phần khác của dashboard */}
      <View style={styles.section}>
        <View style={styles.sectionTitleContainer}>
          <Ionicons
            name="stats-chart"
            size={22}
            color="#0066cc"
            style={styles.sectionIcon}
          />
          <Text style={[styles.sectionTitle, { color: theme.text }]}>
            Báo cáo dự án
          </Text>
        </View>
        <TouchableOpacity
          style={[styles.dashboardCard, { backgroundColor: theme.card }]}
          onPress={() => navigation.navigate('ProjectManagement')}
        >
          <Ionicons
            name="stats-chart"
            size={24}
            color={theme.primary}
            style={styles.cardIcon}
          />
          <View style={styles.cardContent}>
            <Text style={[styles.cardTitle, { color: theme.text }]}>
              Quản lý dự án
            </Text>
            <Text
              style={[styles.cardDescription, { color: theme.textSecondary }]}
            >
              Xem và quản lý tất cả dự án
            </Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color={theme.textMuted} />
        </TouchableOpacity>
      </View>

      <View style={styles.section}>
        <View style={styles.sectionTitleContainer}>
          <Ionicons
            name="people"
            size={22}
            color="#FF9500"
            style={styles.sectionIcon}
          />
          <Text style={[styles.sectionTitle, { color: theme.text }]}>
            Quản lý nhân sự
          </Text>
        </View>
        <TouchableOpacity
          style={[styles.dashboardCard, { backgroundColor: theme.card }]}
          onPress={() => navigation.navigate('Attendance')}
        >
          <Ionicons
            name="people"
            size={24}
            color="#FF9500"
            style={styles.cardIcon}
          />
          <View style={styles.cardContent}>
            <Text style={[styles.cardTitle, { color: theme.text }]}>
              Chấm công
            </Text>
            <Text
              style={[styles.cardDescription, { color: theme.textSecondary }]}
            >
              Quản lý chấm công và tăng ca
            </Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color={theme.textMuted} />
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.dashboardCard, { backgroundColor: theme.card }]}
          onPress={() => navigation.navigate('UserManagement')}
        >
          <Ionicons
            name="person-add"
            size={24}
            color="#FF2D55"
            style={styles.cardIcon}
          />
          <View style={styles.cardContent}>
            <Text style={[styles.cardTitle, { color: theme.text }]}>
              Quản lý người dùng
            </Text>
            <Text
              style={[styles.cardDescription, { color: theme.textSecondary }]}
            >
              Thêm và phân quyền người dùng
            </Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color={theme.textMuted} />
        </TouchableOpacity>
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  contentContainer: {
    padding: 16,
    paddingBottom: 32,
  },
  screenTitle: {
    fontSize: 22,
    fontWeight: 'bold',
    marginBottom: 20,
  },
  debtButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 12,
    borderRadius: 8,
    marginBottom: 20,
  },
  debtButtonText: {
    color: 'white',
    fontWeight: 'bold',
    fontSize: 16,
    marginLeft: 8,
  },
  section: {
    marginBottom: 24,
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  sectionTitleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  sectionIcon: {
    marginRight: 8,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  viewAllButton: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  viewAllText: {
    fontSize: 14,
    fontWeight: '500',
    marginRight: 4,
  },
  proposalsContainer: {
    borderWidth: 1,
    borderRadius: 8,
    height: 220, // Chiều cao cố định
    marginBottom: 8,
  },
  proposalsList: {
    flex: 1,
  },
  proposalItem: {
    flexDirection: 'row',
    alignItems: 'center', // Changed from flex-start to center
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  proposalIconContainer: {
    marginRight: 12,
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: '#f0f0f0',
    justifyContent: 'center',
    alignItems: 'center',
  },
  proposalContent: {
    flex: 1,
    marginRight: 8, // Add margin to prevent text touching the arrow
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 2,
  },
  proposalCode: {
    fontWeight: 'bold',
    fontSize: 15,
  },
  projectName: {
    fontSize: 13,
    marginTop: 2,
  },
  requiredDate: {
    fontSize: 12,
    marginTop: 2,
  },
  statusBadge: {
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 4,
  },
  statusText: {
    color: '#fff',
    fontSize: 10,
    fontWeight: '500',
  },
  moreButton: {
    padding: 12,
    alignItems: 'center',
    borderBottomLeftRadius: 8,
    borderBottomRightRadius: 8,
  },
  moreButtonText: {
    fontWeight: '500',
  },
  emptyState: {
    padding: 24,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  emptyText: {
    marginTop: 12,
    fontSize: 16,
    textAlign: 'center',
  },
  loader: {
    padding: 24,
  },
  dashboardCard: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderRadius: 8,
    marginBottom: 12,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  cardIcon: {
    marginRight: 16,
  },
  cardContent: {
    flex: 1,
  },
  cardTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 4,
  },
  cardDescription: {
    fontSize: 14,
  },
});

export default DirectorDashboardScreen;

//src/screens/EditCustomerScreen.js
import React, { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { updateCustomer } from '../api/customerService';
import { useAuth } from '../contexts/AuthContext';

const EditCustomerScreen = ({ route, navigation }) => {
  const { customer } = route.params;
  const { currentUser } = useAuth();
  const [isLoading, setIsLoading] = useState(false);
  const [formData, setFormData] = useState({
    name: customer.name || '',
    contactPerson: customer.contactPerson || '',
    phone: customer.phone || '',
    email: customer.email || '',
    address: customer.address || '',
    type: customer.type || 'regular',
    taxCode: customer.taxCode || '',
  });

  // Cập nhật giá trị form
  const handleChange = (field, value) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));
  };

  // Kiểm tra form hợp lệ
  const validateForm = () => {
    if (!formData.name.trim()) {
      Alert.alert('Lỗi', 'Vui lòng nhập tên khách hàng');
      return false;
    }

    if (!formData.contactPerson.trim()) {
      Alert.alert('Lỗi', 'Vui lòng nhập tên người liên hệ');
      return false;
    }

    if (formData.email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
      Alert.alert('Lỗi', 'Email không hợp lệ');
      return false;
    }

    return true;
  };

  // Xử lý cập nhật khách hàng
  const handleUpdate = async () => {
    if (!validateForm()) {
      return;
    }

    setIsLoading(true);

    try {
      // Gọi API cập nhật thông tin khách hàng
      await updateCustomer(customer.id, formData, currentUser?.uid);

      Alert.alert('Thành công', 'Đã cập nhật thông tin khách hàng thành công', [
        {
          text: 'OK',
          onPress: () => navigation.goBack(),
        },
      ]);
    } catch (error) {
      if (error.code === 'permission-denied') {
        Alert.alert(
          'Lỗi quyền',
          'Bạn không có đủ quyền để thực hiện hành động này.'
        );
      } else {
        console.error('Lỗi khi cập nhật khách hàng:', error);
        Alert.alert(
          'Lỗi',
          'Không thể cập nhật thông tin khách hàng. Vui lòng thử lại sau.'
        );
      }
    } finally {
      setIsLoading(false);
    }
  };

  // Xử lý thay đổi loại khách hàng
  const handleSelectType = (type) => {
    handleChange('type', type);
  };

  return (
    <KeyboardAvoidingView
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      style={styles.container}
    >
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Chỉnh sửa thông tin khách hàng</Text>
        <View style={styles.placeholder} />
      </View>

      <ScrollView
        style={styles.formContainer}
        contentContainerStyle={styles.formContent}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.inputGroup}>
          <Text style={styles.label}>
            Tên công ty / Tổ chức <Text style={styles.required}>*</Text>
          </Text>
          <TextInput
            style={styles.input}
            value={formData.name}
            onChangeText={(text) => handleChange('name', text)}
            placeholder="Nhập tên công ty hoặc tổ chức"
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>
            Người liên hệ <Text style={styles.required}>*</Text>
          </Text>
          <TextInput
            style={styles.input}
            value={formData.contactPerson}
            onChangeText={(text) => handleChange('contactPerson', text)}
            placeholder="Nhập tên người liên hệ"
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>Số điện thoại</Text>
          <TextInput
            style={styles.input}
            value={formData.phone}
            onChangeText={(text) => handleChange('phone', text)}
            placeholder="Nhập số điện thoại"
            keyboardType="phone-pad"
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>Email</Text>
          <TextInput
            style={styles.input}
            value={formData.email}
            onChangeText={(text) => handleChange('email', text)}
            placeholder="Nhập địa chỉ email"
            keyboardType="email-address"
            autoCapitalize="none"
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>Địa chỉ</Text>
          <TextInput
            style={[styles.input, styles.textArea]}
            value={formData.address}
            onChangeText={(text) => handleChange('address', text)}
            placeholder="Nhập địa chỉ"
            multiline
            numberOfLines={3}
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>Mã số thuế</Text>
          <TextInput
            style={styles.input}
            value={formData.taxCode}
            onChangeText={(text) => handleChange('taxCode', text)}
            placeholder="Nhập mã số thuế"
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>Loại khách hàng</Text>
          <View style={styles.typeButtonsContainer}>
            <TouchableOpacity
              style={[
                styles.typeButton,
                formData.type === 'potential' && styles.selectedTypeButton,
              ]}
              onPress={() => handleSelectType('potential')}
            >
              <Text
                style={[
                  styles.typeButtonText,
                  formData.type === 'potential' &&
                    styles.selectedTypeButtonText,
                ]}
              >
                Tiềm năng
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.typeButton,
                formData.type === 'regular' && styles.selectedTypeButton,
              ]}
              onPress={() => handleSelectType('regular')}
            >
              <Text
                style={[
                  styles.typeButtonText,
                  formData.type === 'regular' && styles.selectedTypeButtonText,
                ]}
              >
                Thường xuyên
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.typeButton,
                formData.type === 'vip' && styles.selectedTypeButton,
              ]}
              onPress={() => handleSelectType('vip')}
            >
              <Text
                style={[
                  styles.typeButtonText,
                  formData.type === 'vip' && styles.selectedTypeButtonText,
                ]}
              >
                VIP
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      </ScrollView>

      <View style={styles.footer}>
        <TouchableOpacity
          style={styles.saveButton}
          onPress={handleUpdate}
          disabled={isLoading}
        >
          {isLoading ? (
            <ActivityIndicator color="#fff" size="small" />
          ) : (
            <>
              <Ionicons name="save-outline" size={20} color="#fff" />
              <Text style={styles.saveButtonText}>Lưu thay đổi</Text>
            </>
          )}
        </TouchableOpacity>
      </View>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  placeholder: {
    width: 24,
  },
  formContainer: {
    flex: 1,
  },
  formContent: {
    padding: 16,
  },
  inputGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    marginBottom: 6,
    color: '#333',
  },
  required: {
    color: '#e74c3c',
  },
  input: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    color: '#333',
  },
  textArea: {
    minHeight: 80,
    textAlignVertical: 'top',
  },
  typeButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  typeButton: {
    flex: 1,
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 8,
    borderRadius: 8,
    marginHorizontal: 4,
    alignItems: 'center',
  },
  selectedTypeButton: {
    backgroundColor: '#0066cc',
  },
  typeButtonText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '500',
  },
  selectedTypeButtonText: {
    color: '#fff',
  },
  footer: {
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  saveButton: {
    backgroundColor: '#0066cc',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    borderRadius: 8,
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
});

export default EditCustomerScreen;

import React, { useState, useEffect } from 'react';
import {
  View,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  Image,
  Alert,
  Platform,
} from 'react-native';
import {
  TextInput,
  Button,
  Text,
  Appbar,
  HelperText,
  Divider,
  Dialog,
  Portal,
  List,
  ActivityIndicator,
} from 'react-native-paper';
import { useNavigation, useRoute } from '@react-navigation/native';
import * as ImagePicker from 'expo-image-picker';
import InventoryService from '../api/inventoryService';
import { firebase } from '../config/firebaseConfig';
import useInventory from '../hooks/useInventory';

const EditInventoryItemScreen = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { itemId } = route.params || {};
  const { updateInventoryItem, getInventoryItemDetail } = useInventory();

  // State cho form chỉnh sửa vật tư
  const [formData, setFormData] = useState({
    name: '',
    code: '',
    description: '',
    categoryId: '',
    unit: '',
    stockQuantity: 0,
    minQuantity: 0,
    price: 0,
    weight: 0,
    material: '',
    totalPrice: 0,
  });
  const [image, setImage] = useState(null);
  const [imageBlob, setImageBlob] = useState(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [errors, setErrors] = useState({});
  const [categories, setCategories] = useState([]);
  const [selectedCategory, setSelectedCategory] = useState(null);
  const [categoryDialogVisible, setCategoryDialogVisible] = useState(false);
  const [units] = useState([
    'cái',
    'bộ',
    'tấm',
    'kg',
    'mét',
    'm2',
    'cuộn',
    'lít',
    'lon',
  ]);
  const [unitDialogVisible, setUnitDialogVisible] = useState(false);

  // Load dữ liệu vật tư và danh sách danh mục khi màn hình được mount
  useEffect(() => {
    fetchCategories();
    requestPermissions();

    // Nếu có itemId thì load thông tin vật tư
    if (itemId) {
      fetchItemDetails();
    } else {
      // Nếu không có itemId, quay về màn hình trước
      Alert.alert('Lỗi', 'Không tìm thấy thông tin vật tư');
      navigation.goBack();
      setLoading(false);
    }
  }, [itemId]);

  // Hàm lấy chi tiết vật tư
  const fetchItemDetails = async () => {
    try {
      const itemDetails = await getInventoryItemDetail(itemId);

      // Cập nhật formData từ thông tin vật tư
      setFormData({
        name: itemDetails.name || '',
        code: itemDetails.code || '',
        description: itemDetails.description || '',
        categoryId: itemDetails.categoryId || '',
        unit: itemDetails.unit || '',
        stockQuantity: itemDetails.stockQuantity || 0,
        minQuantity: itemDetails.minQuantity || 0,
        price: itemDetails.price || 0,
        weight: itemDetails.weight || 0,
        material: itemDetails.material || '',
        totalPrice: itemDetails.totalPrice || 0,
      });

      // Cập nhật category đã chọn
      if (itemDetails.categoryId && categories.length > 0) {
        const category = categories.find(
          (c) => c.id === itemDetails.categoryId
        );
        if (category) {
          setSelectedCategory(category);
        }
      } else if (itemDetails.category) {
        setSelectedCategory(itemDetails.category);
      }

      // Cập nhật hình ảnh nếu có
      if (itemDetails.imageUrl) {
        setImage(itemDetails.imageUrl);
      }

      setLoading(false);
    } catch (error) {
      console.error('Lỗi khi lấy chi tiết vật tư:', error);
      Alert.alert('Lỗi', 'Không thể lấy thông tin vật tư');
      navigation.goBack();
    }
  };

  // Hàm lấy danh sách danh mục từ Firestore
  const fetchCategories = async () => {
    try {
      const snapshot = await firebase
        .firestore()
        .collection('inventory_categories')
        .get();
      const fetchedCategories = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));
      setCategories(fetchedCategories);
    } catch (error) {
      console.error('Lỗi khi lấy danh mục:', error);
      Alert.alert('Lỗi', 'Không thể lấy danh sách danh mục');
    }
  };

  // Yêu cầu quyền truy cập camera và thư viện ảnh
  const requestPermissions = async () => {
    if (Platform.OS !== 'web') {
      const { status: cameraStatus } =
        await ImagePicker.requestCameraPermissionsAsync();
      const { status: libraryStatus } =
        await ImagePicker.requestMediaLibraryPermissionsAsync();

      if (cameraStatus !== 'granted' || libraryStatus !== 'granted') {
        Alert.alert(
          'Cần quyền truy cập',
          'Bạn cần cấp quyền để sử dụng camera và thư viện ảnh.'
        );
      }
    }
  };

  // Xử lý thay đổi giá trị các trường
  const handleChange = (field, value) => {
    // Xử lý cho trường số
    if (['stockQuantity', 'minQuantity', 'price', 'weight'].includes(field)) {
      const numericValue = parseFloat(value.replace(/[^0-9.]/g, ''));
      const updatedValue = isNaN(numericValue) ? 0 : numericValue;

      const updatedFormData = {
        ...formData,
        [field]: updatedValue,
      };

      // Tính toán lại giá trị totalPrice nếu thay đổi số lượng hoặc đơn giá
      if (field === 'stockQuantity' || field === 'price') {
        updatedFormData.totalPrice =
          updatedFormData.stockQuantity * updatedFormData.price;
      }

      setFormData(updatedFormData);
    } else {
      setFormData({
        ...formData,
        [field]: value,
      });
    }

    // Xóa lỗi khi người dùng điền lại
    if (errors[field]) {
      setErrors({
        ...errors,
        [field]: null,
      });
    }
  };

  // Chọn danh mục
  const handleCategorySelect = (category) => {
    setSelectedCategory(category);
    setFormData({
      ...formData,
      categoryId: category.id,
    });
    setCategoryDialogVisible(false);

    // Xóa lỗi danh mục nếu có
    if (errors.categoryId) {
      setErrors({
        ...errors,
        categoryId: null,
      });
    }
  };

  // Chọn đơn vị tính
  const handleUnitSelect = (unit) => {
    setFormData({
      ...formData,
      unit,
    });
    setUnitDialogVisible(false);

    // Xóa lỗi đơn vị nếu có
    if (errors.unit) {
      setErrors({
        ...errors,
        unit: null,
      });
    }
  };

  // Chọn ảnh từ thư viện
  const pickImage = async () => {
    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        aspect: [4, 3],
        quality: 0.8,
      });

      if (!result.canceled && result.assets && result.assets[0]) {
        const imageUri = result.assets[0].uri;
        setImage(imageUri);

        // Chuyển ảnh thành blob để upload
        const response = await fetch(imageUri);
        const blob = await response.blob();
        setImageBlob(blob);
      }
    } catch (error) {
      console.error('Lỗi khi chọn ảnh:', error);
      Alert.alert('Lỗi', 'Không thể chọn ảnh');
    }
  };

  // Chụp ảnh từ camera
  const takePhoto = async () => {
    try {
      const result = await ImagePicker.launchCameraAsync({
        allowsEditing: true,
        aspect: [4, 3],
        quality: 0.8,
      });

      if (!result.canceled && result.assets && result.assets[0]) {
        const imageUri = result.assets[0].uri;
        setImage(imageUri);

        // Chuyển ảnh thành blob để upload
        const response = await fetch(imageUri);
        const blob = await response.blob();
        setImageBlob(blob);
      }
    } catch (error) {
      console.error('Lỗi khi chụp ảnh:', error);
      Alert.alert('Lỗi', 'Không thể chụp ảnh');
    }
  };

  // Kiểm tra form trước khi lưu
  const validateForm = () => {
    const newErrors = {};

    if (!formData.name.trim()) {
      newErrors.name = 'Vui lòng nhập tên vật tư';
    }

    if (!formData.code.trim()) {
      newErrors.code = 'Vui lòng nhập mã vật tư';
    }

    if (!formData.categoryId) {
      newErrors.categoryId = 'Vui lòng chọn danh mục';
    }

    if (!formData.unit.trim()) {
      newErrors.unit = 'Vui lòng chọn đơn vị tính';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Cập nhật vật tư
  const handleSave = async () => {
    if (!validateForm()) return;

    setSaving(true);

    try {
      // Cập nhật vật tư
      const result = await updateInventoryItem(itemId, formData);

      // Nếu có hình ảnh mới, upload và cập nhật URL
      if (imageBlob) {
        await InventoryService.uploadItemImage(itemId, imageBlob);
      }

      Alert.alert('Thành công', 'Đã cập nhật thông tin vật tư', [
        { text: 'OK', onPress: () => navigation.goBack() },
      ]);
    } catch (error) {
      console.error('Lỗi khi cập nhật vật tư:', error);
      Alert.alert('Lỗi', error.message || 'Không thể cập nhật vật tư');
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0066cc" />
        <Text style={styles.loadingText}>Đang tải thông tin vật tư...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Appbar.Header>
        <Appbar.BackAction onPress={() => navigation.goBack()} />
        <Appbar.Content title="Chỉnh sửa vật tư" />
      </Appbar.Header>

      <ScrollView style={styles.scrollView}>
        {/* Thông tin cơ bản */}
        <Text style={styles.sectionTitle}>Thông tin cơ bản</Text>

        <TextInput
          label="Tên vật tư *"
          value={formData.name}
          onChangeText={(text) => handleChange('name', text)}
          style={styles.input}
          error={!!errors.name}
        />
        {errors.name && <HelperText type="error">{errors.name}</HelperText>}

        <TextInput
          label="Mã vật tư *"
          value={formData.code}
          onChangeText={(text) => handleChange('code', text)}
          style={styles.input}
          error={!!errors.code}
        />
        {errors.code && <HelperText type="error">{errors.code}</HelperText>}

        <TouchableOpacity
          onPress={() => setCategoryDialogVisible(true)}
          style={styles.input}
        >
          <TextInput
            label="Danh mục *"
            value={selectedCategory ? selectedCategory.name : ''}
            editable={false}
            right={<TextInput.Icon icon="menu-down" />}
            error={!!errors.categoryId}
          />
        </TouchableOpacity>
        {errors.categoryId && (
          <HelperText type="error">{errors.categoryId}</HelperText>
        )}

        <TouchableOpacity
          onPress={() => setUnitDialogVisible(true)}
          style={styles.input}
        >
          <TextInput
            label="Đơn vị tính *"
            value={formData.unit}
            editable={false}
            right={<TextInput.Icon icon="menu-down" />}
            error={!!errors.unit}
          />
        </TouchableOpacity>
        {errors.unit && <HelperText type="error">{errors.unit}</HelperText>}

        <TextInput
          label="Mô tả"
          value={formData.description}
          onChangeText={(text) => handleChange('description', text)}
          multiline
          numberOfLines={3}
          style={styles.input}
        />

        <Divider style={styles.divider} />

        {/* Thông tin số lượng và đơn giá */}
        <Text style={styles.sectionTitle}>Thông tin số lượng và đơn giá</Text>

        <TextInput
          label="Số lượng tồn kho"
          value={formData.stockQuantity.toString()}
          onChangeText={(text) => handleChange('stockQuantity', text)}
          keyboardType="numeric"
          style={styles.input}
        />

        <TextInput
          label="Số lượng tồn tối thiểu"
          value={formData.minQuantity.toString()}
          onChangeText={(text) => handleChange('minQuantity', text)}
          keyboardType="numeric"
          style={styles.input}
        />

        <TextInput
          label={`Đơn giá (VNĐ/${formData.unit || 'đơn vị'})`}
          value={formData.price.toString()}
          onChangeText={(text) => handleChange('price', text)}
          keyboardType="numeric"
          style={styles.input}
        />

        <View style={styles.totalPriceContainer}>
          <Text style={styles.totalPriceLabel}>Tổng giá trị:</Text>
          <Text style={styles.totalPriceValue}>
            {(formData.totalPrice || 0).toLocaleString('vi-VN')} VNĐ
          </Text>
        </View>

        <Divider style={styles.divider} />

        {/* Thông tin bổ sung */}
        <Text style={styles.sectionTitle}>Thông tin bổ sung</Text>

        <TextInput
          label="Vật liệu"
          value={formData.material}
          onChangeText={(text) => handleChange('material', text)}
          style={styles.input}
        />

        <TextInput
          label="Khối lượng (kg)"
          value={formData.weight.toString()}
          onChangeText={(text) => handleChange('weight', text)}
          keyboardType="numeric"
          style={styles.input}
        />

        {/* Phần upload hình ảnh */}
        <Text style={styles.sectionTitle}>Hình ảnh vật tư</Text>

        <View style={styles.imageContainer}>
          {image ? (
            <Image source={{ uri: image }} style={styles.image} />
          ) : (
            <View style={styles.imagePlaceholder}>
              <Text style={styles.placeholderText}>Chưa có ảnh</Text>
            </View>
          )}

          <View style={styles.imageButtons}>
            <Button
              mode="contained"
              onPress={pickImage}
              style={styles.imageButton}
            >
              Chọn ảnh
            </Button>
            <Button
              mode="outlined"
              onPress={takePhoto}
              style={styles.imageButton}
            >
              Chụp ảnh
            </Button>
          </View>
        </View>

        {/* Nút lưu */}
        <Button
          mode="contained"
          onPress={handleSave}
          style={styles.saveButton}
          loading={saving}
          disabled={saving}
        >
          Cập nhật vật tư
        </Button>
      </ScrollView>

      {/* Dialog chọn danh mục */}
      <Portal>
        <Dialog
          visible={categoryDialogVisible}
          onDismiss={() => setCategoryDialogVisible(false)}
        >
          <Dialog.Title>Chọn danh mục</Dialog.Title>
          <Dialog.Content>
            <ScrollView style={{ maxHeight: 300 }}>
              {categories.map((category) => (
                <List.Item
                  key={category.id}
                  title={category.name}
                  description={category.description}
                  onPress={() => handleCategorySelect(category)}
                />
              ))}
            </ScrollView>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setCategoryDialogVisible(false)}>
              Đóng
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* Dialog chọn đơn vị tính */}
      <Portal>
        <Dialog
          visible={unitDialogVisible}
          onDismiss={() => setUnitDialogVisible(false)}
        >
          <Dialog.Title>Chọn đơn vị tính</Dialog.Title>
          <Dialog.Content>
            <ScrollView style={{ maxHeight: 300 }}>
              {units.map((unit) => (
                <List.Item
                  key={unit}
                  title={unit}
                  onPress={() => handleUnitSelect(unit)}
                />
              ))}
            </ScrollView>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setUnitDialogVisible(false)}>Đóng</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  loadingText: {
    marginTop: 10,
    color: '#666',
  },
  scrollView: {
    flex: 1,
    padding: 16,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginVertical: 12,
  },
  input: {
    marginBottom: 8,
    backgroundColor: 'white',
  },
  divider: {
    marginVertical: 16,
  },
  imageContainer: {
    marginVertical: 10,
    alignItems: 'center',
  },
  image: {
    width: '100%',
    height: 200,
    borderRadius: 8,
    marginBottom: 10,
  },
  imagePlaceholder: {
    width: '100%',
    height: 200,
    borderRadius: 8,
    backgroundColor: '#e0e0e0',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 10,
  },
  placeholderText: {
    color: '#757575',
  },
  imageButtons: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    width: '100%',
  },
  imageButton: {
    flex: 1,
    marginHorizontal: 5,
  },
  saveButton: {
    marginVertical: 24,
    paddingVertical: 6,
    backgroundColor: '#3f51b5',
  },
  totalPriceContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    backgroundColor: '#f0f0f0',
    borderRadius: 8,
    marginBottom: 16,
  },
  totalPriceLabel: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  totalPriceValue: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#3f51b5',
  },
});

export default EditInventoryItemScreen;

//src/screens/EditProjectScreen.js
import React, { useState, useEffect, useLayoutEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
  Modal,
  FlatList,
  LogBox,
  ActionSheetIOS,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import DateTimePicker from '@react-native-community/datetimepicker';
import { updateProject } from '../api/projectService';
import { getCustomers } from '../api/customerService';
import { useAuth } from '../contexts/AuthContext';
import DraggableFlatList from 'react-native-draggable-flatlist';
import ProcessPickerModal from '../components/ProcessPickerModal';
import uuid from 'react-native-uuid';
import { GestureHandlerRootView } from 'react-native-gesture-handler';

// Ignore the VirtualizedLists nested warning (we purposely nest one non-scrollable list inside a ScrollView)
LogBox.ignoreLogs(['VirtualizedLists should never be nested']);

const EditProjectScreen = ({ route, navigation }) => {
  // Lấy thông tin dự án từ route params
  const { project } = route.params;
  const { currentUser } = useAuth();
  const [isLoading, setIsLoading] = useState(false);
  const [customers, setCustomers] = useState([]);
  const [loadingCustomers, setLoadingCustomers] = useState(true);
  const [customerModalVisible, setCustomerModalVisible] = useState(false);
  const [customerSearchQuery, setCustomerSearchQuery] = useState('');
  const [filteredCustomers, setFilteredCustomers] = useState([]);

  // Thêm state cho date picker
  const [showStartDatePicker, setShowStartDatePicker] = useState(false);
  const [showEndDatePicker, setShowEndDatePicker] = useState(false);

  // Khởi tạo formData với dữ liệu dự án hiện tại
  const [formData, setFormData] = useState({
    name: project?.name || '',
    description: project?.description || '',
    customerId: project?.customerId || '',
    customerName: project?.customerName || '',
    status: project?.status || 'pending',
    startDate: project?.startDate
      ? new Date(project.startDate.seconds * 1000)
      : null,
    endDate: project?.endDate ? new Date(project.endDate.seconds * 1000) : null,
    durationInDays: project?.durationInDays
      ? String(project.durationInDays)
      : '',
    location: project?.location || 'workshop', // 'workshop' (tại xưởng) hoặc 'site' (tại công trình)
    budget: project?.budget ? String(project.budget) : '',
    notes: project?.notes || '',
  });

  // Lấy danh sách khách hàng khi màn hình được tải
  useEffect(() => {
    const fetchCustomers = async () => {
      try {
        setLoadingCustomers(true);
        const data = await getCustomers();
        setCustomers(data);
        setFilteredCustomers(data);
      } catch (error) {
        console.error('Lỗi khi lấy danh sách khách hàng:', error);
        Alert.alert('Lỗi', 'Không thể tải danh sách khách hàng');
      } finally {
        setLoadingCustomers(false);
      }
    };

    fetchCustomers();
  }, []);

  // Lọc danh sách khách hàng khi từ khóa tìm kiếm thay đổi
  useEffect(() => {
    if (!customerSearchQuery.trim()) {
      setFilteredCustomers(customers);
      return;
    }

    const query = customerSearchQuery.toLowerCase().trim();
    const filtered = customers.filter((customer) => {
      const name = (customer.name || '').toLowerCase();
      const contact = (customer.contactPerson || '').toLowerCase();
      const email = (customer.email || '').toLowerCase();

      return (
        name.includes(query) || contact.includes(query) || email.includes(query)
      );
    });

    setFilteredCustomers(filtered);
  }, [customerSearchQuery, customers]);

  // Cập nhật giá trị form
  const handleChange = (field, value) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));
  };

  // Xử lý khi chọn ngày bắt đầu
  const handleStartDateChange = (event, selectedDate) => {
    setShowStartDatePicker(false);
    if (selectedDate) {
      handleChange('startDate', selectedDate);

      // Tự động tính ngày kết thúc nếu có số ngày thi công
      if (formData.durationInDays) {
        const endDate = new Date(selectedDate);
        endDate.setDate(endDate.getDate() + Number(formData.durationInDays));
        handleChange('endDate', endDate);
      }
    }
  };

  // Xử lý khi nhập số ngày thi công
  const handleDurationChange = (text) => {
    handleChange('durationInDays', text);

    // Tự động tính ngày kết thúc nếu có ngày bắt đầu
    if (formData.startDate && text) {
      const endDate = new Date(formData.startDate);
      endDate.setDate(endDate.getDate() + Number(text));
      handleChange('endDate', endDate);
    }
  };

  // Xử lý khi chọn vị trí
  const handleLocationChange = (location) => {
    handleChange('location', location);
  };

  // Định dạng ngày để hiển thị
  const formatDate = (date) => {
    if (!date) return '';
    return date.toLocaleDateString('vi-VN');
  };

  // Kiểm tra form hợp lệ
  const validateForm = () => {
    if (!formData.name.trim()) {
      Alert.alert('Lỗi', 'Vui lòng nhập tên dự án');
      return false;
    }

    return true;
  };

  // Xử lý cập nhật dự án
  const handleUpdate = async () => {
    if (!validateForm()) {
      return;
    }

    setIsLoading(true);

    try {
      // Chuẩn bị dữ liệu để lưu
      const projectData = {
        ...formData,
        budget: formData.budget ? Number(formData.budget) : null,
        durationInDays: formData.durationInDays
          ? Number(formData.durationInDays)
          : null,
        workflowStages: workflowStages.map((s, index) => ({
          ...s,
          order: index,
        })),
      };

      // Gọi API cập nhật dự án
      await updateProject(project.id, projectData, currentUser?.uid);

      Alert.alert('Thành công', 'Đã cập nhật dự án thành công', [
        {
          text: 'OK',
          onPress: () => navigation.goBack(),
        },
      ]);
    } catch (error) {
      if (error.code === 'permission-denied') {
        Alert.alert(
          'Lỗi quyền',
          'Bạn không có đủ quyền để thực hiện hành động này.'
        );
      } else {
        console.error('Lỗi khi cập nhật dự án:', error);
        Alert.alert('Lỗi', 'Không thể cập nhật dự án. Vui lòng thử lại sau.');
      }
    } finally {
      setIsLoading(false);
    }
  };

  // Xử lý thay đổi trạng thái dự án
  const handleSelectStatus = (status) => {
    handleChange('status', status);
  };

  // Xử lý mở modal chọn khách hàng
  const handleOpenCustomerModal = () => {
    setCustomerModalVisible(true);
  };

  // Xử lý đóng modal chọn khách hàng
  const handleCloseCustomerModal = () => {
    setCustomerModalVisible(false);
    setCustomerSearchQuery('');
  };

  // Xử lý khi chọn khách hàng
  const handleSelectCustomer = (customer) => {
    setFormData((prev) => ({
      ...prev,
      customerId: customer.id,
      customerName: customer.name,
    }));
    handleCloseCustomerModal();
  };

  // Xử lý khi tìm kiếm khách hàng
  const handleSearchCustomer = (text) => {
    setCustomerSearchQuery(text);
  };

  // Xử lý khi xóa khách hàng đã chọn
  const handleClearCustomer = () => {
    setFormData((prev) => ({
      ...prev,
      customerId: '',
      customerName: '',
    }));
  };

  // Render một item trong danh sách khách hàng
  const renderCustomerItem = ({ item }) => (
    <TouchableOpacity
      style={[
        styles.customerItem,
        item.id === formData.customerId && styles.selectedCustomerItem,
      ]}
      onPress={() => handleSelectCustomer(item)}
    >
      <View>
        <Text style={styles.customerName}>
          {item.name}
          {item.id === formData.customerId && ' (Đã chọn)'}
        </Text>
        {item.contactPerson && (
          <Text style={styles.customerDetail}>
            Người liên hệ: {item.contactPerson}
          </Text>
        )}
        {item.email && (
          <Text style={styles.customerDetail}>Email: {item.email}</Text>
        )}
      </View>
      {item.id === formData.customerId && (
        <Ionicons name="checkmark-circle" size={20} color="#0066cc" />
      )}
      {item.id !== formData.customerId && (
        <Ionicons name="chevron-forward" size={20} color="#999" />
      )}
    </TouchableOpacity>
  );

  // Ẩn header mặc định để tránh trùng lặp
  useLayoutEffect(() => {
    navigation.setOptions({ headerShown: false });
  }, [navigation]);

  const [workflowStages, setWorkflowStages] = useState(
    project?.workflowStages || []
  );
  const [pickerVisible, setPickerVisible] = useState(false);

  // Remove stage
  const handleRemoveStage = (stageId) => {
    Alert.alert('Xác nhận', 'Xóa công đoạn này?', [
      { text: 'Hủy', style: 'cancel' },
      {
        text: 'Xóa',
        style: 'destructive',
        onPress: () =>
          setWorkflowStages((prev) =>
            prev.filter((s) => s.stageId !== stageId)
          ),
      },
    ]);
  };

  const STATUS_OPTIONS = [
    { value: 'pending', label: 'Chờ xử lý' },
    { value: 'in_progress', label: 'Đang làm' },
    { value: 'completed', label: 'Hoàn thành' },
  ];

  const changeStageStatusLocal = (stageId, newStatus) => {
    setWorkflowStages((prev) =>
      prev.map((s) => (s.stageId === stageId ? { ...s, status: newStatus } : s))
    );
  };

  const quickChangeStatus = (stage) => {
    if (Platform.OS === 'ios') {
      ActionSheetIOS.showActionSheetWithOptions(
        {
          options: [...STATUS_OPTIONS.map((s) => s.label), 'Hủy'],
          cancelButtonIndex: STATUS_OPTIONS.length,
        },
        (idx) => {
          if (idx < STATUS_OPTIONS.length) {
            changeStageStatusLocal(stage.stageId, STATUS_OPTIONS[idx].value);
          }
        }
      );
    } else {
      Alert.alert('Chọn trạng thái', null, [
        ...STATUS_OPTIONS.map((opt) => ({
          text: opt.label,
          onPress: () => changeStageStatusLocal(stage.stageId, opt.value),
        })),
        { text: 'Hủy', style: 'cancel' },
      ]);
    }
  };

  /* -------------------- WORKFLOW BUILDER ------------------- */
  const renderStageItem = ({ item, drag, isActive }) => {
    const statusColor =
      item.status === 'completed'
        ? '#4CAF50'
        : item.status === 'in_progress'
        ? '#FFD54F'
        : '#9E9E9E';

    return (
      <View style={[styles.stageRow, isActive && { opacity: 0.8 }]}>
        <TouchableOpacity onLongPress={drag} style={styles.dragHandle}>
          <Ionicons name="reorder-two-outline" size={20} color="#666" />
        </TouchableOpacity>

        <View style={styles.stageInfo}>
          <Text style={styles.stageName}>{item.processName}</Text>
          <TouchableOpacity
            style={[
              styles.statusBadge,
              { backgroundColor: statusColor + '22' },
            ]}
            onPress={() => quickChangeStatus(item)}
          >
            <Text style={[styles.statusBadgeText, { color: statusColor }]}>
              {
                {
                  pending: 'Chờ xử lý',
                  in_progress: 'Đang làm',
                  completed: 'Hoàn thành',
                }[item.status]
              }
            </Text>
          </TouchableOpacity>
        </View>

        <TouchableOpacity
          style={styles.deleteStageBtn}
          onPress={() => handleRemoveStage(item.stageId)}
        >
          <Ionicons name="trash-outline" size={20} color="#d11a2a" />
        </TouchableOpacity>
      </View>
    );
  };

  const handleAddStages = (selectedTemplates) => {
    const next = [...workflowStages];
    selectedTemplates.forEach((tpl) => {
      next.push({
        stageId: uuid.v4(),
        processKey: tpl.processKey,
        processName: tpl.processName,
        order: next.length,
        status: 'pending',
      });
    });
    setWorkflowStages(next);
    setPickerVisible(false);
  };

  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.container}
      >
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
          >
            <Ionicons name="arrow-back" size={24} color="#333" />
          </TouchableOpacity>
          <Text style={styles.headerTitle}>Chỉnh sửa dự án</Text>
          <View style={styles.placeholder} />
        </View>

        <ScrollView
          style={styles.formContainer}
          contentContainerStyle={styles.formContent}
          keyboardShouldPersistTaps="handled"
        >
          <View style={styles.inputGroup}>
            <Text style={styles.label}>
              Tên dự án <Text style={styles.required}>*</Text>
            </Text>
            <TextInput
              style={styles.input}
              value={formData.name}
              onChangeText={(text) => handleChange('name', text)}
              placeholder="Nhập tên dự án"
            />
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Mô tả</Text>
            <TextInput
              style={[styles.input, styles.textArea]}
              value={formData.description}
              onChangeText={(text) => handleChange('description', text)}
              placeholder="Nhập mô tả dự án"
              multiline
              numberOfLines={3}
            />
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Khách hàng</Text>
            {formData.customerName ? (
              <View style={styles.selectedCustomerContainer}>
                <View style={styles.selectedCustomer}>
                  <Ionicons name="business-outline" size={20} color="#0066cc" />
                  <Text style={styles.selectedCustomerText}>
                    {formData.customerName}
                  </Text>
                </View>
                <TouchableOpacity
                  style={styles.clearCustomerButton}
                  onPress={handleClearCustomer}
                >
                  <Ionicons name="close-circle" size={20} color="#999" />
                </TouchableOpacity>
              </View>
            ) : (
              <TouchableOpacity
                style={styles.customerSelectButton}
                onPress={handleOpenCustomerModal}
              >
                <Ionicons name="add-circle-outline" size={20} color="#0066cc" />
                <Text style={styles.customerSelectButtonText}>
                  Chọn khách hàng
                </Text>
              </TouchableOpacity>
            )}
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Trạng thái</Text>
            <View style={styles.statusButtonsContainer}>
              <TouchableOpacity
                style={[
                  styles.statusButton,
                  formData.status === 'pending' && styles.selectedStatusButton,
                ]}
                onPress={() => handleSelectStatus('pending')}
              >
                <Text
                  style={[
                    styles.statusButtonText,
                    formData.status === 'pending' &&
                      styles.selectedStatusButtonText,
                  ]}
                >
                  Chờ xử lý
                </Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.statusButton,
                  formData.status === 'in-progress' &&
                    styles.selectedStatusButton,
                ]}
                onPress={() => handleSelectStatus('in-progress')}
              >
                <Text
                  style={[
                    styles.statusButtonText,
                    formData.status === 'in-progress' &&
                      styles.selectedStatusButtonText,
                  ]}
                >
                  Đang thực hiện
                </Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.statusButton,
                  formData.status === 'completed' &&
                    styles.selectedStatusButton,
                ]}
                onPress={() => handleSelectStatus('completed')}
              >
                <Text
                  style={[
                    styles.statusButtonText,
                    formData.status === 'completed' &&
                      styles.selectedStatusButtonText,
                  ]}
                >
                  Hoàn thành
                </Text>
              </TouchableOpacity>
            </View>

            <View style={[styles.statusButtonsContainer, { marginTop: 8 }]}>
              <TouchableOpacity
                style={[
                  styles.statusButton,
                  formData.status === 'cancelled' &&
                    styles.selectedStatusButton,
                ]}
                onPress={() => handleSelectStatus('cancelled')}
              >
                <Text
                  style={[
                    styles.statusButtonText,
                    formData.status === 'cancelled' &&
                      styles.selectedStatusButtonText,
                  ]}
                >
                  Đã hủy
                </Text>
              </TouchableOpacity>
            </View>
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Ngày bắt đầu</Text>
            <TouchableOpacity
              style={styles.dateButton}
              onPress={() => setShowStartDatePicker(true)}
            >
              <Ionicons name="calendar-outline" size={20} color="#0066cc" />
              <Text style={styles.dateButtonText}>
                {formData.startDate
                  ? formatDate(formData.startDate)
                  : 'Chọn ngày bắt đầu'}
              </Text>
            </TouchableOpacity>
            {showStartDatePicker && (
              <DateTimePicker
                value={formData.startDate || new Date()}
                mode="date"
                display="default"
                onChange={handleStartDateChange}
              />
            )}
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Số ngày thi công</Text>
            <TextInput
              style={styles.input}
              value={formData.durationInDays}
              onChangeText={handleDurationChange}
              placeholder="Nhập số ngày thi công"
              keyboardType="numeric"
            />
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Ngày kết thúc (tự động tính)</Text>
            <View style={styles.readOnlyField}>
              <Ionicons name="calendar-outline" size={20} color="#666" />
              <Text style={styles.readOnlyText}>
                {formData.endDate
                  ? formatDate(formData.endDate)
                  : 'Chưa xác định'}
              </Text>
            </View>
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Vị trí thi công</Text>
            <View style={styles.locationButtonsContainer}>
              <TouchableOpacity
                style={[
                  styles.locationButton,
                  formData.location === 'workshop' &&
                    styles.selectedLocationButton,
                ]}
                onPress={() => handleLocationChange('workshop')}
              >
                <Text
                  style={[
                    styles.locationButtonText,
                    formData.location === 'workshop' &&
                      styles.selectedLocationButtonText,
                  ]}
                >
                  Tại xưởng
                </Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.locationButton,
                  formData.location === 'site' && styles.selectedLocationButton,
                ]}
                onPress={() => handleLocationChange('site')}
              >
                <Text
                  style={[
                    styles.locationButtonText,
                    formData.location === 'site' &&
                      styles.selectedLocationButtonText,
                  ]}
                >
                  Tại công trình
                </Text>
              </TouchableOpacity>
            </View>
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Ngân sách</Text>
            <TextInput
              style={styles.input}
              value={formData.budget}
              onChangeText={(text) => handleChange('budget', text)}
              placeholder="Nhập ngân sách dự án"
              keyboardType="numeric"
            />
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Ghi chú</Text>
            <TextInput
              style={[styles.input, styles.textArea]}
              value={formData.notes}
              onChangeText={(text) => handleChange('notes', text)}
              placeholder="Nhập ghi chú"
              multiline
              numberOfLines={3}
            />
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Quy trình Sản xuất</Text>
            <DraggableFlatList
              data={workflowStages}
              keyExtractor={(item) => item.stageId}
              onDragEnd={({ data }) => setWorkflowStages(data)}
              renderItem={renderStageItem}
              scrollEnabled={false}
            />
            <TouchableOpacity
              style={styles.addStageBtn}
              onPress={() => setPickerVisible(true)}
            >
              <Ionicons name="add-circle-outline" size={20} color="#0066cc" />
              <Text style={styles.addStageText}>Thêm Công đoạn</Text>
            </TouchableOpacity>
          </View>
        </ScrollView>

        <View style={styles.footer}>
          <TouchableOpacity
            style={styles.saveButton}
            onPress={handleUpdate}
            disabled={isLoading}
          >
            {isLoading ? (
              <ActivityIndicator color="#fff" size="small" />
            ) : (
              <>
                <Ionicons name="save-outline" size={20} color="#fff" />
                <Text style={styles.saveButtonText}>Lưu thay đổi</Text>
              </>
            )}
          </TouchableOpacity>
        </View>

        {/* Modal chọn khách hàng */}
        <Modal
          visible={customerModalVisible}
          animationType="slide"
          transparent={true}
          onRequestClose={handleCloseCustomerModal}
        >
          <View style={styles.modalContainer}>
            <View style={styles.modalContent}>
              <View style={styles.modalHeader}>
                <Text style={styles.modalTitle}>Chọn khách hàng</Text>
                <TouchableOpacity
                  style={styles.closeButton}
                  onPress={handleCloseCustomerModal}
                >
                  <Ionicons name="close" size={24} color="#333" />
                </TouchableOpacity>
              </View>

              <View style={styles.searchContainer}>
                <Ionicons
                  name="search"
                  size={20}
                  color="#999"
                  style={styles.searchIcon}
                />
                <TextInput
                  style={styles.searchInput}
                  placeholder="Tìm kiếm khách hàng..."
                  value={customerSearchQuery}
                  onChangeText={handleSearchCustomer}
                />
                {customerSearchQuery.length > 0 && (
                  <TouchableOpacity
                    onPress={() => setCustomerSearchQuery('')}
                    style={styles.clearSearchButton}
                  >
                    <Ionicons name="close-circle" size={18} color="#999" />
                  </TouchableOpacity>
                )}
              </View>

              {loadingCustomers ? (
                <View style={styles.loadingContainer}>
                  <ActivityIndicator size="large" color="#0066cc" />
                  <Text style={styles.loadingText}>
                    Đang tải danh sách khách hàng...
                  </Text>
                </View>
              ) : (
                <FlatList
                  data={filteredCustomers}
                  keyExtractor={(item) => item.id}
                  renderItem={renderCustomerItem}
                  contentContainerStyle={styles.customersList}
                  ListEmptyComponent={() => (
                    <View style={styles.emptyListContainer}>
                      <Ionicons name="search-outline" size={40} color="#ccc" />
                      <Text style={styles.emptyListText}>
                        Không tìm thấy khách hàng phù hợp
                      </Text>
                    </View>
                  )}
                />
              )}
            </View>
          </View>
        </Modal>

        <ProcessPickerModal
          visible={pickerVisible}
          onClose={() => setPickerVisible(false)}
          onConfirm={handleAddStages}
          existingStageKeys={workflowStages.map((s) => s.processKey)}
        />
      </KeyboardAvoidingView>
    </GestureHandlerRootView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  placeholder: {
    width: 24,
  },
  formContainer: {
    flex: 1,
  },
  formContent: {
    padding: 16,
  },
  inputGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    marginBottom: 6,
    color: '#333',
  },
  required: {
    color: '#e74c3c',
  },
  input: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    color: '#333',
  },
  textArea: {
    minHeight: 80,
    textAlignVertical: 'top',
  },
  statusButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  statusButton: {
    flex: 1,
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 8,
    borderRadius: 8,
    marginHorizontal: 4,
    alignItems: 'center',
  },
  selectedStatusButton: {
    backgroundColor: '#0066cc',
  },
  statusButtonText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '500',
  },
  selectedStatusButtonText: {
    color: '#fff',
  },
  // Thêm style cho các trường mới
  dateButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
  },
  dateButtonText: {
    fontSize: 16,
    color: '#333',
    marginLeft: 8,
  },
  locationButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  locationButton: {
    flex: 1,
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 8,
    borderRadius: 8,
    marginHorizontal: 4,
    alignItems: 'center',
  },
  selectedLocationButton: {
    backgroundColor: '#0066cc',
  },
  locationButtonText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '500',
  },
  selectedLocationButtonText: {
    color: '#fff',
  },
  customerSelectButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
  },
  customerSelectButtonText: {
    fontSize: 16,
    color: '#0066cc',
    marginLeft: 8,
  },
  selectedCustomerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
  },
  selectedCustomer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  selectedCustomerText: {
    fontSize: 16,
    color: '#333',
    marginLeft: 8,
  },
  clearCustomerButton: {
    padding: 4,
  },
  footer: {
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  saveButton: {
    backgroundColor: '#0066cc',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    borderRadius: 8,
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  modalContainer: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: '#fff',
    borderTopLeftRadius: 16,
    borderTopRightRadius: 16,
    height: '80%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  closeButton: {
    padding: 4,
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    margin: 16,
    borderRadius: 8,
    paddingHorizontal: 12,
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    height: 40,
    fontSize: 16,
  },
  clearSearchButton: {
    padding: 4,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
  },
  customersList: {
    padding: 16,
    paddingTop: 0,
  },
  customerItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#f9f9f9',
    padding: 12,
    borderRadius: 8,
    marginBottom: 8,
  },
  selectedCustomerItem: {
    borderWidth: 1,
    borderColor: '#0066cc',
    backgroundColor: '#f0f7ff',
  },
  customerName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 2,
  },
  customerDetail: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  emptyListContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 40,
  },
  emptyListText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  readOnlyField: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
  },
  readOnlyText: {
    fontSize: 16,
    color: '#666',
    marginLeft: 8,
  },
  stageRow: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    marginBottom: 8,
    backgroundColor: '#fff',
  },
  dragHandle: {
    padding: 4,
    marginRight: 8,
  },
  stageInfo: { flex: 1 },
  statusBadge: {
    alignSelf: 'flex-start',
    marginTop: 4,
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  statusBadgeText: { fontSize: 12, fontWeight: '500' },
  deleteStageBtn: { padding: 4, marginLeft: 8 },
  addStageBtn: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
    marginTop: 16,
  },
  addStageText: {
    fontSize: 16,
    color: '#0066cc',
    marginLeft: 8,
  },
});

export default EditProjectScreen;

// src/screens/EditSupplierScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  ScrollView,
  Alert,
  ActivityIndicator,
  SafeAreaView,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { getSupplierById, updateSupplier } from '../api/supplierService';
import { useAuth } from '../contexts/AuthContext';

const MATERIAL_CATEGORIES = [
  'Thép',
  'Gỗ',
  'Kính',
  'Nhôm',
  'Điện',
  'Nước',
  'Sơn',
  'Gạch',
  'Xi măng',
  'Thiết bị vệ sinh',
  'Thiết bị điện',
  'Vật liệu hoàn thiện',
  'Sắt',
  'Inox',
  'Phụ kiện',
  'Măng sông',
  'Thiết bị hàn',
  'Khí hàn',
  'Khác',
];

const EditSupplierScreen = ({ route, navigation }) => {
  const { supplier: initialSupplier } = route.params;
  const { currentUser } = useAuth();
  const [formData, setFormData] = useState({
    name: '',
    contactName: '',
    phone: '',
    email: '',
    address: '',
    taxCode: '',
    bankAccount: '',
    bankName: '',
    description: '',
    categories: [],
    verified: false,
  });
  const [errors, setErrors] = useState({});
  const [saving, setSaving] = useState(false);
  const [loading, setLoading] = useState(true);

  // Tải dữ liệu nhà cung cấp
  useEffect(() => {
    const loadSupplierData = async () => {
      try {
        if (initialSupplier) {
          // Nếu đã có dữ liệu từ route params, sử dụng nó
          setFormData({
            ...initialSupplier,
            categories: initialSupplier.categories || [],
          });
          setLoading(false);
        } else if (route.params?.supplierId) {
          // Nếu chỉ có ID, tải dữ liệu từ Firestore
          const supplierData = await getSupplierById(route.params.supplierId);
          setFormData({
            ...supplierData,
            categories: supplierData.categories || [],
          });
          setLoading(false);
        } else {
          // Không có dữ liệu
          Alert.alert('Lỗi', 'Không tìm thấy thông tin nhà cung cấp');
          navigation.goBack();
        }
      } catch (error) {
        console.error('Lỗi khi tải dữ liệu nhà cung cấp:', error);
        Alert.alert('Lỗi', 'Không thể tải thông tin nhà cung cấp');
        navigation.goBack();
      }
    };

    loadSupplierData();
  }, [route.params, initialSupplier, navigation]);

  const handleChange = (field, value) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));

    // Clear error when field is edited
    if (errors[field]) {
      setErrors((prev) => ({
        ...prev,
        [field]: null,
      }));
    }
  };

  const toggleCategory = (category) => {
    setFormData((prev) => {
      const updatedCategories = [...prev.categories];

      if (updatedCategories.includes(category)) {
        // Remove category if already selected
        return {
          ...prev,
          categories: updatedCategories.filter((c) => c !== category),
        };
      } else {
        // Add category if not selected
        return {
          ...prev,
          categories: [...updatedCategories, category],
        };
      }
    });
  };

  const validateForm = () => {
    const newErrors = {};

    if (!formData.name.trim()) {
      newErrors.name = 'Vui lòng nhập tên nhà cung cấp';
    }

    if (formData.phone && !/^[0-9]{10,11}$/.test(formData.phone.trim())) {
      newErrors.phone = 'Số điện thoại không hợp lệ';
    }

    if (formData.email && !/\S+@\S+\.\S+/.test(formData.email.trim())) {
      newErrors.email = 'Email không hợp lệ';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async () => {
    if (!validateForm()) {
      Alert.alert('Lỗi', 'Vui lòng kiểm tra lại thông tin nhập');
      return;
    }

    setSaving(true);
    try {
      // Thêm thông tin người cập nhật
      const updatedData = {
        ...formData,
        updatedBy: currentUser?.uid || 'unknown',
        updatedByName:
          currentUser?.displayName || currentUser?.email || 'Người dùng',
      };

      await updateSupplier(formData.id, updatedData);
      Alert.alert('Thành công', 'Đã cập nhật thông tin nhà cung cấp', [
        { text: 'OK', onPress: () => navigation.goBack() },
      ]);
    } catch (error) {
      console.error('Lỗi khi cập nhật nhà cung cấp:', error);
      Alert.alert(
        'Lỗi',
        'Không thể cập nhật thông tin nhà cung cấp. Vui lòng thử lại sau.'
      );
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return (
      <SafeAreaView style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0066cc" />
        <Text style={styles.loadingText}>Đang tải dữ liệu...</Text>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={{ flex: 1 }}
      >
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
          >
            <Ionicons name="arrow-back" size={24} color="#333" />
          </TouchableOpacity>
          <Text style={styles.headerTitle}>Chỉnh sửa nhà cung cấp</Text>
          <View style={{ width: 24 }} />
        </View>

        <ScrollView style={styles.content}>
          <View style={styles.formGroup}>
            <Text style={styles.label}>
              Tên nhà cung cấp <Text style={styles.required}>*</Text>
            </Text>
            <TextInput
              style={[styles.input, errors.name && styles.inputError]}
              value={formData.name}
              onChangeText={(text) => handleChange('name', text)}
              placeholder="Nhập tên nhà cung cấp"
            />
            {errors.name && <Text style={styles.errorText}>{errors.name}</Text>}
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Người liên hệ</Text>
            <TextInput
              style={styles.input}
              value={formData.contactName}
              onChangeText={(text) => handleChange('contactName', text)}
              placeholder="Nhập tên người liên hệ"
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Số điện thoại</Text>
            <TextInput
              style={[styles.input, errors.phone && styles.inputError]}
              value={formData.phone}
              onChangeText={(text) => handleChange('phone', text)}
              placeholder="Nhập số điện thoại"
              keyboardType="phone-pad"
            />
            {errors.phone && (
              <Text style={styles.errorText}>{errors.phone}</Text>
            )}
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Email</Text>
            <TextInput
              style={[styles.input, errors.email && styles.inputError]}
              value={formData.email}
              onChangeText={(text) => handleChange('email', text)}
              placeholder="Nhập địa chỉ email"
              keyboardType="email-address"
              autoCapitalize="none"
            />
            {errors.email && (
              <Text style={styles.errorText}>{errors.email}</Text>
            )}
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Địa chỉ</Text>
            <TextInput
              style={styles.input}
              value={formData.address}
              onChangeText={(text) => handleChange('address', text)}
              placeholder="Nhập địa chỉ"
              multiline
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Mã số thuế</Text>
            <TextInput
              style={styles.input}
              value={formData.taxCode}
              onChangeText={(text) => handleChange('taxCode', text)}
              placeholder="Nhập mã số thuế"
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Tài khoản ngân hàng</Text>
            <TextInput
              style={styles.input}
              value={formData.bankAccount}
              onChangeText={(text) => handleChange('bankAccount', text)}
              placeholder="Nhập số tài khoản"
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Tên ngân hàng</Text>
            <TextInput
              style={styles.input}
              value={formData.bankName}
              onChangeText={(text) => handleChange('bankName', text)}
              placeholder="Nhập tên ngân hàng"
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Danh mục vật tư cung cấp</Text>
            <View style={styles.categoriesContainer}>
              {MATERIAL_CATEGORIES.map((category, index) => (
                <TouchableOpacity
                  key={index}
                  style={[
                    styles.categoryTag,
                    formData.categories.includes(category) &&
                      styles.categoryTagSelected,
                  ]}
                  onPress={() => toggleCategory(category)}
                >
                  <Text
                    style={[
                      styles.categoryText,
                      formData.categories.includes(category) &&
                        styles.categoryTextSelected,
                    ]}
                  >
                    {category}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Mô tả</Text>
            <TextInput
              style={[styles.input, styles.textArea]}
              value={formData.description}
              onChangeText={(text) => handleChange('description', text)}
              placeholder="Nhập mô tả về nhà cung cấp"
              multiline
              numberOfLines={4}
              textAlignVertical="top"
            />
          </View>

          <View style={styles.verifiedContainer}>
            <TouchableOpacity
              style={styles.checkboxContainer}
              onPress={() => handleChange('verified', !formData.verified)}
            >
              <View
                style={[
                  styles.checkbox,
                  formData.verified && styles.checkboxChecked,
                ]}
              >
                {formData.verified && (
                  <Ionicons name="checkmark" size={16} color="#fff" />
                )}
              </View>
              <Text style={styles.checkboxLabel}>Đã xác minh</Text>
            </TouchableOpacity>
          </View>

          <TouchableOpacity
            style={styles.saveButton}
            onPress={handleSubmit}
            disabled={saving}
          >
            {saving ? (
              <ActivityIndicator color="#fff" size="small" />
            ) : (
              <Text style={styles.saveButtonText}>Cập nhật</Text>
            )}
          </TouchableOpacity>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  loadingText: {
    marginTop: 12,
    color: '#666',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  content: {
    flex: 1,
    padding: 16,
  },
  formGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    color: '#333',
    marginBottom: 6,
  },
  required: {
    color: 'red',
  },
  input: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    fontSize: 16,
  },
  inputError: {
    borderColor: 'red',
  },
  errorText: {
    color: 'red',
    fontSize: 12,
    marginTop: 4,
  },
  textArea: {
    minHeight: 100,
    textAlignVertical: 'top',
  },
  categoriesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginTop: 8,
  },
  categoryTag: {
    backgroundColor: '#f0f0f0',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 16,
    marginRight: 8,
    marginBottom: 8,
  },
  categoryTagSelected: {
    backgroundColor: '#e6f2ff',
    borderWidth: 1,
    borderColor: '#0066cc',
  },
  categoryText: {
    fontSize: 14,
    color: '#666',
  },
  categoryTextSelected: {
    color: '#0066cc',
    fontWeight: '500',
  },
  verifiedContainer: {
    marginBottom: 24,
  },
  checkboxContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  checkbox: {
    width: 20,
    height: 20,
    borderRadius: 4,
    borderWidth: 1,
    borderColor: '#999',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 8,
  },
  checkboxChecked: {
    backgroundColor: '#0066cc',
    borderColor: '#0066cc',
  },
  checkboxLabel: {
    fontSize: 16,
    color: '#333',
  },
  saveButton: {
    backgroundColor: '#0066cc',
    paddingVertical: 14,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 30,
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
});

export default EditSupplierScreen;

//src/screens/FinalizeQuotationScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  Alert,
  ActivityIndicator,
  Linking,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import * as FileSystem from 'expo-file-system';
import * as Sharing from 'expo-sharing';
import { getAuth } from 'firebase/auth';
import { saveQuotation } from '../api/quotationService';
import useQuotationGenerator from '../hooks/useQuotationGenerator';
import useContractGenerator from '../hooks/useContractGenerator';
import { getFunctions, httpsCallable } from 'firebase/functions';

// HTML2PDF API key
// const HTML2PDF_API_KEY = 'Uvwhf4HC3SED5GIYlCx1F8A6jq2r3iJEt3FH8C16u1LprY5J5hBNXGIVfsLtqRxH';
// const HTML2PDF_API_URL = 'https://api.html2pdf.app/v1/generate';

// Hàm chuyển đổi số thành chữ tiếng Việt
const convertNumberToWords = (number) => {
  // Mảng từ ngữ cho các số
  const units = [
    'không',
    'một',
    'hai',
    'ba',
    'bốn',
    'năm',
    'sáu',
    'bảy',
    'tám',
    'chín',
  ];
  const teens = [
    'mười',
    'mười một',
    'mười hai',
    'mười ba',
    'mười bốn',
    'mười lăm',
    'mười sáu',
    'mười bảy',
    'mười tám',
    'mười chín',
  ];
  const tens = [
    '',
    'mười',
    'hai mươi',
    'ba mươi',
    'bốn mươi',
    'năm mươi',
    'sáu mươi',
    'bảy mươi',
    'tám mươi',
    'chín mươi',
  ];
  const scales = ['', 'nghìn', 'triệu', 'tỷ', 'nghìn tỷ', 'triệu tỷ'];

  // Hàm xử lý số có 3 chữ số
  const handleHundreds = (num, isFirstGroup) => {
    let result = '';
    const originalNum = num;

    // Xử lý hàng trăm
    if (num >= 100) {
      result += units[Math.floor(num / 100)] + ' trăm ';
      num %= 100;
    }

    // Xử lý hàng chục và đơn vị
    if (num > 0) {
      // Chỉ thêm "lẻ" nếu nó không phải là nhóm đầu tiên (nhóm đơn vị) và số có 1 chữ số
      // hoặc nếu hàng trăm của nhóm đó > 0
      if (num < 10 && !isFirstGroup && originalNum > 99) {
        if (num === 1 && Math.floor(originalNum / 100) > 0) {
          result += 'linh một'; // Sử dụng "linh một" thay vì "lẻ một"
        } else {
          result += 'lẻ ' + units[num];
        }
      } else if (num < 10) {
        result += units[num];
      } else if (num < 20) {
        // Nếu số dư < 20, sử dụng mảng teens
        result += teens[num - 10];
      } else {
        // Nếu số dư >= 20
        const ten = Math.floor(num / 10);
        const unit = num % 10;
        result += tens[ten];
        if (unit > 0) {
          // Xử lý trường hợp đặc biệt cho "mốt" và "lăm"
          if (unit === 1 && ten > 1) {
            result += ' mốt';
          } else if (unit === 5 && ten > 0) {
            result += ' lăm';
          } else {
            result += ' ' + units[unit];
          }
        }
      }
    }

    return result.trim();
  };

  // Hàm chính để chuyển đổi số thành chữ
  const convert = (num) => {
    if (num === 0) return 'không';

    let result = '';
    let scaleIndex = 0;

    // Xử lý số theo từng nhóm 3 chữ số
    while (num > 0) {
      const group = num % 1000;
      if (group !== 0) {
        const isFirstGroup = scaleIndex === 0;
        const groupText = handleHundreds(group, isFirstGroup);
        result =
          groupText +
          (scaleIndex > 0 ? ' ' + scales[scaleIndex] + ' ' : '') +
          result;
      }

      num = Math.floor(num / 1000);
      scaleIndex++;
    }

    return result.trim().replace(/\s\s+/g, ' '); // Loại bỏ khoảng trắng thừa
  };

  // Xử lý số tiền (chỉ lấy phần nguyên)
  const integerPart = Math.floor(number);

  let result = convert(integerPart) + ' đồng';

  // Viết hoa chữ cái đầu
  return result.charAt(0).toUpperCase() + result.slice(1);
};

const FinalizeQuotationScreen = ({ route, navigation }) => {
  const {
    materials: newMaterials,
    subTotal: newSubTotal,
    projectId,
    projectName,
    customerData,
    initialData,
  } = route.params;

  // Determine if we are re-quoting and calculate subTotal accordingly
  const isRequoting = !!initialData;
  const materialsData = isRequoting ? initialData.materials : newMaterials;

  const subTotalData = isRequoting
    ? initialData.materials.reduce(
        (acc, item) => acc + (item.totalPrice || 0),
        0
      )
    : newSubTotal;

  // Initialize the quotation generator hook
  const {
    generateExcelQuotation,
    shareExcelQuotation,
    isLoading: isExcelLoading,
    excelUrl,
  } = useQuotationGenerator({
    projectId,
    customerData,
    materials: materialsData,
  });

  // Initialize the contract generator hook
  const {
    generateContract,
    shareContractDoc,
    isLoading: isContractLoading,
    contractDocUrl,
  } = useContractGenerator({
    projectId,
    customerData,
    materials: materialsData,
    quotationData: {
      deliveryTime,
      paymentTerms,
      warrantyTerms,
    },
  });

  // Use initialData if it exists (for re-quoting), otherwise use new data
  const sourceData = initialData || route.params;

  // State cho các trường nhập liệu
  const [discountPercentage, setDiscountPercentage] = useState(
    sourceData.discountPercentage?.toString() || '0'
  );
  const [vatPercentage, setVatPercentage] = useState(
    sourceData.vatPercentage?.toString() || '10'
  );
  const [quoteValidity, setQuoteValidity] = useState(
    sourceData.quoteValidity || '7 ngày'
  );
  const [deliveryTime, setDeliveryTime] = useState(
    sourceData.deliveryTime || '15 ngày'
  );
  const [notes, setNotes] = useState(sourceData.notes || '');
  const [paymentTerms, setPaymentTerms] = useState(
    sourceData.paymentTerms ||
      'Đợt 1: Thanh toán 50% ngay sau khi ký hợp đồng.\nĐợt 2: Thanh toán 50% còn lại sau khi nghiệm thu và bàn giao.'
  );
  const [warrantyTerms, setWarrantyTerms] = useState(
    sourceData.warrantyTerms || 'Bảo hành 12 tháng cho toàn bộ công trình.'
  );
  const [otherTerms, setOtherTerms] = useState(sourceData.otherTerms || '');
  const [bankDetails, setBankDetails] = useState(
    sourceData.bankDetails ||
      'Tên tài khoản: CÔNG TY TNHH ABC\nSố tài khoản: 123456789\nNgân hàng: Vietcombank - Chi nhánh XYZ'
  );

  // State cho các giá trị tính toán
  const [discountAmount, setDiscountAmount] = useState(0);
  const [afterDiscountTotal, setAfterDiscountTotal] = useState(subTotalData);
  const [vatAmount, setVatAmount] = useState(0);
  const [grandTotal, setGrandTotal] = useState(subTotalData);
  const [amountInWords, setAmountInWords] = useState('');

  // State cho quá trình tạo PDF và Excel
  const [isLoading, setIsLoading] = useState(false);
  const [pdfLocalUri, setPdfLocalUri] = useState(null);
  const [materials, setMaterials] = useState(materialsData || []);

  // Tính toán lại các giá trị khi người dùng thay đổi đầu vào
  useEffect(() => {
    // Defensive calculations to prevent NaN issues
    const safeSubTotal = Number(subTotalData) || 0;
    const discountPercent = parseFloat(discountPercentage) || 0;
    const vatPercent = parseFloat(vatPercentage) || 0;

    // Calculate all financial values as local constants
    const calculatedDiscountAmount = (safeSubTotal * discountPercent) / 100;
    const calculatedAfterDiscountTotal =
      safeSubTotal - calculatedDiscountAmount;
    const calculatedVatAmount =
      (calculatedAfterDiscountTotal * vatPercent) / 100;
    const calculatedGrandTotal =
      calculatedAfterDiscountTotal + calculatedVatAmount;
    const calculatedAmountInWords = convertNumberToWords(calculatedGrandTotal);

    // Update all states at once
    setDiscountAmount(calculatedDiscountAmount);
    setAfterDiscountTotal(calculatedAfterDiscountTotal);
    setVatAmount(calculatedVatAmount);
    setGrandTotal(calculatedGrandTotal);
    setAmountInWords(calculatedAmountInWords);
  }, [subTotalData, discountPercentage, vatPercentage]);

  const handleGenerateAndSave = async () => {
    setIsLoading(true);
    setPdfLocalUri(null); // Reset previous URI

    try {
      const auth = getAuth();
      const userId = auth.currentUser?.uid;

      if (!userId) {
        Alert.alert('Lỗi', 'Bạn cần đăng nhập để tạo báo giá.');
        setIsLoading(false); // Stop loading on error
        return;
      }

      const effectiveProjectId = projectId || route?.params?.projectId;

      if (!effectiveProjectId) {
        Alert.alert('Lỗi', 'Không tìm thấy thông tin dự án. Vui lòng thử lại.');
        setIsLoading(false);
        return;
      }

      // 1. Chuẩn bị dữ liệu báo giá
      const quotationNumber = `HK-${new Date().getFullYear()}-${Math.floor(
        Math.random() * 1000
      )
        .toString()
        .padStart(3, '0')}`;

      // Assemble the complete, self-contained quotation object for versioning
      // This is the complete snapshot sent to the Cloud Function and saved to Firestore.
      const quotationDataForSaving = {
        // Core Info
        quotationNumber,
        createdBy: userId,
        projectName: projectName,
        quotationDate: new Date().toISOString(),

        // Customer Info
        customerData: customerData,

        // Financial Snapshot (Using state values)
        subTotal: subTotalData,
        discountPercentage: parseFloat(discountPercentage) || 0,
        discountAmount: discountAmount,
        afterDiscountTotal: afterDiscountTotal,
        vatPercentage: parseFloat(vatPercentage) || 0,
        vatAmount: vatAmount,
        grandTotal: grandTotal,
        amountInWords: amountInWords,

        // Materials Snapshot
        materials: materials,

        // Terms Snapshot
        quoteValidity: quoteValidity,
        deliveryTime: deliveryTime,
        paymentTerms: paymentTerms,
        warrantyTerms: warrantyTerms,
        otherTerms: otherTerms,
        bankDetails: bankDetails,
        notes: notes,
      };

      // 2. Gọi Cloud Function để lấy URL của PDF
      console.log('Calling Cloud Function with complete data payload...');
      const functions = getFunctions();
      const generateInvoicePDF = httpsCallable(functions, 'generateInvoicePDF');
      const result = await generateInvoicePDF({
        userId,
        quotationData: quotationDataForSaving, // Pass the self-contained data
        projectId: effectiveProjectId,
      });

      const { pdfUrl } = result.data;
      if (!pdfUrl) {
        throw new Error('Không nhận được URL của PDF từ server.');
      }
      console.log('Received PDF URL:', pdfUrl);

      // 3. Tải file PDF về máy để lấy local URI
      console.log('Downloading PDF to local device...');
      const fileUri = FileSystem.documentDirectory + `${quotationNumber}.pdf`;
      const { uri } = await FileSystem.downloadAsync(pdfUrl, fileUri);
      console.log('File downloaded to:', uri);

      // Lưu local URI vào state để có thể chia sẻ sau
      setPdfLocalUri(uri);

      // 4. Lưu thông tin báo giá vào Firestore, now including the pdfUrl
      await saveQuotation(effectiveProjectId, {
        ...quotationDataForSaving,
        pdfUrl,
      });

      // 5. Thông báo thành công
      Alert.alert(
        'Thành công',
        'Đã tạo và lưu báo giá thành công. Bạn có muốn xem hoặc chia sẻ file PDF không?',
        [
          { text: 'Để sau', style: 'cancel' },
          { text: 'Chia sẻ', onPress: () => handleSharePdf(uri) },
          { text: 'Xem PDF', onPress: () => handleSharePdf(uri) },
        ]
      );
    } catch (error) {
      console.error('Error generating PDF and saving quotation:', error);
      const errorMessage = error.message || 'Một lỗi không xác định đã xảy ra.';
      Alert.alert('Lỗi', `Không thể tạo báo giá: ${errorMessage}`);
    } finally {
      setIsLoading(false);
    }
  };

  // Hàm chia sẻ file PDF đã được tải về
  const handleSharePdf = async (localUri) => {
    if (!localUri) {
      Alert.alert(
        'Lỗi',
        'Không tìm thấy file PDF để chia sẻ. Vui lòng tạo lại.'
      );
      return;
    }
    const isSharingAvailable = await Sharing.isAvailableAsync();
    if (!isSharingAvailable) {
      Alert.alert('Lỗi', 'Chia sẻ không khả dụng trên thiết bị của bạn.');
      return;
    }
    try {
      await Sharing.shareAsync(localUri, {
        mimeType: 'application/pdf',
        dialogTitle: 'Chia sẻ báo giá',
      });
    } catch (error) {
      console.error('Error sharing PDF:', error);
      Alert.alert('Lỗi', 'Không thể chia sẻ file PDF.');
    }
  };

  // Hàm tạo báo giá Excel
  const handleGenerateExcel = async () => {
    try {
      const auth = getAuth();
      const userId = auth.currentUser?.uid;

      if (!userId) {
        Alert.alert('Lỗi', 'Bạn cần đăng nhập để tạo báo giá Excel.');
        return;
      }

      const effectiveProjectId = projectId || route?.params?.projectId;

      if (!effectiveProjectId) {
        Alert.alert('Lỗi', 'Không tìm thấy thông tin dự án. Vui lòng thử lại.');
        return;
      }

      // 1. Chuẩn bị dữ liệu báo giá
      const quotationNumber = `THP-${new Date().getFullYear()}-${Math.floor(
        Math.random() * 1000
      )
        .toString()
        .padStart(3, '0')}`;

      // Assemble the complete quotation data
      const quotationData = {
        // Core Info
        quotationNumber,
        createdBy: userId,
        projectName: projectName,
        quotationDate: new Date().toISOString(),

        // Customer Info - Đảm bảo dữ liệu khách hàng được gửi đúng định dạng
        metadata: {
          projectName: projectName,
          customerName: customerData?.name || '',
          customerAddress: customerData?.address || '',
          customerPhone: customerData?.phone || '',
          customerEmail: customerData?.email || '',
          customerTaxCode: customerData?.taxCode || '',
          customerContactPerson: customerData?.contactPerson || '',
          quotationNumber: quotationNumber,
          quoteValidity: quoteValidity,
          deliveryTime: deliveryTime,
        },

        // Financial Snapshot
        subTotal: subTotalData,
        discountPercentage: parseFloat(discountPercentage) || 0,
        discountAmount: discountAmount,
        afterDiscountTotal: afterDiscountTotal,
        vatPercentage: parseFloat(vatPercentage) || 0,
        vatAmount: vatAmount,
        grandTotal: grandTotal,
        amountInWords: amountInWords,

        // Materials Snapshot
        materials: materials.map((material) => ({
          no: material.no || material.id || 0,
          name: material.name || material.description || '',
          material: material.material || material.type || '',
          unit: material.unit || 'cái',
          quantity: material.quantity || 0,
          unitPrice: material.unitPrice || material.price || 0,
          total: material.totalPrice || material.total || 0,
          weight: material.weight || 0,
        })),

        // Terms Snapshot
        quoteValidity: quoteValidity,
        deliveryTime: deliveryTime,
        paymentTerms: paymentTerms,
        warrantyTerms: warrantyTerms,
        otherTerms: otherTerms,
        bankDetails: bankDetails,
        notes: notes,

        // Tổng hợp thông tin tài chính
        summary: {
          subTotal: subTotalData,
          vatPercentage: parseFloat(vatPercentage) || 0,
          vatAmount: vatAmount,
          grandTotal: grandTotal,
        },
      };

      // Gọi function tạo báo giá Excel
      const url = await generateExcelQuotation(quotationData);

      if (url) {
        Alert.alert(
          'Thành công',
          'Đã tạo báo giá Excel thành công. Bạn có muốn chia sẻ file Excel không?',
          [
            { text: 'Để sau', style: 'cancel' },
            { text: 'Chia sẻ', onPress: () => shareExcelQuotation() },
          ]
        );
      }
    } catch (error) {
      console.error('Error generating Excel:', error);
      Alert.alert(
        'Lỗi',
        `Không thể tạo báo giá Excel: ${error.message || 'Unknown error'}`
      );
    }
  };

  // Function to handle contract generation
  const handleGenerateContract = async () => {
    try {
      await generateContract();
    } catch (error) {
      console.error('Error generating contract:', error);
      Alert.alert('Lỗi', 'Không thể tạo hợp đồng: ' + error.message);
    }
  };

  // Format số tiền VND
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
    }).format(amount);
  };

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}
    >
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Hoàn thiện báo giá</Text>
        <View style={styles.placeholder} />
      </View>

      <ScrollView style={styles.content}>
        {/* Hiển thị tổng tiền vật tư */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Tổng cộng vật tư</Text>
          <Text style={styles.subTotalValue}>
            {formatCurrency(subTotalData)}
          </Text>
        </View>

        {/* Phần nhập chiết khấu và VAT */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Điều chỉnh giá</Text>

          <View style={styles.inputRow}>
            <Text style={styles.inputLabel}>Chiết khấu (%)</Text>
            <TextInput
              style={styles.input}
              value={discountPercentage}
              onChangeText={setDiscountPercentage}
              keyboardType="numeric"
              placeholder="0"
              maxLength={5}
            />
          </View>

          <View style={styles.inputRow}>
            <Text style={styles.inputLabel}>Thuế VAT (%)</Text>
            <TextInput
              style={styles.input}
              value={vatPercentage}
              onChangeText={setVatPercentage}
              keyboardType="numeric"
              placeholder="10"
              maxLength={5}
            />
          </View>
        </View>

        {/* Phần tóm tắt tính toán */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Tóm tắt</Text>

          <View style={styles.summaryRow}>
            <Text style={styles.summaryLabel}>Tổng cộng vật tư:</Text>
            <Text style={styles.summaryValue}>
              {formatCurrency(subTotalData)}
            </Text>
          </View>

          <View style={styles.summaryRow}>
            <Text style={styles.summaryLabel}>
              Chiết khấu ({discountPercentage}%):
            </Text>
            <Text style={styles.summaryValue}>
              - {formatCurrency(discountAmount)}
            </Text>
          </View>

          <View style={styles.summaryRow}>
            <Text style={styles.summaryLabel}>Tổng cộng sau chiết khấu:</Text>
            <Text style={styles.summaryValue}>
              {formatCurrency(afterDiscountTotal)}
            </Text>
          </View>

          <View style={styles.summaryRow}>
            <Text style={styles.summaryLabel}>
              Tiền thuế VAT ({vatPercentage}%):
            </Text>
            <Text style={styles.summaryValue}>{formatCurrency(vatAmount)}</Text>
          </View>

          <View style={[styles.summaryRow, styles.totalRow]}>
            <Text style={styles.totalLabel}>TỔNG CỘNG ĐÃ BAO GỒM VAT:</Text>
            <Text style={styles.totalValue}>{formatCurrency(grandTotal)}</Text>
          </View>

          <View style={styles.wordsContainer}>
            <Text style={styles.wordsLabel}>Bằng chữ:</Text>
            <Text style={styles.wordsValue}>{amountInWords}</Text>
          </View>
        </View>

        {/* Phần điều khoản */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Điều khoản báo giá</Text>

          <View style={styles.inputRow}>
            <Text style={styles.inputLabel}>Hiệu lực báo giá</Text>
            <TextInput
              style={styles.input}
              value={quoteValidity}
              onChangeText={setQuoteValidity}
              placeholder="7 ngày"
            />
          </View>

          <View style={styles.inputRow}>
            <Text style={styles.inputLabel}>Thời gian giao hàng</Text>
            <TextInput
              style={styles.input}
              value={deliveryTime}
              onChangeText={setDeliveryTime}
              placeholder="15 ngày"
            />
          </View>

          <View style={styles.notesContainer}>
            <Text style={styles.inputLabel}>Ghi chú</Text>
            <TextInput
              style={styles.notesInput}
              value={notes}
              onChangeText={setNotes}
              placeholder="Nhập ghi chú (ví dụ: + SƠN EPOXY)"
              multiline
              numberOfLines={3}
              textAlignVertical="top"
            />
          </View>

          <View style={styles.notesContainer}>
            <Text style={styles.inputLabel}>Phương thức thanh toán</Text>
            <TextInput
              style={styles.notesInput}
              value={paymentTerms}
              onChangeText={setPaymentTerms}
              placeholder="Nhập phương thức thanh toán"
              multiline
              numberOfLines={2}
              textAlignVertical="top"
            />
          </View>

          <View style={styles.notesContainer}>
            <Text style={styles.inputLabel}>Điều khoản bảo hành</Text>
            <TextInput
              style={styles.notesInput}
              value={warrantyTerms}
              onChangeText={setWarrantyTerms}
              placeholder="Nhập điều khoản bảo hành"
              multiline
              numberOfLines={2}
              textAlignVertical="top"
            />
          </View>

          <View style={styles.notesContainer}>
            <Text style={styles.inputLabel}>Thông tin ngân hàng</Text>
            <TextInput
              style={styles.notesInput}
              value={bankDetails}
              onChangeText={setBankDetails}
              placeholder="Nhập thông tin ngân hàng"
              multiline
              numberOfLines={3}
              textAlignVertical="top"
            />
          </View>

          <View style={styles.notesContainer}>
            <Text style={styles.inputLabel}>Điều khoản khác</Text>
            <TextInput
              style={styles.notesInput}
              value={otherTerms}
              onChangeText={setOtherTerms}
              placeholder="Nhập các điều khoản khác"
              multiline
              numberOfLines={2}
              textAlignVertical="top"
            />
          </View>
        </View>
      </ScrollView>

      {/* Nút tạo PDF và Excel */}
      <View style={styles.footer}>
        <TouchableOpacity
          style={[styles.button, { backgroundColor: '#4CAF50' }]}
          onPress={handleGenerateAndSave}
          disabled={isLoading}
        >
          {isLoading ? (
            <ActivityIndicator size="small" color="#fff" />
          ) : (
            <Text style={styles.buttonText}>Tạo & Lưu Báo Giá PDF</Text>
          )}
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.button, { backgroundColor: '#FF9800' }]}
          onPress={handleGenerateExcel}
          disabled={isExcelLoading}
        >
          {isExcelLoading ? (
            <ActivityIndicator size="small" color="#fff" />
          ) : (
            <>
              <Ionicons
                name="document-text"
                size={20}
                color="white"
                style={{ marginRight: 10 }}
              />
              <Text style={styles.buttonText}>Tạo Báo Giá Excel</Text>
            </>
          )}
        </TouchableOpacity>

        {/* Contract generation button */}
        <TouchableOpacity
          style={[styles.button, { backgroundColor: '#9C27B0' }]}
          onPress={handleGenerateContract}
          disabled={isContractLoading}
        >
          {isContractLoading ? (
            <ActivityIndicator size="small" color="#fff" />
          ) : (
            <>
              <Ionicons
                name="document-text"
                size={20}
                color="white"
                style={{ marginRight: 10 }}
              />
              <Text style={styles.buttonText}>Tạo Hợp Đồng</Text>
            </>
          )}
        </TouchableOpacity>

        {pdfLocalUri && (
          <TouchableOpacity
            style={[styles.button, { backgroundColor: '#2196F3' }]}
            onPress={() => handleSharePdf(pdfLocalUri)}
          >
            <Ionicons
              name="share-social"
              size={20}
              color="white"
              style={{ marginRight: 10 }}
            />
            <Text style={styles.buttonText}>Chia Sẻ PDF</Text>
          </TouchableOpacity>
        )}

        {/* Nút Chia Sẻ Hợp Đồng (chỉ hiển thị khi có link) */}
        {contractDocUrl && !isContractLoading && (
          <TouchableOpacity
            style={[styles.button, { backgroundColor: '#673AB7' }]}
            onPress={() => shareContractDoc()}
          >
            <Ionicons
              name="share-social"
              size={20}
              color="white"
              style={{ marginRight: 10 }}
            />
            <Text style={styles.buttonText}>Chia Sẻ Hợp Đồng</Text>
          </TouchableOpacity>
        )}

        {excelUrl && (
          <TouchableOpacity
            style={[styles.button, { backgroundColor: '#009688' }]}
            onPress={shareExcelQuotation}
          >
            <Ionicons
              name="share-social"
              size={20}
              color="white"
              style={{ marginRight: 10 }}
            />
            <Text style={styles.buttonText}>Chia Sẻ Excel</Text>
          </TouchableOpacity>
        )}
      </View>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F5F5',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  placeholder: {
    width: 24,
  },
  content: {
    flex: 1,
  },
  section: {
    backgroundColor: '#fff',
    marginBottom: 12,
    padding: 16,
    borderRadius: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginBottom: 16,
  },
  subTotalValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#0066cc',
  },
  inputRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  inputLabel: {
    fontSize: 16,
    color: '#555',
    flex: 1,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 6,
    padding: 10,
    fontSize: 16,
    width: '40%',
    textAlign: 'right',
  },
  notesContainer: {
    marginBottom: 16,
  },
  notesInput: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 6,
    padding: 10,
    fontSize: 16,
    marginTop: 8,
    height: 80,
  },
  summaryRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  summaryLabel: {
    fontSize: 16,
    color: '#555',
  },
  summaryValue: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
  },
  totalRow: {
    marginTop: 8,
    paddingTop: 12,
    borderTopWidth: 1,
    borderTopColor: '#ddd',
    borderBottomWidth: 0,
  },
  totalLabel: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  totalValue: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#0066cc',
  },
  wordsContainer: {
    marginTop: 16,
    padding: 12,
    backgroundColor: '#f5f5f5',
    borderRadius: 6,
  },
  wordsLabel: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
  },
  wordsValue: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    fontStyle: 'italic',
  },
  footer: {
    backgroundColor: '#fff',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 15,
    borderRadius: 8,
    marginVertical: 10,
    marginHorizontal: 20,
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
});

export default FinalizeQuotationScreen;

//src/screens/HomeScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  StatusBar,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { getProjects } from '../api/projectService';
import { getCustomers } from '../api/customerService';
import { useFocusEffect } from '@react-navigation/native';
import {
  getAttendance,
  clockIn,
  clockOut,
  addOvertime,
  getAttendanceStatus,
} from '../api/attendanceService';
import { useAuth } from '../contexts/AuthContext';

const HomeScreen = ({ navigation }) => {
  const { theme, isDarkMode } = useTheme();
  const { user } = useAuth();
  const [recentProjects, setRecentProjects] = useState([]);
  const [recentCustomers, setRecentCustomers] = useState([]);
  const [loading, setLoading] = useState(true);

  // Attendance state
  const [attendance, setAttendance] = useState(null);
  const [attLoading, setAttLoading] = useState(true);

  const ROLE_CAN_ATTEND = ['ke_toan'];

  const canUseAttendance = ROLE_CAN_ATTEND.includes(
    (user?.role || '').toLowerCase()
  );

  const loadAttendance = async () => {
    if (!user?.uid || !canUseAttendance) {
      setAttendance(null);
      setAttLoading(false);
      return;
    }
    try {
      setAttLoading(true);
      const doc = await getAttendance(user.uid);
      setAttendance(doc);
    } catch (err) {
      console.error('Load attendance error:', err);
    } finally {
      setAttLoading(false);
    }
  };

  // Hàm tải dữ liệu trang chủ
  const loadHomeData = async () => {
    try {
      setLoading(true);

      // Lấy danh sách dự án và khách hàng
      const projectsData = await getProjects();
      const customersData = await getCustomers();

      // Lấy 3 dự án mới nhất
      setRecentProjects(projectsData.slice(0, 3));

      // Lấy 3 khách hàng mới nhất
      setRecentCustomers(customersData.slice(0, 3));
    } catch (error) {
      console.error('Lỗi khi tải dữ liệu trang chủ:', error);
    } finally {
      setLoading(false);
    }
  };

  // Tải dữ liệu khi màn hình được mở
  useEffect(() => {
    loadHomeData();
    loadAttendance();
  }, []);

  // Làm mới dữ liệu khi màn hình được focus
  useFocusEffect(
    React.useCallback(() => {
      loadHomeData();
      loadAttendance();
    }, [])
  );

  const handleClockIn = async () => {
    try {
      setAttLoading(true);
      await clockIn(user.uid);
      loadAttendance();
    } catch (err) {
      console.error(err);
      Alert.alert('Lỗi', 'Không thể chấm công vào.');
    }
  };

  const handleClockOut = async () => {
    try {
      setAttLoading(true);
      await clockOut(user.uid);
      loadAttendance();
    } catch (err) {
      console.error(err);
      Alert.alert('Lỗi', 'Không thể chấm công ra.');
    }
  };

  const handleAddOvertime = async (hours) => {
    try {
      setAttLoading(true);
      await addOvertime(user.uid, hours);
      loadAttendance();
    } catch (err) {
      console.error(err);
      Alert.alert('Lỗi', 'Không thể thêm giờ tăng ca.');
    }
  };

  // Xử lý khi người dùng nhấn vào dự án
  const handleProjectPress = (project) => {
    navigation.navigate('ProjectDetail', { projectId: project.id });
  };

  // Xử lý khi người dùng nhấn vào khách hàng
  const handleCustomerPress = (customer) => {
    navigation.navigate('CustomerDetail', { customerId: customer.id });
  };

  // Xử lý khi người dùng nhấn vào nút xem tất cả dự án
  const handleViewAllProjects = () => {
    navigation.navigate('Projects');
  };

  // Xử lý khi người dùng nhấn vào nút xem tất cả khách hàng
  const handleViewAllCustomers = () => {
    navigation.navigate('Customers');
  };

  // Hàm lấy màu trạng thái dự án
  const getStatusColor = (status) => {
    switch (status) {
      case 'completed':
        return theme.statusCompleted;
      case 'in-progress':
        return theme.statusInProgress;
      case 'pending':
        return theme.statusPending;
      case 'cancelled':
        return theme.statusCancelled;
      default:
        return theme.textMuted;
    }
  };

  // Hàm lấy nhãn trạng thái dự án
  const getStatusLabel = (status) => {
    switch (status) {
      case 'completed':
        return 'Hoàn thành';
      case 'in-progress':
        return 'Đang thực hiện';
      case 'pending':
        return 'Chờ xử lý';
      case 'cancelled':
        return 'Đã hủy';
      default:
        return status || 'Không xác định';
    }
  };

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <StatusBar
        barStyle={isDarkMode ? 'light-content' : 'dark-content'}
        backgroundColor={theme.background}
      />

      {canUseAttendance && (
        <View style={{ paddingHorizontal: 16, marginTop: 8 }}>
          <View
            style={{
              backgroundColor: theme.card,
              borderRadius: 8,
              padding: 16,
              borderWidth: 1,
              borderColor: theme.border,
              marginBottom: 16,
            }}
          >
            <Text
              style={{
                fontSize: 18,
                fontWeight: 'bold',
                color: theme.text,
                marginBottom: 8,
              }}
            >
              Chấm Công Hôm Nay
            </Text>
            {attLoading ? (
              <ActivityIndicator color={theme.primary} />
            ) : (
              <>
                {(() => {
                  const status = getAttendanceStatus(attendance);
                  if (status === 'none') {
                    return (
                      <TouchableOpacity
                        style={getAttBtnStyle(theme)}
                        onPress={handleClockIn}
                      >
                        <Ionicons
                          name="log-in-outline"
                          size={20}
                          color="#fff"
                          style={{ marginRight: 6 }}
                        />
                        <Text style={{ color: '#fff', fontWeight: '600' }}>
                          Chấm Công Vào
                        </Text>
                      </TouchableOpacity>
                    );
                  }
                  if (status === 'clocked_in') {
                    return (
                      <>
                        <Text style={{ color: theme.text, marginBottom: 8 }}>
                          Vào lúc:{' '}
                          {attendance.clockIn.toDate().toLocaleTimeString()}
                        </Text>
                        <TouchableOpacity
                          style={getAttBtnStyle(theme)}
                          onPress={handleClockOut}
                        >
                          <Ionicons
                            name="log-out-outline"
                            size={20}
                            color="#fff"
                            style={{ marginRight: 6 }}
                          />
                          <Text style={{ color: '#fff', fontWeight: '600' }}>
                            Chấm Công Ra
                          </Text>
                        </TouchableOpacity>
                      </>
                    );
                  }
                  if (status === 'clocked_out') {
                    return (
                      <>
                        <Text style={{ color: theme.text, marginBottom: 4 }}>
                          Vào lúc:{' '}
                          {attendance.clockIn.toDate().toLocaleTimeString()}
                        </Text>
                        <Text style={{ color: theme.text, marginBottom: 8 }}>
                          Ra lúc:{' '}
                          {attendance.clockOut.toDate().toLocaleTimeString()}
                        </Text>
                        <Text style={{ color: theme.text, marginBottom: 8 }}>
                          Tăng ca: {attendance.overtime || 0} giờ
                        </Text>
                        <View style={{ flexDirection: 'row' }}>
                          {[1, 2, 3].map((h) => (
                            <TouchableOpacity
                              key={h}
                              style={getOvertimeBtnStyle(theme)}
                              onPress={() => handleAddOvertime(h)}
                            >
                              <Text style={{ color: '#fff' }}>+{h}</Text>
                            </TouchableOpacity>
                          ))}
                        </View>
                      </>
                    );
                  }
                })()}
              </>
            )}
          </View>
        </View>
      )}

      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
            Đang tải dữ liệu...
          </Text>
        </View>
      ) : (
        <ScrollView
          style={styles.scrollView}
          contentContainerStyle={styles.scrollContent}
        >
          {/* Phần dự án gần đây */}
          <View style={styles.section}>
            <View style={styles.sectionHeader}>
              <Text style={[styles.sectionTitle, { color: theme.text }]}>
                Dự án gần đây
              </Text>
              <TouchableOpacity onPress={handleViewAllProjects}>
                <Text style={[styles.viewAllText, { color: theme.primary }]}>
                  Xem tất cả
                </Text>
              </TouchableOpacity>
            </View>

            {recentProjects.length > 0 ? (
              recentProjects.map((project) => (
                <TouchableOpacity
                  key={project.id}
                  style={[
                    styles.card,
                    { backgroundColor: theme.card, borderColor: theme.border },
                  ]}
                  onPress={() => handleProjectPress(project)}
                >
                  <View style={styles.cardContent}>
                    <View style={styles.cardMain}>
                      <Text style={[styles.cardTitle, { color: theme.text }]}>
                        {project.name || 'Chưa có tên'}
                      </Text>
                      {project.customerName && (
                        <View style={styles.cardRow}>
                          <Ionicons
                            name="business-outline"
                            size={14}
                            color={theme.textSecondary}
                          />
                          <Text
                            style={[
                              styles.cardText,
                              { color: theme.textSecondary },
                            ]}
                          >
                            {project.customerName}
                          </Text>
                        </View>
                      )}
                    </View>
                    <View
                      style={[
                        styles.statusBadge,
                        { backgroundColor: getStatusColor(project.status) },
                      ]}
                    >
                      <Text style={styles.statusText}>
                        {getStatusLabel(project.status)}
                      </Text>
                    </View>
                  </View>
                </TouchableOpacity>
              ))
            ) : (
              <View
                style={[
                  styles.emptyCard,
                  { backgroundColor: theme.card, borderColor: theme.border },
                ]}
              >
                <Ionicons
                  name="briefcase-outline"
                  size={24}
                  color={theme.textMuted}
                />
                <Text style={[styles.emptyText, { color: theme.textMuted }]}>
                  Chưa có dự án nào
                </Text>
              </View>
            )}
          </View>

          {/* 库存管理菜单 - 只对特定角色显示 */}
          {['thuong_mai', 'ky_su', 'ke_toan'].includes(
            (user?.role || '').toLowerCase()
          ) && (
            <View style={styles.section}>
              <View style={styles.sectionHeader}>
                <Text style={[styles.sectionTitle, { color: theme.text }]}>
                  Quản lý kho
                </Text>
              </View>
              <View style={styles.menuGrid}>
                <TouchableOpacity
                  style={[
                    styles.menuCard,
                    { backgroundColor: theme.card, borderColor: theme.border },
                  ]}
                  onPress={() =>
                    navigation.navigate('Inventory', {
                      screen: 'InventoryMain',
                    })
                  }
                >
                  <View
                    style={[styles.menuIcon, { backgroundColor: '#4CAF50' }]}
                  >
                    <Ionicons name="cube" size={24} color="#fff" />
                  </View>
                  <Text style={[styles.menuText, { color: theme.text }]}>
                    Vật tư tồn kho
                  </Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[
                    styles.menuCard,
                    { backgroundColor: theme.card, borderColor: theme.border },
                  ]}
                  onPress={() =>
                    navigation.navigate('Inventory', {
                      screen: 'InventoryReport',
                    })
                  }
                >
                  <View
                    style={[styles.menuIcon, { backgroundColor: '#FF9800' }]}
                  >
                    <Ionicons name="bar-chart" size={24} color="#fff" />
                  </View>
                  <Text style={[styles.menuText, { color: theme.text }]}>
                    Báo cáo kho
                  </Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[
                    styles.menuCard,
                    { backgroundColor: theme.card, borderColor: theme.border },
                  ]}
                  onPress={() =>
                    navigation.navigate('Inventory', {
                      screen: 'InventoryTransaction',
                    })
                  }
                >
                  <View
                    style={[styles.menuIcon, { backgroundColor: '#2196F3' }]}
                  >
                    <Ionicons name="swap-horizontal" size={24} color="#fff" />
                  </View>
                  <Text style={[styles.menuText, { color: theme.text }]}>
                    Giao dịch kho
                  </Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[
                    styles.menuCard,
                    { backgroundColor: theme.card, borderColor: theme.border },
                  ]}
                  onPress={() =>
                    navigation.navigate('Inventory', {
                      screen: 'AddInventoryItem',
                    })
                  }
                >
                  <View
                    style={[styles.menuIcon, { backgroundColor: '#673AB7' }]}
                  >
                    <Ionicons name="add-circle" size={24} color="#fff" />
                  </View>
                  <Text style={[styles.menuText, { color: theme.text }]}>
                    Thêm vật tư
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          )}

          {/* Phần khách hàng gần đây */}
          <View style={styles.section}>
            <View style={styles.sectionHeader}>
              <Text style={[styles.sectionTitle, { color: theme.text }]}>
                Khách hàng gần đây
              </Text>
              <TouchableOpacity onPress={handleViewAllCustomers}>
                <Text style={[styles.viewAllText, { color: theme.primary }]}>
                  Xem tất cả
                </Text>
              </TouchableOpacity>
            </View>

            {recentCustomers.length > 0 ? (
              recentCustomers.map((customer) => (
                <TouchableOpacity
                  key={customer.id}
                  style={[
                    styles.card,
                    { backgroundColor: theme.card, borderColor: theme.border },
                  ]}
                  onPress={() => handleCustomerPress(customer)}
                >
                  <View style={styles.cardContent}>
                    <View style={styles.cardMain}>
                      <Text style={[styles.cardTitle, { color: theme.text }]}>
                        {customer.name || 'Chưa có tên'}
                      </Text>
                      {customer.contactPerson && (
                        <View style={styles.cardRow}>
                          <Ionicons
                            name="person-outline"
                            size={14}
                            color={theme.textSecondary}
                          />
                          <Text
                            style={[
                              styles.cardText,
                              { color: theme.textSecondary },
                            ]}
                          >
                            {customer.contactPerson}
                          </Text>
                        </View>
                      )}
                      {customer.phone && (
                        <View style={styles.cardRow}>
                          <Ionicons
                            name="call-outline"
                            size={14}
                            color={theme.textSecondary}
                          />
                          <Text
                            style={[
                              styles.cardText,
                              { color: theme.textSecondary },
                            ]}
                          >
                            {customer.phone}
                          </Text>
                        </View>
                      )}
                    </View>
                    <Ionicons
                      name="chevron-forward"
                      size={20}
                      color={theme.textMuted}
                    />
                  </View>
                </TouchableOpacity>
              ))
            ) : (
              <View
                style={[
                  styles.emptyCard,
                  { backgroundColor: theme.card, borderColor: theme.border },
                ]}
              >
                <Ionicons
                  name="people-outline"
                  size={24}
                  color={theme.textMuted}
                />
                <Text style={[styles.emptyText, { color: theme.textMuted }]}>
                  Chưa có khách hàng nào
                </Text>
              </View>
            )}
          </View>

          {/* Thông tin ứng dụng */}
          <View
            style={[styles.infoCard, { backgroundColor: theme.primaryLight }]}
          >
            <Ionicons
              name="information-circle-outline"
              size={24}
              color={theme.primary}
            />
            <Text style={[styles.infoText, { color: theme.text }]}>
              THP App - Phiên bản 1.0.0
            </Text>
          </View>

          {/* Nút quản lý nhà cung cấp */}
          <TouchableOpacity
            style={styles.menuItem}
            onPress={() => navigation.navigate('SupplierManagement')}
          >
            <View style={[styles.menuIcon, { backgroundColor: '#4caf50' }]}>
              <Ionicons name="business-outline" size={24} color="#fff" />
            </View>
            <Text style={styles.menuText}>Quản lý nhà cung cấp</Text>
            <Ionicons name="chevron-forward" size={20} color="#999" />
          </TouchableOpacity>

          {/* Trong phần menu items, thêm mục quản lý kho */}
          <TouchableOpacity
            style={styles.menuItem}
            onPress={() => navigation.navigate('Inventory')}
          >
            <View style={[styles.menuIcon, { backgroundColor: '#4CAF50' }]}>
              <Ionicons name="package-variant" size={24} color="#fff" />
            </View>
            <View style={{ flex: 1 }}>
              <Text style={styles.menuText}>Quản lý kho</Text>
              <Text
                style={[styles.menuDescription, { color: theme.textMuted }]}
              >
                Quản lý vật tư, nhập xuất kho
              </Text>
            </View>
            <Ionicons name="chevron-forward" size={20} color="#999" />
          </TouchableOpacity>
        </ScrollView>
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    padding: 16,
    paddingBottom: 32,
  },
  section: {
    marginBottom: 24,
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  viewAllText: {
    fontSize: 14,
    fontWeight: '500',
  },
  card: {
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  cardContent: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  cardMain: {
    flex: 1,
  },
  cardTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  cardRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 4,
  },
  cardText: {
    fontSize: 14,
    marginLeft: 6,
  },
  statusBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  statusText: {
    fontSize: 12,
    fontWeight: '500',
    color: 'white',
  },
  emptyCard: {
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    alignItems: 'center',
    justifyContent: 'center',
    height: 100,
  },
  emptyText: {
    fontSize: 14,
    marginTop: 8,
  },
  infoCard: {
    borderRadius: 8,
    padding: 16,
    marginTop: 12,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  infoText: {
    fontSize: 14,
    marginLeft: 8,
    fontWeight: '500',
  },
  // Note: dynamic button styles are generated via helper functions below
  menuItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 8,
    marginBottom: 12,
    backgroundColor: '#f5f5f5',
  },
  menuIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  menuText: {
    flex: 1,
    marginLeft: 12,
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
  },
  menuDescription: {
    fontSize: 12,
    marginTop: 4,
  },
  menuGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  menuCard: {
    width: '48%',
    padding: 16,
    borderRadius: 10,
    borderWidth: 1,
    marginBottom: 12,
    alignItems: 'center',
  },
});

// Dynamic styles generators
const getAttBtnStyle = (theme) => ({
  backgroundColor: theme.primary,
  borderRadius: 8,
  paddingVertical: 12,
  paddingHorizontal: 20,
  flexDirection: 'row',
  alignItems: 'center',
  justifyContent: 'center',
  marginTop: 10,
});

const getOvertimeBtnStyle = (theme) => ({
  backgroundColor: theme.primary,
  borderRadius: 20,
  paddingVertical: 8,
  paddingHorizontal: 15,
  marginHorizontal: 5,
});

export default HomeScreen;

import React, { useState, useEffect } from 'react';
import { View, StyleSheet, ScrollView, Image, Alert } from 'react-native';
import {
  Text,
  Appbar,
  Card,
  Button,
  List,
  Divider,
  FAB,
  ActivityIndicator,
  Dialog,
  Portal,
  TextInput,
  HelperText,
} from 'react-native-paper';
import { useNavigation, useRoute } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import useInventory from '../hooks/useInventory';
import { firebase } from '../config/firebaseConfig';
import StatusIndicator from '../components/StatusIndicator';

const InventoryItemDetailScreen = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { itemId } = route.params || {};

  const { getInventoryItemDetail } = useInventory();

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [itemDetail, setItemDetail] = useState(null);
  const [transactionDialogVisible, setTransactionDialogVisible] =
    useState(false);
  const [transactionType, setTransactionType] = useState('IN');
  const [transactionData, setTransactionData] = useState({
    quantity: '1',
    note: '',
  });
  const [transactionErrors, setTransactionErrors] = useState({});
  const [processingTransaction, setProcessingTransaction] = useState(false);

  // 加载物料详情
  useEffect(() => {
    if (itemId) {
      fetchItemDetail();
    } else {
      setError('Không tìm thấy ID vật tư');
      setLoading(false);
    }
  }, [itemId]);

  // 获取物料详情
  const fetchItemDetail = async () => {
    try {
      setLoading(true);
      const detail = await getInventoryItemDetail(itemId);
      setItemDetail(detail);
    } catch (error) {
      console.error('Lỗi khi lấy thông tin vật tư:', error);
      setError('Không thể lấy thông tin vật tư');
    } finally {
      setLoading(false);
    }
  };

  // 确定库存状态
  const getStockStatus = () => {
    if (!itemDetail || !itemDetail.minQuantity) return 'normal';

    if (itemDetail.stockQuantity <= 0) {
      return 'critical';
    } else if (itemDetail.stockQuantity <= itemDetail.minQuantity) {
      return 'warning';
    } else {
      return 'normal';
    }
  };

  // 显示状态
  const renderStockStatus = () => {
    if (!itemDetail) return null;

    const status = getStockStatus();
    let statusText = 'Bình thường';

    if (status === 'critical') {
      statusText = 'Hết hàng';
    } else if (status === 'warning') {
      statusText = 'Dưới mức tối thiểu';
    }

    return <StatusIndicator status={status} text={statusText} />;
  };

  // 打开交易对话框
  const openTransactionDialog = (type) => {
    setTransactionType(type);
    setTransactionData({
      quantity: '1',
      note: type === 'IN' ? 'Nhập kho' : 'Xuất kho',
    });
    setTransactionErrors({});
    setTransactionDialogVisible(true);
  };

  // 处理交易数据变化
  const handleTransactionChange = (field, value) => {
    setTransactionData({
      ...transactionData,
      [field]: value,
    });

    // 清除错误
    if (transactionErrors[field]) {
      setTransactionErrors({
        ...transactionErrors,
        [field]: null,
      });
    }
  };

  // 验证交易表单
  const validateTransactionForm = () => {
    const newErrors = {};
    const quantity = parseFloat(transactionData.quantity);

    if (isNaN(quantity) || quantity <= 0) {
      newErrors.quantity = 'Số lượng phải lớn hơn 0';
    }

    if (transactionType === 'OUT' && quantity > itemDetail.stockQuantity) {
      newErrors.quantity = 'Số lượng xuất vượt quá tồn kho';
    }

    if (!transactionData.note.trim()) {
      newErrors.note = 'Vui lòng nhập ghi chú';
    }

    setTransactionErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // 执行交易
  const handleTransaction = async () => {
    if (!validateTransactionForm()) return;

    setProcessingTransaction(true);

    try {
      const db = firebase.firestore();
      const user = firebase.auth().currentUser;

      if (!user) {
        throw new Error('Bạn cần đăng nhập để thực hiện giao dịch');
      }

      // 准备交易数据
      const quantity = parseFloat(transactionData.quantity);
      const transaction = {
        type: transactionType,
        itemId,
        quantity,
        date: firebase.firestore.Timestamp.now(),
        note: transactionData.note,
        userId: user.uid,
        status: 'COMPLETED',
      };

      // 计算新数量
      let newQuantity = itemDetail.stockQuantity;
      if (transactionType === 'IN') {
        newQuantity += quantity;
      } else if (transactionType === 'OUT') {
        newQuantity -= quantity;
      }

      // 开始事务确保数据一致性
      await db.runTransaction(async (transaction) => {
        // 保存交易
        const transactionRef = db.collection('inventory_transactions').doc();
        transaction.set(transactionRef, transaction);

        // 更新库存数量
        const itemRef = db.collection('inventory').doc(itemId);
        transaction.update(itemRef, {
          stockQuantity: newQuantity,
          lastUpdated: firebase.firestore.Timestamp.now(),
        });
      });

      // 关闭对话框并重新加载信息
      setTransactionDialogVisible(false);
      Alert.alert(
        'Thành công',
        `Đã ${transactionType === 'IN' ? 'nhập' : 'xuất'} ${quantity} ${
          itemDetail.unit
        }`,
        [{ text: 'OK' }]
      );

      // 刷新物料信息
      await fetchItemDetail();
    } catch (error) {
      console.error('Lỗi khi thực hiện giao dịch:', error);
      Alert.alert('Lỗi', error.message || 'Không thể thực hiện giao dịch');
    } finally {
      setProcessingTransaction(false);
    }
  };

  // 跳转到编辑页面
  const handleEdit = () => {
    navigation.navigate('EditInventoryItem', { itemId, item: itemDetail });
  };

  // 处理添加到报价单
  const handleAddToQuotation = () => {
    navigation.navigate('QuotationScreen', {
      screen: 'CreateQuotation',
      params: { selectedItem: itemDetail },
    });
  };

  // 格式化时间戳
  const formatTimestamp = (timestamp) => {
    if (!timestamp) return '';

    const date = timestamp.toDate();
    return date.toLocaleDateString('vi-VN', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  // 渲染加载页面
  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" />
        <Text style={{ marginTop: 16 }}>Đang tải thông tin vật tư...</Text>
      </View>
    );
  }

  // 渲染错误页面
  if (error || !itemDetail) {
    return (
      <View style={styles.errorContainer}>
        <Ionicons name="alert-circle-outline" size={48} color="#f44336" />
        <Text style={styles.errorText}>
          {error || 'Không tìm thấy thông tin vật tư'}
        </Text>
        <Button
          mode="contained"
          onPress={() => navigation.goBack()}
          style={{ marginTop: 16 }}
        >
          Quay lại
        </Button>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Appbar.Header>
        <Appbar.BackAction onPress={() => navigation.goBack()} />
        <Appbar.Content title="Chi tiết vật tư" />
        <Appbar.Action icon="pencil" onPress={handleEdit} />
      </Appbar.Header>

      <ScrollView style={styles.scrollView}>
        {/* 基本信息 */}
        <Card style={styles.card}>
          <Card.Content>
            {itemDetail.imageUrl ? (
              <Image
                source={{ uri: itemDetail.imageUrl }}
                style={styles.itemImage}
                resizeMode="contain"
              />
            ) : null}

            <View style={styles.header}>
              <View>
                <Text style={styles.itemName}>{itemDetail.name}</Text>
                <Text style={styles.itemCode}>Mã: {itemDetail.code}</Text>
              </View>
              {renderStockStatus()}
            </View>

            <Divider style={styles.divider} />

            <View style={styles.detailGrid}>
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Tồn kho:</Text>
                <Text style={styles.detailValue}>
                  {itemDetail.stockQuantity} {itemDetail.unit}
                </Text>
              </View>

              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Tồn tối thiểu:</Text>
                <Text style={styles.detailValue}>
                  {itemDetail.minQuantity || 0} {itemDetail.unit}
                </Text>
              </View>

              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Danh mục:</Text>
                <Text style={styles.detailValue}>
                  {itemDetail.category?.name || 'Không có'}
                </Text>
              </View>

              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Đơn vị tính:</Text>
                <Text style={styles.detailValue}>{itemDetail.unit}</Text>
              </View>

              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Vật liệu:</Text>
                <Text style={styles.detailValue}>
                  {itemDetail.material || 'Không có'}
                </Text>
              </View>

              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Khối lượng:</Text>
                <Text style={styles.detailValue}>
                  {itemDetail.weight ? `${itemDetail.weight} kg` : 'Không có'}
                </Text>
              </View>

              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Đơn giá:</Text>
                <Text style={styles.detailValue}>
                  {itemDetail.price
                    ? itemDetail.price.toLocaleString('vi-VN') + ' đ'
                    : 'Không có'}
                </Text>
              </View>

              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Cập nhật:</Text>
                <Text style={styles.detailValue}>
                  {formatTimestamp(itemDetail.lastUpdated)}
                </Text>
              </View>
            </View>

            {itemDetail.description ? (
              <>
                <Divider style={styles.divider} />
                <Text style={styles.sectionTitle}>Mô tả</Text>
                <Text style={styles.description}>{itemDetail.description}</Text>
              </>
            ) : null}
          </Card.Content>
        </Card>

        {/* 入库出库按钮 */}
        <View style={styles.actionButtons}>
          <Button
            mode="contained"
            icon="arrow-down-bold"
            style={styles.inButton}
            onPress={() => openTransactionDialog('IN')}
          >
            Nhập kho
          </Button>
          <Button
            mode="contained"
            icon="arrow-up-bold"
            style={styles.outButton}
            onPress={() => openTransactionDialog('OUT')}
            disabled={itemDetail.stockQuantity <= 0}
          >
            Xuất kho
          </Button>
        </View>

        {/* 交易历史 */}
        <Card style={styles.card}>
          <Card.Title title="Lịch sử giao dịch" />
          <Card.Content>
            {itemDetail.transactions && itemDetail.transactions.length > 0 ? (
              itemDetail.transactions.slice(0, 5).map((transaction, index) => (
                <React.Fragment key={transaction.id || index}>
                  <List.Item
                    title={transaction.type === 'IN' ? 'Nhập kho' : 'Xuất kho'}
                    description={`${transaction.note || ''}\n${formatTimestamp(
                      transaction.date
                    )}`}
                    left={() => (
                      <List.Icon
                        icon={
                          transaction.type === 'IN'
                            ? 'arrow-down-bold'
                            : 'arrow-up-bold'
                        }
                        color={
                          transaction.type === 'IN' ? '#4CAF50' : '#F44336'
                        }
                      />
                    )}
                    right={() => (
                      <View style={{ alignItems: 'flex-end' }}>
                        <Text style={{ fontWeight: 'bold' }}>
                          {transaction.type === 'IN' ? '+' : '-'}
                          {transaction.quantity} {itemDetail.unit}
                        </Text>
                      </View>
                    )}
                  />
                  {index < itemDetail.transactions.length - 1 && <Divider />}
                </React.Fragment>
              ))
            ) : (
              <Text style={{ textAlign: 'center', padding: 16, color: '#666' }}>
                Chưa có giao dịch nào
              </Text>
            )}

            {itemDetail.transactions && itemDetail.transactions.length > 5 && (
              <Button
                mode="text"
                onPress={() =>
                  navigation.navigate('InventoryTransaction', { itemId })
                }
              >
                Xem tất cả giao dịch
              </Button>
            )}
          </Card.Content>
        </Card>
      </ScrollView>

      {/* 交易对话框 */}
      <Portal>
        <Dialog
          visible={transactionDialogVisible}
          onDismiss={() =>
            !processingTransaction && setTransactionDialogVisible(false)
          }
        >
          <Dialog.Title>
            {transactionType === 'IN' ? 'Nhập kho' : 'Xuất kho'}
          </Dialog.Title>

          <Dialog.Content>
            <TextInput
              label="Số lượng"
              value={transactionData.quantity}
              onChangeText={(text) => handleTransactionChange('quantity', text)}
              keyboardType="numeric"
              error={!!transactionErrors.quantity}
              style={styles.dialogInput}
              right={<TextInput.Affix text={itemDetail.unit} />}
              disabled={processingTransaction}
            />
            {transactionErrors.quantity && (
              <HelperText type="error">{transactionErrors.quantity}</HelperText>
            )}

            <TextInput
              label="Ghi chú"
              value={transactionData.note}
              onChangeText={(text) => handleTransactionChange('note', text)}
              error={!!transactionErrors.note}
              style={styles.dialogInput}
              disabled={processingTransaction}
            />
            {transactionErrors.note && (
              <HelperText type="error">{transactionErrors.note}</HelperText>
            )}

            <Text style={styles.stockInfo}>
              Tồn kho hiện tại: {itemDetail.stockQuantity} {itemDetail.unit}
            </Text>
          </Dialog.Content>

          <Dialog.Actions>
            <Button
              onPress={() => setTransactionDialogVisible(false)}
              disabled={processingTransaction}
            >
              Hủy
            </Button>
            <Button
              mode="contained"
              onPress={handleTransaction}
              loading={processingTransaction}
              disabled={processingTransaction}
            >
              Xác nhận
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* 添加到报价按钮 */}
      <FAB
        style={styles.fab}
        icon="file-document-edit"
        label="Thêm vào báo giá"
        onPress={handleAddToQuotation}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollView: {
    flex: 1,
    padding: 16,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  errorText: {
    marginTop: 8,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  card: {
    marginBottom: 16,
    elevation: 2,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
  },
  itemImage: {
    width: '100%',
    height: 200,
    marginBottom: 16,
    borderRadius: 4,
  },
  itemName: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  itemCode: {
    fontSize: 14,
    color: '#666',
    marginBottom: 8,
  },
  divider: {
    marginVertical: 12,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  description: {
    color: '#333',
  },
  detailGrid: {
    marginTop: 8,
  },
  detailRow: {
    flexDirection: 'row',
    paddingVertical: 6,
  },
  detailLabel: {
    width: 100,
    color: '#666',
  },
  detailValue: {
    flex: 1,
    fontWeight: '500',
  },
  actionButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  inButton: {
    flex: 1,
    marginRight: 8,
    backgroundColor: '#4CAF50',
  },
  outButton: {
    flex: 1,
    marginLeft: 8,
    backgroundColor: '#F44336',
  },
  dialogInput: {
    marginBottom: 12,
  },
  stockInfo: {
    marginTop: 8,
    color: '#666',
    fontStyle: 'italic',
  },
  fab: {
    position: 'absolute',
    margin: 16,
    right: 0,
    bottom: 0,
    backgroundColor: '#3f51b5',
  },
});

export default InventoryItemDetailScreen;

import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  FlatList,
} from 'react-native';
import {
  Appbar,
  Text,
  Card,
  Title,
  Paragraph,
  DataTable,
  ProgressBar,
  Divider,
  ActivityIndicator,
  Chip,
  Button,
  SegmentedButtons,
} from 'react-native-paper';
import { useNavigation, useFocusEffect } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import useInventory from '../hooks/useInventory';
import { firebase } from '../config/firebaseConfig';
import StatusIndicator from '../components/StatusIndicator';

const InventoryReportScreen = () => {
  const navigation = useNavigation();

  const {
    fetchInventoryItems,
    inventoryItems,
    categories,
    fetchCategories,
    loading,
  } = useInventory();

  const [reportType, setReportType] = useState('lowStock');
  const [categoryFilter, setCategoryFilter] = useState(null);
  const [topItems, setTopItems] = useState([]);
  const [summaryData, setSummaryData] = useState({
    totalItems: 0,
    totalValue: 0,
    lowStockItems: 0,
    outOfStockItems: 0,
    normalItems: 0,
  });

  // Cập nhật dữ liệu khi màn hình được focus
  useFocusEffect(
    useCallback(() => {
      loadData();
    }, [])
  );

  // Load dữ liệu báo cáo
  const loadData = async () => {
    try {
      // Lấy dữ liệu vật tư và danh mục
      await Promise.all([fetchInventoryItems(), fetchCategories()]);

      // Tính toán các số liệu tổng hợp
      calculateSummary();

      // Tính top vật tư có giá trị cao
      calculateTopItems();
    } catch (error) {
      console.error('Lỗi khi tải dữ liệu báo cáo:', error);
    }
  };

  // Tính toán số liệu tổng hợp
  const calculateSummary = () => {
    const total = inventoryItems.length;
    let totalValue = 0;
    let lowStock = 0;
    let outOfStock = 0;

    inventoryItems.forEach((item) => {
      // Tính tổng giá trị
      totalValue += (item.price || 0) * (item.stockQuantity || 0);

      // Đếm số vật tư tồn thấp
      if (
        item.stockQuantity <= (item.minQuantity || 0) &&
        item.minQuantity > 0
      ) {
        lowStock++;
      }

      // Đếm số vật tư hết hàng
      if (item.stockQuantity <= 0) {
        outOfStock++;
      }
    });

    setSummaryData({
      totalItems: total,
      totalValue,
      lowStockItems: lowStock,
      outOfStockItems: outOfStock,
      normalItems: total - lowStock,
    });
  };

  // Tính toán top vật tư có giá trị cao
  const calculateTopItems = () => {
    // Sao chép mảng để không ảnh hưởng đến dữ liệu gốc
    const items = [...inventoryItems];

    // Sắp xếp theo giá trị tồn kho (số lượng * đơn giá)
    items.sort((a, b) => {
      const valueA = (a.stockQuantity || 0) * (a.price || 0);
      const valueB = (b.stockQuantity || 0) * (b.price || 0);
      return valueB - valueA;
    });

    // Lấy 10 vật tư đầu tiên
    setTopItems(items.slice(0, 10));
  };

  // Lọc vật tư theo loại báo cáo và danh mục
  const getFilteredItems = () => {
    let filteredItems = [...inventoryItems];

    // Lọc theo danh mục nếu có
    if (categoryFilter) {
      filteredItems = filteredItems.filter(
        (item) => item.categoryId === categoryFilter
      );
    }

    // Lọc theo loại báo cáo
    switch (reportType) {
      case 'lowStock':
        return filteredItems.filter(
          (item) =>
            item.stockQuantity <= (item.minQuantity || 0) &&
            item.minQuantity > 0
        );
      case 'outOfStock':
        return filteredItems.filter((item) => item.stockQuantity <= 0);
      case 'allItems':
      default:
        return filteredItems;
    }
  };

  // Lấy tên danh mục từ ID
  const getCategoryName = (categoryId) => {
    const category = categories.find((cat) => cat.id === categoryId);
    return category ? category.name : 'Không có';
  };

  // Format số tiền VNĐ
  const formatCurrency = (value) => {
    return value.toLocaleString('vi-VN') + ' đ';
  };

  // Render biểu đồ phân tích
  const renderAnalyticsChart = () => {
    const { totalItems, lowStockItems, outOfStockItems, normalItems } =
      summaryData;

    if (totalItems === 0) return null;

    const normalPercent = (normalItems / totalItems) * 100;
    const lowPercent = (lowStockItems / totalItems) * 100;
    const outPercent = (outOfStockItems / totalItems) * 100;

    return (
      <Card style={styles.card}>
        <Card.Content>
          <Title>Phân tích tồn kho</Title>

          <View style={styles.chartContainer}>
            <View style={styles.chartRow}>
              <View style={styles.chartLabelContainer}>
                <View
                  style={[
                    styles.colorIndicator,
                    { backgroundColor: '#4CAF50' },
                  ]}
                />
                <Text>Bình thường</Text>
              </View>
              <View style={styles.chartBarContainer}>
                <ProgressBar
                  progress={normalPercent / 100}
                  color="#4CAF50"
                  style={styles.progressBar}
                />
                <Text style={styles.percentageText}>
                  {Math.round(normalPercent)}% ({normalItems})
                </Text>
              </View>
            </View>

            <View style={styles.chartRow}>
              <View style={styles.chartLabelContainer}>
                <View
                  style={[
                    styles.colorIndicator,
                    { backgroundColor: '#FFC107' },
                  ]}
                />
                <Text>Tồn thấp</Text>
              </View>
              <View style={styles.chartBarContainer}>
                <ProgressBar
                  progress={lowPercent / 100}
                  color="#FFC107"
                  style={styles.progressBar}
                />
                <Text style={styles.percentageText}>
                  {Math.round(lowPercent)}% ({lowStockItems - outOfStockItems})
                </Text>
              </View>
            </View>

            <View style={styles.chartRow}>
              <View style={styles.chartLabelContainer}>
                <View
                  style={[
                    styles.colorIndicator,
                    { backgroundColor: '#F44336' },
                  ]}
                />
                <Text>Hết hàng</Text>
              </View>
              <View style={styles.chartBarContainer}>
                <ProgressBar
                  progress={outPercent / 100}
                  color="#F44336"
                  style={styles.progressBar}
                />
                <Text style={styles.percentageText}>
                  {Math.round(outPercent)}% ({outOfStockItems})
                </Text>
              </View>
            </View>
          </View>
        </Card.Content>
      </Card>
    );
  };

  // Render phần tổng quan
  const renderSummary = () => {
    return (
      <Card style={styles.card}>
        <Card.Content>
          <Title>Tổng quan kho hàng</Title>

          <View style={styles.summaryContainer}>
            <View style={styles.summaryItem}>
              <Text style={styles.summaryValue}>{summaryData.totalItems}</Text>
              <Text style={styles.summaryLabel}>Tổng vật tư</Text>
            </View>

            <View style={styles.summaryItem}>
              <Text style={styles.summaryValue}>
                {formatCurrency(summaryData.totalValue)}
              </Text>
              <Text style={styles.summaryLabel}>Giá trị kho</Text>
            </View>
          </View>

          <View style={styles.summaryContainer}>
            <View style={styles.summaryItem}>
              <Text style={[styles.summaryValue, { color: '#FFC107' }]}>
                {summaryData.lowStockItems}
              </Text>
              <Text style={styles.summaryLabel}>Cần nhập thêm</Text>
            </View>

            <View style={styles.summaryItem}>
              <Text style={[styles.summaryValue, { color: '#F44336' }]}>
                {summaryData.outOfStockItems}
              </Text>
              <Text style={styles.summaryLabel}>Hết hàng</Text>
            </View>
          </View>
        </Card.Content>
      </Card>
    );
  };

  // Render top vật tư giá trị cao
  const renderTopItems = () => {
    if (topItems.length === 0) return null;

    return (
      <Card style={styles.card}>
        <Card.Content>
          <Title>Top vật tư giá trị cao</Title>

          <DataTable>
            <DataTable.Header>
              <DataTable.Title>Tên vật tư</DataTable.Title>
              <DataTable.Title numeric>Tồn kho</DataTable.Title>
              <DataTable.Title numeric>Giá trị</DataTable.Title>
            </DataTable.Header>

            {topItems.slice(0, 5).map((item) => {
              const value = (item.stockQuantity || 0) * (item.price || 0);
              return (
                <DataTable.Row
                  key={item.id}
                  onPress={() =>
                    navigation.navigate('InventoryItemDetail', {
                      itemId: item.id,
                    })
                  }
                >
                  <DataTable.Cell>{item.name}</DataTable.Cell>
                  <DataTable.Cell numeric>
                    {item.stockQuantity} {item.unit}
                  </DataTable.Cell>
                  <DataTable.Cell numeric>
                    {formatCurrency(value)}
                  </DataTable.Cell>
                </DataTable.Row>
              );
            })}
          </DataTable>

          {topItems.length > 5 && (
            <Button
              mode="text"
              onPress={() =>
                navigation.navigate('Inventory', { filter: 'valueHigh' })
              }
              style={{ marginTop: 8 }}
            >
              Xem tất cả
            </Button>
          )}
        </Card.Content>
      </Card>
    );
  };

  // Render danh sách vật tư theo filter
  const renderInventoryList = () => {
    const filteredItems = getFilteredItems();

    return (
      <Card style={styles.card}>
        <Card.Content>
          <View style={styles.listHeader}>
            <Title>
              {reportType === 'lowStock' && 'Vật tư tồn thấp'}
              {reportType === 'outOfStock' && 'Vật tư hết hàng'}
              {reportType === 'allItems' && 'Tất cả vật tư'}
            </Title>

            <Text style={styles.itemCount}>{filteredItems.length} vật tư</Text>
          </View>

          <View style={styles.filterChips}>
            {categories.slice(0, 5).map((category) => (
              <Chip
                key={category.id}
                selected={categoryFilter === category.id}
                onPress={() =>
                  setCategoryFilter(
                    categoryFilter === category.id ? null : category.id
                  )
                }
                style={styles.filterChip}
              >
                {category.name}
              </Chip>
            ))}

            {categories.length > 5 && (
              <Chip
                onPress={() => navigation.navigate('Inventory')}
                style={styles.filterChip}
              >
                +{categories.length - 5} thêm
              </Chip>
            )}
          </View>

          <SegmentedButtons
            value={reportType}
            onValueChange={setReportType}
            buttons={[
              { value: 'lowStock', label: 'Tồn thấp' },
              { value: 'outOfStock', label: 'Hết hàng' },
              { value: 'allItems', label: 'Tất cả' },
            ]}
            style={styles.segmentedButtons}
          />

          <Divider style={{ marginTop: 16 }} />

          {filteredItems.length > 0 ? (
            filteredItems.slice(0, 10).map((item) => (
              <TouchableOpacity
                key={item.id}
                onPress={() =>
                  navigation.navigate('InventoryItemDetail', {
                    itemId: item.id,
                  })
                }
              >
                <View style={styles.itemRow}>
                  <View style={styles.itemInfo}>
                    <Text style={styles.itemName}>{item.name}</Text>
                    <Text style={styles.itemCode}>Mã: {item.code}</Text>
                    <Text style={styles.itemCategory}>
                      {getCategoryName(item.categoryId)}
                    </Text>
                  </View>

                  <View style={styles.itemQuantity}>
                    <Text style={styles.quantityValue}>
                      {item.stockQuantity} {item.unit}
                    </Text>
                    <StatusIndicator
                      status={
                        item.stockQuantity <= 0
                          ? 'critical'
                          : item.stockQuantity <= (item.minQuantity || 0)
                          ? 'warning'
                          : 'normal'
                      }
                      text={
                        item.stockQuantity <= 0
                          ? 'Hết hàng'
                          : item.stockQuantity <= (item.minQuantity || 0)
                          ? 'Tồn thấp'
                          : 'Bình thường'
                      }
                    />
                  </View>
                </View>
                <Divider />
              </TouchableOpacity>
            ))
          ) : (
            <View style={styles.emptyListContainer}>
              <Ionicons name="cube-outline" size={48} color="#ccc" />
              <Text style={styles.emptyListText}>
                Không có vật tư nào
                {reportType === 'lowStock' && ' tồn thấp'}
                {reportType === 'outOfStock' && ' hết hàng'}
                {categoryFilter &&
                  ` trong danh mục ${getCategoryName(categoryFilter)}`}
              </Text>
            </View>
          )}

          {filteredItems.length > 10 && (
            <Button
              mode="outlined"
              onPress={() =>
                navigation.navigate('Inventory', {
                  reportType,
                  categoryId: categoryFilter,
                })
              }
              style={{ marginTop: 16 }}
            >
              Xem tất cả {filteredItems.length} vật tư
            </Button>
          )}
        </Card.Content>
      </Card>
    );
  };

  return (
    <View style={styles.container}>
      <Appbar.Header>
        <Appbar.BackAction onPress={() => navigation.goBack()} />
        <Appbar.Content title="Báo cáo kho" />
        <Appbar.Action icon="refresh" onPress={loadData} />
        <Appbar.Action
          icon="file-export-outline"
          onPress={() => alert('Chức năng xuất báo cáo sẽ được phát triển sau')}
        />
      </Appbar.Header>

      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" />
          <Text style={{ marginTop: 16 }}>Đang tải dữ liệu báo cáo...</Text>
        </View>
      ) : (
        <ScrollView style={styles.scrollView}>
          {renderSummary()}
          {renderAnalyticsChart()}
          {renderTopItems()}
          {renderInventoryList()}

          <View style={styles.footer}>
            <Text style={styles.footerText}>
              Dữ liệu được cập nhật lần cuối:{' '}
              {new Date().toLocaleString('vi-VN')}
            </Text>
          </View>
        </ScrollView>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollView: {
    flex: 1,
    padding: 16,
  },
  card: {
    marginBottom: 16,
    elevation: 2,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  summaryContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginVertical: 16,
  },
  summaryItem: {
    alignItems: 'center',
  },
  summaryValue: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#3f51b5',
  },
  summaryLabel: {
    fontSize: 12,
    color: '#666',
    marginTop: 4,
  },
  chartContainer: {
    marginTop: 16,
  },
  chartRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  chartLabelContainer: {
    width: 100,
    flexDirection: 'row',
    alignItems: 'center',
  },
  colorIndicator: {
    width: 16,
    height: 16,
    borderRadius: 8,
    marginRight: 8,
  },
  chartBarContainer: {
    flex: 1,
  },
  progressBar: {
    height: 8,
    borderRadius: 4,
  },
  percentageText: {
    fontSize: 12,
    color: '#666',
    marginTop: 2,
  },
  listHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  itemCount: {
    fontSize: 14,
    color: '#666',
  },
  filterChips: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginVertical: 12,
  },
  filterChip: {
    marginRight: 8,
    marginBottom: 8,
  },
  segmentedButtons: {
    marginTop: 8,
  },
  itemRow: {
    flexDirection: 'row',
    paddingVertical: 12,
    justifyContent: 'space-between',
  },
  itemInfo: {
    flex: 1,
  },
  itemName: {
    fontWeight: 'bold',
    fontSize: 16,
  },
  itemCode: {
    fontSize: 12,
    color: '#666',
  },
  itemCategory: {
    fontSize: 12,
    color: '#3f51b5',
    marginTop: 4,
  },
  itemQuantity: {
    alignItems: 'flex-end',
  },
  quantityValue: {
    fontWeight: 'bold',
    marginBottom: 4,
  },
  emptyListContainer: {
    alignItems: 'center',
    paddingVertical: 32,
  },
  emptyListText: {
    marginTop: 16,
    color: '#666',
    textAlign: 'center',
  },
  footer: {
    alignItems: 'center',
    marginTop: 8,
    marginBottom: 24,
  },
  footerText: {
    fontSize: 12,
    color: '#666',
    fontStyle: 'italic',
  },
});

export default InventoryReportScreen;

import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  FlatList,
  StyleSheet,
  ActivityIndicator,
  Text,
  Alert,
} from 'react-native';
import {
  Searchbar,
  FAB,
  Button,
  Chip,
  Menu,
  Portal,
  Dialog,
  TextInput,
  Paragraph,
  Divider,
  List,
} from 'react-native-paper';
import { db, functions } from '../config/firebaseConfig';
import { collection, getDocs, query, orderBy } from 'firebase/firestore';
import {
  useNavigation,
  useFocusEffect,
  useRoute,
} from '@react-navigation/native';
import InventoryItemCard from '../components/InventoryItemCard';
import { TouchableOpacity } from 'react-native-gesture-handler';
import useInventory from '../hooks/useInventory';
import { useAuth } from '../contexts/AuthContext';
import { GoogleSignin } from '@react-native-google-signin/google-signin';
import { httpsCallable } from 'firebase/functions';

/**
 * Màn hình quản lý kho
 */
const InventoryScreen = () => {
  const [items, setItems] = useState([]);
  const [filteredItems, setFilteredItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState('');
  const [categories, setCategories] = useState([]);
  const [selectedCategory, setSelectedCategory] = useState(null);
  const [menuVisible, setMenuVisible] = useState(false);
  const [sortOption, setSortOption] = useState('name'); // Mặc định sắp xếp theo tên
  const [filterLowStock, setFilterLowStock] = useState(false);
  const [importDialogVisible, setImportDialogVisible] = useState(false);
  const [driveFolderId, setDriveFolderId] = useState(
    '1ipw1E6FaVNVnCREuVVC9Ts8vRQ42VZas'
  );
  const [importLoading, setImportLoading] = useState(false);
  const [importResult, setImportResult] = useState(null);
  const [importResultDialogVisible, setImportResultDialogVisible] =
    useState(false);
  const [driveFiles, setDriveFiles] = useState([]);
  const [isPickerVisible, setIsPickerVisible] = useState(false);
  const [isLoadingFiles, setIsLoadingFiles] = useState(false);
  const [refreshKey, setRefreshKey] = useState(0);

  const navigation = useNavigation();
  const route = useRoute();
  const { user } = useAuth();
  const [fabOpen, setFabOpen] = useState(false);

  // Xử lý tham số refresh
  useEffect(() => {
    // Kiểm tra nếu có tham số refresh từ màn hình AddInventoryItem
    if (route.params?.refresh) {
      console.log('Refreshing inventory list from navigation param');
      // Reset param để tránh refresh vô hạn
      navigation.setParams({ refresh: undefined });
      // Trigger refresh bằng cách tăng refreshKey
      setRefreshKey((prev) => prev + 1);
    }
  }, [route.params?.refresh, navigation]);

  // Lấy danh sách vật tư từ Firestore - tối ưu hiệu suất
  const fetchInventory = useCallback(async () => {
    setLoading(true);
    try {
      const inventoryRef = collection(db, 'inventory');
      const q = query(inventoryRef, orderBy('lastUpdated', 'desc'));
      const snapshot = await getDocs(q);

      const fetchedItems = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));

      setItems(fetchedItems);
      applyFiltersAndSort(
        fetchedItems,
        searchQuery,
        selectedCategory,
        filterLowStock,
        sortOption
      );
    } catch (error) {
      console.error('Lỗi khi lấy dữ liệu kho:', error);
    } finally {
      setLoading(false);
    }
  }, [searchQuery, selectedCategory, filterLowStock, sortOption]);

  // Lấy danh sách danh mục
  const fetchCategories = useCallback(async () => {
    try {
      const snapshot = await getDocs(collection(db, 'inventory_categories'));
      const fetchedCategories = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));
      setCategories(fetchedCategories);
    } catch (error) {
      console.error('Lỗi khi lấy danh mục:', error);
    }
  }, []);

  // Load dữ liệu khi màn hình được focus hoặc refresh
  useFocusEffect(
    useCallback(() => {
      fetchInventory();
      fetchCategories();
      return () => {}; // cleanup function
    }, [fetchInventory, fetchCategories, refreshKey])
  );

  // Hàm áp dụng bộ lọc và sắp xếp - đã tối ưu để tránh re-render
  const applyFiltersAndSort = useCallback(
    (itemsToFilter, query, category, lowStock, sort) => {
      // Lọc theo từ khóa tìm kiếm
      let result = [...itemsToFilter];

      if (query) {
        const normalizedQuery = query.toLowerCase().trim();
        result = result.filter(
          (item) =>
            item.name?.toLowerCase().includes(normalizedQuery) ||
            item.code?.toLowerCase().includes(normalizedQuery) ||
            item.material?.toLowerCase().includes(normalizedQuery)
        );
      }

      // Lọc theo danh mục
      if (category) {
        result = result.filter((item) => item.categoryId === category.id);
      }

      // Lọc vật tư có tồn kho thấp
      if (lowStock) {
        result = result.filter(
          (item) =>
            item.stockQuantity <= (item.minQuantity || 0) &&
            item.minQuantity > 0
        );
      }

      // Sắp xếp
      switch (sort) {
        case 'name':
          result.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
          break;
        case 'stockLow':
          result.sort(
            (a, b) => (a.stockQuantity || 0) - (b.stockQuantity || 0)
          );
          break;
        case 'stockHigh':
          result.sort(
            (a, b) => (b.stockQuantity || 0) - (a.stockQuantity || 0)
          );
          break;
        case 'code':
          result.sort((a, b) => (a.code || '').localeCompare(b.code || ''));
          break;
      }

      setFilteredItems(result);
    },
    []
  );

  // Xử lý thay đổi từ khóa tìm kiếm
  const onChangeSearch = (query) => {
    setSearchQuery(query);
    applyFiltersAndSort(
      items,
      query,
      selectedCategory,
      filterLowStock,
      sortOption
    );
  };

  // Xử lý chọn danh mục
  const handleCategorySelect = (category) => {
    setSelectedCategory(category === selectedCategory ? null : category);
    applyFiltersAndSort(
      items,
      searchQuery,
      category === selectedCategory ? null : category,
      filterLowStock,
      sortOption
    );
  };

  // Xử lý thay đổi sắp xếp
  const handleSortChange = (option) => {
    setSortOption(option);
    setMenuVisible(false);
    applyFiltersAndSort(
      items,
      searchQuery,
      selectedCategory,
      filterLowStock,
      option
    );
  };

  // Xử lý lọc hàng tồn thấp
  const toggleLowStockFilter = () => {
    const newFilterValue = !filterLowStock;
    setFilterLowStock(newFilterValue);
    applyFiltersAndSort(
      items,
      searchQuery,
      selectedCategory,
      newFilterValue,
      sortOption
    );
  };

  // Xử lý chọn vật tư
  const handleItemPress = (item) => {
    navigation.navigate('InventoryItemDetail', { itemId: item.id });
  };

  // Xử lý thêm mới
  const handleAddItem = () => {
    navigation.navigate('AddInventoryItem');
  };

  const fetchGoogleDriveFiles = async (token, folderId = null) => {
    setIsLoadingFiles(true);
    const baseUrl = 'https://www.googleapis.com/drive/v3/files';
    const params = new URLSearchParams();

    // Build query based on whether we have a specific folder ID or not
    let query =
      "mimeType='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' and trashed=false";
    if (folderId) {
      query = `'${folderId}' in parents and ${query}`;
    }

    params.append('q', query);
    params.append('orderBy', 'modifiedTime desc');
    params.append('fields', 'files(id, name, modifiedTime, iconLink)');
    const url = `${baseUrl}?${params.toString()}`;

    try {
      const response = await fetch(url, {
        headers: { Authorization: `Bearer ${token}` },
      });
      if (!response.ok) {
        throw new Error(`Google Drive API error: ${response.status}`);
      }
      const json = await response.json();
      return json.files || [];
    } catch (error) {
      console.error('Error in fetchGoogleDriveFiles:', error);
      Alert.alert('Lỗi', 'Không thể lấy danh sách file từ Google Drive.');
      throw error;
    } finally {
      setIsLoadingFiles(false);
    }
  };

  // Xử lý nhập vật tư từ Google Drive
  const handleImportFromDrive = async () => {
    setImportLoading(true);
    try {
      // Kiểm tra xem người dùng đã đăng nhập Google chưa
      const isSignedIn = await GoogleSignin.isSignedIn();
      if (!isSignedIn) {
        await GoogleSignin.signIn();
      }
      // Lấy token
      const tokens = await GoogleSignin.getTokens();
      const accessToken = tokens.accessToken;

      if (!accessToken) {
        throw new Error('Không thể lấy được access token.');
      }

      if (!driveFolderId) {
        Alert.alert('Lỗi', 'Vui lòng nhập ID thư mục Google Drive');
        return;
      }

      // Lấy danh sách file Excel từ folder
      const files = await fetchGoogleDriveFiles(accessToken, driveFolderId);
      if (files && files.length > 0) {
        setDriveFiles(files);
        setImportDialogVisible(false);
        setIsPickerVisible(true);
      } else {
        Alert.alert(
          'Không tìm thấy file',
          'Không tìm thấy file Excel nào trong thư mục Google Drive này.'
        );
      }
    } catch (error) {
      console.error('Lỗi khi nhập vật tư:', error);
      if (error.code !== 'SIGN_IN_CANCELLED') {
        Alert.alert(
          'Lỗi nhập vật tư',
          error.message || 'Không thể nhập vật tư từ Google Drive'
        );
      }
    } finally {
      setImportLoading(false);
    }
  };

  const handleFileSelect = async (file) => {
    setIsPickerVisible(false);
    setImportLoading(true);

    try {
      // Lấy access token
      const tokens = await GoogleSignin.getTokens();
      const { accessToken } = tokens;

      if (!accessToken) {
        throw new Error('Không thể lấy được access token của Google.');
      }

      // Gọi Cloud Function để xử lý và nhập vật tư
      const importInventory = httpsCallable(
        functions,
        'importInventoryFromExcel'
      );
      const result = await importInventory({
        driveFileId: file.id,
        accessToken,
      });

      // Xử lý kết quả
      console.log('Kết quả nhập vật tư:', result.data);
      setImportResult(result.data);
      setImportResultDialogVisible(true);

      // Cập nhật lại danh sách vật tư - dùng refreshKey để trigger useFocusEffect
      setRefreshKey((prev) => prev + 1);
    } catch (error) {
      console.error('Lỗi khi xử lý file Excel:', error);

      let errorMessage = error.message;
      if (error.code === 'functions/unauthenticated') {
        errorMessage =
          'Xác thực thất bại. Vui lòng đăng xuất và đăng nhập lại.';
      } else if (error.code === 'functions/permission-denied') {
        errorMessage =
          'Token truy cập Google Drive đã hết hạn. Vui lòng thử lại.';
      }

      Alert.alert('Lỗi xử lý file', `Chi tiết: ${errorMessage}`);
    } finally {
      setImportLoading(false);
    }
  };

  const handleCloseResultDialog = () => {
    setImportResultDialogVisible(false);
    // Đảm bảo danh sách được tải lại sau khi đóng dialog
    setTimeout(() => {
      fetchInventory();
    }, 300);
  };

  // Hiển thị các danh mục
  const renderCategoryChips = () => {
    return (
      <FlatList
        data={categories}
        horizontal
        showsHorizontalScrollIndicator={false}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <Chip
            style={[
              styles.chip,
              selectedCategory?.id === item.id ? styles.selectedChip : null,
            ]}
            onPress={() => handleCategorySelect(item)}
            mode={selectedCategory?.id === item.id ? 'flat' : 'outlined'}
          >
            {item.name}
          </Chip>
        )}
        contentContainerStyle={styles.chipsContainer}
      />
    );
  };

  return (
    <View style={styles.container}>
      {/* Thanh tìm kiếm */}
      <Searchbar
        placeholder="Tìm kiếm vật tư..."
        onChangeText={onChangeSearch}
        value={searchQuery}
        style={styles.searchBar}
      />

      {/* Thanh công cụ */}
      <View style={styles.toolbar}>
        {/* Menu sắp xếp */}
        <Menu
          visible={menuVisible}
          onDismiss={() => setMenuVisible(false)}
          anchor={
            <Button
              mode="outlined"
              onPress={() => setMenuVisible(true)}
              icon="sort"
            >
              Sắp xếp
            </Button>
          }
        >
          <Menu.Item
            title="Theo tên (A-Z)"
            onPress={() => handleSortChange('name')}
          />
          <Menu.Item
            title="Tồn kho (Thấp-Cao)"
            onPress={() => handleSortChange('stockLow')}
          />
          <Menu.Item
            title="Tồn kho (Cao-Thấp)"
            onPress={() => handleSortChange('stockHigh')}
          />
          <Menu.Item title="Theo mã" onPress={() => handleSortChange('code')} />
        </Menu>

        {/* Nút lọc hàng tồn thấp */}
        <Button
          mode={filterLowStock ? 'contained' : 'outlined'}
          onPress={toggleLowStockFilter}
          icon="alert-circle"
        >
          Tồn thấp
        </Button>
      </View>

      {/* Danh sách danh mục */}
      {renderCategoryChips()}

      {/* Danh sách vật tư */}
      {loading ? (
        <ActivityIndicator size="large" style={styles.loader} />
      ) : filteredItems.length > 0 ? (
        <FlatList
          data={filteredItems}
          keyExtractor={(item) => item.id}
          renderItem={({ item }) => (
            <InventoryItemCard item={item} onPress={handleItemPress} />
          )}
          contentContainerStyle={styles.listContainer}
        />
      ) : (
        <View style={styles.emptyState}>
          <Text style={styles.emptyText}>
            Không có vật tư nào{' '}
            {searchQuery ? 'phù hợp với tìm kiếm' : 'trong kho'}
          </Text>
        </View>
      )}

      {/* FAB Group cho các hành động */}
      <Portal>
        <FAB.Group
          open={fabOpen}
          icon={fabOpen ? 'close' : 'plus'}
          actions={[
            {
              icon: 'plus',
              label: 'Thêm vật tư mới',
              onPress: handleAddItem,
            },
            {
              icon: 'file-excel',
              label: 'Nhập từ Excel',
              onPress: () => setImportDialogVisible(true),
            },
          ]}
          onStateChange={({ open }) => setFabOpen(open)}
          fabStyle={styles.fab}
        />
      </Portal>

      {/* Dialog nhập từ Google Drive */}
      <Portal>
        <Dialog
          visible={importDialogVisible}
          onDismiss={() => !importLoading && setImportDialogVisible(false)}
        >
          <Dialog.Title>Nhập vật tư từ Google Drive</Dialog.Title>
          <Dialog.Content>
            <Paragraph>
              Chức năng này sẽ nhập vật tư từ file Excel mới nhất trong thư mục
              Google Drive. File cần có định dạng với các cột sau:
            </Paragraph>

            <View style={styles.excelInfo}>
              <List.Item
                title="Cột A: Mã vật tư (code)"
                left={(props) => <List.Icon {...props} icon="pound" />}
              />
              <List.Item
                title="Cột B: Tên vật tư (name)"
                left={(props) => <List.Icon {...props} icon="text" />}
              />
              <List.Item
                title="Cột C: Mô tả (description)"
                left={(props) => <List.Icon {...props} icon="text-box" />}
              />
              <List.Item
                title="Cột D: Danh mục (category)"
                left={(props) => <List.Icon {...props} icon="folder" />}
              />
              <List.Item
                title="Cột E: Đơn vị tính (unit)"
                left={(props) => <List.Icon {...props} icon="cube" />}
              />
              <List.Item
                title="Cột F: Số lượng (stockQuantity)"
                left={(props) => <List.Icon {...props} icon="counter" />}
              />
              <List.Item
                title="Cột G: Số lượng tối thiểu (minQuantity)"
                left={(props) => <List.Icon {...props} icon="alert" />}
              />
              <List.Item
                title="Cột H: Đơn giá (price)"
                left={(props) => <List.Icon {...props} icon="currency-usd" />}
              />
              <List.Item
                title="Cột I: Vật liệu (material)"
                left={(props) => <List.Icon {...props} icon="tools" />}
              />
              <List.Item
                title="Cột J: Khối lượng (weight)"
                left={(props) => <List.Icon {...props} icon="weight" />}
              />
            </View>

            <Divider style={styles.divider} />

            <TextInput
              label="Google Drive Folder ID"
              value={driveFolderId}
              onChangeText={setDriveFolderId}
              style={styles.input}
              disabled={importLoading}
            />
          </Dialog.Content>
          <Dialog.Actions>
            <Button
              onPress={() => setImportDialogVisible(false)}
              disabled={importLoading}
            >
              Hủy
            </Button>
            <Button
              mode="contained"
              onPress={handleImportFromDrive}
              loading={importLoading}
              disabled={importLoading}
            >
              Tiếp tục
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* Dialog chọn file từ Drive */}
      <Portal>
        <Dialog
          visible={isPickerVisible}
          onDismiss={() => !importLoading && setIsPickerVisible(false)}
          style={styles.filePickerDialog}
        >
          <Dialog.Title>Chọn file Excel</Dialog.Title>
          <Dialog.Content>
            {isLoadingFiles ? (
              <ActivityIndicator size="large" style={styles.loader} />
            ) : driveFiles.length > 0 ? (
              <FlatList
                data={driveFiles}
                keyExtractor={(item) => item.id}
                renderItem={({ item }) => (
                  <List.Item
                    title={item.name}
                    description={`Sửa đổi: ${new Date(
                      item.modifiedTime
                    ).toLocaleString()}`}
                    left={(props) => <List.Icon {...props} icon="file-excel" />}
                    onPress={() => handleFileSelect(item)}
                    disabled={importLoading}
                  />
                )}
                style={styles.fileList}
              />
            ) : (
              <Text style={styles.emptyText}>Không tìm thấy file Excel</Text>
            )}
          </Dialog.Content>
          <Dialog.Actions>
            <Button
              onPress={() => setIsPickerVisible(false)}
              disabled={importLoading}
            >
              Hủy
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* Dialog kết quả nhập */}
      <Portal>
        <Dialog
          visible={importResultDialogVisible}
          onDismiss={handleCloseResultDialog}
        >
          <Dialog.Title>Kết quả nhập vật tư</Dialog.Title>
          <Dialog.Content>
            {importResult && (
              <View>
                <Paragraph style={styles.resultText}>
                  Tổng số vật tư đã xử lý: {importResult.total}
                </Paragraph>
                <Paragraph style={styles.resultText}>
                  Số vật tư đã thêm mới:{' '}
                  <Text style={styles.successText}>{importResult.added}</Text>
                </Paragraph>
                <Paragraph style={styles.resultText}>
                  Số vật tư đã cập nhật:{' '}
                  <Text style={styles.warningText}>{importResult.updated}</Text>
                </Paragraph>
                <Paragraph style={styles.resultText}>
                  Số vật tư bị bỏ qua:{' '}
                  <Text style={styles.errorText}>{importResult.skipped}</Text>
                </Paragraph>

                {importResult.errors && importResult.errors.length > 0 && (
                  <View style={styles.errorList}>
                    <Text style={styles.errorHeader}>Các lỗi gặp phải:</Text>
                    {importResult.errors.map((error, index) => (
                      <Text key={index} style={styles.errorItem}>
                        Hàng {error.row}: {error.message}
                      </Text>
                    ))}
                  </View>
                )}
              </View>
            )}
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={handleCloseResultDialog}>Đóng</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  searchBar: {
    margin: 16,
    elevation: 2,
  },
  toolbar: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    marginBottom: 10,
  },
  chipsContainer: {
    paddingHorizontal: 16,
    marginBottom: 10,
  },
  chip: {
    marginRight: 8,
  },
  selectedChip: {
    backgroundColor: '#3f51b5',
  },
  listContainer: {
    paddingBottom: 80, // Để không bị FAB che khuất
  },
  fab: {
    position: 'absolute',
    margin: 16,
    right: 0,
    bottom: 0,
    backgroundColor: '#3f51b5',
  },
  loader: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  emptyState: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  emptyText: {
    fontSize: 16,
    color: '#888',
    textAlign: 'center',
  },
  divider: {
    marginVertical: 16,
  },
  input: {
    marginBottom: 10,
    backgroundColor: 'white',
  },
  excelInfo: {
    marginVertical: 10,
    backgroundColor: '#f5f5f5',
    borderRadius: 8,
    padding: 10,
    maxHeight: 250,
  },
  resultText: {
    fontSize: 16,
    marginBottom: 8,
  },
  successText: {
    color: '#4CAF50',
    fontWeight: 'bold',
  },
  warningText: {
    color: '#FF9800',
    fontWeight: 'bold',
  },
  errorText: {
    color: '#F44336',
    fontWeight: 'bold',
  },
  errorList: {
    marginTop: 16,
    backgroundColor: '#FFEBEE',
    padding: 12,
    borderRadius: 8,
  },
  errorHeader: {
    fontWeight: 'bold',
    marginBottom: 8,
    color: '#F44336',
  },
  errorItem: {
    color: '#D32F2F',
    marginBottom: 4,
  },
  filePickerDialog: {
    maxHeight: '80%',
  },
  fileList: {
    maxHeight: 300,
  },
});

export default InventoryScreen;

import React, { useState, useEffect } from 'react';
import { View, StyleSheet, FlatList, TouchableOpacity } from 'react-native';
import {
  Appbar,
  Text,
  Divider,
  List,
  ActivityIndicator,
  Chip,
  Searchbar,
  Button,
  Card,
  Menu,
} from 'react-native-paper';
import { useNavigation, useRoute } from '@react-navigation/native';
import { firebase } from '../config/firebaseConfig';
import DateTimePicker from '@react-native-community/datetimepicker';
import { Ionicons } from '@expo/vector-icons';

const InventoryTransactionScreen = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { itemId } = route.params || {};

  const [loading, setLoading] = useState(true);
  const [transactions, setTransactions] = useState([]);
  const [item, setItem] = useState(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [filterType, setFilterType] = useState(null);
  const [dateRange, setDateRange] = useState({
    start: null,
    end: null,
  });

  const [showDatePicker, setShowDatePicker] = useState(false);
  const [datePickerMode, setDatePickerMode] = useState('start');
  const [menuVisible, setMenuVisible] = useState(false);

  // Lấy dữ liệu giao dịch khi mở màn hình
  useEffect(() => {
    fetchData();
  }, [itemId]);

  // Lấy danh sách giao dịch và thông tin vật tư
  const fetchData = async () => {
    try {
      setLoading(true);

      // Lấy thông tin chi tiết vật tư nếu có itemId
      if (itemId) {
        const itemDoc = await firebase
          .firestore()
          .collection('inventory')
          .doc(itemId)
          .get();

        if (itemDoc.exists) {
          setItem({
            id: itemDoc.id,
            ...itemDoc.data(),
          });
        }

        // Lấy giao dịch của vật tư cụ thể
        const query = firebase
          .firestore()
          .collection('inventory_transactions')
          .where('itemId', '==', itemId)
          .orderBy('date', 'desc');

        const snapshot = await query.get();
        const transactionsData = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        }));

        setTransactions(transactionsData);
      } else {
        // Lấy tất cả giao dịch kho
        const query = firebase
          .firestore()
          .collection('inventory_transactions')
          .orderBy('date', 'desc')
          .limit(100); // Giới hạn để tránh lấy quá nhiều dữ liệu

        const snapshot = await query.get();
        const transactionsData = await Promise.all(
          snapshot.docs.map(async (doc) => {
            const data = {
              id: doc.id,
              ...doc.data(),
            };

            // Nếu không có item ở prop, lấy thông tin vật tư
            if (!data.itemName) {
              try {
                const itemDoc = await firebase
                  .firestore()
                  .collection('inventory')
                  .doc(data.itemId)
                  .get();

                if (itemDoc.exists) {
                  data.itemName = itemDoc.data().name;
                  data.itemUnit = itemDoc.data().unit;
                }
              } catch (error) {
                console.error('Lỗi khi lấy thông tin vật tư:', error);
              }
            }

            return data;
          })
        );

        setTransactions(transactionsData);
      }
    } catch (error) {
      console.error('Lỗi khi lấy dữ liệu giao dịch:', error);
    } finally {
      setLoading(false);
    }
  };

  // Xử lý tìm kiếm
  const handleSearch = (query) => {
    setSearchQuery(query);
  };

  // Xử lý chọn loại giao dịch để lọc
  const handleFilterType = (type) => {
    setFilterType(type === filterType ? null : type);
  };

  // Xử lý chọn ngày bắt đầu
  const handleStartDateSelect = (event, date) => {
    setShowDatePicker(false);
    if (date) {
      setDateRange({
        ...dateRange,
        start: date,
      });
    }
  };

  // Xử lý chọn ngày kết thúc
  const handleEndDateSelect = (event, date) => {
    setShowDatePicker(false);
    if (date) {
      setDateRange({
        ...dateRange,
        end: date,
      });
    }
  };

  // Mở date picker
  const showDatePickerDialog = (mode) => {
    setDatePickerMode(mode);
    setShowDatePicker(true);
  };

  // Xóa bộ lọc
  const clearFilters = () => {
    setFilterType(null);
    setDateRange({
      start: null,
      end: null,
    });
    setSearchQuery('');
  };

  // Lọc giao dịch
  const filteredTransactions = () => {
    let result = [...transactions];

    // Lọc theo loại
    if (filterType) {
      result = result.filter((transaction) => transaction.type === filterType);
    }

    // Lọc theo ngày bắt đầu
    if (dateRange.start) {
      const startTimestamp = firebase.firestore.Timestamp.fromDate(
        dateRange.start
      );
      result = result.filter(
        (transaction) =>
          transaction.date && transaction.date.seconds >= startTimestamp.seconds
      );
    }

    // Lọc theo ngày kết thúc
    if (dateRange.end) {
      // Thêm 1 ngày để bao gồm cả ngày được chọn
      const endDate = new Date(dateRange.end);
      endDate.setDate(endDate.getDate() + 1);
      const endTimestamp = firebase.firestore.Timestamp.fromDate(endDate);

      result = result.filter(
        (transaction) =>
          transaction.date && transaction.date.seconds < endTimestamp.seconds
      );
    }

    // Lọc theo từ khóa tìm kiếm
    if (searchQuery) {
      const normalizedQuery = searchQuery.toLowerCase().trim();
      result = result.filter(
        (transaction) =>
          transaction.note?.toLowerCase().includes(normalizedQuery) ||
          transaction.itemName?.toLowerCase().includes(normalizedQuery)
      );
    }

    return result;
  };

  // Format ngày giờ
  const formatDate = (timestamp) => {
    if (!timestamp) return '';

    const date = timestamp.toDate();
    return date.toLocaleDateString('vi-VN', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  // Render mỗi giao dịch
  const renderTransactionItem = ({ item: transaction }) => {
    const isIn = transaction.type === 'IN';
    return (
      <Card style={styles.transactionCard}>
        <Card.Content>
          <View style={styles.transactionHeader}>
            <View>
              <Text style={styles.transactionTitle}>
                {isIn ? 'Nhập kho' : 'Xuất kho'}
              </Text>
              <Text style={styles.transactionDate}>
                {formatDate(transaction.date)}
              </Text>
            </View>

            <Chip
              mode="outlined"
              style={[
                styles.transactionTypeChip,
                { borderColor: isIn ? '#4CAF50' : '#F44336' },
              ]}
              textStyle={{
                color: isIn ? '#4CAF50' : '#F44336',
                fontWeight: 'bold',
              }}
            >
              {isIn ? '+' : '-'}
              {transaction.quantity} {transaction.itemUnit || item?.unit || ''}
            </Chip>
          </View>

          {!itemId && transaction.itemName && (
            <Text style={styles.itemName}>{transaction.itemName}</Text>
          )}

          <Text style={styles.transactionNote}>{transaction.note}</Text>

          <View style={styles.transactionFooter}>
            <Text style={styles.transactionUser}>
              {transaction.userId
                ? transaction.userId.substring(0, 8)
                : 'Không xác định'}
            </Text>
            <Text style={styles.transactionStatus}>
              {transaction.status === 'COMPLETED' ? 'Hoàn thành' : 'Chờ xử lý'}
            </Text>
          </View>
        </Card.Content>
      </Card>
    );
  };

  return (
    <View style={styles.container}>
      <Appbar.Header>
        <Appbar.BackAction onPress={() => navigation.goBack()} />
        <Appbar.Content
          title={item ? `Giao dịch của ${item.name}` : 'Lịch sử giao dịch kho'}
          subtitle={item ? `Mã: ${item.code}` : ''}
        />
        <Appbar.Action icon="refresh" onPress={fetchData} />
      </Appbar.Header>

      <View style={styles.filterContainer}>
        <Searchbar
          placeholder="Tìm kiếm giao dịch..."
          onChangeText={handleSearch}
          value={searchQuery}
          style={styles.searchBar}
        />

        <View style={styles.chipRow}>
          <Chip
            selected={filterType === 'IN'}
            onPress={() => handleFilterType('IN')}
            style={styles.filterChip}
            icon="arrow-down"
          >
            Nhập kho
          </Chip>
          <Chip
            selected={filterType === 'OUT'}
            onPress={() => handleFilterType('OUT')}
            style={styles.filterChip}
            icon="arrow-up"
          >
            Xuất kho
          </Chip>
          <Menu
            visible={menuVisible}
            onDismiss={() => setMenuVisible(false)}
            anchor={
              <Chip
                onPress={() => setMenuVisible(true)}
                style={styles.filterChip}
                icon="calendar"
              >
                Ngày
              </Chip>
            }
          >
            <Menu.Item
              title="Chọn ngày bắt đầu"
              onPress={() => {
                setMenuVisible(false);
                showDatePickerDialog('start');
              }}
            />
            <Menu.Item
              title="Chọn ngày kết thúc"
              onPress={() => {
                setMenuVisible(false);
                showDatePickerDialog('end');
              }}
            />
            <Divider />
            <Menu.Item
              title="Xóa lọc ngày"
              onPress={() => {
                setMenuVisible(false);
                setDateRange({ start: null, end: null });
              }}
            />
          </Menu>

          {(filterType || dateRange.start || dateRange.end || searchQuery) && (
            <Chip
              onPress={clearFilters}
              style={styles.clearChip}
              icon="close-circle"
            >
              Xóa lọc
            </Chip>
          )}
        </View>

        {(dateRange.start || dateRange.end) && (
          <View style={styles.dateRangeContainer}>
            <Text style={styles.dateRangeText}>
              {dateRange.start
                ? formatDate(
                    firebase.firestore.Timestamp.fromDate(dateRange.start)
                  )
                : 'Từ đầu'}
              {' → '}
              {dateRange.end
                ? formatDate(
                    firebase.firestore.Timestamp.fromDate(dateRange.end)
                  )
                : 'đến nay'}
            </Text>
          </View>
        )}
      </View>

      {showDatePicker && (
        <DateTimePicker
          value={
            datePickerMode === 'start'
              ? dateRange.start || new Date()
              : dateRange.end || new Date()
          }
          mode="date"
          display="default"
          onChange={
            datePickerMode === 'start'
              ? handleStartDateSelect
              : handleEndDateSelect
          }
        />
      )}

      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" />
          <Text style={{ marginTop: 16 }}>Đang tải dữ liệu giao dịch...</Text>
        </View>
      ) : (
        <FlatList
          data={filteredTransactions()}
          keyExtractor={(item) => item.id}
          renderItem={renderTransactionItem}
          contentContainerStyle={styles.listContainer}
          ListEmptyComponent={() => (
            <View style={styles.emptyContainer}>
              <Ionicons name="archive-outline" size={48} color="#666" />
              <Text style={styles.emptyText}>
                {searchQuery || filterType || dateRange.start || dateRange.end
                  ? 'Không tìm thấy giao dịch nào khớp với điều kiện lọc'
                  : 'Chưa có giao dịch nào'}
              </Text>
              {(searchQuery ||
                filterType ||
                dateRange.start ||
                dateRange.end) && (
                <Button
                  mode="outlined"
                  onPress={clearFilters}
                  style={{ marginTop: 16 }}
                >
                  Xóa bộ lọc
                </Button>
              )}
            </View>
          )}
        />
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  filterContainer: {
    padding: 16,
    backgroundColor: 'white',
    elevation: 2,
  },
  searchBar: {
    marginBottom: 12,
    elevation: 0,
    backgroundColor: '#f0f0f0',
  },
  chipRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  filterChip: {
    marginRight: 8,
    marginBottom: 8,
  },
  clearChip: {
    backgroundColor: '#e57373',
    marginRight: 8,
    marginBottom: 8,
  },
  dateRangeContainer: {
    marginTop: 8,
    backgroundColor: '#f0f0f0',
    padding: 8,
    borderRadius: 4,
  },
  dateRangeText: {
    fontStyle: 'italic',
    color: '#666',
  },
  listContainer: {
    padding: 16,
    paddingBottom: 80,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 32,
    marginTop: 50,
  },
  emptyText: {
    marginTop: 16,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  transactionCard: {
    marginBottom: 12,
    elevation: 1,
  },
  transactionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
  },
  transactionTitle: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  transactionDate: {
    fontSize: 12,
    color: '#666',
    marginTop: 4,
  },
  transactionTypeChip: {
    minWidth: 80,
    justifyContent: 'center',
  },
  itemName: {
    fontWeight: '500',
    marginTop: 8,
    color: '#3f51b5',
  },
  transactionNote: {
    marginTop: 8,
    marginBottom: 8,
  },
  transactionFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 8,
  },
  transactionUser: {
    fontSize: 12,
    color: '#666',
  },
  transactionStatus: {
    fontSize: 12,
    fontWeight: '500',
    color: '#4CAF50',
  },
});

export default InventoryTransactionScreen;

//src/screens/LoginScreen.js
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  Image,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  ActivityIndicator,
  Alert,
  Dimensions,
  Keyboard,
} from 'react-native';
import { useAuth } from '../contexts/AuthContext';
import { Ionicons } from '@expo/vector-icons';
import { SafeAreaView } from 'react-native-safe-area-context';
import StyledTextInput from '../components/StyledTextInput';

const { width, height } = Dimensions.get('window');

const LoginScreen = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [isEmailValid, setIsEmailValid] = useState(true);
  const [isFormValid, setIsFormValid] = useState(false);
  const [isLoggingIn, setIsLoggingIn] = useState(false);
  const [keyboardVisible, setKeyboardVisible] = useState(false);

  const passwordRef = useRef(null);
  const { login, error } = useAuth();

  // Kiểm tra tính hợp lệ của form
  useEffect(() => {
    const validateEmail = (email) => {
      const re =
        /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
      return re.test(String(email).toLowerCase());
    };

    const isValid =
      email.trim() !== '' && password.trim() !== '' && validateEmail(email);

    setIsEmailValid(email === '' || validateEmail(email));
    setIsFormValid(isValid);
  }, [email, password]);

  // Theo dõi trạng thái hiển thị của bàn phím
  useEffect(() => {
    const keyboardDidShowListener = Keyboard.addListener(
      'keyboardDidShow',
      () => {
        setKeyboardVisible(true);
      }
    );
    const keyboardDidHideListener = Keyboard.addListener(
      'keyboardDidHide',
      () => {
        setKeyboardVisible(false);
      }
    );

    return () => {
      keyboardDidShowListener.remove();
      keyboardDidHideListener.remove();
    };
  }, []);

  // Xử lý đăng nhập
  const handleLogin = async () => {
    if (!isFormValid) {
      Alert.alert('Lỗi đăng nhập', 'Vui lòng nhập email và mật khẩu hợp lệ');
      return;
    }

    Keyboard.dismiss();
    setIsLoggingIn(true);
    try {
      const success = await login(email, password);
      if (!success) {
        console.log('Đăng nhập thất bại');
      }
    } catch (error) {
      console.error('Lỗi khi đăng nhập:', error);
      Alert.alert(
        'Lỗi đăng nhập',
        'Đã xảy ra lỗi khi đăng nhập. Vui lòng thử lại sau.'
      );
    } finally {
      setIsLoggingIn(false);
    }
  };

  // Xử lý quên mật khẩu
  const handleForgotPassword = () => {
    // Sẽ triển khai sau
    Alert.alert(
      'Quên mật khẩu',
      'Tính năng này sẽ được triển khai trong phiên bản tiếp theo.'
    );
  };

  // Tạo nút hiển thị/ẩn mật khẩu
  const PasswordToggleButton = (
    <TouchableOpacity
      onPress={() => setShowPassword(!showPassword)}
      style={styles.passwordToggle}
    >
      <Ionicons
        name={showPassword ? 'eye-off-outline' : 'eye-outline'}
        size={20}
        color="#666"
      />
    </TouchableOpacity>
  );

  return (
    <SafeAreaView style={styles.safeArea}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.container}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 0 : 20}
      >
        <ScrollView
          contentContainerStyle={[
            styles.scrollContainer,
            keyboardVisible && { justifyContent: 'flex-start', paddingTop: 20 },
          ]}
          keyboardShouldPersistTaps="handled"
          showsVerticalScrollIndicator={false}
        >
          <View
            style={[
              styles.logoContainer,
              keyboardVisible && {
                marginBottom: 10,
                transform: [{ scale: 0.8 }],
              },
            ]}
          >
            <Image
              source={require('../../assets/logo-placeholder.png')}
              style={styles.logo}
              resizeMode="contain"
            />
            <Text style={styles.appName}>Tân Hòa Phát</Text>
            <Text style={styles.appDescription}>
              Hệ thống quản lý khách hàng
            </Text>
          </View>

          <View style={styles.formContainer}>
            <Text style={styles.welcomeText}>Đăng nhập</Text>

            <StyledTextInput
              iconName="mail-outline"
              placeholder="Email"
              value={email}
              onChangeText={setEmail}
              keyboardType="email-address"
              autoCapitalize="none"
              returnKeyType="next"
              blurOnSubmit={false}
              onSubmitEditing={() => passwordRef.current.focus()}
              error={!isEmailValid ? 'Email không hợp lệ' : null}
            />

            <StyledTextInput
              ref={passwordRef}
              iconName="lock-closed-outline"
              placeholder="Mật khẩu"
              value={password}
              onChangeText={setPassword}
              secureTextEntry={!showPassword}
              returnKeyType="done"
              onSubmitEditing={handleLogin}
              rightIcon={PasswordToggleButton}
            />

            <TouchableOpacity
              style={styles.forgotPassword}
              onPress={handleForgotPassword}
            >
              <Text style={styles.forgotPasswordText}>Quên mật khẩu?</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.loginButton,
                (!isFormValid || isLoggingIn) && styles.loginButtonDisabled,
              ]}
              onPress={handleLogin}
              disabled={!isFormValid || isLoggingIn}
            >
              {isLoggingIn ? (
                <ActivityIndicator color="#fff" size="small" />
              ) : (
                <Text style={styles.loginButtonText}>Đăng nhập</Text>
              )}
            </TouchableOpacity>

            {error && (
              <View style={styles.errorContainer}>
                <Ionicons
                  name="alert-circle-outline"
                  size={18}
                  color="#e74c3c"
                />
                <Text style={styles.errorMessage}>{error}</Text>
              </View>
            )}
          </View>

          {!keyboardVisible && (
            <View style={styles.footer}>
              <Text style={styles.footerText}>
                © 2023 Tân Hòa Phát. All rights reserved.
              </Text>
            </View>
          )}
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  scrollContainer: {
    flexGrow: 1,
    justifyContent: 'center',
    padding: 20,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 30,
  },
  logo: {
    width: 100,
    height: 100,
    marginBottom: 10,
  },
  appName: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#0066cc',
    marginBottom: 5,
  },
  appDescription: {
    fontSize: 16,
    color: '#666',
  },
  formContainer: {
    backgroundColor: '#fff',
    borderRadius: 10,
    padding: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
    marginBottom: 20,
    width: '100%',
  },
  welcomeText: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center',
    color: '#333',
  },
  passwordToggle: {
    padding: 8,
  },
  forgotPassword: {
    alignSelf: 'flex-end',
    marginBottom: 20,
  },
  forgotPasswordText: {
    color: '#0066cc',
    fontSize: 14,
  },
  loginButton: {
    backgroundColor: '#0066cc',
    borderRadius: 8,
    paddingVertical: 14,
    alignItems: 'center',
    justifyContent: 'center',
  },
  loginButtonDisabled: {
    backgroundColor: '#ccc',
  },
  loginButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#fde2e2',
    padding: 10,
    borderRadius: 8,
    marginTop: 15,
  },
  errorMessage: {
    color: '#e74c3c',
    fontSize: 14,
    marginLeft: 5,
    flex: 1,
  },
  footer: {
    marginTop: 20,
    alignItems: 'center',
  },
  footerText: {
    color: '#999',
    fontSize: 12,
  },
});

export default LoginScreen;

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  FlatList,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  Alert,
  Modal,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { Picker } from '@react-native-picker/picker';

const MATERIAL_OPTIONS = ['SUS304', 'SS400', 'SUS316', 'SUS304 2B', 'Khác'];

const UNIT_OPTIONS = ['Cái', 'Cây', 'Bộ', 'Kg', 'm'];

const ManualQuotationScreen = ({ route, navigation }) => {
  const { projectId, projectName, project } = route.params;

  const [materials, setMaterials] = useState([
    {
      name: '',
      material: MATERIAL_OPTIONS[0],
      unit: UNIT_OPTIONS[0],
      quantity: '',
      unitPrice: '',
      totalPrice: 0,
      selected: false,
    },
  ]);

  // Add new states for bulk price update
  const [showBulkPriceModal, setShowBulkPriceModal] = useState(false);
  const [bulkPrice, setBulkPrice] = useState('');
  const [hasSelections, setHasSelections] = useState(false);

  const addMaterialRow = () => {
    setMaterials((prev) => [
      ...prev,
      {
        name: '',
        material: MATERIAL_OPTIONS[0],
        unit: UNIT_OPTIONS[0],
        quantity: '',
        unitPrice: '',
        totalPrice: 0,
        selected: false,
      },
    ]);
  };

  const handleChange = (index, field, value) => {
    setMaterials((prev) => {
      const newArr = [...prev];
      newArr[index][field] = value;
      // Auto-recalculate total
      const qty = parseFloat(newArr[index].quantity) || 0;
      const unitP = parseFloat(newArr[index].unitPrice) || 0;
      newArr[index].totalPrice = qty * unitP;

      // Update hasSelections state if needed
      if (field === 'selected') {
        const anySelected = newArr.some((item) => item.selected);
        setHasSelections(anySelected);
      }

      return newArr;
    });
  };

  // Handle bulk price update
  const handleApplyBulkPrice = () => {
    if (!bulkPrice || isNaN(parseFloat(bulkPrice))) {
      Alert.alert('Lỗi', 'Vui lòng nhập giá hợp lệ');
      return;
    }

    const price = parseFloat(bulkPrice);

    setMaterials((prev) => {
      return prev.map((item) => {
        if (item.selected) {
          const qty = parseFloat(item.quantity) || 0;
          return {
            ...item,
            unitPrice: price.toString(),
            totalPrice: qty * price,
          };
        }
        return item;
      });
    });

    setShowBulkPriceModal(false);
    setBulkPrice('');
  };

  const toggleSelectAll = (value) => {
    setMaterials((prev) =>
      prev.map((item) => ({
        ...item,
        selected: value,
      }))
    );
    setHasSelections(value);
  };

  const formatNumber = (num) => (num || num === 0 ? num.toString() : '');

  const computeSubTotal = () => {
    return materials.reduce((sum, m) => sum + (m.totalPrice || 0), 0);
  };

  const handleContinue = () => {
    // Validate
    if (materials.length === 0) {
      Alert.alert('Thông báo', 'Vui lòng nhập ít nhất 1 vật tư.');
      return;
    }

    const cleaned = materials.filter((m) => (m.name || '').trim() !== '');

    if (cleaned.length === 0) {
      Alert.alert('Thông báo', 'Tên vật tư không được bỏ trống.');
      return;
    }

    const subTotal = computeSubTotal();

    const customerData = {
      id: project.customerId || '',
      name: project.customerName || 'Khách hàng',
      address: project.customerAddress || '',
      phone: project.customerPhone || '',
      email: project.customerEmail || '',
      contactPerson: project.customerContactPerson || '',
      taxCode: project.customerTaxCode || '',
    };

    // Remove selected property before navigation
    const cleanedWithoutSelected = cleaned.map(({ selected, ...rest }) => rest);

    navigation.navigate('FinalizeQuotation', {
      materials: cleanedWithoutSelected,
      subTotal,
      projectId,
      projectName: project.name || projectName || 'Dự án',
      customerData,
    });
  };

  const renderRow = ({ item, index }) => {
    return (
      <View style={styles.row}>
        <TouchableOpacity
          style={styles.checkbox}
          onPress={() => handleChange(index, 'selected', !item.selected)}
        >
          <Ionicons
            name={item.selected ? 'checkbox' : 'square-outline'}
            size={20}
            color={item.selected ? '#0066CC' : '#999'}
          />
        </TouchableOpacity>

        <TextInput
          style={[styles.input, { flex: 2 }]}
          placeholder="Tên vật tư"
          value={item.name}
          onChangeText={(text) => handleChange(index, 'name', text)}
        />

        <TouchableOpacity
          style={[styles.pickerButton, { flex: 1.5 }]}
          onPress={() => {
            setActiveMaterialPicker(index);
            setShowMaterialModal(true);
          }}
        >
          <Text>{item.material || MATERIAL_OPTIONS[0]}</Text>
          <Ionicons name="chevron-down" size={16} color="#666" />
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.pickerButton, { flex: 0.9 }]}
          onPress={() => {
            setActiveUnitPicker(index);
            setShowUnitModal(true);
          }}
        >
          <Text>{item.unit || UNIT_OPTIONS[0]}</Text>
          <Ionicons name="chevron-down" size={16} color="#666" />
        </TouchableOpacity>

        <TextInput
          style={[styles.input, { flex: 0.8 }]}
          placeholder="SL"
          keyboardType="numeric"
          value={formatNumber(item.quantity)}
          onChangeText={(text) => handleChange(index, 'quantity', text)}
        />

        <TextInput
          style={[styles.input, { flex: 1 }]}
          placeholder="Đơn giá"
          keyboardType="numeric"
          value={formatNumber(item.unitPrice)}
          onChangeText={(text) => handleChange(index, 'unitPrice', text)}
        />

        <View style={[styles.totalCol, { flex: 1 }]}>
          <Text>
            {item.totalPrice ? item.totalPrice.toLocaleString('vi-VN') : ''}
          </Text>
        </View>
      </View>
    );
  };

  const [showMaterialModal, setShowMaterialModal] = useState(false);
  const [showUnitModal, setShowUnitModal] = useState(false);
  const [activeMaterialPicker, setActiveMaterialPicker] = useState(-1);
  const [activeUnitPicker, setActiveUnitPicker] = useState(-1);

  const handleSelectMaterial = (value) => {
    if (activeMaterialPicker >= 0) {
      handleChange(activeMaterialPicker, 'material', value);
    }
    setShowMaterialModal(false);
  };

  const handleSelectUnit = (value) => {
    if (activeUnitPicker >= 0) {
      handleChange(activeUnitPicker, 'unit', value);
    }
    setShowUnitModal(false);
  };

  const subTotal = computeSubTotal();

  return (
    <KeyboardAvoidingView
      style={{ flex: 1 }}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
    >
      <ScrollView contentContainerStyle={{ padding: 16 }}>
        <Text style={styles.title}>Báo Giá Thủ Công – {projectName}</Text>

        <View style={styles.bulkActionContainer}>
          <View style={styles.selectAllContainer}>
            <TouchableOpacity
              style={styles.actionButton}
              onPress={() => toggleSelectAll(true)}
            >
              <Ionicons name="checkbox-outline" size={18} color="#fff" />
              <Text style={styles.actionButtonText}>Chọn tất cả</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.actionButton, styles.unselectButton]}
              onPress={() => toggleSelectAll(false)}
            >
              <Ionicons name="square-outline" size={18} color="#fff" />
              <Text style={styles.actionButtonText}>Bỏ chọn</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.actionButton,
                styles.priceButton,
                !hasSelections && styles.disabledButton,
              ]}
              disabled={!hasSelections}
              onPress={() => setShowBulkPriceModal(true)}
            >
              <Ionicons name="pricetag-outline" size={18} color="#fff" />
              <Text style={styles.actionButtonText}>Áp dụng giá</Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.tableHeader}>
          <View style={{ width: 30 }}></View>
          <Text style={[styles.headerCell, { flex: 2 }]}>Tên VT</Text>
          <Text style={[styles.headerCell, { flex: 1.5 }]}>Vật Liệu</Text>
          <Text style={[styles.headerCell, { flex: 0.9 }]}>ĐVT</Text>
          <Text style={[styles.headerCell, { flex: 0.8 }]}>SL</Text>
          <Text style={[styles.headerCell, { flex: 1 }]}>Đơn giá</Text>
          <Text style={[styles.headerCell, { flex: 1 }]}>Thành tiền</Text>
        </View>

        <FlatList
          data={materials}
          keyExtractor={(_, idx) => idx.toString()}
          renderItem={renderRow}
          scrollEnabled={false}
        />

        <TouchableOpacity style={styles.addBtn} onPress={addMaterialRow}>
          <Ionicons name="add-circle-outline" size={20} color="#fff" />
          <Text style={{ color: '#fff', marginLeft: 6 }}>Thêm vật tư</Text>
        </TouchableOpacity>

        <View style={styles.subTotalRow}>
          <Text style={styles.subTotalLabel}>Tổng cộng:</Text>
          <Text style={styles.subTotalVal}>
            {subTotal.toLocaleString('vi-VN')} đ
          </Text>
        </View>

        <TouchableOpacity style={styles.continueBtn} onPress={handleContinue}>
          <Ionicons name="arrow-forward-circle" size={22} color="#fff" />
          <Text style={{ color: '#fff', marginLeft: 8 }}>Tiếp tục</Text>
        </TouchableOpacity>
      </ScrollView>

      {/* Material Selection Modal */}
      <Modal
        transparent={true}
        visible={showMaterialModal}
        animationType="slide"
        onRequestClose={() => setShowMaterialModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Chọn vật liệu</Text>
            {MATERIAL_OPTIONS.map((option) => (
              <TouchableOpacity
                key={option}
                style={styles.modalItem}
                onPress={() => handleSelectMaterial(option)}
              >
                <Text style={styles.modalItemText}>{option}</Text>
              </TouchableOpacity>
            ))}
            <TouchableOpacity
              style={styles.modalCloseButton}
              onPress={() => setShowMaterialModal(false)}
            >
              <Text style={styles.modalCloseText}>Đóng</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Unit Selection Modal */}
      <Modal
        transparent={true}
        visible={showUnitModal}
        animationType="slide"
        onRequestClose={() => setShowUnitModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Chọn đơn vị tính</Text>
            {UNIT_OPTIONS.map((option) => (
              <TouchableOpacity
                key={option}
                style={styles.modalItem}
                onPress={() => handleSelectUnit(option)}
              >
                <Text style={styles.modalItemText}>{option}</Text>
              </TouchableOpacity>
            ))}
            <TouchableOpacity
              style={styles.modalCloseButton}
              onPress={() => setShowUnitModal(false)}
            >
              <Text style={styles.modalCloseText}>Đóng</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Bulk Price Modal */}
      <Modal
        transparent={true}
        visible={showBulkPriceModal}
        animationType="slide"
        onRequestClose={() => setShowBulkPriceModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Áp dụng giá cho mục đã chọn</Text>

            <TextInput
              style={styles.bulkPriceInput}
              placeholder="Nhập đơn giá áp dụng"
              keyboardType="numeric"
              value={bulkPrice}
              onChangeText={setBulkPrice}
              autoFocus
            />

            <View style={styles.bulkPriceActions}>
              <TouchableOpacity
                style={[styles.bulkPriceActionButton, styles.cancelButton]}
                onPress={() => setShowBulkPriceModal(false)}
              >
                <Text style={styles.cancelButtonText}>Hủy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.bulkPriceActionButton, styles.applyButton]}
                onPress={handleApplyBulkPrice}
              >
                <Text style={styles.applyButtonText}>Áp dụng</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  tableHeader: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    paddingVertical: 6,
    alignItems: 'center',
  },
  headerCell: {
    fontWeight: '600',
  },
  row: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 4,
  },
  checkbox: {
    width: 30,
    alignItems: 'center',
    justifyContent: 'center',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 4,
    padding: 6,
    marginRight: 4,
  },
  pickerContainer: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 4,
    overflow: 'hidden',
    marginRight: 4,
    height: 40,
  },
  totalCol: {
    alignItems: 'flex-end',
    paddingHorizontal: 4,
  },
  addBtn: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#007AFF',
    padding: 10,
    borderRadius: 6,
    alignSelf: 'flex-start',
    marginTop: 8,
  },
  subTotalRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
  },
  subTotalLabel: {
    fontWeight: 'bold',
    fontSize: 16,
  },
  subTotalVal: {
    fontWeight: 'bold',
    fontSize: 16,
    color: '#d11a2a',
  },
  continueBtn: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#28a745',
    justifyContent: 'center',
    padding: 12,
    borderRadius: 8,
    marginTop: 20,
  },
  pickerButton: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 4,
    paddingHorizontal: 10,
    paddingVertical: 8,
    marginRight: 4,
    backgroundColor: '#fff',
  },
  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.5)',
    padding: 20,
  },
  modalContent: {
    backgroundColor: '#fff',
    borderRadius: 10,
    padding: 20,
    width: '80%',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 15,
    textAlign: 'center',
  },
  modalItem: {
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  modalItemText: {
    fontSize: 16,
  },
  modalCloseButton: {
    marginTop: 15,
    backgroundColor: '#0066CC',
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
  },
  modalCloseText: {
    color: '#fff',
    fontWeight: 'bold',
    fontSize: 16,
  },
  bulkActionContainer: {
    marginBottom: 16,
  },
  selectAllContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'flex-start',
    flexWrap: 'wrap',
    gap: 10,
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 6,
    backgroundColor: '#0066CC',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 1.5,
    minWidth: 110,
  },
  unselectButton: {
    backgroundColor: '#6c757d',
  },
  priceButton: {
    backgroundColor: '#28a745',
  },
  actionButtonText: {
    color: '#fff',
    marginLeft: 6,
    fontWeight: '500',
  },
  disabledButton: {
    backgroundColor: '#ccc',
    opacity: 0.7,
  },
  bulkPriceButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#0066CC',
    paddingVertical: 6,
    paddingHorizontal: 10,
    borderRadius: 4,
  },
  disabledButton: {
    backgroundColor: '#ccc',
  },
  bulkPriceText: {
    color: '#fff',
    marginLeft: 5,
  },
  bulkPriceInput: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 4,
    padding: 12,
    fontSize: 16,
    marginTop: 10,
    marginBottom: 20,
  },
  bulkPriceActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  bulkPriceActionButton: {
    paddingVertical: 10,
    paddingHorizontal: 15,
    borderRadius: 4,
    flex: 1,
    marginHorizontal: 5,
    alignItems: 'center',
  },
  cancelButton: {
    backgroundColor: '#f8f9fa',
    borderWidth: 1,
    borderColor: '#ccc',
  },
  cancelButtonText: {
    color: '#333',
  },
  applyButton: {
    backgroundColor: '#28a745',
  },
  applyButtonText: {
    color: '#fff',
    fontWeight: 'bold',
  },
});

export default ManualQuotationScreen;

// src/screens/MaterialPurchaseScreen.js
import React, { useState, useEffect, useCallback, memo } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  ActivityIndicator,
  TouchableOpacity,
  Alert,
  SafeAreaView,
  ScrollView,
  Modal,
  TextInput,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';
import { useProjectDetails } from '../hooks/useProjectDetails';
import { useAuth } from '../contexts/AuthContext';
import { db } from '../config/firebaseConfig';
import {
  collection,
  doc,
  getDoc,
  getDocs,
  addDoc,
  updateDoc,
  query,
  orderBy,
  serverTimestamp,
  where,
} from 'firebase/firestore';
import { getQuotationsByProject } from '../api/quotationService';
import {
  getProposalsByStatus,
  updateProposalMaterialPrices,
} from '../api/proposalService';

// Memoized row component for the materials list
const MaterialRow = memo(({ item, index, onTogglePurchased }) => {
  return (
    <View style={styles.tableRow}>
      <TouchableOpacity
        style={styles.checkbox}
        onPress={() => onTogglePurchased(index)}
      >
        <Ionicons
          name={item.purchased ? 'checkbox' : 'square-outline'}
          size={18}
          color={item.purchased ? '#4CAF50' : '#999'}
        />
      </TouchableOpacity>
      <View style={[styles.tableCell, { flex: 3 }]}>
        <Text style={styles.materialName}>{item.name}</Text>
        {item.material ? (
          <Text style={styles.materialType}>{item.material}</Text>
        ) : null}
        {item.quyCach ? (
          <Text style={styles.materialType}>Quy cách: {item.quyCach}</Text>
        ) : null}
      </View>
      <Text style={[styles.tableCell, { flex: 1, textAlign: 'center' }]}>
        {formatNumber(item.quantity)}
      </Text>
      <Text style={[styles.tableCell, { flex: 1, textAlign: 'center' }]}>
        {formatNumber(item.weight)}
      </Text>
      <Text style={[styles.tableCell, { flex: 0.8, textAlign: 'center' }]}>
        {item.unit}
      </Text>
    </View>
  );
});

// Helper functions
const formatNumber = (num) => {
  if (typeof num !== 'number' || isNaN(num)) return '0';
  const roundedNum = Math.round(num * 10) / 10;
  return roundedNum.toString().replace('.', ',');
};

const MaterialPurchaseScreen = ({ route, navigation }) => {
  const { projectId, projectName, project } = route.params;
  const { currentUser } = useAuth();
  const { project: projectDetails, loading: loadingProject } =
    useProjectDetails(projectId);

  const [materials, setMaterials] = useState([]);
  const [purchaseHistory, setPurchaseHistory] = useState([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [selectedForProposal, setSelectedForProposal] = useState([]);
  const [quotations, setQuotations] = useState([]);
  const [approvedProposals, setApprovedProposals] = useState([]);
  const [showPriceModal, setShowPriceModal] = useState(false);
  const [editableMaterials, setEditableMaterials] = useState([]);
  const [currentProposalId, setCurrentProposalId] = useState(null);
  const [loadingProposals, setLoadingProposals] = useState(false);
  const [showConfirmModal, setShowConfirmModal] = useState(false);
  const [purchasedMaterials, setPurchasedMaterials] = useState([]);
  const [showHistoryDetailModal, setShowHistoryDetailModal] = useState(false);
  const [selectedHistory, setSelectedHistory] = useState(null);
  const [historyMaterials, setHistoryMaterials] = useState([]);
  const [updatingHistory, setUpdatingHistory] = useState(false);

  const handleTogglePurchased = (index) => {
    setMaterials((prev) => {
      const updated = [...prev];
      updated[index] = {
        ...updated[index],
        purchased: !updated[index].purchased,
        selectedForProposal: !updated[index].purchased, // Đồng bộ với trạng thái purchased
      };
      return updated;
    });
  };

  const handleToggleSelectForProposal = (index) => {
    setMaterials((prev) => {
      const arr = [...prev];
      arr[index].selectedForProposal = !arr[index].selectedForProposal;
      return arr;
    });
  };

  const handleCreateProposal = () => {
    // Lọc theo thuộc tính purchased thay vì selectedForProposal
    const selected = materials.filter((m) => m.purchased);
    if (!selected.length)
      return Alert.alert(
        'Chưa chọn vật tư',
        'Vui lòng tick chọn các vật tư cần mua.'
      );
    navigation.navigate('CreateProposal', {
      projectId,
      projectName: projectDetails?.name || projectName,
      selectedItems: selected,
    });
  };

  // Modified function to show confirmation before saving
  const handleSavePurchaseList = () => {
    const selected = materials.filter((m) => m.purchased);

    if (selected.length === 0) {
      Alert.alert(
        'Chưa chọn vật tư',
        'Vui lòng tick chọn các vật tư đã mua trước khi lưu.'
      );
      return;
    }

    setPurchasedMaterials(selected);
    setShowConfirmModal(true);
  };

  // New function to actually save the purchase list after confirmation
  const confirmSavePurchaseList = async () => {
    setSaving(true);
    try {
      // Create a map of material names to purchase status
      const purchasedItems = {};
      materials.forEach((item) => {
        purchasedItems[item.name] = item.purchased === true;
      });

      // Save to purchase history collection
      const purchaseRef = collection(db, 'projects', projectId, 'purchases');
      await addDoc(purchaseRef, {
        projectId,
        purchasedItems,
        createdAt: serverTimestamp(),
        createdBy: currentUser?.uid || 'unknown',
        createdByName: currentUser?.displayName || 'Người dùng',
      });

      // Calculate if all items are purchased
      const allItems = Object.values(purchasedItems);
      const purchasedCount = allItems.filter((v) => v === true).length;
      const totalCount = allItems.length;

      // Update project task status based on purchase progress
      const projectRef = doc(db, 'projects', projectId);
      await updateDoc(projectRef, {
        'tasks.material_purchasing.status':
          purchasedCount === totalCount ? 'completed' : 'in_progress',
      });

      // Close modal and show success message
      setShowConfirmModal(false);
      Alert.alert(
        'Thành công',
        `Đã lưu danh sách ${purchasedCount} vật tư đã mua.`
      );

      // Reload purchase history
      const purchaseQuery = query(purchaseRef, orderBy('createdAt', 'desc'));
      const purchaseSnapshot = await getDocs(purchaseQuery);
      setPurchaseHistory(
        purchaseSnapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }))
      );
    } catch (error) {
      console.error('Lỗi khi lưu danh sách:', error);
      Alert.alert('Lỗi', 'Không thể lưu danh sách vật tư.');
    } finally {
      setSaving(false);
    }
  };

  // Handle loading quotation materials
  const handleRequote = useCallback(
    (quotation) => {
      if (quotation.materials && Array.isArray(quotation.materials)) {
        // Get purchase history to merge with quotation materials
        const loadPurchaseHistory = async () => {
          try {
            const purchaseRef = collection(
              db,
              'projects',
              projectId,
              'purchases'
            );
            const purchaseQuery = query(
              purchaseRef,
              orderBy('createdAt', 'desc')
            );
            const purchaseSnapshot = await getDocs(purchaseQuery);

            let purchasedItems = {};
            if (!purchaseSnapshot.empty) {
              const latestPurchase = purchaseSnapshot.docs[0].data();
              purchasedItems = latestPurchase.purchasedItems || {};
              setPurchaseHistory(
                purchaseSnapshot.docs.map((doc) => ({
                  id: doc.id,
                  ...doc.data(),
                }))
              );
            }

            // Merge purchased state with materials
            const materialsWithPurchaseState = quotation.materials.map(
              (item) => ({
                ...item,
                purchased: purchasedItems[item.name] === true,
              })
            );

            setMaterials(materialsWithPurchaseState);
          } catch (error) {
            console.error('Lỗi khi tải lịch sử mua hàng:', error);
          }
        };

        loadPurchaseHistory();
        Alert.alert(
          'Tải thành công',
          `Đã tải dữ liệu từ báo giá ${
            quotation.quotationNumber || 'mới nhất'
          }.`
        );
      } else {
        Alert.alert('Lỗi', 'Báo giá này không chứa dữ liệu vật tư để tải.');
      }
    },
    [projectId]
  );

  // Load approved proposals
  const loadApprovedProposals = useCallback(async () => {
    setLoadingProposals(true);
    try {
      // Get all approved proposals
      const allApproved = await getProposalsByStatus('approved');

      // Filter for this project if projectId is provided
      let projectProposals = allApproved;
      if (projectId) {
        projectProposals = allApproved.filter((p) => p.projectId === projectId);
      }

      setApprovedProposals(projectProposals);
    } catch (error) {
      console.error('Lỗi khi tải đề xuất đã duyệt:', error);
    } finally {
      setLoadingProposals(false);
    }
  }, [projectId]);

  // Handle price updates for a proposal
  const openPriceEditor = (proposal) => {
    // Create a deep copy of materials with price fields
    const materialsWithPrices = proposal.items
      ? JSON.parse(JSON.stringify(proposal.items))
      : [];

    // Ensure each material has price and totalPrice fields
    materialsWithPrices.forEach((item) => {
      if (!item.price) item.price = '';
      if (!item.totalPrice) item.totalPrice = '';
    });

    setEditableMaterials(materialsWithPrices);
    setCurrentProposalId(proposal.id);
    setShowPriceModal(true);
  };

  const handlePriceChange = (index, price) => {
    const updatedMaterials = [...editableMaterials];
    updatedMaterials[index].price = price;

    // Calculate total price if both price and quantity exist
    const quantity = parseFloat(updatedMaterials[index].quantity);
    const priceValue = parseFloat(price);

    if (!isNaN(quantity) && !isNaN(priceValue)) {
      updatedMaterials[index].totalPrice = (quantity * priceValue).toString();
    }

    setEditableMaterials(updatedMaterials);
  };

  const savePriceUpdates = async () => {
    if (!currentProposalId) return;

    try {
      await updateProposalMaterialPrices(currentProposalId, editableMaterials);
      Alert.alert('Thành công', 'Đã cập nhật giá vật tư');
      setShowPriceModal(false);
      loadApprovedProposals(); // Reload to get updated data
    } catch (error) {
      console.error('Error updating prices:', error);
      Alert.alert('Lỗi', 'Không thể cập nhật giá vật tư');
    }
  };

  // Load project materials and purchase history
  useFocusEffect(
    useCallback(() => {
      const loadData = async () => {
        setLoading(true);
        try {
          // Load quotations to get materials
          const pastQuotations = await getQuotationsByProject(projectId);
          setQuotations(pastQuotations);

          if (pastQuotations.length > 0) {
            // Automatically load the latest quotation
            const latestQuotation = pastQuotations[0];
            handleRequote(latestQuotation);
          }

          // Load approved proposals
          await loadApprovedProposals();
        } catch (error) {
          console.error('Lỗi khi tải dữ liệu:', error);
          Alert.alert('Lỗi', 'Không thể tải dữ liệu vật tư.');
        } finally {
          setLoading(false);
        }
      };

      loadData();
    }, [projectId, handleRequote, loadApprovedProposals])
  );

  // Calculate purchase stats
  const calculateStats = () => {
    if (!materials.length)
      return { purchasedCount: 0, totalCount: 0, percentComplete: 0 };

    const purchasedCount = materials.filter((item) => item.purchased).length;
    const totalCount = materials.length;
    const percentComplete = Math.round((purchasedCount / totalCount) * 100);

    return { purchasedCount, totalCount, percentComplete };
  };

  const stats = calculateStats();

  const renderHeader = () => (
    <View style={styles.header}>
      <Text style={styles.headerTitle}>Danh Sách Vật Tư Cần Mua</Text>
      <Text style={styles.projectName}>
        {projectDetails?.name || projectName}
      </Text>

      {materials.length > 0 && (
        <View style={styles.statsContainer}>
          <View style={styles.progressBar}>
            <View
              style={[
                styles.progressFill,
                { width: `${stats.percentComplete}%` },
              ]}
            />
          </View>
          <Text style={styles.statsText}>
            {stats.purchasedCount}/{stats.totalCount} vật tư đã mua (
            {stats.percentComplete}%)
          </Text>
        </View>
      )}
    </View>
  );

  const renderMaterialsSection = () => (
    <View style={styles.section}>
      <Text style={styles.sectionTitle}>Danh sách vật tư</Text>
      {materials.length > 0 ? (
        <>
          <View style={styles.tableHeader}>
            <View style={{ width: 30 }}></View>
            <Text style={[styles.headerCell, { flex: 3 }]}>Tên vật tư</Text>
            <Text style={[styles.headerCell, { flex: 1, textAlign: 'center' }]}>
              SL
            </Text>
            <Text style={[styles.headerCell, { flex: 1, textAlign: 'center' }]}>
              KL
            </Text>
            <Text
              style={[styles.headerCell, { flex: 0.8, textAlign: 'center' }]}
            >
              ĐVT
            </Text>
          </View>
          <FlatList
            data={materials}
            keyExtractor={(item, index) => `material-row-${index}`}
            renderItem={({ item, index }) => (
              <MaterialRow
                item={item}
                index={index}
                onTogglePurchased={handleTogglePurchased}
              />
            )}
            nestedScrollEnabled={true}
            style={{ maxHeight: 300 }}
          />
        </>
      ) : (
        <View style={styles.emptyContainer}>
          <Ionicons name="list-outline" size={48} color="#ccc" />
          <Text style={styles.emptyText}>
            Chưa có dữ liệu vật tư từ báo giá
          </Text>
          <TouchableOpacity
            style={styles.createQuotationButton}
            onPress={() =>
              navigation.navigate('Quotation', {
                projectId,
                projectName: projectDetails?.name || projectName,
                project: projectDetails,
              })
            }
          >
            <Text style={styles.createQuotationButtonText}>Tạo báo giá</Text>
          </TouchableOpacity>
        </View>
      )}
    </View>
  );

  const renderPurchaseHistory = () => (
    <View style={styles.section}>
      <Text style={styles.sectionTitle}>Danh sách cần mua</Text>
      {purchaseHistory.length === 0 ? (
        <Text style={styles.emptyText}>
          Chưa có danh sách mua hàng nào được lưu.
        </Text>
      ) : (
        <FlatList
          data={purchaseHistory}
          keyExtractor={(item) => item.id}
          renderItem={({ item }) => {
            const purchasedCount = Object.values(item.purchasedItems).filter(
              (v) => v === true
            ).length;
            const totalCount = Object.values(item.purchasedItems).length;

            return (
              <TouchableOpacity
                style={styles.historyItem}
                onPress={() => viewHistoryDetails(item)}
              >
                <Text style={styles.historyDate}>
                  {item.createdAt
                    ? new Date(
                        item.createdAt.seconds * 1000
                      ).toLocaleDateString('vi-VN')
                    : 'Không rõ ngày'}
                </Text>
                <Text style={styles.historyCreator}>
                  Người lưu: {item.createdByName || 'Không xác định'}
                </Text>
                <View style={styles.historyStats}>
                  <Text style={styles.historyStatText}>
                    Đã mua: {purchasedCount} vật tư
                  </Text>
                  <Text style={styles.historyStatText}>
                    Chưa mua: {totalCount - purchasedCount} vật tư
                  </Text>
                </View>
                <View style={styles.viewDetailsButton}>
                  <Text style={styles.viewDetailsText}>Xem chi tiết</Text>
                  <Ionicons name="chevron-forward" size={16} color="#0066cc" />
                </View>
              </TouchableOpacity>
            );
          }}
        />
      )}
    </View>
  );

  const renderQuotationsSection = () => (
    <View style={styles.section}>
      <Text style={styles.sectionTitle}>Lịch sử báo giá</Text>
      {quotations.length === 0 ? (
        <Text style={styles.emptyText}>Chưa có báo giá nào.</Text>
      ) : (
        <FlatList
          horizontal
          data={quotations}
          keyExtractor={(item) => item.id}
          renderItem={({ item }) => (
            <TouchableOpacity
              style={styles.quotationItem}
              onPress={() => handleRequote(item)}
            >
              <Text style={styles.quotationNumber}>
                {item.quotationNumber || `Báo giá #${item.id.substring(0, 5)}`}
              </Text>
              <Text style={styles.quotationDate}>
                {item.createdAt
                  ? new Date(item.createdAt.seconds * 1000).toLocaleDateString(
                      'vi-VN'
                    )
                  : 'Không rõ'}
              </Text>
            </TouchableOpacity>
          )}
        />
      )}
    </View>
  );

  // Render approved proposals section
  const renderApprovedProposals = () => (
    <View style={styles.section}>
      <View style={styles.sectionHeader}>
        <Text style={styles.sectionTitle}>Đề xuất đã được duyệt</Text>
      </View>

      {loadingProposals ? (
        <ActivityIndicator size="small" color="#0066cc" />
      ) : approvedProposals.length === 0 ? (
        <Text style={styles.emptyText}>Chưa có đề xuất nào được duyệt</Text>
      ) : (
        <FlatList
          data={approvedProposals}
          keyExtractor={(item) => item.id}
          renderItem={({ item }) => (
            <View style={styles.proposalCard}>
              <View style={styles.proposalHeader}>
                <Text style={styles.proposalCode}>
                  {item.proposalCode || `PO-${item.id.substring(0, 6)}`}
                </Text>
                {item.hasPrices && (
                  <View style={styles.priceBadge}>
                    <Text style={styles.priceBadgeText}>Đã có giá</Text>
                  </View>
                )}
              </View>

              <Text style={styles.proposalProject}>{item.projectName}</Text>

              <View style={styles.proposalDetails}>
                <View style={styles.proposalDetailRow}>
                  <Text style={styles.proposalDetailLabel}>Ngày yêu cầu:</Text>
                  <Text style={styles.proposalDetailValue}>
                    {item.requiredDate
                      ? new Date(
                          item.requiredDate.seconds * 1000
                        ).toLocaleDateString('vi-VN')
                      : 'N/A'}
                  </Text>
                </View>

                <View style={styles.proposalDetailRow}>
                  <Text style={styles.proposalDetailLabel}>
                    Số lượng vật tư:
                  </Text>
                  <Text style={styles.proposalDetailValue}>
                    {item.items?.length || 0}
                  </Text>
                </View>

                {item.totalValue && (
                  <View style={styles.proposalDetailRow}>
                    <Text style={styles.proposalDetailLabel}>
                      Tổng giá trị:
                    </Text>
                    <Text style={styles.proposalDetailValue}>
                      {item.totalValue.toLocaleString('vi-VN')} VNĐ
                    </Text>
                  </View>
                )}
              </View>

              <View style={styles.proposalActions}>
                <TouchableOpacity
                  style={[styles.proposalButton, styles.viewButton]}
                  onPress={() => navigation.navigate('ProposalList')}
                >
                  <Ionicons name="eye-outline" size={16} color="#0066cc" />
                  <Text style={styles.viewButtonText}>Xem chi tiết</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[styles.proposalButton, styles.priceButton]}
                  onPress={() => openPriceEditor(item)}
                >
                  <Ionicons name="cash-outline" size={16} color="#28a745" />
                  <Text style={[styles.viewButtonText, { color: '#28a745' }]}>
                    {item.hasPrices ? 'Cập nhật giá' : 'Nhập giá'}
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          )}
          contentContainerStyle={styles.proposalList}
        />
      )}
    </View>
  );

  // New function to render the confirmation modal
  const renderConfirmationModal = () => (
    <Modal visible={showConfirmModal} transparent animationType="slide">
      <View style={styles.modalOverlay}>
        <View style={styles.modalContainer}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>Xác nhận vật tư đã mua</Text>
            <TouchableOpacity onPress={() => setShowConfirmModal(false)}>
              <Ionicons name="close" size={24} color="#666" />
            </TouchableOpacity>
          </View>

          <Text style={styles.confirmText}>
            Bạn đang xác nhận đã mua {purchasedMaterials.length} vật tư sau:
          </Text>

          <ScrollView style={styles.confirmList}>
            {purchasedMaterials.map((item, index) => (
              <View key={index} style={styles.confirmItem}>
                <Ionicons
                  name="checkmark-circle"
                  size={18}
                  color="#4CAF50"
                  style={styles.confirmIcon}
                />
                <View style={styles.confirmItemContent}>
                  <Text style={styles.confirmItemName}>
                    {index + 1}. {item.name}
                  </Text>
                  <Text style={styles.confirmItemDetails}>
                    {item.quantity} {item.unit || 'cái'}
                    {item.quyCach ? ` - ${item.quyCach}` : ''}
                  </Text>
                </View>
              </View>
            ))}
          </ScrollView>

          <View style={styles.modalActions}>
            <TouchableOpacity
              style={[styles.modalButton, styles.cancelButton]}
              onPress={() => setShowConfirmModal(false)}
            >
              <Text style={styles.cancelButtonText}>Hủy</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.modalButton, styles.confirmButton]}
              onPress={confirmSavePurchaseList}
              disabled={saving}
            >
              {saving ? (
                <ActivityIndicator size="small" color="#fff" />
              ) : (
                <Text style={styles.confirmButtonText}>Xác nhận</Text>
              )}
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );

  // Function to view history details
  const viewHistoryDetails = async (historyItem) => {
    setSelectedHistory(historyItem);

    try {
      // Get the full material list from the latest quotation
      let materialsList = [...materials];

      // Merge with purchase status from history
      if (historyItem.purchasedItems) {
        materialsList = materialsList.map((material) => ({
          ...material,
          purchased: historyItem.purchasedItems[material.name] === true,
        }));
      }

      setHistoryMaterials(materialsList);
      setShowHistoryDetailModal(true);
    } catch (error) {
      console.error('Lỗi khi tải chi tiết lịch sử:', error);
      Alert.alert('Lỗi', 'Không thể tải chi tiết lịch sử mua hàng.');
    }
  };

  // Function to toggle purchase status in history detail
  const toggleHistoryItemStatus = (index) => {
    setHistoryMaterials((prev) => {
      const updated = [...prev];
      updated[index] = {
        ...updated[index],
        purchased: !updated[index].purchased,
      };
      return updated;
    });
  };

  // Function to update purchase history
  const updatePurchaseHistory = async () => {
    if (!selectedHistory) return;

    setUpdatingHistory(true);
    try {
      // Create updated purchasedItems object
      const purchasedItems = {};
      historyMaterials.forEach((item) => {
        purchasedItems[item.name] = item.purchased === true;
      });

      // Update the history document
      const historyRef = doc(
        db,
        'projects',
        projectId,
        'purchases',
        selectedHistory.id
      );
      await updateDoc(historyRef, {
        purchasedItems,
        updatedAt: serverTimestamp(),
        updatedBy: currentUser?.uid || 'unknown',
        updatedByName:
          currentUser?.displayName || currentUser?.email || 'Người dùng',
      });

      // Calculate if all items are purchased
      const purchasedCount = Object.values(purchasedItems).filter(
        (v) => v === true
      ).length;
      const totalCount = Object.values(purchasedItems).length;

      // Update project task status
      const projectRef = doc(db, 'projects', projectId);
      await updateDoc(projectRef, {
        'tasks.material_purchasing.status':
          purchasedCount === totalCount ? 'completed' : 'in_progress',
      });

      // Reload purchase history
      const purchaseRef = collection(db, 'projects', projectId, 'purchases');
      const purchaseQuery = query(purchaseRef, orderBy('createdAt', 'desc'));
      const purchaseSnapshot = await getDocs(purchaseQuery);
      setPurchaseHistory(
        purchaseSnapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }))
      );

      setShowHistoryDetailModal(false);
      Alert.alert('Thành công', 'Đã cập nhật trạng thái mua hàng.');
    } catch (error) {
      console.error('Lỗi khi cập nhật lịch sử:', error);
      Alert.alert('Lỗi', 'Không thể cập nhật lịch sử mua hàng.');
    } finally {
      setUpdatingHistory(false);
    }
  };

  // New function to render history detail modal
  const renderHistoryDetailModal = () => (
    <Modal visible={showHistoryDetailModal} transparent animationType="slide">
      <View style={styles.modalOverlay}>
        <View style={[styles.modalContainer, styles.historyModalContainer]}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>Chi tiết mua hàng</Text>
            <TouchableOpacity onPress={() => setShowHistoryDetailModal(false)}>
              <Ionicons name="close" size={24} color="#666" />
            </TouchableOpacity>
          </View>

          {selectedHistory && (
            <View style={styles.historyDetailHeader}>
              <Text style={styles.historyDetailDate}>
                Ngày:{' '}
                {selectedHistory.createdAt
                  ? new Date(
                      selectedHistory.createdAt.seconds * 1000
                    ).toLocaleDateString('vi-VN')
                  : 'Không rõ'}
              </Text>
              <Text style={styles.historyDetailPerson}>
                Người lưu: {selectedHistory.createdByName || 'Không xác định'}
              </Text>
              {selectedHistory.updatedAt && (
                <Text style={styles.historyDetailUpdate}>
                  Cập nhật lần cuối:{' '}
                  {new Date(
                    selectedHistory.updatedAt.seconds * 1000
                  ).toLocaleDateString('vi-VN')}
                </Text>
              )}
            </View>
          )}

          <Text style={styles.historyDetailInstruction}>
            Nhấn vào ô vuông để thay đổi trạng thái đã mua/chưa mua
          </Text>

          <ScrollView style={styles.historyDetailList}>
            {historyMaterials.length > 0 ? (
              historyMaterials.map((item, index) => (
                <TouchableOpacity
                  key={index}
                  style={styles.historyDetailItem}
                  onPress={() => toggleHistoryItemStatus(index)}
                >
                  <View style={styles.historyCheckbox}>
                    <Ionicons
                      name={item.purchased ? 'checkbox' : 'square-outline'}
                      size={22}
                      color={item.purchased ? '#4CAF50' : '#999'}
                    />
                  </View>
                  <View style={styles.historyItemContent}>
                    <Text style={styles.historyItemName}>{item.name}</Text>
                    <Text style={styles.historyItemDetails}>
                      {item.quantity} {item.unit || 'cái'}
                      {item.quyCach ? ` - ${item.quyCach}` : ''}
                    </Text>
                  </View>
                  <View
                    style={[
                      styles.historyItemStatus,
                      {
                        backgroundColor: item.purchased ? '#e8f5e9' : '#fff3e0',
                      },
                    ]}
                  >
                    <Text
                      style={[
                        styles.historyItemStatusText,
                        { color: item.purchased ? '#4CAF50' : '#FF9800' },
                      ]}
                    >
                      {item.purchased ? 'Đã mua' : 'Chưa mua'}
                    </Text>
                  </View>
                </TouchableOpacity>
              ))
            ) : (
              <Text style={styles.emptyText}>Không có dữ liệu vật tư</Text>
            )}
          </ScrollView>

          <View style={styles.modalActions}>
            <TouchableOpacity
              style={[styles.modalButton, styles.cancelButton]}
              onPress={() => setShowHistoryDetailModal(false)}
            >
              <Text style={styles.cancelButtonText}>Đóng</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.modalButton, styles.updateButton]}
              onPress={updatePurchaseHistory}
              disabled={updatingHistory}
            >
              {updatingHistory ? (
                <ActivityIndicator size="small" color="#fff" />
              ) : (
                <Text style={styles.updateButtonText}>Cập nhật</Text>
              )}
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );

  return (
    <SafeAreaView style={styles.container}>
      {renderHeader()}

      {loading || loadingProject ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#0066cc" />
          <Text style={styles.loadingText}>Đang tải dữ liệu...</Text>
        </View>
      ) : (
        <View style={{ flex: 1 }}>
          <ScrollView>
            {renderQuotationsSection()}
            {renderMaterialsSection()}
            {renderApprovedProposals()}
            {renderPurchaseHistory()}
          </ScrollView>

          {materials.length > 0 && (
            <View style={styles.buttonContainer}>
              <TouchableOpacity
                style={styles.saveButton}
                onPress={handleSavePurchaseList}
                disabled={saving}
              >
                <View style={styles.buttonContent}>
                  {saving ? (
                    <ActivityIndicator size="small" color="#fff" />
                  ) : (
                    <Ionicons name="save-outline" size={20} color="#fff" />
                  )}
                  <Text style={styles.saveButtonText}>
                    Lưu danh sách mua hàng
                  </Text>
                </View>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.saveButton,
                  { backgroundColor: '#0066cc', marginTop: 8 },
                ]}
                onPress={handleCreateProposal}
              >
                <View style={styles.buttonContent}>
                  <Ionicons name="send" size={20} color="#fff" />
                  <Text style={styles.saveButtonText}>
                    Tạo Đề Xuất Mua Vật Tư
                  </Text>
                </View>
              </TouchableOpacity>
            </View>
          )}
        </View>
      )}

      {/* Price Update Modal */}
      <Modal visible={showPriceModal} transparent animationType="slide">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContainer}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Cập nhật giá vật tư</Text>
              <TouchableOpacity onPress={() => setShowPriceModal(false)}>
                <Ionicons name="close" size={24} color="#666" />
              </TouchableOpacity>
            </View>

            <ScrollView style={styles.priceScrollView}>
              {editableMaterials && editableMaterials.length > 0 ? (
                editableMaterials.map((item, index) => (
                  <View key={index} style={styles.priceItem}>
                    <Text style={styles.materialName}>
                      {index + 1}. {item.name || 'Không có tên'}
                    </Text>
                    <View style={styles.materialDetails}>
                      {item.specification ? (
                        <Text style={styles.materialSpec}>
                          Quy cách: {item.specification}
                        </Text>
                      ) : null}
                      <Text style={styles.materialQuantity}>
                        Số lượng: {item.quantity || 0} {item.unit || ''}
                      </Text>

                      <View style={styles.priceInputContainer}>
                        <Text style={styles.priceLabel}>Đơn giá (VNĐ):</Text>
                        <TextInput
                          style={styles.priceInput}
                          value={item.price}
                          onChangeText={(text) =>
                            handlePriceChange(index, text)
                          }
                          keyboardType="numeric"
                          placeholder="Nhập đơn giá"
                        />
                      </View>

                      {item.totalPrice && (
                        <Text style={styles.materialTotalPrice}>
                          Thành tiền: {item.totalPrice} VNĐ
                        </Text>
                      )}
                    </View>
                  </View>
                ))
              ) : (
                <Text style={styles.emptyText}>Không có vật tư nào.</Text>
              )}
            </ScrollView>

            <View style={styles.modalActions}>
              <TouchableOpacity
                style={[styles.modalButton, styles.cancelButton]}
                onPress={() => setShowPriceModal(false)}
              >
                <Text style={styles.cancelButtonText}>Hủy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.modalButton, styles.saveButton]}
                onPress={savePriceUpdates}
              >
                <Text style={styles.saveButtonText}>Lưu giá</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Confirmation Modal */}
      {renderConfirmationModal()}

      {/* History Detail Modal */}
      {renderHistoryDetailModal()}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  header: {
    padding: 16,
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  projectName: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
  section: {
    backgroundColor: '#fff',
    borderRadius: 8,
    margin: 8,
    padding: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 3,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 10,
  },
  tableHeader: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
    paddingBottom: 8,
    marginBottom: 8,
  },
  headerCell: {
    fontWeight: '600',
    fontSize: 14,
    color: '#333',
  },
  tableRow: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
    paddingVertical: 8,
    alignItems: 'center',
  },
  checkbox: {
    width: 30,
    alignItems: 'center',
    justifyContent: 'center',
  },
  tableCell: {
    paddingHorizontal: 4,
  },
  materialName: {
    fontSize: 14,
    fontWeight: '500',
  },
  materialType: {
    fontSize: 12,
    color: '#666',
    marginTop: 2,
  },
  saveButton: {
    backgroundColor: '#4CAF50',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center', // This will center the content
    paddingVertical: 12,
    marginHorizontal: 8,
    borderRadius: 8,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 3,
  },
  saveButtonText: {
    color: '#fff',
    fontWeight: '600',
    marginLeft: 8,
    fontSize: 15, // Slightly larger text
    textAlignVertical: 'center', // Align text vertically
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 12,
    color: '#666',
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 24,
  },
  emptyText: {
    color: '#999',
    marginTop: 8,
  },
  createQuotationButton: {
    marginTop: 16,
    paddingVertical: 8,
    paddingHorizontal: 16,
    backgroundColor: '#0066cc',
    borderRadius: 20,
  },
  createQuotationButtonText: {
    color: '#fff',
    fontWeight: '500',
  },
  historyItem: {
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderRadius: 8,
    padding: 12,
    marginBottom: 8,
    backgroundColor: '#fff',
  },
  historyDate: {
    fontWeight: '600',
    fontSize: 14,
  },
  historyCreator: {
    fontSize: 12,
    color: '#666',
    marginTop: 4,
  },
  historyStats: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 8,
    paddingTop: 8,
    borderTopWidth: 1,
    borderTopColor: '#f0f0f0',
  },
  historyStatText: {
    fontSize: 12,
  },
  statsContainer: {
    marginTop: 10,
    alignItems: 'center',
  },
  progressBar: {
    width: '100%',
    height: 8,
    backgroundColor: '#e0e0e0',
    borderRadius: 4,
    overflow: 'hidden',
    marginBottom: 5,
  },
  progressFill: {
    height: '100%',
    backgroundColor: '#4CAF50',
    borderRadius: 4,
  },
  statsText: {
    fontSize: 14,
    color: '#666',
  },
  quotationItem: {
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderRadius: 8,
    padding: 10,
    marginRight: 10,
    width: 150,
    backgroundColor: '#f9f9f9',
  },
  quotationNumber: {
    fontWeight: '600',
    fontSize: 14,
    marginBottom: 4,
  },
  quotationDate: {
    fontSize: 12,
    color: '#666',
  },
  buttonContainer: {
    paddingHorizontal: 8,
    paddingBottom: 16,
  },
  buttonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    width: '100%', // Ensure the content takes the full width
  },

  // Proposal card styles
  proposalCard: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 12,
    marginBottom: 10,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  proposalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  proposalCode: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  priceBadge: {
    backgroundColor: '#28a745',
    paddingVertical: 2,
    paddingHorizontal: 8,
    borderRadius: 12,
  },
  priceBadgeText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '500',
  },
  proposalProject: {
    fontSize: 14,
    color: '#444',
    marginBottom: 8,
  },
  proposalDetails: {
    marginBottom: 10,
  },
  proposalDetailRow: {
    flexDirection: 'row',
    marginBottom: 4,
  },
  proposalDetailLabel: {
    fontSize: 13,
    color: '#666',
    width: 100,
  },
  proposalDetailValue: {
    fontSize: 13,
    color: '#333',
    fontWeight: '500',
  },
  proposalActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    borderTopWidth: 1,
    borderTopColor: '#eee',
    paddingTop: 8,
  },
  proposalButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 6,
    paddingHorizontal: 12,
    borderRadius: 16,
    marginLeft: 8,
  },
  viewButton: {
    backgroundColor: '#f0f7ff',
  },
  priceButton: {
    backgroundColor: '#e8f5e9',
  },
  viewButtonText: {
    color: '#0066cc',
    fontSize: 12,
    fontWeight: '500',
    marginLeft: 4,
  },
  emptyText: {
    textAlign: 'center',
    color: '#666',
    padding: 16,
  },

  // Modal styles
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    width: '90%',
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    maxHeight: '80%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    paddingBottom: 8,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  priceScrollView: {
    maxHeight: '70%',
  },
  priceItem: {
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  materialName: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 4,
  },
  materialSpec: {
    fontSize: 13,
    color: '#666',
    marginBottom: 2,
  },
  materialQuantity: {
    fontSize: 13,
    color: '#333',
  },
  priceInputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 6,
    marginBottom: 4,
  },
  priceLabel: {
    fontSize: 13,
    color: '#555',
    width: 100,
  },
  priceInput: {
    flex: 1,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 4,
    paddingHorizontal: 8,
    paddingVertical: 4,
    fontSize: 13,
  },
  materialTotalPrice: {
    fontSize: 13,
    color: '#28a745',
    fontWeight: '500',
    marginTop: 2,
  },
  modalActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    marginTop: 16,
  },
  modalButton: {
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 4,
    marginLeft: 8,
  },
  cancelButton: {
    backgroundColor: '#f5f5f5',
  },
  cancelButtonText: {
    color: '#333',
  },
  saveButton: {
    backgroundColor: '#28a745',
  },
  saveButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
  // New styles for confirmation modal
  confirmText: {
    fontSize: 14,
    color: '#333',
    marginBottom: 12,
  },
  confirmList: {
    maxHeight: 300,
    marginBottom: 12,
  },
  confirmItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  confirmIcon: {
    marginRight: 8,
  },
  confirmItemContent: {
    flex: 1,
  },
  confirmItemName: {
    fontSize: 14,
    fontWeight: '500',
    color: '#333',
  },
  confirmItemDetails: {
    fontSize: 12,
    color: '#666',
    marginTop: 2,
  },
  confirmButton: {
    backgroundColor: '#4CAF50',
    minWidth: 100,
    justifyContent: 'center',
    alignItems: 'center',
  },
  confirmButtonText: {
    color: '#fff',
    fontWeight: '600',
  },

  // History detail modal styles
  historyModalContainer: {
    maxHeight: '80%',
    width: '90%',
  },
  historyDetailHeader: {
    backgroundColor: '#f9f9f9',
    padding: 12,
    borderRadius: 4,
    marginBottom: 16,
  },
  historyDetailDate: {
    fontSize: 15,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  historyDetailPerson: {
    fontSize: 13,
    color: '#666',
    marginBottom: 2,
  },
  historyDetailUpdate: {
    fontSize: 12,
    color: '#888',
    fontStyle: 'italic',
  },
  historyDetailInstruction: {
    fontSize: 13,
    color: '#666',
    marginBottom: 12,
    fontStyle: 'italic',
  },
  historyDetailList: {
    maxHeight: '60%',
  },
  historyDetailItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
    paddingHorizontal: 4,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  historyCheckbox: {
    width: 30,
    alignItems: 'center',
    justifyContent: 'center',
  },
  historyItemContent: {
    flex: 1,
    paddingHorizontal: 8,
  },
  historyItemName: {
    fontSize: 14,
    fontWeight: '500',
    color: '#333',
  },
  historyItemDetails: {
    fontSize: 12,
    color: '#666',
    marginTop: 2,
  },
  historyItemStatus: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    minWidth: 80,
    alignItems: 'center',
  },
  historyItemStatusText: {
    fontSize: 12,
    fontWeight: '500',
  },
  updateButton: {
    backgroundColor: '#0066cc',
    minWidth: 100,
    justifyContent: 'center',
    alignItems: 'center',
  },
  updateButtonText: {
    color: '#fff',
    fontWeight: '600',
  },

  // ... other existing styles ...
});

export default MaterialPurchaseScreen;

// src/screens/NotificationsScreen.js
import React, { useState, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  ActivityIndicator,
  TouchableOpacity,
  RefreshControl,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';
import { useAuth } from '../contexts/AuthContext';
import {
  getUserNotifications,
  markNotificationAsRead,
} from '../api/notificationService';

const NotificationsScreen = ({ navigation }) => {
  const { currentUser } = useAuth();
  const [notifications, setNotifications] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  const loadNotifications = useCallback(async () => {
    setLoading(true);
    const data = await getUserNotifications(currentUser?.uid);
    setNotifications(data);
    setLoading(false);
  }, [currentUser]);

  useFocusEffect(
    useCallback(() => {
      loadNotifications();
    }, [loadNotifications])
  );

  const onRefresh = useCallback(() => {
    setRefreshing(true);
    loadNotifications().then(() => setRefreshing(false));
  }, [loadNotifications]);

  const handleNotificationPress = async (item) => {
    if (!item.read) {
      await markNotificationAsRead(item.id);
      // Update UI instantly
      setNotifications((prev) =>
        prev.map((n) => (n.id === item.id ? { ...n, read: true } : n))
      );
    }

    if (item.navLink?.screen) {
      navigation.navigate(item.navLink.screen, item.navLink.params || {});
    }
  };

  const renderItem = ({ item }) => (
    <TouchableOpacity
      style={[styles.notificationItem, !item.read && styles.unreadItem]}
      onPress={() => handleNotificationPress(item)}
    >
      <Ionicons
        name={
          item.type === 'PROPOSAL_APPROVED'
            ? 'checkmark-circle'
            : 'close-circle'
        }
        size={24}
        color={item.type === 'PROPOSAL_APPROVED' ? '#28a745' : '#dc3545'}
        style={styles.icon}
      />
      <View style={styles.content}>
        <Text style={styles.message}>{item.message}</Text>
        <Text style={styles.date}>
          {item.createdAt
            ? new Date(item.createdAt.seconds * 1000).toLocaleString('vi-VN')
            : ''}
        </Text>
      </View>
    </TouchableOpacity>
  );

  if (loading && !refreshing) {
    return (
      <View style={[styles.container, styles.center]}>
        <ActivityIndicator size="large" color="#0066cc" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {notifications.length === 0 ? (
        <View style={styles.center}>
          <Ionicons name="notifications-off-outline" size={60} color="#ccc" />
          <Text style={styles.emptyText}>Bạn không có thông báo nào.</Text>
        </View>
      ) : (
        <FlatList
          data={notifications}
          renderItem={renderItem}
          keyExtractor={(item) => item.id}
          contentContainerStyle={styles.list}
          refreshControl={
            <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
          }
        />
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  center: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  list: {
    padding: 16,
  },
  notificationItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#fff',
    padding: 16,
    borderRadius: 8,
    marginBottom: 12,
    elevation: 1,
  },
  unreadItem: {
    backgroundColor: '#eef7ff',
    borderLeftWidth: 4,
    borderLeftColor: '#0066cc',
  },
  icon: {
    marginRight: 16,
  },
  content: {
    flex: 1,
  },
  message: {
    fontSize: 14,
    color: '#333',
    marginBottom: 4,
  },
  date: {
    fontSize: 12,
    color: '#888',
  },
  emptyText: {
    marginTop: 16,
    fontSize: 16,
    color: '#666',
  },
});

export default NotificationsScreen;

import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ActivityIndicator,
  FlatList,
  TouchableOpacity,
} from 'react-native';
import {
  useNavigation,
  useRoute,
  useFocusEffect,
} from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import { getPOsByProject, getAllPOs } from '../api/purchaseOrderService';
import { getProposalsByProject } from '../api/proposalService';

const POListScreen = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { projectId, projectName: routeProjectName } = route.params || {};

  const [pos, setPos] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [expandedId, setExpandedId] = useState(null);

  // Handler to create PO with materials pre-filled from approved proposal
  const handleCreatePO = async () => {
    if (!projectId) {
      navigation.navigate('CreatePO');
      return;
    }

    try {
      // Fetch proposals for this project
      const proposals = await getProposalsByProject(projectId);
      // Find first approved proposal (could enhance to choose latest or prompt user)
      const approved = proposals.find((p) => p.status === 'approved');

      if (!approved) {
        navigation.navigate('CreatePO', { projectId });
        return;
      }

      const poData = {
        projectId,
        projectName: approved.projectName,
        materials:
          approved.items?.map((item) => ({
            name: item.name,
            specs: item.specification || '',
            unit: item.unit || '',
            quantity: item.quantity?.toString() || '',
            unitPrice: item.price?.toString() || '',
          })) || [],
        vatPercentage: 10,
        proposalId: approved.id,
        proposalCode: approved.proposalCode,
      };

      navigation.navigate('CreatePO', poData);
    } catch (e) {
      console.error('Failed to fetch proposals for PO creation', e);
      navigation.navigate('CreatePO', { projectId });
    }
  };

  // Header button to create new PO
  React.useLayoutEffect(() => {
    navigation.setOptions({
      headerRight: () => (
        <TouchableOpacity onPress={handleCreatePO} style={{ marginRight: 15 }}>
          <Ionicons name="add" size={24} color="#007AFF" />
        </TouchableOpacity>
      ),
    });
  }, [navigation, projectId]);

  const loadPOs = async () => {
    try {
      setLoading(true);
      const data = projectId
        ? await getPOsByProject(projectId)
        : await getAllPOs();
      setPos(data);
    } catch (e) {
      console.error('Failed to load POs', e);
    } finally {
      setLoading(false);
    }
  };

  useFocusEffect(
    useCallback(() => {
      loadPOs();
    }, [projectId])
  );

  const handleRefresh = async () => {
    setRefreshing(true);
    await loadPOs();
    setRefreshing(false);
  };

  const formatDate = (timestamp) => {
    if (!timestamp) return 'N/A';
    const date = timestamp.seconds
      ? new Date(timestamp.seconds * 1000)
      : new Date(timestamp);
    return date.toLocaleDateString('vi-VN');
  };

  const renderMaterials = (materials = []) => (
    <View style={styles.materialsContainer}>
      {materials.map((m, index) => (
        <View key={index.toString()} style={styles.materialRow}>
          <Text style={styles.materialName}>
            {index + 1}. {m.name} {m.specs ? `(${m.specs})` : ''}
          </Text>
          <Text style={styles.materialInfo}>
            {m.quantity} {m.unit} x {m.unitPrice}
          </Text>
        </View>
      ))}
    </View>
  );

  const renderItem = ({ item }) => {
    const expanded = expandedId === item.id;
    const isReceived = item.status === 'received';

    return (
      <View style={styles.card}>
        <TouchableOpacity
          style={styles.cardHeader}
          onPress={() => setExpandedId(expanded ? null : item.id)}
        >
          <View style={{ flex: 1 }}>
            <Text style={styles.poNumber}>{item.poNumber || item.id}</Text>
            <Text style={styles.supplierName}>{item.supplierName}</Text>
            <Text style={styles.createdAt}>{formatDate(item.createdAt)}</Text>
          </View>
          <View style={styles.headerRight}>
            {isReceived && (
              <View style={styles.statusBadge}>
                <Text style={styles.statusText}>Đã nhận</Text>
              </View>
            )}
            <Ionicons
              name={expanded ? 'chevron-up' : 'chevron-down'}
              size={20}
              color="#555"
            />
          </View>
        </TouchableOpacity>

        {expanded && (
          <View style={styles.cardBody}>
            {item.projectName || routeProjectName ? (
              <Text style={styles.label}>
                Dự án: {item.projectName || routeProjectName}
              </Text>
            ) : null}
            {item.proposalNumber ? (
              <Text style={styles.label}>
                Số đề xuất: {item.proposalNumber}
              </Text>
            ) : null}
            {item.deliveryTime ? (
              <Text style={styles.label}>Giao hàng: {item.deliveryTime}</Text>
            ) : null}
            <Text style={styles.sectionTitle}>Vật tư</Text>
            {renderMaterials(item.materials)}

            {isReceived ? (
              <View style={styles.receivedInfo}>
                <Ionicons name="checkmark-circle" size={18} color="#28a745" />
                <Text style={styles.receivedText}>
                  Đã xác nhận nhận hàng ngày {formatDate(item.receivedAt)}
                </Text>
              </View>
            ) : (
              <TouchableOpacity
                style={styles.confirmBtn}
                onPress={() =>
                  navigation.navigate('ConfirmPOReceipt', { po: item })
                }
              >
                <Ionicons name="checkbox-outline" size={18} color="#fff" />
                <Text style={styles.confirmBtnText}>
                  Xác nhận đã nhận và thêm vào kho
                </Text>
              </TouchableOpacity>
            )}
          </View>
        )}
      </View>
    );
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0066cc" />
        <Text style={{ marginTop: 8 }}>Đang tải...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <FlatList
        data={pos}
        keyExtractor={(item) => item.id}
        renderItem={renderItem}
        refreshing={refreshing}
        onRefresh={handleRefresh}
        ListEmptyComponent={
          <View style={styles.emptyContainer}>
            <Ionicons name="document-text-outline" size={48} color="#ccc" />
            <Text style={styles.emptyText}>Chưa có đơn đặt hàng</Text>
          </View>
        }
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 40,
  },
  emptyText: {
    marginTop: 8,
    color: '#666',
  },
  card: {
    backgroundColor: '#fff',
    borderRadius: 8,
    marginBottom: 12,
    elevation: 2,
  },
  cardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
  },
  headerRight: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  statusBadge: {
    backgroundColor: '#28a745',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    marginRight: 8,
  },
  statusText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '500',
  },
  poNumber: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  supplierName: {
    fontSize: 14,
    color: '#555',
  },
  createdAt: {
    color: '#888',
    fontSize: 12,
  },
  cardBody: {
    padding: 12,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  label: {
    fontSize: 14,
    marginBottom: 4,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: 'bold',
    marginTop: 8,
  },
  materialsContainer: {
    marginTop: 4,
  },
  materialRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  materialName: {
    fontSize: 13,
    flex: 1,
  },
  materialInfo: {
    fontSize: 13,
    color: '#555',
  },
  confirmBtn: {
    marginTop: 12,
    backgroundColor: '#28a745',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 8,
    borderRadius: 6,
  },
  confirmBtnText: {
    color: '#fff',
    marginLeft: 6,
    fontSize: 14,
    fontWeight: '600',
  },
  receivedInfo: {
    marginTop: 12,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#e8f5e9',
    padding: 8,
    borderRadius: 6,
  },
  receivedText: {
    marginLeft: 8,
    color: '#2e7d32',
    fontSize: 14,
  },
});

export default POListScreen;

//src/screens/ProjectDetailScreen.js
import React, {
  useState,
  useEffect,
  useCallback,
  useLayoutEffect,
} from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  Modal,
  TextInput,
  ActionSheetIOS,
  Platform,
  FlatList,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import {
  updateTaskStatus,
  updateCustomTask,
  deleteProject,
  updateWorkflowStageStatus,
} from '../api/projectService';
import { useAuth } from '../contexts/AuthContext';
import StatusIndicator from '../components/StatusIndicator';
import { useProjectDetails } from '../hooks/useProjectDetails';
import * as Clipboard from 'expo-clipboard';
import ProjectService from '../api/projectService';
import { GoogleSignin } from '@react-native-google-signin/google-signin';

// Định nghĩa danh sách công việc cố định
const TASK_DEFINITIONS = [
  { key: 'material_separation', label: 'Bóc tách vật tư' },
  { key: 'quotation', label: 'Báo giá' },
  { key: 'material_cutting', label: 'Cắt phôi' },
  { key: 'assembly', label: 'Lắp ráp' },
  { key: 'painting', label: 'Sơn' },
  { key: 'shipping', label: 'Vận chuyển' },
  { key: 'other', label: 'Công việc khác' },
];

// Định nghĩa các trạng thái công việc
const TASK_STATUSES = [
  { value: 'pending', label: 'Chưa thực hiện' },
  { value: 'in_progress', label: 'Đang thực hiện' },
  { value: 'completed', label: 'Hoàn thành' },
];

const ProjectDetailScreen = ({ route, navigation }) => {
  const { projectId } = route.params;
  const { currentUser } = useAuth();
  const { project, loading, error, fetchProjectData } =
    useProjectDetails(projectId);

  // State cho quản lý công việc
  const [customTaskModalVisible, setCustomTaskModalVisible] = useState(false);
  const [customTaskName, setCustomTaskName] = useState('');
  const [copySuccess, setCopySuccess] = useState(false);

  useEffect(() => {
    if (project?.tasks?.other?.name) {
      setCustomTaskName(project.tasks.other.name);
    }
  }, [project]);

  // Ẩn header mặc định để tránh trùng lặp nút back / tiêu đề
  useLayoutEffect(() => {
    navigation.setOptions({ headerShown: false });
  }, [navigation]);

  // Hàm cập nhật trạng thái công việc
  const handleUpdateTaskStatus = async (taskKey) => {
    // Không cho phép thay đổi trạng thái "Báo giá" và "Bóc tách" trực tiếp từ đây
    if (taskKey === 'quotation' || taskKey === 'material_separation') {
      Alert.alert(
        'Thông báo',
        `Để cập nhật trạng thái "${getTaskDisplayName(
          taskKey
        )}", vui lòng vào mục "Quản lý Báo giá".`
      );
      return;
    }

    if (Platform.OS === 'ios') {
      // Sử dụng ActionSheetIOS cho iOS
      ActionSheetIOS.showActionSheetWithOptions(
        {
          options: [...TASK_STATUSES.map((s) => s.label), 'Hủy'],
          cancelButtonIndex: TASK_STATUSES.length,
          title: `Cập nhật "${getTaskDisplayName(taskKey)}"`,
        },
        async (buttonIndex) => {
          if (buttonIndex < TASK_STATUSES.length) {
            try {
              await updateTaskStatus(
                projectId,
                taskKey,
                TASK_STATUSES[buttonIndex].value
              );
              fetchProjectData();
            } catch (err) {
              Alert.alert('Lỗi', err.message);
            }
          }
        }
      );
    } else {
      // Sử dụng Alert cho Android
      Alert.alert(
        'Chọn trạng thái công việc',
        `Cập nhật trạng thái cho "${getTaskDisplayName(taskKey)}"`,
        [
          ...TASK_STATUSES.map((status) => ({
            text: status.label,
            onPress: async () => {
              try {
                await updateTaskStatus(projectId, taskKey, status.value);
                fetchProjectData();
              } catch (err) {
                Alert.alert('Lỗi', err.message);
              }
            },
          })),
          { text: 'Hủy', style: 'cancel' },
        ]
      );
    }
  };

  // Hàm cập nhật tên công việc khác
  const handleUpdateCustomTask = async () => {
    if (!customTaskName.trim() && project?.tasks?.other?.name) {
      Alert.alert('Lỗi', 'Vui lòng nhập tên công việc');
      return;
    }

    try {
      await updateCustomTask(
        projectId,
        customTaskName.trim(),
        currentUser?.uid
      );
      setCustomTaskModalVisible(false);
      fetchProjectData();
    } catch (err) {
      Alert.alert('Lỗi', 'Không thể cập nhật tên công việc khác');
    }
  };

  // Điều hướng đến trang chi tiết khách hàng
  const navigateToCustomerDetail = () => {
    if (project && project.customerId) {
      navigation.navigate('CustomerDetail', { customerId: project.customerId });
    } else {
      Alert.alert('Thông báo', 'Dự án này chưa được gán cho khách hàng nào.');
    }
  };

  // Hàm xoá dự án
  const handleDeleteProject = async () => {
    Alert.alert(
      'Xác nhận Xóa',
      'Bạn có chắc chắn muốn xóa dự án này không? Hành động này không thể hoàn tác.',
      [
        { text: 'Hủy', style: 'cancel' },
        {
          text: 'Xóa',
          style: 'destructive',
          onPress: async () => {
            try {
              await deleteProject(projectId);
              Alert.alert('Thành công', 'Dự án đã được xóa.', [
                { text: 'OK', onPress: () => navigation.goBack() },
              ]);
            } catch (err) {
              Alert.alert('Lỗi', err.message);
            }
          },
        },
      ]
    );
  };

  // Xử lý khi chọn khách hàng
  const handleCopyDriveLink = async () => {
    if (project?.driveFolderUrl) {
      try {
        await Clipboard.setStringAsync(project.driveFolderUrl);
        setCopySuccess(true);
        setTimeout(() => setCopySuccess(false), 2000);
      } catch (err) {
        Alert.alert('Lỗi', 'Không thể copy đường dẫn.');
      }
    } else {
      Alert.alert(
        'Thông báo',
        'Không có đường dẫn Drive để copy. Bạn có muốn tạo thư mục Drive cho dự án này không?',
        [
          {
            text: 'Không',
            style: 'cancel',
          },
          {
            text: 'Tạo thư mục',
            onPress: handleCreateDriveFolders,
          },
        ]
      );
    }
  };

  // Hàm tạo thư mục Drive cho dự án
  const handleCreateDriveFolders = async () => {
    try {
      // Kiểm tra đã đăng nhập Google chưa
      const isSignedIn = await GoogleSignin.isSignedIn();
      if (!isSignedIn) {
        Alert.alert(
          'Cần đăng nhập Google',
          'Bạn cần đăng nhập tài khoản Google để tạo thư mục Drive'
        );
        return;
      }

      // Lấy token
      const { accessToken } = await GoogleSignin.getTokens();
      if (!accessToken) {
        Alert.alert('Lỗi', 'Không thể lấy thông tin xác thực Google');
        return;
      }

      // Hiện thông báo đang tạo
      Alert.alert('Thông báo', 'Đang tạo thư mục Drive, vui lòng đợi...');

      // Gọi Cloud Function
      const result = await ProjectService.createProjectFolders(
        projectId,
        accessToken
      );

      if (result) {
        fetchProjectData(); // Làm mới dữ liệu dự án
        Alert.alert('Thành công', 'Đã tạo thư mục Drive cho dự án thành công');
      }
    } catch (err) {
      console.error('Lỗi tạo thư mục Drive:', err);
      Alert.alert('Lỗi', 'Không thể tạo thư mục Drive: ' + err.message);
    }
  };

  const handleStagePress = (stage) => {
    navigation.navigate('StageDetail', { projectId, stage });
  };

  const changeStatus = async (stage, status) => {
    try {
      await updateWorkflowStageStatus(projectId, stage.stageId, status);
      fetchProjectData();
    } catch (e) {
      Alert.alert('Lỗi', e.message);
    }
  };

  // Hiển thị khi đang tải dữ liệu
  if (loading) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color="#0066cc" />
        <Text style={styles.loadingText}>Đang tải thông tin dự án...</Text>
      </View>
    );
  }

  // Hiển thị khi có lỗi
  if (error) {
    return (
      <View style={styles.centerContainer}>
        <Ionicons name="alert-circle-outline" size={50} color="#FF3B30" />
        <Text style={styles.errorText}>{error}</Text>
        <TouchableOpacity
          style={styles.retryButton}
          onPress={() => navigation.goBack()}
        >
          <Text style={styles.retryButtonText}>Quay lại</Text>
        </TouchableOpacity>
      </View>
    );
  }

  // Hiển thị khi không tìm thấy dự án
  if (!project) {
    return (
      <View style={styles.centerContainer}>
        <Ionicons name="briefcase-outline" size={50} color="#999" />
        <Text style={styles.errorText}>Không tìm thấy thông tin dự án</Text>
        <TouchableOpacity
          style={styles.retryButton}
          onPress={() => navigation.goBack()}
        >
          <Text style={styles.retryButtonText}>Quay lại</Text>
        </TouchableOpacity>
      </View>
    );
  }

  // Định dạng ngày tháng
  const formatDate = (timestamp) => {
    if (!timestamp) return 'Chưa xác định';
    try {
      return new Date(timestamp.seconds * 1000).toLocaleDateString('vi-VN');
    } catch (e) {
      return 'Ngày không hợp lệ';
    }
  };

  // Định dạng số tiền
  const formatCurrency = (amount) => {
    if (!amount) return '0 VNĐ';

    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
      minimumFractionDigits: 0,
    }).format(amount);
  };

  // Lấy màu sắc theo trạng thái dự án
  const getStatusColor = (status) => {
    switch (status) {
      case 'completed':
        return '#4CAF50';
      case 'in-progress':
        return '#FFD54F';
      case 'pending':
        return '#9E9E9E';
      case 'cancelled':
        return '#F44336';
      default:
        return '#6c757d';
    }
  };

  // Lấy nhãn hiển thị cho trạng thái dự án
  const getStatusLabel = (status) => {
    switch (status) {
      case 'completed':
        return 'Hoàn thành';
      case 'in-progress':
        return 'Đang thực hiện';
      case 'pending':
        return 'Chờ xử lý';
      case 'cancelled':
        return 'Đã hủy';
      default:
        return 'Không xác định';
    }
  };

  // Lấy màu sắc theo trạng thái công việc
  const getTaskStatusColor = (status) => {
    switch (status) {
      case 'completed':
        return '#4CAF50';
      case 'in_progress':
        return '#2196F3';
      default:
        return '#FF9800';
    }
  };

  // Lấy nhãn hiển thị cho trạng thái công việc
  const getTaskStatusLabel = (status) => {
    switch (status) {
      case 'completed':
        return 'Hoàn thành';
      case 'in_progress':
        return 'Đang làm';
      default:
        return 'Chờ xử lý';
    }
  };

  // Lấy tên hiển thị cho công việc
  const getTaskDisplayName = (taskKey) => {
    const task = TASK_DEFINITIONS.find((t) => t.key === taskKey);
    return task ? task.label : 'Công việc không xác định';
  };

  // Render chính
  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Chi tiết dự án</Text>
        <TouchableOpacity
          style={styles.deleteButton}
          onPress={handleDeleteProject}
        >
          <Ionicons name="trash-outline" size={24} color="#d11a2a" />
        </TouchableOpacity>
      </View>

      <ScrollView contentContainerStyle={styles.contentContainer}>
        {/* Project Header */}
        <View style={styles.projectHeader}>
          <Text style={styles.projectName}>
            {project.name || 'Chưa có tên'}
          </Text>

          <View style={styles.statusContainer}>
            <View
              style={[
                styles.statusTag,
                { borderColor: getStatusColor(project.status) },
              ]}
            >
              <Text
                style={[
                  styles.statusText,
                  { color: getStatusColor(project.status) },
                ]}
              >
                {getStatusLabel(project.status)}
              </Text>
            </View>
          </View>

          <Text style={styles.projectDescription}>
            {project.description || 'Không có mô tả'}
          </Text>
        </View>

        {/* Nút điều hướng đến màn hình báo giá */}
        <View style={styles.infoSection}>
          <TouchableOpacity
            style={styles.quotationButton}
            onPress={() =>
              navigation.navigate('Quotation', {
                projectId: project.id,
                projectName: project.name,
                project: project, // Truyền toàn bộ object project
              })
            }
          >
            <Ionicons name="calculator-outline" size={24} color="#fff" />
            <Text style={styles.quotationButtonText}>Quản lý Báo giá</Text>
          </TouchableOpacity>

          {/* Nút quản lý mua vật tư - chỉ hiện khi dự án đang thực hiện */}
          {project.status === 'in-progress' && (
            <TouchableOpacity
              style={[
                styles.quotationButton,
                { backgroundColor: '#4CAF50', marginTop: 8 },
              ]}
              onPress={() =>
                navigation.navigate('MaterialPurchase', {
                  projectId: project.id,
                  projectName: project.name,
                  project: project,
                })
              }
            >
              <Ionicons name="cart-outline" size={24} color="#fff" />
              <Text style={styles.quotationButtonText}>Quản lý Mua Vật Tư</Text>
            </TouchableOpacity>
          )}

          {/* Nút mở thư mục dự án trên Google Drive */}
          {project.driveFolderUrl ? (
            <View style={styles.driveLinkContainer}>
              <TouchableOpacity
                style={styles.driveLinkButton}
                onPress={() => {
                  const { Linking } = require('react-native');
                  Linking.openURL(project.driveFolderUrl).catch(() =>
                    Alert.alert('Lỗi', 'Không thể mở thư mục Google Drive')
                  );
                }}
              >
                <Ionicons
                  name="folder-open"
                  size={18}
                  color="#fff"
                  style={styles.buttonIcon}
                />
                <Text style={styles.driveLinkText}>Mở thư mục Drive</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.shareButton,
                  { backgroundColor: copySuccess ? '#4CAF50' : '#2980B9' },
                ]}
                onPress={handleCopyDriveLink}
              >
                <Ionicons
                  name={copySuccess ? 'checkmark' : 'copy'}
                  size={20}
                  color="#fff"
                />
              </TouchableOpacity>
            </View>
          ) : (
            <Text style={styles.driveNotAvailable}>
              Thư mục Google Drive đang được tạo...
            </Text>
          )}
        </View>

        {/* Phần thông tin khách hàng và các thông tin khác */}
        <View style={styles.infoSection}>
          <Text style={styles.sectionTitle}>Thông tin khách hàng</Text>

          <TouchableOpacity
            style={styles.customerCard}
            onPress={navigateToCustomerDetail}
          >
            <View style={styles.customerInfo}>
              <Ionicons
                name="business"
                size={24}
                color="#0066cc"
                style={styles.customerIcon}
              />
              <View>
                <Text style={styles.customerName}>
                  {project.customerName || 'Không xác định'}
                </Text>
                {project.customerContact && (
                  <Text style={styles.customerDetail}>
                    Người liên hệ: {project.customerContact}
                  </Text>
                )}
                {project.customerEmail && (
                  <Text style={styles.customerDetail}>
                    Email: {project.customerEmail}
                  </Text>
                )}
                {project.customerPhone && (
                  <Text style={styles.customerDetail}>
                    SĐT: {project.customerPhone}
                  </Text>
                )}
              </View>
            </View>
            <Ionicons name="chevron-forward" size={20} color="#999" />
          </TouchableOpacity>
        </View>

        <View style={styles.infoSection}>
          <Text style={styles.sectionTitle}>Thông tin cơ bản</Text>

          <View style={styles.infoRow}>
            <Text style={styles.infoLabel}>Ngày bắt đầu:</Text>
            <Text style={styles.infoValue}>
              {project.startDate
                ? formatDate(project.startDate)
                : 'Chưa xác định'}
            </Text>
          </View>

          {/* Hiển thị đường dẫn Drive */}
          <View style={styles.infoRow}>
            <Text style={styles.infoLabel}>Google Drive:</Text>
            {project.driveFolderUrl ? (
              <TouchableOpacity
                style={styles.driveLink}
                onPress={handleCopyDriveLink}
              >
                <Ionicons name="link" size={16} color="#0066cc" />
                <Text style={styles.driveLinkText}>
                  {copySuccess ? 'Đã copy đường dẫn!' : 'Copy đường dẫn'}
                </Text>
              </TouchableOpacity>
            ) : (
              <TouchableOpacity
                style={styles.createFolderButton}
                onPress={handleCreateDriveFolders}
              >
                <Ionicons name="cloud-upload" size={16} color="#0066cc" />
                <Text style={styles.createFolderText}>Tạo thư mục Drive</Text>
              </TouchableOpacity>
            )}
          </View>

          <View style={styles.infoRow}>
            <Text style={styles.infoLabel}>Ngày kết thúc:</Text>
            <Text style={styles.infoValue}>
              {project.endDate ? formatDate(project.endDate) : 'Chưa xác định'}
            </Text>
          </View>

          <View style={styles.infoRow}>
            <Text style={styles.infoLabel}>Số ngày thi công:</Text>
            <Text style={styles.infoValue}>
              {project.durationInDays
                ? `${project.durationInDays} ngày`
                : 'Chưa xác định'}
            </Text>
          </View>

          <View style={styles.infoRow}>
            <Text style={styles.infoLabel}>Vị trí thi công:</Text>
            <Text style={styles.infoValue}>
              {project.location === 'workshop'
                ? 'Tại xưởng'
                : project.location === 'site'
                ? 'Tại công trình'
                : 'Chưa xác định'}
            </Text>
          </View>

          <View style={styles.infoRow}>
            <Text style={styles.infoLabel}>Ngân sách:</Text>
            <Text style={styles.infoValue}>
              {project.budget
                ? formatCurrency(project.budget)
                : 'Chưa xác định'}
            </Text>
          </View>

          {project.notes && (
            <>
              <Text style={styles.notesLabel}>Ghi chú:</Text>
              <Text style={styles.notesText}>{project.notes}</Text>
            </>
          )}
        </View>

        {/* Quy trình Sản xuất */}
        <View style={styles.tasksBoard}>
          <Text style={styles.sectionTitle}>Quy trình Sản xuất</Text>
          {project.workflowStages?.length ? (
            project.workflowStages
              .sort((a, b) => a.order - b.order)
              .map((item) => {
                const color =
                  item.status === 'completed'
                    ? '#4CAF50'
                    : item.status === 'in_progress'
                    ? '#FFD54F'
                    : '#9E9E9E';
                return (
                  <TouchableOpacity
                    key={item.stageId}
                    style={styles.taskRow}
                    onPress={() => handleStagePress(item)}
                  >
                    <Text style={styles.taskName}>{item.processName}</Text>
                    <Text
                      style={[
                        styles.taskStatusText,
                        { backgroundColor: color + '33', color: color },
                      ]}
                    >
                      {item.status === 'completed'
                        ? 'Hoàn thành'
                        : item.status === 'in_progress'
                        ? 'Đang làm'
                        : 'Chờ xử lý'}
                    </Text>
                  </TouchableOpacity>
                );
              })
          ) : (
            <Text style={styles.emptyTasksText}>Chưa có công đoạn.</Text>
          )}
        </View>
      </ScrollView>

      {/* Footer */}
      <View style={styles.footer}>
        <TouchableOpacity
          style={styles.editButton}
          onPress={() => navigation.navigate('EditProject', { project })}
        >
          <Ionicons name="create-outline" size={20} color="#fff" />
          <Text style={styles.editButtonText}>Chỉnh sửa</Text>
        </TouchableOpacity>
      </View>

      {/* Modal cập nhật tên công việc khác */}
      <Modal
        visible={customTaskModalVisible}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setCustomTaskModalVisible(false)}
      >
        <TouchableOpacity
          style={styles.modalContainer}
          activeOpacity={1}
          onPress={() => setCustomTaskModalVisible(false)}
        >
          <TouchableOpacity
            style={styles.modalContent}
            activeOpacity={1}
            onPress={(e) => e.stopPropagation()}
          >
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Cập nhật công việc khác</Text>
              <TouchableOpacity
                style={styles.closeButton}
                onPress={() => setCustomTaskModalVisible(false)}
                hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
              >
                <Ionicons name="close" size={24} color="#333" />
              </TouchableOpacity>
            </View>

            <View style={styles.modalBody}>
              <Text style={styles.inputLabel}>Tên công việc:</Text>
              <TextInput
                style={styles.input}
                value={customTaskName}
                onChangeText={setCustomTaskName}
                placeholder="Nhập tên công việc khác..."
              />

              <TouchableOpacity
                style={[styles.saveTaskButton, { marginTop: 20 }]}
                onPress={handleUpdateCustomTask}
              >
                <Text style={styles.saveTaskButtonText}>Lưu</Text>
              </TouchableOpacity>
            </View>
          </TouchableOpacity>
        </TouchableOpacity>
      </Modal>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
  },
  errorText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  retryButton: {
    marginTop: 16,
    backgroundColor: '#0066cc',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 6,
  },
  retryButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '500',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  deleteButton: {
    padding: 4,
  },
  contentContainer: {
    paddingBottom: 20,
  },
  projectHeader: {
    backgroundColor: '#fff',
    padding: 16,
    marginBottom: 12,
  },
  projectName: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 8,
  },
  statusContainer: {
    flexDirection: 'row',
    marginBottom: 12,
  },
  statusTag: {
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  statusText: {
    fontSize: 14,
    fontWeight: '500',
  },
  projectDescription: {
    fontSize: 16,
    color: '#666',
    lineHeight: 22,
    marginTop: 8,
  },
  infoSection: {
    backgroundColor: '#fff',
    padding: 16,
    marginBottom: 12,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginBottom: 12,
  },
  customerCard: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#f9f9f9',
    padding: 12,
    borderRadius: 8,
    borderLeftWidth: 4,
    borderLeftColor: '#0066cc',
  },
  customerInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  customerIcon: {
    marginRight: 12,
  },
  customerName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 2,
  },
  customerDetail: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  infoRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  infoLabel: {
    fontSize: 15,
    color: '#666',
    flex: 1,
  },
  infoValue: {
    fontSize: 15,
    color: '#333',
    fontWeight: '500',
    flex: 1,
    textAlign: 'right',
  },
  notesLabel: {
    fontSize: 15,
    color: '#666',
    marginTop: 12,
    marginBottom: 6,
  },
  notesText: {
    fontSize: 15,
    color: '#333',
    lineHeight: 20,
  },
  footer: {
    backgroundColor: '#fff',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  editButton: {
    backgroundColor: '#0066cc',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    borderRadius: 8,
  },
  editButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
    marginLeft: 8,
  },
  tasksBoard: {
    backgroundColor: '#fff',
    padding: 16,
    marginBottom: 12,
  },
  taskRow: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  taskContent: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginLeft: 12,
  },
  taskName: {
    fontSize: 16,
    color: '#333',
    flex: 1,
    marginRight: 8,
  },
  taskNamePlaceholder: {
    fontSize: 16,
    color: '#999',
    fontStyle: 'italic',
  },
  taskStatusText: {
    fontSize: 14,
    fontWeight: '500',
    backgroundColor: '#f5f5f5',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    overflow: 'hidden',
    minWidth: 80,
    textAlign: 'center',
  },
  editTaskButton: {
    padding: 8,
  },
  emptyTasksContainer: {
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  emptyTasksText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  modalContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  modalContent: {
    backgroundColor: 'white',
    padding: 20,
    borderRadius: 10,
    width: '85%',
    maxWidth: 400,
  },
  modalHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingBottom: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    marginBottom: 16,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  closeButton: {
    padding: 4,
  },
  modalBody: {
    width: '100%',
  },
  inputLabel: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 12,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 12,
    borderRadius: 6,
    width: '100%',
    backgroundColor: '#fff',
    fontSize: 16,
  },
  saveTaskButton: {
    backgroundColor: '#0066cc',
    padding: 12,
    borderRadius: 6,
    alignItems: 'center',
  },
  saveTaskButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  quotationButton: {
    backgroundColor: '#4CAF50',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    borderRadius: 8,
    marginBottom: 10,
  },
  quotationButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
    marginLeft: 10,
  },
  driveLinkContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 10,
  },
  driveLinkButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#2196F3',
    paddingVertical: 12,
    borderRadius: 8,
  },
  buttonIcon: {
    marginRight: 10,
  },
  driveLinkText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  shareButton: {
    marginLeft: 12,
    width: 44,
    height: 44,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  driveNotAvailable: {
    textAlign: 'center',
    color: '#888',
    fontSize: 14,
    marginTop: 8,
    fontStyle: 'italic',
  },
  driveLink: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
    padding: 10,
    borderRadius: 6,
    marginTop: 4,
  },
  createFolderButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
    padding: 10,
    borderRadius: 6,
    marginTop: 4,
  },
  createFolderText: {
    marginLeft: 8,
    color: '#0066cc',
    fontSize: 14,
    fontWeight: '500',
  },
});

export default ProjectDetailScreen;

//src/screens/ProjectManagementScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  FlatList,
  StyleSheet,
  ActivityIndicator,
  Pressable,
  TouchableOpacity,
  SafeAreaView,
  StatusBar,
  TextInput,
  LayoutAnimation,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { getProjectsByStatus } from '../api/projectService';
import { useTheme } from '../contexts/ThemeContext';

// Component hiển thị từng dự án trong danh sách
const ProjectListItem = ({ project, onPress }) => {
  const { theme } = useTheme();
  // Xác định màu sắc theo trạng thái dự án
  const getStatusColor = (status) => {
    switch (status) {
      case 'completed':
        return '#4CAF50'; // xanh lá
      case 'in-progress':
        return '#FFD54F'; // vàng nhạt
      case 'pending':
        return theme.textSecondary; // gray
      case 'cancelled':
        return '#F44336'; // đỏ
      default:
        return theme.textMuted; // Sử dụng màu từ theme
    }
  };

  // Lấy nhãn hiển thị cho trạng thái dự án
  const getStatusLabel = (status) => {
    switch (status) {
      case 'completed':
        return 'Hoàn thành';
      case 'in-progress':
        return 'Đang thực hiện';
      case 'pending':
        return 'Chờ xử lý';
      case 'cancelled':
        return 'Đã hủy';
      default:
        return status || 'Không xác định';
    }
  };

  return (
    <Pressable
      style={({ pressed }) => [
        styles.projectCard,
        { backgroundColor: theme.card },
        pressed && styles.cardPressed,
      ]}
      onPress={() => onPress(project)}
    >
      <View style={styles.projectInfo}>
        <Text style={[styles.projectName, { color: theme.text }]}>
          {project.name || 'Chưa có tên'}
        </Text>

        {project.customerName && (
          <View style={styles.infoRow}>
            <Ionicons
              name="business-outline"
              size={14}
              color={theme.textSecondary}
            />
            <Text style={[styles.infoText, { color: theme.textSecondary }]}>
              {project.customerName}
            </Text>
          </View>
        )}

        {project.startDate && (
          <View style={styles.infoRow}>
            <Ionicons
              name="calendar-outline"
              size={14}
              color={theme.textSecondary}
            />
            <Text style={[styles.infoText, { color: theme.textSecondary }]}>
              {new Date(project.startDate.seconds * 1000).toLocaleDateString(
                'vi-VN'
              )}
            </Text>
          </View>
        )}

        {project.endDate && (
          <View style={styles.infoRow}>
            <Ionicons
              name="flag-outline"
              size={14}
              color={theme.textSecondary}
            />
            <Text style={[styles.infoText, { color: theme.textSecondary }]}>
              {new Date(project.endDate.seconds * 1000).toLocaleDateString(
                'vi-VN'
              )}
            </Text>
          </View>
        )}
      </View>

      <View style={styles.projectStatusContainer}>
        <View
          style={[
            styles.projectStatusTag,
            { borderColor: getStatusColor(project.status) },
          ]}
        >
          <Text
            style={[
              styles.projectStatusText,
              { color: getStatusColor(project.status) },
            ]}
          >
            {getStatusLabel(project.status)}
          </Text>
        </View>
      </View>
    </Pressable>
  );
};

const ProjectManagementScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const [projects, setProjects] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [refreshing, setRefreshing] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [filteredProjects, setFilteredProjects] = useState([]);

  // Status filters
  const FILTERS = [
    {
      key: 'pending',
      label: 'Chờ xử lý',
      color: 'transparent',
      textColor: theme.text,
    },
    {
      key: 'in-progress',
      label: 'Đang thực hiện',
      color: '#FFF9C4',
      textColor: theme.text,
    },
    {
      key: 'completed',
      label: 'Đã hoàn thành',
      color: '#4CAF50',
      textColor: '#fff',
    },
  ];

  const [activeFilter, setActiveFilter] = useState('pending');
  const [cacheByStatus, setCacheByStatus] = useState({});

  // Hàm tải danh sách dự án
  const loadProjectsByStatus = async (statusKey, forceRefresh = false) => {
    try {
      setLoading(true);
      setError(null);

      if (!forceRefresh && cacheByStatus[statusKey]) {
        setProjects(cacheByStatus[statusKey]);
        return;
      }

      if (forceRefresh) {
        setCacheByStatus((prev) => ({ ...prev, [statusKey]: undefined }));
      }

      const data = await getProjectsByStatus(statusKey);

      // Lưu cache mới
      setCacheByStatus((prev) => ({ ...prev, [statusKey]: data }));

      // Thêm animation khi cập nhật danh sách
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);

      setProjects(data);
      setFilteredProjects(data); // Khởi tạo danh sách lọc ban đầu
    } catch (err) {
      console.error('Lỗi khi tải danh sách dự án:', err);
      setError('Không thể tải danh sách dự án. Vui lòng thử lại sau.');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  // Tải dữ liệu khi màn hình được mở
  useEffect(() => {
    loadProjectsByStatus(activeFilter);

    // Thêm listener để làm mới danh sách khi quay lại từ màn hình khác
    const unsubscribe = navigation.addListener('focus', () => {
      loadProjectsByStatus(activeFilter, true); // force refresh để cập nhật nếu trạng thái dự án thay đổi
    });

    return unsubscribe;
  }, [navigation, activeFilter]);

  // Lọc danh sách dự án theo từ khóa tìm kiếm
  useEffect(() => {
    if (!searchQuery.trim()) {
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
      setFilteredProjects(projects);
      return;
    }

    const query = searchQuery.toLowerCase().trim();
    const filtered = projects.filter((project) => {
      const name = (project.name || '').toLowerCase();
      const customerName = (project.customerName || '').toLowerCase();
      const description = (project.description || '').toLowerCase();

      return (
        name.includes(query) ||
        customerName.includes(query) ||
        description.includes(query)
      );
    });

    // Thêm animation khi cập nhật kết quả tìm kiếm
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);

    setFilteredProjects(filtered);
  }, [searchQuery, projects]);

  // Xử lý khi người dùng kéo để làm mới
  const handleRefresh = () => {
    setRefreshing(true);
    // clear cache for current status then reload
    setCacheByStatus((prev) => ({ ...prev, [activeFilter]: undefined }));
    loadProjectsByStatus(activeFilter);
  };

  // Xử lý khi thay đổi bộ lọc
  const handleFilterChange = (statusKey) => {
    // Luôn refetch để đảm bảo dữ liệu mới nhất
    loadProjectsByStatus(statusKey, true);
    setActiveFilter(statusKey);
    setSearchQuery('');
  };

  // Xử lý khi người dùng nhấn vào một dự án
  const handleProjectPress = (project) => {
    navigation.navigate('ProjectDetail', { projectId: project.id });
  };

  // Xử lý khi người dùng muốn thêm dự án mới
  const handleAddProject = () => {
    navigation.navigate('AddProject');
  };

  // Xử lý khi người dùng nhập từ khóa tìm kiếm
  const handleSearch = (text) => {
    setSearchQuery(text);
  };

  // Xử lý khi người dùng muốn xóa từ khóa tìm kiếm
  const handleClearSearch = () => {
    setSearchQuery('');
  };

  // Render filter buttons
  const renderFilterButtons = () => (
    <View style={styles.filterContainer}>
      {FILTERS.map((f) => (
        <TouchableOpacity
          key={f.key}
          style={[
            styles.filterButton,
            {
              backgroundColor: f.color,
              borderWidth: activeFilter === f.key ? 2 : 1,
              borderColor:
                activeFilter === f.key ? theme.primary : theme.border,
            },
          ]}
          onPress={() => handleFilterChange(f.key)}
        >
          <Text style={[styles.filterText, { color: f.textColor }]}>
            {f.label}
          </Text>
        </TouchableOpacity>
      ))}
    </View>
  );

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <StatusBar
        barStyle={theme.dark ? 'light-content' : 'dark-content'}
        backgroundColor={theme.background}
      />

      {renderFilterButtons()}

      {/* Search Bar */}
      <View style={styles.searchContainer}>
        <Ionicons
          name="search-outline"
          size={20}
          color={theme.textMuted}
          style={styles.searchIcon}
        />
        <TextInput
          style={[
            styles.searchInput,
            { color: theme.text, borderColor: theme.border },
          ]}
          placeholder="Tìm theo tên, khách hàng..."
          placeholderTextColor={theme.textMuted}
          value={searchQuery}
          onChangeText={handleSearch}
        />
        {searchQuery.length > 0 && (
          <TouchableOpacity
            onPress={handleClearSearch}
            style={styles.clearSearchButton}
          >
            <Ionicons name="close-circle" size={20} color={theme.textMuted} />
          </TouchableOpacity>
        )}
      </View>

      {/* Project List */}
      {loading && !refreshing ? (
        <View style={styles.centerContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
        </View>
      ) : error ? (
        <View style={styles.centerContainer}>
          <Ionicons
            name="alert-circle-outline"
            size={50}
            color={theme.danger}
          />
          <Text style={[styles.errorText, { color: theme.textSecondary }]}>
            {error}
          </Text>
          <TouchableOpacity
            onPress={handleRefresh}
            style={[styles.button, { backgroundColor: theme.primary }]}
          >
            <Text style={styles.buttonText}>Thử lại</Text>
          </TouchableOpacity>
        </View>
      ) : filteredProjects.length === 0 ? (
        <View style={styles.centerContainer}>
          <Ionicons
            name="file-tray-outline"
            size={60}
            color={theme.textMuted}
          />
          <Text style={[styles.emptyText, { color: theme.textSecondary }]}>
            Chưa có dự án nào
          </Text>
          <TouchableOpacity
            onPress={handleAddProject}
            style={[styles.button, { backgroundColor: theme.primary }]}
          >
            <Text style={styles.buttonText}>Thêm dự án mới</Text>
          </TouchableOpacity>
        </View>
      ) : (
        <FlatList
          data={filteredProjects}
          renderItem={({ item }) => (
            <ProjectListItem project={item} onPress={handleProjectPress} />
          )}
          keyExtractor={(item) => item.id.toString()}
          contentContainerStyle={styles.listContainer}
          onRefresh={handleRefresh}
          refreshing={refreshing}
        />
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
    backgroundColor: '#fff',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: 'bold',
  },
  addButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    position: 'absolute',
    right: 16,
    bottom: 24,
    zIndex: 1,
    elevation: 4,
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: 'white',
    borderBottomWidth: 1,
    borderBottomColor: '#EEEEEE',
  },
  searchInputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    borderRadius: 8,
    paddingHorizontal: 10,
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    height: 44,
    fontSize: 16,
    color: '#333',
  },
  clearButton: {
    padding: 4,
  },
  listContainer: {
    paddingHorizontal: 16,
  },
  resultCount: {
    marginHorizontal: 16,
    marginBottom: 8,
    fontSize: 14,
  },
  projectCard: {
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    flexDirection: 'row',
    justifyContent: 'space-between',
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  cardPressed: {
    opacity: 0.7,
    backgroundColor: '#f5f5f5',
  },
  projectInfo: {
    flex: 1,
    paddingRight: 8,
  },
  projectName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333333',
    marginBottom: 6,
  },
  infoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 4,
  },
  infoText: {
    fontSize: 14,
    color: '#666666',
    marginLeft: 6,
  },
  projectStatusContainer: {
    justifyContent: 'flex-start',
    alignItems: 'flex-end',
  },
  projectStatusTag: {
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 8,
    paddingVertical: 2,
  },
  projectStatusText: {
    fontSize: 12,
    fontWeight: '500',
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666666',
  },
  errorText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666666',
    textAlign: 'center',
  },
  retryButton: {
    marginTop: 16,
    backgroundColor: '#0066cc',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 6,
  },
  retryButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '500',
  },
  emptyText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666666',
    marginBottom: 20,
  },
  addProjectButton: {
    backgroundColor: '#0066cc',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 6,
  },
  addProjectButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  emptySearchContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 40,
  },
  emptySearchText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666666',
    textAlign: 'center',
  },
  button: {
    marginTop: 16,
    backgroundColor: '#0066cc',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 6,
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '500',
  },
  clearSearchButton: {
    padding: 4,
  },
  filterContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    padding: 12,
  },
  filterButton: {
    flex: 1,
    paddingVertical: 8,
    borderRadius: 6,
    alignItems: 'center',
    marginHorizontal: 4,
  },
  filterText: {
    fontSize: 14,
    fontWeight: '500',
  },
});

export default ProjectManagementScreen;

//src/screens/ProjectsScreen.js
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  SafeAreaView,
  StatusBar,
  FlatList,
  TouchableOpacity,
  ActivityIndicator,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { getProjectsByStatus } from '../api/projectService';
import { useFocusEffect } from '@react-navigation/native';

const ProjectsScreen = ({ navigation }) => {
  const [projects, setProjects] = useState([]); // projects hiển thị theo bộ lọc hiện hành
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [refreshing, setRefreshing] = useState(false);

  // Lọc theo trạng thái dự án
  const FILTERS = [
    {
      key: 'pending',
      label: 'Chờ xử lý',
      color: 'transparent',
      textColor: '#333',
    },
    {
      key: 'in-progress',
      label: 'Đang thực hiện',
      color: '#FFF9C4',
      textColor: '#333',
    }, // vàng nhạt
    {
      key: 'completed',
      label: 'Hoàn thành',
      color: '#4CAF50',
      textColor: '#fff',
    },
  ];

  const [activeFilter, setActiveFilter] = useState('pending');
  // Cache dự án theo trạng thái để không phải gọi lại
  const [cacheByStatus, setCacheByStatus] = useState({});

  // Hàm tải danh sách dự án
  const loadProjectsByStatus = async (statusKey) => {
    // Nếu đã có trong cache thì dùng luôn
    if (cacheByStatus[statusKey]) {
      setProjects(cacheByStatus[statusKey]);
      return;
    }

    try {
      setLoading(true);
      setError(null);
      const data = await getProjectsByStatus(statusKey);
      // Lưu cache
      setCacheByStatus((prev) => ({ ...prev, [statusKey]: data }));
      setProjects(data);
    } catch (err) {
      console.error('Lỗi khi tải danh sách dự án:', err);
      setError('Không thể tải danh sách dự án. Vui lòng thử lại sau.');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  // Tải dữ liệu khi màn hình được mở
  useEffect(() => {
    loadProjectsByStatus(activeFilter);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [activeFilter]);

  // Làm mới dữ liệu khi màn hình được focus
  useFocusEffect(
    React.useCallback(() => {
      loadProjectsByStatus(activeFilter);
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [activeFilter])
  );

  // Xử lý khi người dùng kéo để làm mới
  const handleRefresh = () => {
    setRefreshing(true);
    // Xóa cache của bộ lọc hiện hành để buộc refetch
    setCacheByStatus((prev) => ({ ...prev, [activeFilter]: undefined }));
    loadProjectsByStatus(activeFilter);
  };

  // Xử lý khi người dùng nhấn vào nút quản lý dự án
  const handleManageProjects = () => {
    navigation.navigate('ProjectManagement');
  };

  // Xử lý khi người dùng nhấn vào một dự án
  const handleProjectPress = (project) => {
    navigation.navigate('ProjectDetail', { projectId: project.id });
  };

  // Nút lọc trạng thái
  const renderFilterButtons = () => (
    <View style={styles.filterContainer}>
      {FILTERS.map((f) => (
        <TouchableOpacity
          key={f.key}
          style={[
            styles.filterButton,
            {
              backgroundColor: activeFilter === f.key ? f.color : '#fff',
              borderWidth: 1,
              borderColor:
                activeFilter === f.key
                  ? f.color === 'transparent'
                    ? '#ccc'
                    : f.color
                  : '#ccc',
            },
          ]}
          onPress={() => setActiveFilter(f.key)}
        >
          <Text
            style={[
              styles.filterText,
              { color: activeFilter === f.key ? f.textColor : '#333' },
            ]}
          >
            {f.label}
          </Text>
        </TouchableOpacity>
      ))}
    </View>
  );

  // Hiển thị từng dự án trong danh sách
  const renderProjectItem = ({ item }) => {
    const getStatusColor = (status) => {
      switch (status) {
        case 'completed':
          return '#4CAF50';
        case 'in-progress':
          return '#FFD54F'; // vàng nhạt
        case 'pending':
          return '#9E9E9E';
        case 'cancelled':
          return '#F44336';
        default:
          return '#9E9E9E';
      }
    };

    const getStatusLabel = (status) => {
      switch (status) {
        case 'completed':
          return 'Hoàn thành';
        case 'in-progress':
          return 'Đang thực hiện';
        case 'pending':
          return 'Chờ xử lý';
        case 'cancelled':
          return 'Đã hủy';
        default:
          return status || 'Không xác định';
      }
    };

    return (
      <TouchableOpacity
        style={styles.projectCard}
        onPress={() => handleProjectPress(item)}
      >
        <View style={styles.projectHeader}>
          <Text style={styles.projectName}>{item.name || 'Chưa có tên'}</Text>
          <View
            style={[
              styles.statusBadge,
              { backgroundColor: getStatusColor(item.status) },
            ]}
          >
            <Text style={styles.statusText}>{getStatusLabel(item.status)}</Text>
          </View>
        </View>

        {item.customerName && (
          <View style={styles.infoRow}>
            <Ionicons name="business-outline" size={14} color="#666" />
            <Text style={styles.infoText}>{item.customerName}</Text>
          </View>
        )}
      </TouchableOpacity>
    );
  };

  if (loading && !refreshing) {
    return (
      <SafeAreaView style={styles.container}>
        <StatusBar barStyle="dark-content" backgroundColor="#f8f8f8" />
        <View style={styles.header}>
          <Text style={styles.headerTitle}>Dự Án</Text>
        </View>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#0066cc" />
          <Text style={styles.loadingText}>Đang tải dự án...</Text>
        </View>
      </SafeAreaView>
    );
  }

  if (error) {
    return (
      <SafeAreaView style={styles.container}>
        <StatusBar barStyle="dark-content" backgroundColor="#f8f8f8" />
        <View style={styles.header}>
          <Text style={styles.headerTitle}>Dự Án</Text>
        </View>
        <View style={styles.errorContainer}>
          <Ionicons name="alert-circle-outline" size={50} color="#FF3B30" />
          <Text style={styles.errorText}>{error}</Text>
          <TouchableOpacity
            style={styles.retryButton}
            onPress={() => loadProjectsByStatus(activeFilter)}
          >
            <Text style={styles.retryButtonText}>Thử lại</Text>
          </TouchableOpacity>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar barStyle="dark-content" backgroundColor="#f8f8f8" />

      <View style={styles.header}>
        <Text style={styles.headerTitle}>Dự Án</Text>
        <TouchableOpacity
          style={styles.manageButton}
          onPress={handleManageProjects}
        >
          <Text style={styles.manageButtonText}>Quản lý</Text>
          <Ionicons name="settings-outline" size={16} color="#0066cc" />
        </TouchableOpacity>
      </View>

      {renderFilterButtons()}

      {projects.length > 0 ? (
        <FlatList
          data={projects}
          keyExtractor={(item) => item.id}
          renderItem={renderProjectItem}
          contentContainerStyle={styles.listContent}
          refreshing={refreshing}
          onRefresh={handleRefresh}
        />
      ) : (
        <View style={styles.emptyContainer}>
          <Ionicons name="briefcase" size={80} color="#0066cc" />
          <Text style={styles.emptyTitle}>Chưa có dự án nào</Text>
          <Text style={styles.emptySubtitle}>
            Bạn chưa có dự án nào. Hãy tạo dự án mới trong mục quản lý dự án.
          </Text>
          <TouchableOpacity
            style={styles.manageFullButton}
            onPress={handleManageProjects}
          >
            <Text style={styles.manageFullButtonText}>Quản lý dự án</Text>
          </TouchableOpacity>
        </View>
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: 'white',
    borderBottomWidth: 1,
    borderBottomColor: '#EEEEEE',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333333',
  },
  manageButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 6,
    paddingHorizontal: 10,
    borderRadius: 16,
    backgroundColor: '#E6F0FF',
  },
  manageButtonText: {
    fontSize: 14,
    fontWeight: '500',
    color: '#0066cc',
    marginRight: 4,
  },
  listContent: {
    padding: 16,
  },
  projectCard: {
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  projectHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  projectName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    flex: 1,
  },
  statusBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  statusText: {
    fontSize: 12,
    fontWeight: '500',
    color: 'white',
  },
  infoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 4,
  },
  infoText: {
    fontSize: 14,
    color: '#666',
    marginLeft: 6,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  errorText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  retryButton: {
    marginTop: 16,
    paddingVertical: 8,
    paddingHorizontal: 16,
    backgroundColor: '#0066cc',
    borderRadius: 8,
  },
  retryButtonText: {
    fontSize: 14,
    fontWeight: '500',
    color: 'white',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  emptyTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
    marginTop: 20,
    textAlign: 'center',
  },
  emptySubtitle: {
    fontSize: 16,
    color: '#666',
    marginTop: 10,
    textAlign: 'center',
    paddingHorizontal: 30,
  },
  manageFullButton: {
    marginTop: 24,
    paddingVertical: 12,
    paddingHorizontal: 24,
    backgroundColor: '#0066cc',
    borderRadius: 8,
  },
  manageFullButtonText: {
    fontSize: 16,
    fontWeight: '500',
    color: 'white',
  },
  filterContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 10,
  },
  filterButton: {
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 16,
  },
  filterText: {
    fontSize: 14,
    fontWeight: '500',
  },
});

export default ProjectsScreen;

// src/screens/ProposalListScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  Alert,
  Modal,
  TextInput,
  ActivityIndicator,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useAuth } from '../contexts/AuthContext';
import {
  getProposalsByStatus,
  updateProposalStatus,
  canApproveProposal,
  updateProposalMaterialPrices,
} from '../api/proposalService';

const ProposalListScreen = ({ navigation }) => {
  const { currentUser } = useAuth();
  const [loading, setLoading] = useState(true);
  const [proposals, setProposals] = useState([]);
  const [selectedTab, setSelectedTab] = useState('pending');
  const [refreshing, setRefreshing] = useState(false);
  const [showApproveModal, setShowApproveModal] = useState(false);
  const [showRejectModal, setShowRejectModal] = useState(false);
  const [selectedProposal, setSelectedProposal] = useState(null);
  const [comment, setComment] = useState('');
  const [showMaterialsModal, setShowMaterialsModal] = useState(false);
  const [selectedMaterials, setSelectedMaterials] = useState([]);
  const [showPriceModal, setShowPriceModal] = useState(false);
  const [editableMaterials, setEditableMaterials] = useState([]);
  const [currentProposalId, setCurrentProposalId] = useState(null);

  const canApprove = canApproveProposal(currentUser?.role);

  useEffect(() => {
    loadProposals();
  }, [selectedTab]);

  const loadProposals = async () => {
    setLoading(true);
    try {
      const data = await getProposalsByStatus(selectedTab);
      console.log(`Loaded ${selectedTab} proposals:`, data.length);
      setProposals(data);
    } catch (error) {
      console.error('Error loading proposals:', error);
      Alert.alert(
        'Lỗi',
        'Không thể tải danh sách đề xuất. Vui lòng tạo chỉ mục theo hướng dẫn trong Firebase Console.'
      );
      setProposals([]);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  const handleRefresh = () => {
    setRefreshing(true);
    loadProposals();
  };

  const formatDate = (timestamp) => {
    if (!timestamp) return 'N/A';
    try {
      if (timestamp.toDate) {
        return timestamp.toDate().toLocaleDateString('vi-VN');
      } else if (timestamp instanceof Date) {
        return timestamp.toLocaleDateString('vi-VN');
      }
      return 'N/A';
    } catch (e) {
      return 'N/A';
    }
  };

  const handleApprove = (proposal) => {
    setSelectedProposal(proposal);
    setComment('');
    setShowApproveModal(true);
  };

  const handleReject = (proposal) => {
    setSelectedProposal(proposal);
    setComment('');
    setShowRejectModal(true);
  };

  const confirmApprove = async () => {
    if (!selectedProposal) return;

    try {
      await updateProposalStatus(
        selectedProposal.id,
        'approved',
        currentUser.uid,
        currentUser.displayName || currentUser.email,
        comment
      );
      setShowApproveModal(false);
      Alert.alert('Thành công', 'Đã phê duyệt đề xuất');
      loadProposals();
    } catch (error) {
      console.error('Error approving proposal:', error);
      Alert.alert('Lỗi', 'Không thể phê duyệt đề xuất');
    }
  };

  const confirmReject = async () => {
    if (!selectedProposal) return;

    if (!comment.trim()) {
      return Alert.alert('Thiếu thông tin', 'Vui lòng nhập lý do từ chối');
    }

    try {
      await updateProposalStatus(
        selectedProposal.id,
        'rejected',
        currentUser.uid,
        currentUser.displayName || currentUser.email,
        comment
      );
      setShowRejectModal(false);
      Alert.alert('Thành công', 'Đã từ chối đề xuất');
      loadProposals();
    } catch (error) {
      console.error('Error rejecting proposal:', error);
      Alert.alert('Lỗi', 'Không thể từ chối đề xuất');
    }
  };

  const showMaterialDetails = (materials) => {
    setSelectedMaterials(materials || []);
    setShowMaterialsModal(true);
  };

  const openPriceEditor = (proposal) => {
    // Create a deep copy of materials with price fields
    const materialsWithPrices = proposal.items
      ? JSON.parse(JSON.stringify(proposal.items))
      : [];

    // Ensure each material has price and totalPrice fields
    materialsWithPrices.forEach((item) => {
      if (!item.price) item.price = '';
      if (!item.totalPrice) item.totalPrice = '';
    });

    setEditableMaterials(materialsWithPrices);
    setCurrentProposalId(proposal.id);
    setShowPriceModal(true);
  };

  const handlePriceChange = (index, price) => {
    const updatedMaterials = [...editableMaterials];
    updatedMaterials[index].price = price;

    // Calculate total price if both price and quantity exist
    const quantity = parseFloat(updatedMaterials[index].quantity);
    const priceValue = parseFloat(price);

    if (!isNaN(quantity) && !isNaN(priceValue)) {
      updatedMaterials[index].totalPrice = (quantity * priceValue).toString();
    }

    setEditableMaterials(updatedMaterials);
  };

  const savePriceUpdates = async () => {
    if (!currentProposalId) return;

    try {
      await updateProposalMaterialPrices(currentProposalId, editableMaterials);
      Alert.alert('Thành công', 'Đã cập nhật giá vật tư');
      setShowPriceModal(false);
      loadProposals(); // Reload to get updated data
    } catch (error) {
      console.error('Error updating prices:', error);
      Alert.alert('Lỗi', 'Không thể cập nhật giá vật tư');
    }
  };

  const navigateToProject = (projectId) => {
    if (projectId) {
      navigation.navigate('ProjectDetail', { projectId });
    } else {
      Alert.alert('Thông báo', 'Không tìm thấy thông tin dự án.');
    }
  };

  // Add function to navigate to CreatePO screen
  const navigateToCreatePO = (proposal) => {
    if (!proposal.projectId) {
      Alert.alert('Thông báo', 'Cần có thông tin dự án để tạo đơn đặt hàng.');
      return;
    }

    // Check if materials have prices
    const missingPrices = proposal.items?.some(
      (item) => !item.price || item.price === '0' || item.price === ''
    );
    if (missingPrices) {
      Alert.alert(
        'Cần cập nhật giá',
        'Một số vật tư chưa có giá. Vui lòng cập nhật giá trước khi tạo đơn đặt hàng.',
        [
          { text: 'Đóng', style: 'cancel' },
          { text: 'Cập nhật giá', onPress: () => openPriceEditor(proposal) },
        ]
      );
      return;
    }

    // Prepare data for PO creation
    const poData = {
      projectId: proposal.projectId,
      projectName: proposal.projectName,
      materials:
        proposal.items?.map((item) => ({
          name: item.name,
          specs: item.specification || '',
          unit: item.unit || '',
          quantity: item.quantity || '0',
          unitPrice: item.price || '0',
        })) || [],
      vatPercentage: 10,
      proposalId: proposal.id,
      proposalCode: proposal.proposalCode,
    };

    navigation.navigate('CreatePO', poData);
  };

  const getPriorityColor = (priority) => {
    switch (priority) {
      case 'urgent':
        return '#FF3B30';
      case 'normal':
        return '#007AFF';
      default:
        return '#007AFF';
    }
  };

  const getPriorityLabel = (priority) => {
    switch (priority) {
      case 'urgent':
        return 'Gấp';
      case 'normal':
        return 'Bình thường';
      default:
        return priority || 'Bình thường';
    }
  };

  const getStatusColor = (status) => {
    switch (status) {
      case 'approved':
        return '#4CAF50';
      case 'rejected':
        return '#FF3B30';
      case 'pending':
        return '#FF9500';
      default:
        return '#999';
    }
  };

  const getStatusLabel = (status) => {
    switch (status) {
      case 'approved':
        return 'Đã duyệt';
      case 'rejected':
        return 'Từ chối';
      case 'pending':
        return 'Chờ duyệt';
      default:
        return status || 'Không xác định';
    }
  };

  const renderItem = ({ item }) => (
    <View style={styles.card}>
      <View style={styles.cardHeader}>
        <Text style={styles.proposalCode}>{item.proposalCode}</Text>
        <View
          style={[
            styles.statusBadge,
            { backgroundColor: getStatusColor(item.status) },
          ]}
        >
          <Text style={styles.statusText}>{getStatusLabel(item.status)}</Text>
        </View>
      </View>

      <Text style={styles.projectName}>{item.projectName}</Text>

      <View style={styles.infoRow}>
        <View style={styles.infoItem}>
          <Text style={styles.infoLabel}>Người đề xuất:</Text>
          <Text style={styles.infoValue}>{item.createdByName || 'N/A'}</Text>
        </View>
        <View style={styles.infoItem}>
          <Text style={styles.infoLabel}>Ngày tạo:</Text>
          <Text style={styles.infoValue}>{formatDate(item.createdAt)}</Text>
        </View>
      </View>

      <View style={styles.infoRow}>
        <View style={styles.infoItem}>
          <Text style={styles.infoLabel}>Ngày cần cung cấp:</Text>
          <Text style={styles.infoValue}>{formatDate(item.requiredDate)}</Text>
        </View>
        <View style={styles.infoItem}>
          <Text style={styles.infoLabel}>Mức độ:</Text>
          {item.priority === 'normal' ? (
            <Text style={styles.infoValue}>
              {getPriorityLabel(item.priority)}
            </Text>
          ) : (
            <View
              style={[
                styles.priorityBadge,
                { backgroundColor: getPriorityColor(item.priority) },
              ]}
            >
              <Text style={styles.priorityText}>
                {getPriorityLabel(item.priority)}
              </Text>
            </View>
          )}
        </View>
      </View>

      <View style={styles.purposeContainer}>
        <Text style={styles.purposeLabel}>Mục đích:</Text>
        <Text style={styles.purposeText}>
          {item.purpose || 'Không có mô tả'}
        </Text>
      </View>

      <View style={styles.cardActions}>
        <Text style={styles.itemsCount}>
          Số lượng vật tư: {item.items?.length || 0}
        </Text>
        <View style={styles.actionButtonsRow}>
          <TouchableOpacity
            style={styles.viewButton}
            onPress={() => showMaterialDetails(item.items)}
          >
            <Ionicons name="list" size={16} color="#0066cc" />
            <Text style={styles.viewButtonText}>Xem vật tư</Text>
          </TouchableOpacity>

          {item.projectId && (
            <TouchableOpacity
              style={styles.viewButton}
              onPress={() => navigateToProject(item.projectId)}
            >
              <Ionicons name="open-outline" size={16} color="#0066cc" />
              <Text style={styles.viewButtonText}>Xem dự án</Text>
            </TouchableOpacity>
          )}

          <TouchableOpacity
            style={[styles.viewButton, styles.priceButton]}
            onPress={() => openPriceEditor(item)}
          >
            <Ionicons name="cash-outline" size={16} color="#28a745" />
            <Text style={[styles.viewButtonText, { color: '#28a745' }]}>
              Cập nhật giá
            </Text>
          </TouchableOpacity>

          {/* Add PO list button for approved proposals */}
          {item.status === 'approved' && (
            <TouchableOpacity
              style={styles.viewButton}
              onPress={() =>
                navigation.navigate('POList', { projectId: item.projectId })
              }
            >
              <Ionicons
                name="document-text-outline"
                size={16}
                color="#0066cc"
              />
              <Text style={styles.viewButtonText}>PO</Text>
            </TouchableOpacity>
          )}
        </View>
      </View>

      {item.status === 'pending' && canApprove && (
        <View style={styles.actionButtons}>
          <TouchableOpacity
            style={[styles.actionButton, styles.approveButton]}
            onPress={() => handleApprove(item)}
          >
            <Ionicons name="checkmark-circle" size={16} color="#fff" />
            <Text style={styles.actionButtonText}>Phê duyệt</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={[styles.actionButton, styles.rejectButton]}
            onPress={() => handleReject(item)}
          >
            <Ionicons name="close-circle" size={16} color="#fff" />
            <Text style={styles.actionButtonText}>Từ chối</Text>
          </TouchableOpacity>
        </View>
      )}

      {item.status !== 'pending' && item.comment && (
        <View style={styles.commentContainer}>
          <Text style={styles.commentLabel}>Ghi chú:</Text>
          <Text style={styles.commentText}>{item.comment}</Text>
        </View>
      )}
    </View>
  );

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Danh sách đề xuất mua vật tư</Text>

      {/* Tab navigation */}
      <View style={styles.tabContainer}>
        <TouchableOpacity
          style={[styles.tab, selectedTab === 'pending' && styles.activeTab]}
          onPress={() => setSelectedTab('pending')}
        >
          <Text
            style={[
              styles.tabText,
              selectedTab === 'pending' && styles.activeTabText,
            ]}
          >
            Chờ duyệt
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.tab, selectedTab === 'approved' && styles.activeTab]}
          onPress={() => setSelectedTab('approved')}
        >
          <Text
            style={[
              styles.tabText,
              selectedTab === 'approved' && styles.activeTabText,
            ]}
          >
            Đã duyệt
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.tab, selectedTab === 'rejected' && styles.activeTab]}
          onPress={() => setSelectedTab('rejected')}
        >
          <Text
            style={[
              styles.tabText,
              selectedTab === 'rejected' && styles.activeTabText,
            ]}
          >
            Từ chối
          </Text>
        </TouchableOpacity>
      </View>

      {loading && !refreshing ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#0066cc" />
          <Text style={styles.loadingText}>Đang tải dữ liệu...</Text>
        </View>
      ) : (
        <FlatList
          data={proposals}
          renderItem={renderItem}
          keyExtractor={(item) => item.id}
          contentContainerStyle={styles.listContent}
          refreshing={refreshing}
          onRefresh={handleRefresh}
          ListEmptyComponent={
            <View style={styles.emptyContainer}>
              <Ionicons name="document-text-outline" size={48} color="#ccc" />
              <Text style={styles.emptyText}>
                {selectedTab === 'pending'
                  ? 'Không có đề xuất nào đang chờ duyệt'
                  : selectedTab === 'approved'
                  ? 'Không có đề xuất nào đã được duyệt'
                  : 'Không có đề xuất nào bị từ chối'}
              </Text>
            </View>
          }
        />
      )}

      {/* Approve Modal */}
      <Modal visible={showApproveModal} transparent animationType="slide">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContainer}>
            <Text style={styles.modalTitle}>Phê duyệt đề xuất</Text>
            <Text style={styles.modalSubtitle}>
              {selectedProposal?.proposalCode} - {selectedProposal?.projectName}
            </Text>

            <TextInput
              style={styles.commentInput}
              placeholder="Ghi chú (không bắt buộc)"
              value={comment}
              onChangeText={setComment}
              multiline
            />

            <View style={styles.modalActions}>
              <TouchableOpacity
                style={[styles.modalButton, styles.cancelButton]}
                onPress={() => setShowApproveModal(false)}
              >
                <Text style={styles.cancelButtonText}>Hủy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.modalButton, styles.confirmButton]}
                onPress={confirmApprove}
              >
                <Text style={styles.confirmButtonText}>Xác nhận</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Reject Modal */}
      <Modal visible={showRejectModal} transparent animationType="slide">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContainer}>
            <Text style={styles.modalTitle}>Từ chối đề xuất</Text>
            <Text style={styles.modalSubtitle}>
              {selectedProposal?.proposalCode} - {selectedProposal?.projectName}
            </Text>

            <TextInput
              style={styles.commentInput}
              placeholder="Lý do từ chối (bắt buộc)"
              value={comment}
              onChangeText={setComment}
              multiline
            />

            <View style={styles.modalActions}>
              <TouchableOpacity
                style={[styles.modalButton, styles.cancelButton]}
                onPress={() => setShowRejectModal(false)}
              >
                <Text style={styles.cancelButtonText}>Hủy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.modalButton, styles.rejectConfirmButton]}
                onPress={confirmReject}
              >
                <Text style={styles.confirmButtonText}>Xác nhận</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Materials Modal */}
      <Modal visible={showMaterialsModal} transparent animationType="slide">
        <View style={styles.modalOverlay}>
          <View style={[styles.modalContainer, styles.materialsModalContainer]}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Chi tiết vật tư</Text>
              <TouchableOpacity onPress={() => setShowMaterialsModal(false)}>
                <Ionicons name="close" size={24} color="#666" />
              </TouchableOpacity>
            </View>

            <ScrollView style={styles.materialsScrollView}>
              {selectedMaterials && selectedMaterials.length > 0 ? (
                selectedMaterials.map((item, index) => (
                  <View key={index} style={styles.materialItem}>
                    <Text style={styles.materialName}>
                      {index + 1}. {item.name || 'Không có tên'}
                    </Text>
                    <View style={styles.materialDetails}>
                      {item.specification ? (
                        <Text style={styles.materialSpec}>
                          Quy cách: {item.specification}
                        </Text>
                      ) : null}
                      <Text style={styles.materialQuantity}>
                        Số lượng: {item.quantity || 0} {item.unit || ''}
                      </Text>
                      {item.price && (
                        <Text style={styles.materialPrice}>
                          Đơn giá: {item.price} VNĐ
                        </Text>
                      )}
                      {item.totalPrice && (
                        <Text style={styles.materialTotalPrice}>
                          Thành tiền: {item.totalPrice} VNĐ
                        </Text>
                      )}
                    </View>
                  </View>
                ))
              ) : (
                <Text style={styles.emptyMaterialsText}>
                  Không có vật tư nào.
                </Text>
              )}
            </ScrollView>

            <TouchableOpacity
              style={styles.closeButton}
              onPress={() => setShowMaterialsModal(false)}
            >
              <Text style={styles.closeButtonText}>Đóng</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Price Update Modal */}
      <Modal visible={showPriceModal} transparent animationType="slide">
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={styles.modalOverlay}
        >
          <View style={[styles.modalContainer, styles.priceModalContainer]}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Cập nhật giá vật tư</Text>
              <TouchableOpacity onPress={() => setShowPriceModal(false)}>
                <Ionicons name="close" size={24} color="#666" />
              </TouchableOpacity>
            </View>

            <ScrollView style={styles.priceScrollView}>
              {editableMaterials && editableMaterials.length > 0 ? (
                editableMaterials.map((item, index) => (
                  <View key={index} style={styles.priceItem}>
                    <Text style={styles.materialName}>
                      {index + 1}. {item.name || 'Không có tên'}
                    </Text>
                    <View style={styles.materialDetails}>
                      {item.specification ? (
                        <Text style={styles.materialSpec}>
                          Quy cách: {item.specification}
                        </Text>
                      ) : null}
                      <Text style={styles.materialQuantity}>
                        Số lượng: {item.quantity || 0} {item.unit || ''}
                      </Text>

                      <View style={styles.priceInputContainer}>
                        <Text style={styles.priceLabel}>Đơn giá (VNĐ):</Text>
                        <TextInput
                          style={styles.priceInput}
                          value={item.price}
                          onChangeText={(text) =>
                            handlePriceChange(index, text)
                          }
                          keyboardType="numeric"
                          placeholder="Nhập đơn giá"
                        />
                      </View>

                      {item.totalPrice && (
                        <Text style={styles.materialTotalPrice}>
                          Thành tiền: {item.totalPrice} VNĐ
                        </Text>
                      )}
                    </View>
                  </View>
                ))
              ) : (
                <Text style={styles.emptyMaterialsText}>
                  Không có vật tư nào.
                </Text>
              )}
            </ScrollView>

            <View style={styles.modalActions}>
              <TouchableOpacity
                style={[styles.modalButton, styles.cancelButton]}
                onPress={() => setShowPriceModal(false)}
              >
                <Text style={styles.cancelButtonText}>Hủy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.modalButton, styles.saveButton]}
                onPress={savePriceUpdates}
              >
                <Text style={styles.confirmButtonText}>Lưu giá</Text>
              </TouchableOpacity>
            </View>
          </View>
        </KeyboardAvoidingView>
      </Modal>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: '#f5f5f5',
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 16,
    color: '#333',
  },
  tabContainer: {
    flexDirection: 'row',
    marginBottom: 16,
    backgroundColor: '#fff',
    borderRadius: 8,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  tab: {
    flex: 1,
    paddingVertical: 12,
    alignItems: 'center',
  },
  activeTab: {
    borderBottomWidth: 2,
    borderBottomColor: '#0066cc',
  },
  tabText: {
    color: '#666',
    fontWeight: '500',
  },
  activeTabText: {
    color: '#0066cc',
    fontWeight: '600',
  },
  listContent: {
    paddingBottom: 20,
  },
  card: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  cardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  proposalCode: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  statusBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  statusText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
  projectName: {
    fontSize: 15,
    fontWeight: '500',
    marginBottom: 12,
    color: '#444',
  },
  infoRow: {
    flexDirection: 'row',
    marginBottom: 8,
    alignItems: 'flex-start', // Align items to the top
  },
  infoItem: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    flexWrap: 'wrap', // Allow content to wrap
  },
  infoLabel: {
    fontSize: 13,
    color: '#666',
    marginRight: 4,
  },
  infoValue: {
    fontSize: 13,
    color: '#333',
    fontWeight: '500',
  },
  priorityBadge: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 12,
  },
  priorityText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
  purposeContainer: {
    marginTop: 4,
    marginBottom: 8,
    padding: 8,
    backgroundColor: '#f9f9f9',
    borderRadius: 4,
  },
  purposeLabel: {
    fontSize: 13,
    fontWeight: '500',
    color: '#555',
    marginBottom: 4,
  },
  purposeText: {
    fontSize: 13,
    color: '#333',
  },
  cardActions: {
    marginTop: 8,
    borderTopWidth: 1,
    borderTopColor: '#f0f0f0',
    paddingTop: 8,
  },
  itemsCount: {
    fontSize: 13,
    color: '#666',
    marginBottom: 8,
  },
  actionButtonsRow: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
  },
  viewButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 6,
    paddingHorizontal: 12,
    backgroundColor: '#f0f7ff',
    borderRadius: 20,
    marginRight: 8,
  },
  viewButtonText: {
    color: '#0066cc',
    fontSize: 12,
    fontWeight: '500',
    marginLeft: 4,
  },
  actionButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 12,
    borderTopWidth: 1,
    borderTopColor: '#eee',
    paddingTop: 12,
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 4,
    flex: 1,
    marginHorizontal: 4,
  },
  approveButton: {
    backgroundColor: '#4CAF50',
  },
  rejectButton: {
    backgroundColor: '#E74C3C', // Softer red color
  },
  actionButtonText: {
    color: '#fff',
    fontWeight: '600',
    marginLeft: 4,
  },
  commentContainer: {
    marginTop: 12,
    padding: 8,
    backgroundColor: '#f5f5f5',
    borderRadius: 4,
    borderLeftWidth: 3,
    borderLeftColor: '#ccc',
  },
  commentLabel: {
    fontSize: 12,
    fontWeight: '500',
    color: '#666',
    marginBottom: 2,
  },
  commentText: {
    fontSize: 13,
    color: '#333',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 8,
    color: '#666',
  },
  emptyContainer: {
    padding: 40,
    alignItems: 'center',
    justifyContent: 'center',
  },
  emptyText: {
    marginTop: 8,
    color: '#666',
    textAlign: 'center',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    width: '90%',
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 20,
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 4,
    color: '#333',
  },
  modalSubtitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 16,
  },
  commentInput: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 4,
    padding: 10,
    height: 100,
    textAlignVertical: 'top',
    marginBottom: 16,
  },
  modalActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
  },
  modalButton: {
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 4,
    marginLeft: 8,
  },
  cancelButton: {
    backgroundColor: '#f5f5f5',
  },
  cancelButtonText: {
    color: '#333',
  },
  confirmButton: {
    backgroundColor: '#4CAF50',
  },
  rejectConfirmButton: {
    backgroundColor: '#E74C3C', // Softer red color
  },
  confirmButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
  materialsModalContainer: {
    maxHeight: '80%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    paddingBottom: 8,
  },
  materialsScrollView: {
    maxHeight: '80%', // Limit height to allow button to be visible
  },
  materialItem: {
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  materialName: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 4,
  },
  materialDetails: {
    marginLeft: 16,
  },
  materialSpec: {
    fontSize: 13,
    color: '#666',
    marginBottom: 2,
  },
  materialQuantity: {
    fontSize: 13,
    color: '#333',
  },
  emptyMaterialsText: {
    textAlign: 'center',
    padding: 20,
    color: '#666',
  },
  closeButton: {
    backgroundColor: '#0066cc',
    padding: 12,
    borderRadius: 4,
    alignItems: 'center',
    marginTop: 16,
  },
  closeButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
  priceModalContainer: {
    maxHeight: '85%',
    width: '92%',
  },
  priceScrollView: {
    maxHeight: '75%',
  },
  priceItem: {
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  priceInputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 6,
    marginBottom: 4,
  },
  priceLabel: {
    fontSize: 13,
    color: '#555',
    width: 100,
  },
  priceInput: {
    flex: 1,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 4,
    paddingHorizontal: 8,
    paddingVertical: 4,
    fontSize: 13,
  },
  materialPrice: {
    fontSize: 13,
    color: '#28a745',
    marginTop: 2,
  },
  materialTotalPrice: {
    fontSize: 13,
    color: '#28a745',
    fontWeight: '500',
    marginTop: 2,
  },
  saveButton: {
    backgroundColor: '#28a745',
  },
  poButton: {
    backgroundColor: '#fff5e6',
    marginLeft: 8,
    borderColor: '#FF9500',
    borderWidth: 1,
  },
});

export default ProposalListScreen;

// src/screens/QuotationScreen.js

import React, { useState, useEffect, useCallback, memo } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  ActivityIndicator,
  Modal,
  TextInput,
  TouchableOpacity,
  Alert,
  SafeAreaView,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';
import { useMaterialsProcessor } from '../hooks/useMaterialsProcessor';
import { getQuotationsByProject } from '../api/quotationService';
import * as Sharing from 'expo-sharing';
import * as FileSystem from 'expo-file-system';

// --- Các Component và Hàm Helper được chuyển từ ProjectDetailScreen ---

// Memoized row component for the materials list
const MaterialRow = memo(
  ({ item, index, onPriceChange, formatNumber, onToggleSelect }) => {
    // If the item is a note, render it differently
    if (item.isNote) {
      return (
        <View style={styles.tableRow}>
          <View style={styles.noteCell}>
            <Text style={styles.noteText}>{item.name}</Text>
          </View>
        </View>
      );
    }
    return (
      <View style={styles.tableRow}>
        <TouchableOpacity
          style={styles.checkbox}
          onPress={() => onToggleSelect(index)}
        >
          <Ionicons
            name={item.selected ? 'checkbox' : 'square-outline'}
            size={18}
            color={item.selected ? '#0066CC' : '#999'}
          />
        </TouchableOpacity>
        <View style={[styles.tableCell, { flex: 3 }]}>
          <Text style={styles.materialName}>{item.name}</Text>
          {item.material ? (
            <Text style={styles.materialType}>{item.material}</Text>
          ) : null}
          {item.quyCach ? (
            <Text style={styles.materialType}>Quy cách: {item.quyCach}</Text>
          ) : null}
        </View>
        <Text style={[styles.tableCell, { flex: 1, textAlign: 'center' }]}>
          {formatNumber(item.quantity)}
        </Text>
        <Text style={[styles.tableCell, { flex: 1, textAlign: 'center' }]}>
          {formatNumber(item.weight)}
        </Text>
        <Text style={[styles.tableCell, { flex: 0.8, textAlign: 'center' }]}>
          {item.unit}
        </Text>
        <View style={[styles.tableCell, { flex: 1.2 }]}>
          <TextInput
            style={styles.priceInput}
            value={item.unitPrice > 0 ? item.unitPrice.toString() : ''}
            onChangeText={(text) => onPriceChange(text, index)}
            placeholder="Nhập..."
            keyboardType="numeric"
            selectTextOnFocus
          />
        </View>
        <Text style={[styles.tableCell, styles.totalPrice, { flex: 1.5 }]}>
          {item.totalPrice > 0 ? item.totalPrice.toLocaleString('vi-VN') : ''}
        </Text>
      </View>
    );
  }
);

// Hàm format tiền
const formatCurrency = (amount) => {
  if (!amount) return '0 VNĐ';
  return new Intl.NumberFormat('vi-VN', {
    style: 'currency',
    currency: 'VND',
    minimumFractionDigits: 0,
  }).format(amount);
};

const formatAppNumber = (num) => {
  if (typeof num !== 'number' || isNaN(num)) return '0';
  const roundedNum = Math.round(num * 10) / 10;
  return roundedNum.toString().replace('.', ',');
};
// --------------------------------------------------------------------

const QuotationScreen = ({ route, navigation }) => {
  const { projectId, projectName, project } = route.params;

  const {
    materials,
    showMaterialsTable,
    driveFiles,
    isPickerVisible,
    isLoadingFiles,
    isGoogleDriveLoading,
    handleImportFromGoogleDrive,
    handleFileSelect,
    handlePriceChange,
    handleRequote,
    setIsPickerVisible,
    setMaterials,
  } = useMaterialsProcessor(project);

  const [quotations, setQuotations] = useState([]);
  const [isLoadingQuotations, setIsLoadingQuotations] = useState(true);
  const [showBulkPriceModal, setShowBulkPriceModal] = useState(false);
  const [bulkPrice, setBulkPrice] = useState('');
  const [hasSelections, setHasSelections] = useState(false);

  // Lấy lịch sử báo giá
  useFocusEffect(
    useCallback(() => {
      const loadQuotations = async () => {
        setIsLoadingQuotations(true);
        try {
          const pastQuotations = await getQuotationsByProject(projectId);
          setQuotations(pastQuotations);
        } catch (error) {
          console.error('Lỗi khi tải lịch sử báo giá:', error);
        } finally {
          setIsLoadingQuotations(false);
        }
      };
      if (projectId) {
        loadQuotations();
      }
    }, [projectId])
  );

  const handleViewPdf = async (pdfUrl, quotationNumber) => {
    if (!pdfUrl) {
      Alert.alert('Lỗi', 'Không tìm thấy đường dẫn PDF cho báo giá này.');
      return;
    }
    Alert.alert('Đang xử lý', 'Đang tải file PDF để xem...');
    try {
      const fileUri =
        FileSystem.documentDirectory + `${quotationNumber || 'quotation'}.pdf`;
      const { uri } = await FileSystem.downloadAsync(pdfUrl, fileUri);
      if (await Sharing.isAvailableAsync()) {
        await Sharing.shareAsync(uri, { dialogTitle: 'Mở hoặc chia sẻ PDF' });
      } else {
        Alert.alert(
          'Không thể chia sẻ',
          'Thiết bị của bạn không hỗ trợ chức năng này.'
        );
      }
    } catch (error) {
      Alert.alert('Lỗi', 'Không thể mở file PDF. Vui lòng thử lại.');
    }
  };

  const handleNavigateToFinalize = () => {
    const subTotal = materials.reduce(
      (sum, item) => sum + (item.totalPrice || 0),
      0
    );
    const customerData = {
      id: project.customerId || '',
      name: project.customerName || 'Khách hàng',
      address: project.customerAddress || '',
      phone: project.customerPhone || '',
      email: project.customerEmail || '',
      contactPerson: project.customerContactPerson || '',
      taxCode: project.customerTaxCode || '',
    };
    navigation.navigate('FinalizeQuotation', {
      materials,
      subTotal,
      projectId,
      projectName: project.name || 'Dự án mới',
      customerData,
    });
  };

  const handleToggleSelect = (index) => {
    setMaterials((prev) => {
      const updated = [...prev];
      updated[index] = {
        ...updated[index],
        selected: !updated[index].selected,
      };

      // Update hasSelections state
      const anySelected = updated.some((item) => item.selected);
      setHasSelections(anySelected);

      return updated;
    });
  };

  const toggleSelectAll = (value) => {
    setMaterials((prev) =>
      prev.map((item) => ({
        ...item,
        selected: value,
      }))
    );
    setHasSelections(value);
  };

  const handleApplyBulkPrice = () => {
    if (!bulkPrice || isNaN(parseFloat(bulkPrice))) {
      Alert.alert('Lỗi', 'Vui lòng nhập giá hợp lệ');
      return;
    }

    const price = parseFloat(bulkPrice);

    setMaterials((prev) => {
      return prev.map((item) => {
        if (item.selected) {
          const weight = parseFloat(item.weight || 0);
          const quantity = parseFloat(item.quantity || 0);

          let totalPrice;
          if (weight > 0) {
            // Nếu có trọng lượng: thành tiền = số lượng × trọng lượng × đơn giá
            totalPrice = quantity * weight * price;
          } else {
            // Nếu không có trọng lượng: thành tiền = số lượng × đơn giá
            totalPrice = quantity * price;
          }

          return {
            ...item,
            unitPrice: price,
            totalPrice: totalPrice,
          };
        }
        return item;
      });
    });

    setShowBulkPriceModal(false);
    setBulkPrice('');
  };

  const renderHeader = () => (
    <View style={styles.section}>
      <Text style={styles.sectionTitle}>1. Nhập Vật Tư</Text>
      <TouchableOpacity
        style={[
          styles.importButton,
          isGoogleDriveLoading && styles.importButtonDisabled,
        ]}
        onPress={handleImportFromGoogleDrive}
        disabled={isGoogleDriveLoading}
      >
        {isGoogleDriveLoading ? (
          <ActivityIndicator size="small" color="#fff" />
        ) : (
          <Ionicons name="cloud-download-outline" size={24} color="#fff" />
        )}
        <Text style={styles.importButtonText}>Nhập từ Google Drive</Text>
      </TouchableOpacity>

      <TouchableOpacity
        style={[styles.manualButton]}
        onPress={() =>
          navigation.navigate('ManualQuotation', {
            projectId,
            projectName,
            project,
          })
        }
      >
        <Ionicons name="create-outline" size={24} color="#fff" />
        <Text style={styles.importButtonText}>Nhập thủ công</Text>
      </TouchableOpacity>
    </View>
  );

  const renderMaterialsSection = () =>
    showMaterialsTable && (
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>2. Bảng Tính Vật Tư</Text>

        {materials.length > 0 && (
          <View style={styles.bulkActionContainer}>
            <View style={styles.bulkActionRow}>
              <TouchableOpacity
                style={styles.bulkActionButton}
                onPress={() => toggleSelectAll(true)}
              >
                <Ionicons name="checkbox-outline" size={18} color="#fff" />
                <Text style={styles.bulkActionButtonText}>Chọn tất cả</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.bulkActionButton, styles.unselectButton]}
                onPress={() => toggleSelectAll(false)}
              >
                <Ionicons name="square-outline" size={18} color="#fff" />
                <Text style={styles.bulkActionButtonText}>Bỏ chọn</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.bulkActionButton,
                  styles.priceButton,
                  !hasSelections && styles.disabledButton,
                ]}
                disabled={!hasSelections}
                onPress={() => setShowBulkPriceModal(true)}
              >
                <Ionicons name="pricetag-outline" size={18} color="#fff" />
                <Text style={styles.bulkActionButtonText}>Áp dụng giá</Text>
              </TouchableOpacity>
            </View>
          </View>
        )}

        <View style={styles.tableHeader}>
          <View style={{ width: 30 }}></View>
          <Text style={[styles.headerCell, { flex: 3 }]}>Tên vật tư</Text>
          <Text style={[styles.headerCell, { flex: 1, textAlign: 'center' }]}>
            SL
          </Text>
          <Text style={[styles.headerCell, { flex: 1, textAlign: 'center' }]}>
            KL
          </Text>
          <Text style={[styles.headerCell, { flex: 0.8, textAlign: 'center' }]}>
            ĐVT
          </Text>
          <Text style={[styles.headerCell, { flex: 1.2, textAlign: 'right' }]}>
            Đơn giá
          </Text>
          <Text style={[styles.headerCell, { flex: 1.5, textAlign: 'right' }]}>
            Thành tiền
          </Text>
        </View>
        <FlatList
          data={materials}
          keyExtractor={(item, index) => `material-row-${index}`}
          renderItem={({ item, index }) => (
            <MaterialRow
              item={item}
              index={index}
              onPriceChange={handlePriceChange}
              formatNumber={formatAppNumber}
              onToggleSelect={handleToggleSelect}
            />
          )}
        />
      </View>
    );

  const renderFooter = () => (
    <>
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>3. Lịch sử báo giá</Text>
        {isLoadingQuotations ? (
          <ActivityIndicator />
        ) : quotations.length === 0 ? (
          <Text style={styles.emptyText}>Chưa có báo giá nào.</Text>
        ) : (
          <View style={styles.historyContainer}>
            {quotations.map((item, index) => (
              <View
                key={item.id}
                style={[
                  styles.historyItem,
                  index > 0 && styles.historyItemBorder,
                ]}
              >
                <View style={styles.historyInfo}>
                  <Text style={styles.historyNumber}>
                    {item.quotationNumber ||
                      `Báo giá #${item.id.substring(0, 5)}`}
                  </Text>
                  <Text style={styles.historyDate}>
                    Ngày tạo:{' '}
                    {item.createdAt
                      ? new Date(
                          item.createdAt.seconds * 1000
                        ).toLocaleDateString('vi-VN')
                      : 'Không rõ'}
                  </Text>
                  <Text style={styles.historyTotal}>
                    Tổng cộng: {formatCurrency(item.grandTotal)}
                  </Text>
                </View>
                <View style={styles.historyActions}>
                  <TouchableOpacity
                    style={styles.historyActionButton}
                    onPress={() =>
                      handleViewPdf(item.pdfUrl, item.quotationNumber)
                    }
                  >
                    <Ionicons
                      name="document-text-outline"
                      size={20}
                      color="#fff"
                    />
                    <Text style={styles.historyActionButtonText}>Xem PDF</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.historyActionButton, styles.requoteButton]}
                    onPress={() => handleRequote(item)}
                  >
                    <Ionicons name="copy-outline" size={20} color="#fff" />
                    <Text style={styles.historyActionButtonText}>
                      Báo giá lại
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>
            ))}
          </View>
        )}
      </View>
    </>
  );

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Báo giá: {projectName}</Text>
        <View style={{ width: 24 }} />
      </View>

      <FlatList
        data={[{ key: 'main' }]}
        renderItem={() => <>{renderMaterialsSection()}</>}
        keyExtractor={(item) => item.key}
        ListHeaderComponent={renderHeader}
        ListFooterComponent={renderFooter}
        contentContainerStyle={{ padding: 12 }}
        ListEmptyComponent={
          !showMaterialsTable ? (
            <View>
              <Text style={styles.emptyText}>
                Vui lòng nhập vật tư để bắt đầu.
              </Text>
            </View>
          ) : null
        }
      />

      {showMaterialsTable && materials.length > 0 && (
        <View style={styles.footer}>
          <View style={styles.summaryContainer}>
            <Text style={styles.summaryLabel}>Tổng cộng:</Text>
            <Text style={styles.summaryValue}>
              {formatCurrency(
                materials.reduce((sum, item) => sum + (item.totalPrice || 0), 0)
              )}
            </Text>
          </View>
          <TouchableOpacity
            style={styles.continueButton}
            onPress={handleNavigateToFinalize}
          >
            <Text style={styles.continueButtonText}>
              Tiếp tục hoàn thiện báo giá
            </Text>
            <Ionicons name="arrow-forward" size={20} color="#fff" />
          </TouchableOpacity>
        </View>
      )}

      <Modal
        animationType="slide"
        transparent={true}
        visible={isPickerVisible}
        onRequestClose={() => setIsPickerVisible(false)}
      >
        <View style={styles.modalContainer}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>
              Chọn file Excel từ Google Drive
            </Text>
            {isLoadingFiles ? (
              <ActivityIndicator size="large" />
            ) : (
              <FlatList
                data={driveFiles}
                keyExtractor={(item) => item.id}
                renderItem={({ item }) => (
                  <TouchableOpacity
                    style={styles.fileItem}
                    onPress={() => handleFileSelect(item)}
                  >
                    <Ionicons
                      name="document-text-outline"
                      size={24}
                      color="#4F8EF7"
                    />
                    <Text style={styles.fileName}>{item.name}</Text>
                  </TouchableOpacity>
                )}
                ListEmptyComponent={<Text>Không tìm thấy file nào.</Text>}
              />
            )}
            <TouchableOpacity
              style={styles.closeButton}
              onPress={() => setIsPickerVisible(false)}
            >
              <Text style={styles.closeButtonText}>Đóng</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Bulk Price Modal */}
      <Modal
        transparent={true}
        visible={showBulkPriceModal}
        animationType="slide"
        onRequestClose={() => setShowBulkPriceModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Áp dụng giá cho mục đã chọn</Text>

            <TextInput
              style={styles.bulkPriceInput}
              placeholder="Nhập đơn giá áp dụng"
              keyboardType="numeric"
              value={bulkPrice}
              onChangeText={setBulkPrice}
              autoFocus
            />

            <View style={styles.bulkPriceActions}>
              <TouchableOpacity
                style={[styles.bulkPriceActionButton, styles.cancelButton]}
                onPress={() => setShowBulkPriceModal(false)}
              >
                <Text style={styles.cancelButtonText}>Hủy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.bulkPriceActionButton, styles.applyButton]}
                onPress={handleApplyBulkPrice}
              >
                <Text style={styles.applyButtonText}>Áp dụng</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#f0f2f5' },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  backButton: { padding: 4 },
  headerTitle: { fontSize: 18, fontWeight: 'bold', color: '#333' },
  section: {
    backgroundColor: '#fff',
    padding: 16,
    borderRadius: 8,
    marginBottom: 12,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginBottom: 12,
  },
  emptyText: { textAlign: 'center', color: '#666', marginTop: 20 },
  importButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#0066cc',
    padding: 12,
    borderRadius: 8,
  },
  importButtonDisabled: { backgroundColor: '#a0a0a0' },
  importButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '500',
    marginLeft: 8,
  },
  manualButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#4CAF50',
    padding: 12,
    borderRadius: 8,
    marginTop: 10,
  },
  tableHeader: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
    paddingBottom: 8,
    marginBottom: 4,
  },
  headerCell: { fontWeight: 'bold', color: '#333' },
  tableRow: {
    flexDirection: 'row',
    alignItems: 'center',
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
    paddingVertical: 8,
  },
  tableCell: { fontSize: 12, color: '#333' },
  noteCell: {
    flex: 1,
    paddingHorizontal: 10,
    justifyContent: 'center',
  },
  noteText: {
    fontStyle: 'italic',
    color: '#555',
    fontSize: 13,
  },
  materialName: { fontWeight: '500', fontSize: 13 },
  materialType: { fontSize: 11, color: '#666' },
  priceInput: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 4,
    padding: 6,
    textAlign: 'right',
    fontSize: 12,
  },
  totalPrice: { fontWeight: '500', textAlign: 'right', fontSize: 13 },
  footer: {
    backgroundColor: '#fff',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
    paddingBottom: 30,
  },
  summaryContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  summaryLabel: { fontSize: 16, fontWeight: '500' },
  summaryValue: { fontSize: 18, fontWeight: 'bold', color: '#d9534f' },
  continueButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#4CAF50',
    padding: 14,
    borderRadius: 8,
  },
  continueButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
    marginRight: 8,
  },
  modalContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  modalContent: {
    backgroundColor: 'white',
    padding: 20,
    borderRadius: 10,
    width: '90%',
    maxHeight: '80%',
  },
  modalTitle: { fontSize: 18, fontWeight: 'bold', marginBottom: 15 },
  fileItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  fileName: { marginLeft: 10, fontSize: 16 },
  closeButton: {
    marginTop: 20,
    backgroundColor: '#d9534f',
    padding: 10,
    borderRadius: 5,
    alignItems: 'center',
  },
  closeButtonText: { color: 'white', fontWeight: 'bold' },
  historyContainer: { marginTop: 8 },
  historyItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 2,
  },
  historyItemBorder: {
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  historyInfo: {
    flex: 1,
    paddingRight: 12,
  },
  historyNumber: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 3,
  },
  historyDate: {
    color: '#666',
    fontSize: 12,
    marginBottom: 3,
  },
  historyTotal: {
    color: '#d9534f',
    fontWeight: '600',
    fontSize: 13,
  },
  historyActions: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  historyActionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 6,
    backgroundColor: '#0066CC',
  },
  historyActionButtonText: {
    color: '#fff',
    marginLeft: 6,
    fontWeight: '500',
    fontSize: 14,
  },
  requoteButton: {
    backgroundColor: '#4CAF50',
  },
  checkbox: {
    width: 30,
    alignItems: 'center',
    justifyContent: 'center',
    paddingRight: 4,
  },

  bulkActionContainer: {
    marginBottom: 16,
  },

  bulkActionRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'flex-start',
    gap: 10,
  },

  bulkActionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 6,
    backgroundColor: '#0066CC',
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 1.5,
  },

  unselectButton: {
    backgroundColor: '#6c757d',
  },

  priceButton: {
    backgroundColor: '#28a745',
  },

  bulkActionButtonText: {
    color: '#fff',
    marginLeft: 6,
    fontWeight: '500',
    fontSize: 14,
  },

  disabledButton: {
    backgroundColor: '#ccc',
    opacity: 0.7,
  },

  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.5)',
    padding: 20,
  },

  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 15,
    textAlign: 'center',
  },

  bulkPriceInput: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 4,
    padding: 12,
    fontSize: 16,
    marginTop: 10,
    marginBottom: 20,
  },

  bulkPriceActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },

  bulkPriceActionButton: {
    paddingVertical: 10,
    paddingHorizontal: 15,
    borderRadius: 4,
    flex: 1,
    marginHorizontal: 5,
    alignItems: 'center',
  },

  cancelButton: {
    backgroundColor: '#f8f9fa',
    borderWidth: 1,
    borderColor: '#ccc',
  },

  cancelButtonText: {
    color: '#333',
  },

  applyButton: {
    backgroundColor: '#28a745',
  },

  applyButtonText: {
    color: '#fff',
    fontWeight: 'bold',
  },
});

export default QuotationScreen;

import React, { useState, useLayoutEffect, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  ScrollView,
  Alert,
  ActivityIndicator,
  Image,
  Platform,
  Modal,
  Linking,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import * as ImagePicker from 'expo-image-picker';
import { httpsCallable } from 'firebase/functions';
import { functions } from '../config/firebaseConfig';
import { GoogleSignin } from '@react-native-google-signin/google-signin';
import { updateStageDetails } from '../api/projectService';
import uuid from 'react-native-uuid';
import * as FileSystem from 'expo-file-system';

const STATUS_OPTIONS = [
  { value: 'pending', label: 'Chờ xử lý', color: '#9E9E9E' },
  { value: 'in_progress', label: 'Đang làm', color: '#FFD54F' },
  { value: 'completed', label: 'Hoàn thành', color: '#4CAF50' },
  { value: 'failed', label: 'Không đạt', color: '#F44336' },
];

const StageDetailScreen = ({ route, navigation }) => {
  const { projectId, stage } = route.params; // stage object passed in

  const [status, setStatus] = useState(stage.status);
  const [notes, setNotes] = useState(stage.notes || '');

  const computePreview = (f) => {
    if (f.preview) return f.preview;
    if (f.mimeType && f.mimeType.startsWith('image/')) {
      return `https://drive.google.com/uc?export=download&id=${f.id}`;
    }
    return undefined;
  };

  const initialFiles = (stage.files || []).map((f) => ({
    ...f,
    preview: computePreview(f),
  }));

  const [files, setFiles] = useState(initialFiles);
  const [imagePreviewUri, setImagePreviewUri] = useState(null);
  const [saving, setSaving] = useState(false);

  useLayoutEffect(() => {
    navigation.setOptions({ headerTitle: stage.processName });
  }, [navigation]);

  const pickFile = async () => {
    const { status: perm } =
      await ImagePicker.requestMediaLibraryPermissionsAsync();
    if (perm !== 'granted') {
      Alert.alert('Lỗi', 'Cần quyền truy cập thư viện ảnh.');
      return;
    }
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.All,
      quality: 0.7,
    });
    if (!result.canceled) {
      uploadPickedFile(result.assets[0]);
    }
  };

  const takePhoto = async () => {
    const { status: perm } = await ImagePicker.requestCameraPermissionsAsync();
    if (perm !== 'granted') {
      Alert.alert('Lỗi', 'Cần quyền truy cập camera.');
      return;
    }
    const result = await ImagePicker.launchCameraAsync({ quality: 0.7 });
    if (!result.canceled) {
      uploadPickedFile(result.assets[0]);
    }
  };

  const uploadPickedFile = async (asset) => {
    try {
      setSaving(true);

      if (!asset || !asset.uri) {
        Alert.alert('Lỗi', 'Tập tin không hợp lệ.');
        return;
      }

      const ext = (asset.fileName || asset.uri).split('.').pop();
      const filename = `${uuid.v4()}.${ext}`;

      console.log('Starting upload for:', asset.uri);

      try {
        // Get file info using FileSystem from expo
        const fileInfo = await FileSystem.getInfoAsync(asset.uri);
        console.log('File info:', fileInfo);

        if (!fileInfo.exists || fileInfo.size === 0) {
          throw new Error('File rỗng hoặc không tồn tại');
        }

        console.log('File size:', fileInfo.size, 'bytes');

        // Đọc file base64 bằng expo-file-system
        const base64Data = await FileSystem.readAsStringAsync(asset.uri, {
          encoding: FileSystem.EncodingType.Base64,
        });
        // Lấy accessToken Google của người dùng
        const tokens = await GoogleSignin.getTokens();
        const accessToken = tokens.accessToken;

        if (!accessToken) {
          throw new Error(
            'Phiên đăng nhập Google đã hết. Vui lòng đăng nhập lại.'
          );
        }

        // Gọi Cloud Function uploadFileToDriveUser
        const uploadFn = httpsCallable(functions, 'uploadFileToDriveUser');
        const result = await uploadFn({
          accessToken,
          projectId,
          fileName: filename,
          mimeType: asset.mimeType || asset.type || 'image/jpeg',
          base64Data,
        });

        const {
          fileId,
          webViewLink,
          thumbnailLink,
          mimeType: returnedMime,
        } = result.data;
        const preview =
          returnedMime && returnedMime.startsWith('image/')
            ? thumbnailLink ||
              `https://drive.google.com/uc?export=download&id=${fileId}`
            : webViewLink;
        setFiles((prev) => [
          ...prev,
          { name: filename, id: fileId, url: webViewLink, preview },
        ]);
      } catch (uploadError) {
        console.error('Upload error:', uploadError);
        throw new Error(`Lỗi khi tải lên: ${uploadError.message}`);
      }
    } catch (err) {
      console.error('Error uploading file:', err);
      Alert.alert(
        'Lỗi',
        `Không thể tải tệp: ${err.message || 'Lỗi không xác định'}`
      );
    } finally {
      setSaving(false);
    }
  };

  const removeFile = (file) => {
    Alert.alert('Xác nhận', 'Xóa tệp đính kèm này?', [
      { text: 'Hủy', style: 'cancel' },
      {
        text: 'Xóa',
        style: 'destructive',
        onPress: async () => {
          try {
            // Cập nhật đường dẫn để khớp với khi tải lên
            const delFn = httpsCallable(functions, 'deleteFileFromDrive');
            await delFn({ fileId: file.id });
          } catch (e) {
            console.log('Cannot delete from storage, maybe already removed');
          }
          setFiles((prev) => prev.filter((f) => f.name !== file.name));
        },
      },
    ]);
  };

  const viewFile = (file) => {
    if (file.preview && file.preview.startsWith('http')) {
      setImagePreviewUri(file.preview);
    } else if (file.url) {
      Linking.openURL(file.url).catch(() =>
        Alert.alert('Lỗi', 'Không thể mở tệp.')
      );
    }
  };

  const handleSave = async () => {
    try {
      setSaving(true);
      // Chỉ lưu các trường cần thiết để Firestore gọn nhẹ
      const filesToSave = files.map(({ name, id, url, mimeType }) => {
        const obj = { name, id, url };
        if (mimeType) obj.mimeType = mimeType;
        return obj;
      });

      await updateStageDetails(projectId, stage.stageId, {
        status,
        notes,
        files: filesToSave,
      });
      Alert.alert('Thành công', 'Đã lưu thay đổi', [
        { text: 'OK', onPress: () => navigation.goBack() },
      ]);
    } catch (err) {
      console.error(err);
      Alert.alert('Lỗi', 'Không thể lưu.');
    } finally {
      setSaving(false);
    }
  };

  return (
    <ScrollView
      style={styles.container}
      contentContainerStyle={{ padding: 16 }}
    >
      <Text style={styles.label}>Trạng thái</Text>
      <View style={styles.statusRow}>
        {STATUS_OPTIONS.map((opt) => (
          <TouchableOpacity
            key={opt.value}
            style={[
              styles.statusBtn,
              status === opt.value && { backgroundColor: opt.color },
            ]}
            onPress={() => setStatus(opt.value)}
          >
            <Text
              style={[
                styles.statusBtnText,
                status === opt.value && { color: '#fff' },
              ]}
            >
              {opt.label}
            </Text>
          </TouchableOpacity>
        ))}
      </View>

      <Text style={styles.label}>Ghi chú / Mô tả kết quả</Text>
      <TextInput
        style={styles.textArea}
        multiline
        value={notes}
        onChangeText={setNotes}
        placeholder="Nhập ghi chú ..."
      />

      <Text style={styles.label}>Tệp đính kèm</Text>
      {files.map((f) => (
        <View key={f.name} style={styles.fileRow}>
          <TouchableOpacity
            style={{ flexDirection: 'row', alignItems: 'center', flex: 1 }}
            onPress={() => viewFile(f)}
          >
            {f.preview && f.preview.startsWith('http') ? (
              <Image source={{ uri: f.preview }} style={styles.thumb} />
            ) : (
              <Ionicons name="document-outline" size={24} color="#666" />
            )}
            <Text style={styles.fileName}>{f.name}</Text>
          </TouchableOpacity>
          <TouchableOpacity
            onPress={() => removeFile(f)}
            style={{ padding: 4 }}
          >
            <Ionicons name="trash-outline" size={20} color="#d11a2a" />
          </TouchableOpacity>
        </View>
      ))}

      <View style={styles.attachActions}>
        <TouchableOpacity style={styles.attachBtn} onPress={pickFile}>
          <Ionicons name="images-outline" size={20} color="#fff" />
          <Text style={styles.attachBtnText}>Chọn từ thư viện</Text>
        </TouchableOpacity>
        <TouchableOpacity style={styles.attachBtn} onPress={takePhoto}>
          <Ionicons name="camera-outline" size={20} color="#fff" />
          <Text style={styles.attachBtnText}>Chụp ảnh</Text>
        </TouchableOpacity>
      </View>

      <TouchableOpacity
        style={styles.saveBtn}
        onPress={handleSave}
        disabled={saving}
      >
        {saving ? (
          <ActivityIndicator color="#fff" />
        ) : (
          <Text style={styles.saveBtnText}>Lưu</Text>
        )}
      </TouchableOpacity>

      {/* Image preview modal */}
      <Modal
        visible={!!imagePreviewUri}
        transparent={true}
        animationType="fade"
      >
        <View style={styles.modalBackdrop}>
          <TouchableOpacity
            style={styles.modalCloseArea}
            onPress={() => setImagePreviewUri(null)}
          />
          <Image
            source={{ uri: imagePreviewUri }}
            style={styles.modalImage}
            resizeMode="contain"
          />
          <TouchableOpacity
            style={styles.modalCloseBtn}
            onPress={() => setImagePreviewUri(null)}
          >
            <Ionicons name="close-circle" size={36} color="#fff" />
          </TouchableOpacity>
        </View>
      </Modal>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#fff' },
  label: { fontWeight: '600', marginBottom: 6, fontSize: 14, color: '#333' },
  statusRow: { flexDirection: 'row', flexWrap: 'wrap', marginBottom: 16 },
  statusBtn: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 8,
    backgroundColor: '#f1f1f1',
    marginRight: 8,
    marginBottom: 8,
  },
  statusBtnText: { color: '#333', fontSize: 14 },
  textArea: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    minHeight: 100,
    textAlignVertical: 'top',
    marginBottom: 16,
  },
  fileRow: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
  },
  thumb: { width: 40, height: 40, borderRadius: 4, marginRight: 8 },
  fileName: { flex: 1, color: '#333' },
  attachActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginVertical: 16,
  },
  attachBtn: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#0066cc',
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderRadius: 8,
    flex: 1,
    marginHorizontal: 4,
  },
  attachBtnText: { color: '#fff', marginLeft: 6, fontWeight: '500' },
  saveBtn: {
    backgroundColor: '#4CAF50',
    paddingVertical: 14,
    borderRadius: 8,
    alignItems: 'center',
  },
  saveBtnText: { color: '#fff', fontSize: 16, fontWeight: '600' },
  modalBackdrop: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.9)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalImage: {
    width: '90%',
    height: '80%',
  },
  modalCloseBtn: {
    position: 'absolute',
    top: 40,
    right: 20,
  },
  modalCloseArea: {
    ...StyleSheet.absoluteFillObject,
  },
});

export default StageDetailScreen;

// src/screens/SupplierDetailScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  SafeAreaView,
  Linking,
  Share,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import {
  getSupplierById,
  deleteSupplier,
  addSupplierRating,
} from '../api/supplierService';
import { useAuth } from '../contexts/AuthContext';

const SupplierDetailScreen = ({ route, navigation }) => {
  const { supplierId } = route.params;
  const { currentUser } = useAuth();
  const [supplier, setSupplier] = useState(null);
  const [loading, setLoading] = useState(true);
  const [showRatingModal, setShowRatingModal] = useState(false);

  useEffect(() => {
    const loadSupplierData = async () => {
      try {
        const data = await getSupplierById(supplierId);
        setSupplier(data);
      } catch (error) {
        console.error('Lỗi khi tải thông tin nhà cung cấp:', error);
        Alert.alert('Lỗi', 'Không thể tải thông tin nhà cung cấp');
        navigation.goBack();
      } finally {
        setLoading(false);
      }
    };

    loadSupplierData();
  }, [supplierId, navigation]);

  const handleCall = () => {
    if (!supplier?.phone) return;

    Linking.openURL(`tel:${supplier.phone}`);
  };

  const handleEmail = () => {
    if (!supplier?.email) return;

    Linking.openURL(`mailto:${supplier.email}`);
  };

  const handleShare = async () => {
    if (!supplier) return;

    try {
      const message = `
Thông tin nhà cung cấp:
Tên: ${supplier.name}
Liên hệ: ${supplier.contactName || 'N/A'}
SĐT: ${supplier.phone || 'N/A'}
Email: ${supplier.email || 'N/A'}
Địa chỉ: ${supplier.address || 'N/A'}
      `;

      await Share.share({
        message,
        title: `Thông tin nhà cung cấp: ${supplier.name}`,
      });
    } catch (error) {
      console.error('Lỗi khi chia sẻ:', error);
    }
  };

  const handleEdit = () => {
    navigation.navigate('EditSupplier', { supplierId, supplier });
  };

  const handleDelete = () => {
    Alert.alert(
      'Xác nhận xóa',
      `Bạn có chắc chắn muốn xóa nhà cung cấp "${supplier?.name}" không?`,
      [
        { text: 'Hủy', style: 'cancel' },
        {
          text: 'Xóa',
          style: 'destructive',
          onPress: async () => {
            try {
              await deleteSupplier(supplierId);
              Alert.alert('Thành công', 'Đã xóa nhà cung cấp');
              navigation.goBack();
            } catch (error) {
              console.error('Lỗi khi xóa nhà cung cấp:', error);
              Alert.alert('Lỗi', 'Không thể xóa nhà cung cấp');
            }
          },
        },
      ]
    );
  };

  if (loading) {
    return (
      <SafeAreaView style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0066cc" />
        <Text style={styles.loadingText}>Đang tải dữ liệu...</Text>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Chi tiết nhà cung cấp</Text>
        <TouchableOpacity onPress={handleShare}>
          <Ionicons name="share-outline" size={24} color="#333" />
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.content}>
        <View style={styles.supplierHeader}>
          <View style={styles.supplierNameContainer}>
            <Text style={styles.supplierName}>{supplier?.name}</Text>
            {supplier?.verified && (
              <View style={styles.verifiedBadge}>
                <Ionicons name="checkmark-circle" size={16} color="#fff" />
                <Text style={styles.verifiedText}>Đã xác minh</Text>
              </View>
            )}
          </View>

          {supplier?.categories && supplier.categories.length > 0 && (
            <View style={styles.categoriesContainer}>
              {supplier.categories.map((category, index) => (
                <View key={index} style={styles.categoryTag}>
                  <Text style={styles.categoryText}>{category}</Text>
                </View>
              ))}
            </View>
          )}
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Thông tin liên hệ</Text>

          {supplier?.contactName && (
            <View style={styles.infoRow}>
              <Ionicons name="person-outline" size={20} color="#666" />
              <Text style={styles.infoLabel}>Người liên hệ:</Text>
              <Text style={styles.infoText}>{supplier.contactName}</Text>
            </View>
          )}

          {supplier?.phone && (
            <TouchableOpacity style={styles.infoRow} onPress={handleCall}>
              <Ionicons name="call-outline" size={20} color="#666" />
              <Text style={styles.infoLabel}>Số điện thoại:</Text>
              <Text style={[styles.infoText, styles.linkText]}>
                {supplier.phone}
              </Text>
            </TouchableOpacity>
          )}

          {supplier?.email && (
            <TouchableOpacity style={styles.infoRow} onPress={handleEmail}>
              <Ionicons name="mail-outline" size={20} color="#666" />
              <Text style={styles.infoLabel}>Email:</Text>
              <Text style={[styles.infoText, styles.linkText]}>
                {supplier.email}
              </Text>
            </TouchableOpacity>
          )}

          {supplier?.address && (
            <View style={styles.infoRow}>
              <Ionicons name="location-outline" size={20} color="#666" />
              <Text style={styles.infoLabel}>Địa chỉ:</Text>
              <Text style={styles.infoText}>{supplier.address}</Text>
            </View>
          )}
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Thông tin thanh toán</Text>

          {supplier?.taxCode ? (
            <View style={styles.infoRow}>
              <Ionicons name="document-text-outline" size={20} color="#666" />
              <Text style={styles.infoLabel}>Mã số thuế:</Text>
              <Text style={styles.infoText}>{supplier.taxCode}</Text>
            </View>
          ) : (
            <Text style={styles.emptyText}>Chưa có thông tin mã số thuế</Text>
          )}

          {supplier?.bankAccount && (
            <View style={styles.infoRow}>
              <Ionicons name="card-outline" size={20} color="#666" />
              <Text style={styles.infoLabel}>Tài khoản:</Text>
              <Text style={styles.infoText}>{supplier.bankAccount}</Text>
            </View>
          )}

          {supplier?.bankName && (
            <View style={styles.infoRow}>
              <Ionicons name="business-outline" size={20} color="#666" />
              <Text style={styles.infoLabel}>Ngân hàng:</Text>
              <Text style={styles.infoText}>{supplier.bankName}</Text>
            </View>
          )}
        </View>

        {supplier?.description && (
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>Mô tả</Text>
            <Text style={styles.descriptionText}>{supplier.description}</Text>
          </View>
        )}

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Đánh giá</Text>
          <View style={styles.ratingContainer}>
            <View style={styles.ratingStars}>
              {supplier?.averageRating ? (
                <>
                  <Text style={styles.ratingValue}>
                    {supplier.averageRating.toFixed(1)}
                  </Text>
                  <View style={styles.starsContainer}>
                    {[1, 2, 3, 4, 5].map((star) => (
                      <Ionicons
                        key={star}
                        name={
                          star <= Math.round(supplier.averageRating)
                            ? 'star'
                            : 'star-outline'
                        }
                        size={16}
                        color="#FFD700"
                      />
                    ))}
                  </View>
                  <Text style={styles.ratingCount}>
                    ({supplier.ratings?.length || 0} đánh giá)
                  </Text>
                </>
              ) : (
                <Text style={styles.emptyText}>Chưa có đánh giá nào</Text>
              )}
            </View>
          </View>
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Thông tin khác</Text>

          <View style={styles.infoRow}>
            <Ionicons name="time-outline" size={20} color="#666" />
            <Text style={styles.infoLabel}>Ngày tạo:</Text>
            <Text style={styles.infoText}>
              {supplier?.createdAt
                ? new Date(
                    supplier.createdAt.seconds * 1000
                  ).toLocaleDateString('vi-VN')
                : 'N/A'}
            </Text>
          </View>

          {supplier?.updatedAt && (
            <View style={styles.infoRow}>
              <Ionicons name="refresh-outline" size={20} color="#666" />
              <Text style={styles.infoLabel}>Cập nhật:</Text>
              <Text style={styles.infoText}>
                {new Date(supplier.updatedAt.seconds * 1000).toLocaleDateString(
                  'vi-VN'
                )}
              </Text>
            </View>
          )}

          {supplier?.createdByName && (
            <View style={styles.infoRow}>
              <Ionicons name="person-add-outline" size={20} color="#666" />
              <Text style={styles.infoLabel}>Người tạo:</Text>
              <Text style={styles.infoText}>{supplier.createdByName}</Text>
            </View>
          )}
        </View>

        <View style={styles.actionButtons}>
          <TouchableOpacity
            style={[styles.actionButton, styles.editButton]}
            onPress={handleEdit}
          >
            <Ionicons name="create-outline" size={20} color="#fff" />
            <Text style={styles.actionButtonText}>Chỉnh sửa</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={[styles.actionButton, styles.deleteButton]}
            onPress={handleDelete}
          >
            <Ionicons name="trash-outline" size={20} color="#fff" />
            <Text style={styles.actionButtonText}>Xóa</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  loadingText: {
    marginTop: 12,
    color: '#666',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  content: {
    flex: 1,
    padding: 16,
  },
  supplierHeader: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  supplierNameContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 12,
  },
  supplierName: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
    flex: 1,
  },
  verifiedBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#4caf50',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  verifiedText: {
    color: '#fff',
    fontSize: 12,
    marginLeft: 4,
  },
  categoriesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  categoryTag: {
    backgroundColor: '#f0f0f0',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    marginRight: 8,
    marginBottom: 8,
  },
  categoryText: {
    color: '#666',
    fontSize: 12,
  },
  section: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
    paddingBottom: 8,
  },
  infoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  infoLabel: {
    width: 100,
    color: '#666',
    fontSize: 14,
    marginLeft: 8,
  },
  infoText: {
    flex: 1,
    color: '#333',
    fontSize: 14,
  },
  linkText: {
    color: '#0066cc',
  },
  descriptionText: {
    color: '#333',
    fontSize: 14,
    lineHeight: 20,
  },
  emptyText: {
    color: '#999',
    fontStyle: 'italic',
    textAlign: 'center',
    marginVertical: 8,
  },
  ratingContainer: {
    alignItems: 'center',
  },
  ratingStars: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  ratingValue: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginRight: 8,
  },
  starsContainer: {
    flexDirection: 'row',
    marginRight: 8,
  },
  ratingCount: {
    color: '#666',
    fontSize: 12,
  },
  actionButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 30,
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    borderRadius: 8,
    flex: 1,
    marginHorizontal: 4,
  },
  editButton: {
    backgroundColor: '#0066cc',
  },
  deleteButton: {
    backgroundColor: '#ff3b30',
  },
  actionButtonText: {
    color: '#fff',
    fontWeight: '600',
    marginLeft: 8,
  },
});

export default SupplierDetailScreen;

// src/screens/SupplierManagementScreen.js
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  TextInput,
  Alert,
  ActivityIndicator,
  SafeAreaView,
  Modal,
  ScrollView,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';
import {
  getAllSuppliers,
  deleteSupplier,
  searchSuppliers,
} from '../api/supplierService';
import { useAuth } from '../contexts/AuthContext';

const SupplierManagementScreen = ({ navigation }) => {
  const { currentUser } = useAuth();
  const [suppliers, setSuppliers] = useState([]);
  const [filteredSuppliers, setFilteredSuppliers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState('');
  const [refreshing, setRefreshing] = useState(false);
  const [showFilterModal, setShowFilterModal] = useState(false);
  const [selectedCategory, setSelectedCategory] = useState(null);
  const [categories, setCategories] = useState([]);

  // Lấy danh sách nhà cung cấp
  const loadSuppliers = useCallback(async () => {
    try {
      setLoading(true);
      const data = await getAllSuppliers();
      setSuppliers(data);
      setFilteredSuppliers(data);

      // Trích xuất danh sách các danh mục từ nhà cung cấp
      const allCategories = new Set();
      data.forEach((supplier) => {
        if (supplier.categories && Array.isArray(supplier.categories)) {
          supplier.categories.forEach((category) =>
            allCategories.add(category)
          );
        }
      });
      setCategories(Array.from(allCategories));
    } catch (error) {
      console.error('Lỗi khi tải danh sách nhà cung cấp:', error);
      Alert.alert('Lỗi', 'Không thể tải danh sách nhà cung cấp');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  }, []);

  // Tải lại danh sách khi màn hình được focus
  useFocusEffect(
    useCallback(() => {
      loadSuppliers();
    }, [loadSuppliers])
  );

  // Xử lý tìm kiếm
  const handleSearch = async (text) => {
    setSearchQuery(text);

    if (!text.trim()) {
      setFilteredSuppliers(suppliers);
      return;
    }

    try {
      const results = await searchSuppliers(text);
      setFilteredSuppliers(results);
    } catch (error) {
      console.error('Lỗi khi tìm kiếm:', error);
    }
  };

  // Xử lý refresh
  const handleRefresh = () => {
    setRefreshing(true);
    loadSuppliers();
  };

  // Xử lý xóa nhà cung cấp
  const handleDeleteSupplier = (supplier) => {
    Alert.alert(
      'Xác nhận xóa',
      `Bạn có chắc chắn muốn xóa nhà cung cấp "${supplier.name}" không?`,
      [
        { text: 'Hủy', style: 'cancel' },
        {
          text: 'Xóa',
          style: 'destructive',
          onPress: async () => {
            try {
              await deleteSupplier(supplier.id);
              Alert.alert('Thành công', 'Đã xóa nhà cung cấp');
              loadSuppliers();
            } catch (error) {
              console.error('Lỗi khi xóa nhà cung cấp:', error);
              Alert.alert('Lỗi', 'Không thể xóa nhà cung cấp');
            }
          },
        },
      ]
    );
  };

  // Xử lý lọc theo danh mục
  const handleFilterByCategory = (category) => {
    setSelectedCategory(category);
    setShowFilterModal(false);

    if (!category) {
      setFilteredSuppliers(suppliers);
      return;
    }

    const filtered = suppliers.filter(
      (supplier) =>
        supplier.categories &&
        Array.isArray(supplier.categories) &&
        supplier.categories.includes(category)
    );

    setFilteredSuppliers(filtered);
  };

  // Hiển thị item nhà cung cấp
  const renderSupplierItem = ({ item }) => (
    <TouchableOpacity
      style={styles.supplierCard}
      onPress={() =>
        navigation.navigate('SupplierDetail', { supplierId: item.id })
      }
    >
      <View style={styles.supplierHeader}>
        <Text style={styles.supplierName}>{item.name}</Text>
        {item.verified && (
          <View style={styles.verifiedBadge}>
            <Ionicons name="checkmark-circle" size={16} color="#fff" />
            <Text style={styles.verifiedText}>Đã xác minh</Text>
          </View>
        )}
      </View>

      <View style={styles.supplierInfo}>
        {item.contactName && (
          <View style={styles.infoRow}>
            <Ionicons name="person-outline" size={16} color="#666" />
            <Text style={styles.infoText}>{item.contactName}</Text>
          </View>
        )}

        {item.phone && (
          <View style={styles.infoRow}>
            <Ionicons name="call-outline" size={16} color="#666" />
            <Text style={styles.infoText}>{item.phone}</Text>
          </View>
        )}

        {item.email && (
          <View style={styles.infoRow}>
            <Ionicons name="mail-outline" size={16} color="#666" />
            <Text style={styles.infoText}>{item.email}</Text>
          </View>
        )}

        {item.address && (
          <View style={styles.infoRow}>
            <Ionicons name="location-outline" size={16} color="#666" />
            <Text style={styles.infoText} numberOfLines={1}>
              {item.address}
            </Text>
          </View>
        )}
      </View>

      {item.categories && item.categories.length > 0 && (
        <View style={styles.categoriesContainer}>
          {item.categories.map((category, index) => (
            <View key={index} style={styles.categoryTag}>
              <Text style={styles.categoryText}>{category}</Text>
            </View>
          ))}
        </View>
      )}

      <View style={styles.supplierActions}>
        <TouchableOpacity
          style={styles.actionButton}
          onPress={() =>
            navigation.navigate('EditSupplier', { supplier: item })
          }
        >
          <Ionicons name="create-outline" size={18} color="#0066cc" />
          <Text style={[styles.actionText, { color: '#0066cc' }]}>Sửa</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.actionButton}
          onPress={() => handleDeleteSupplier(item)}
        >
          <Ionicons name="trash-outline" size={18} color="#ff3b30" />
          <Text style={[styles.actionText, { color: '#ff3b30' }]}>Xóa</Text>
        </TouchableOpacity>
      </View>
    </TouchableOpacity>
  );

  // Hiển thị modal lọc
  const renderFilterModal = () => (
    <Modal
      visible={showFilterModal}
      transparent
      animationType="slide"
      onRequestClose={() => setShowFilterModal(false)}
    >
      <View style={styles.modalOverlay}>
        <View style={styles.modalContainer}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>Lọc theo danh mục</Text>
            <TouchableOpacity onPress={() => setShowFilterModal(false)}>
              <Ionicons name="close" size={24} color="#666" />
            </TouchableOpacity>
          </View>

          <ScrollView style={styles.modalContent}>
            <TouchableOpacity
              style={[
                styles.categoryItem,
                !selectedCategory && styles.selectedCategoryItem,
              ]}
              onPress={() => handleFilterByCategory(null)}
            >
              <Text
                style={[
                  styles.categoryItemText,
                  !selectedCategory && styles.selectedCategoryText,
                ]}
              >
                Tất cả danh mục
              </Text>
              {!selectedCategory && (
                <Ionicons name="checkmark" size={18} color="#0066cc" />
              )}
            </TouchableOpacity>

            {categories.map((category, index) => (
              <TouchableOpacity
                key={index}
                style={[
                  styles.categoryItem,
                  selectedCategory === category && styles.selectedCategoryItem,
                ]}
                onPress={() => handleFilterByCategory(category)}
              >
                <Text
                  style={[
                    styles.categoryItemText,
                    selectedCategory === category &&
                      styles.selectedCategoryText,
                  ]}
                >
                  {category}
                </Text>
                {selectedCategory === category && (
                  <Ionicons name="checkmark" size={18} color="#0066cc" />
                )}
              </TouchableOpacity>
            ))}
          </ScrollView>
        </View>
      </View>
    </Modal>
  );

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.headerTitle}>Quản lý nhà cung cấp</Text>
      </View>

      <View style={styles.searchContainer}>
        <View style={styles.searchBar}>
          <Ionicons
            name="search"
            size={20}
            color="#999"
            style={styles.searchIcon}
          />
          <TextInput
            style={styles.searchInput}
            placeholder="Tìm kiếm nhà cung cấp..."
            value={searchQuery}
            onChangeText={handleSearch}
          />
          {searchQuery ? (
            <TouchableOpacity onPress={() => handleSearch('')}>
              <Ionicons name="close-circle" size={20} color="#999" />
            </TouchableOpacity>
          ) : null}
        </View>

        <TouchableOpacity
          style={styles.filterButton}
          onPress={() => setShowFilterModal(true)}
        >
          <Ionicons name="filter" size={20} color="#fff" />
        </TouchableOpacity>
      </View>

      {selectedCategory && (
        <View style={styles.activeFilterContainer}>
          <Text style={styles.activeFilterText}>
            Đang lọc: {selectedCategory}
          </Text>
          <TouchableOpacity onPress={() => handleFilterByCategory(null)}>
            <Ionicons name="close-circle" size={18} color="#666" />
          </TouchableOpacity>
        </View>
      )}

      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#0066cc" />
          <Text style={styles.loadingText}>Đang tải dữ liệu...</Text>
        </View>
      ) : (
        <FlatList
          data={filteredSuppliers}
          renderItem={renderSupplierItem}
          keyExtractor={(item) => item.id}
          contentContainerStyle={styles.listContainer}
          refreshing={refreshing}
          onRefresh={handleRefresh}
          ListEmptyComponent={
            <View style={styles.emptyContainer}>
              <Ionicons name="business-outline" size={48} color="#ccc" />
              <Text style={styles.emptyText}>
                {searchQuery
                  ? 'Không tìm thấy nhà cung cấp nào phù hợp'
                  : 'Chưa có nhà cung cấp nào'}
              </Text>
            </View>
          }
        />
      )}

      <TouchableOpacity
        style={styles.addButton}
        onPress={() => navigation.navigate('AddSupplier')}
      >
        <Ionicons name="add" size={24} color="#fff" />
      </TouchableOpacity>

      {renderFilterModal()}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  header: {
    backgroundColor: '#fff',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  searchContainer: {
    flexDirection: 'row',
    padding: 12,
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  searchBar: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
    borderRadius: 8,
    paddingHorizontal: 12,
    marginRight: 8,
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    height: 40,
    fontSize: 16,
  },
  filterButton: {
    backgroundColor: '#0066cc',
    width: 40,
    height: 40,
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center',
  },
  activeFilterContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#e6f2ff',
    padding: 8,
    marginHorizontal: 12,
    marginTop: 8,
    borderRadius: 4,
    justifyContent: 'space-between',
  },
  activeFilterText: {
    color: '#0066cc',
    fontSize: 14,
  },
  listContainer: {
    padding: 12,
  },
  supplierCard: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  supplierHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  supplierName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    flex: 1,
  },
  verifiedBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#4caf50',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  verifiedText: {
    color: '#fff',
    fontSize: 12,
    marginLeft: 4,
  },
  supplierInfo: {
    marginBottom: 12,
  },
  infoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 6,
  },
  infoText: {
    marginLeft: 8,
    color: '#666',
    fontSize: 14,
  },
  categoriesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 12,
  },
  categoryTag: {
    backgroundColor: '#f0f0f0',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    marginRight: 8,
    marginBottom: 8,
  },
  categoryText: {
    color: '#666',
    fontSize: 12,
  },
  supplierActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    borderTopWidth: 1,
    borderTopColor: '#f0f0f0',
    paddingTop: 12,
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 6,
    marginLeft: 8,
  },
  actionText: {
    marginLeft: 4,
    fontSize: 14,
    fontWeight: '500',
  },
  addButton: {
    position: 'absolute',
    right: 20,
    bottom: 20,
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: '#0066cc',
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 12,
    color: '#666',
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 40,
  },
  emptyText: {
    marginTop: 12,
    color: '#666',
    textAlign: 'center',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    width: '80%',
    backgroundColor: '#fff',
    borderRadius: 8,
    overflow: 'hidden',
    maxHeight: '70%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  modalTitle: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  modalContent: {
    padding: 16,
    maxHeight: 300,
  },
  categoryItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  selectedCategoryItem: {
    backgroundColor: '#e6f2ff',
  },
  categoryItemText: {
    fontSize: 14,
    color: '#333',
  },
  selectedCategoryText: {
    color: '#0066cc',
    fontWeight: '500',
  },
});

export default SupplierManagementScreen;

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  ActivityIndicator,
  Alert,
  ScrollView,
  Linking,
  Share,
} from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import { doc, getDoc } from 'firebase/firestore';
import { db } from '../config/firebaseConfig';
import { useTheme } from '../contexts/ThemeContext';
import { updateTaskStatus } from '../api/projectService'; // We will create this function
import { Ionicons } from '@expo/vector-icons';
import {
  getTaskDisplayLabel,
  getStatusDisplayLabel,
  getStatusColor,
} from '../utils/taskHelpers';

const TaskDetailScreen = () => {
  const route = useRoute();
  const navigation = useNavigation();
  const { theme } = useTheme();
  const { projectId, taskKey } = route.params;

  const [project, setProject] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isUpdating, setIsUpdating] = useState(false);
  const [shareSuccess, setShareSuccess] = useState(false);

  useEffect(() => {
    const fetchProjectDetails = async () => {
      try {
        setLoading(true);
        const projectRef = doc(db, 'projects', projectId);
        const projectSnap = await getDoc(projectRef);

        if (projectSnap.exists()) {
          setProject({ id: projectSnap.id, ...projectSnap.data() });
        } else {
          setError('Không tìm thấy thông tin dự án.');
        }
      } catch (err) {
        console.error('Error fetching project details for task:', err);
        setError('Lỗi khi tải dữ liệu dự án.');
      } finally {
        setLoading(false);
      }
    };
    fetchProjectDetails();
  }, [projectId]);

  const handleCompleteTask = async () => {
    setIsUpdating(true);
    try {
      await updateTaskStatus(projectId, taskKey, 'completed');
      Alert.alert('Thành công', 'Đã cập nhật trạng thái công việc.', [
        { text: 'OK', onPress: () => navigation.goBack() },
      ]);
    } catch (err) {
      console.error('Error updating task status:', err);
      Alert.alert(
        'Lỗi',
        err.message || 'Không thể cập nhật trạng thái công việc.'
      );
    } finally {
      setIsUpdating(false);
    }
  };

  const handleOpenDriveFolder = () => {
    if (project?.driveFolderUrl) {
      Linking.openURL(project.driveFolderUrl);
    } else {
      Alert.alert('Thông báo', 'Không tìm thấy thư mục Drive cho dự án này.');
    }
  };

  const handleShareDriveLink = async () => {
    if (project?.driveFolderUrl) {
      try {
        await Share.share({
          message: project.driveFolderUrl,
        });
        setShareSuccess(true);

        // Reset success message after 2 seconds
        setTimeout(() => {
          setShareSuccess(false);
        }, 2000);
      } catch (error) {
        console.error('Error sharing link:', error);
        Alert.alert('Lỗi', 'Không thể chia sẻ đường dẫn.');
      }
    } else {
      Alert.alert('Thông báo', 'Không có đường dẫn Drive để chia sẻ.');
    }
  };

  if (loading) {
    return (
      <View
        style={[styles.centerContainer, { backgroundColor: theme.background }]}
      >
        <ActivityIndicator size="large" color={theme.primary} />
      </View>
    );
  }

  if (error) {
    return (
      <View
        style={[styles.centerContainer, { backgroundColor: theme.background }]}
      >
        <Text style={{ color: theme.text }}>{error}</Text>
      </View>
    );
  }

  const task = project?.tasks?.[taskKey];
  const taskLabel = getTaskDisplayLabel(taskKey, task);
  const statusLabel = getStatusDisplayLabel(task?.status);
  const statusColor = getStatusColor(task?.status, theme);

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <View style={styles.header}>
        <TouchableOpacity
          onPress={() => navigation.goBack()}
          style={styles.backButton}
        >
          <Ionicons name="arrow-back" size={28} color={theme.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Chi tiết Công việc
        </Text>
      </View>

      <ScrollView style={styles.content}>
        <View style={[styles.card, { backgroundColor: theme.card }]}>
          <Text style={[styles.sectionTitle, { color: theme.textSecondary }]}>
            Công việc
          </Text>
          <Text style={[styles.taskName, { color: theme.text }]}>
            {taskLabel}
          </Text>
          <View style={styles.statusContainer}>
            <Text style={[styles.detailText, { color: theme.textSecondary }]}>
              Trạng thái:{' '}
            </Text>
            <Text style={[styles.statusText, { color: statusColor }]}>
              {statusLabel}
            </Text>
          </View>
        </View>

        <View style={[styles.card, { backgroundColor: theme.card }]}>
          <Text style={[styles.sectionTitle, { color: theme.textSecondary }]}>
            Thuộc dự án
          </Text>
          <Text style={[styles.detailText, { color: theme.text }]}>
            Tên dự án: {project?.name}
          </Text>
          <Text style={[styles.detailText, { color: theme.text }]}>
            Khách hàng: {project?.customerName || 'Không có'}
          </Text>

          {project?.driveFolderUrl && (
            <View style={styles.driveLinkContainer}>
              <TouchableOpacity
                style={[
                  styles.driveLinkButton,
                  { backgroundColor: theme.primary },
                ]}
                onPress={handleOpenDriveFolder}
              >
                <Ionicons
                  name="folder-open"
                  size={18}
                  color="#fff"
                  style={styles.buttonIcon}
                />
                <Text style={styles.driveLinkText}>Mở thư mục Drive</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.shareButton,
                  {
                    backgroundColor: shareSuccess
                      ? theme.success
                      : theme.secondary,
                  },
                ]}
                onPress={handleShareDriveLink}
                accessibilityLabel="Chia sẻ đường dẫn thư mục"
              >
                <Ionicons
                  name={shareSuccess ? 'checkmark' : 'share'}
                  size={20}
                  color="#fff"
                />
              </TouchableOpacity>
            </View>
          )}
        </View>
      </ScrollView>

      <View style={styles.footer}>
        <TouchableOpacity
          style={[
            styles.completeButton,
            {
              backgroundColor:
                task?.status === 'completed' || isUpdating
                  ? theme.textMuted
                  : theme.success || '#28a745',
            },
          ]}
          onPress={handleCompleteTask}
          disabled={task?.status === 'completed' || isUpdating}
        >
          {isUpdating ? (
            <ActivityIndicator color="#fff" />
          ) : (
            <Text style={styles.buttonText}>
              {task?.status === 'completed'
                ? 'Đã hoàn thành'
                : 'Hoàn thành công việc'}
            </Text>
          )}
        </TouchableOpacity>
      </View>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1 },
  centerContainer: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#333',
  },
  backButton: { padding: 5 },
  headerTitle: { fontSize: 22, fontWeight: 'bold', marginLeft: 16 },
  content: { flex: 1, padding: 16 },
  card: {
    padding: 20,
    borderRadius: 12,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: '#333',
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 12,
    color: '#888',
  },
  taskName: { fontSize: 26, fontWeight: 'bold', marginBottom: 10 },
  statusContainer: { flexDirection: 'row', alignItems: 'center' },
  statusText: { fontSize: 16, fontWeight: 'bold' },
  detailText: { fontSize: 16, lineHeight: 24 },
  footer: { padding: 16, borderTopWidth: 1, borderTopColor: '#333' },
  completeButton: {
    paddingVertical: 15,
    borderRadius: 12,
    alignItems: 'center',
  },
  buttonText: { color: '#fff', fontSize: 18, fontWeight: 'bold' },
  driveLinkContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 16,
  },
  driveLinkButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 8,
    flex: 1,
  },
  driveLinkText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 16,
  },
  buttonIcon: {
    marginRight: 8,
  },
  shareButton: {
    marginLeft: 12,
    width: 44,
    height: 44,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
});

export default TaskDetailScreen;

//src/screens/TaskReportScreen.js
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  FlatList,
  StyleSheet,
  ActivityIndicator,
  TouchableOpacity,
  SafeAreaView,
  ScrollView,
} from 'react-native';
import { useFocusEffect } from '@react-navigation/native';
import { collection, query, where, getDocs, orderBy } from 'firebase/firestore';
import { db } from '../config/firebaseConfig';
import { useAuth } from '../contexts/AuthContext';
import { useTheme } from '../contexts/ThemeContext';

const TaskCard = ({ item, onPress, theme }) => {
  const getStatusColor = (status) => {
    switch (status) {
      case 'completed':
        return { bg: 'rgba(46, 204, 113, 0.2)', text: '#27AE60' };
      case 'in_progress':
        return { bg: 'rgba(52, 152, 219, 0.2)', text: '#2980B9' };
      case 'pending':
        return { bg: 'rgba(241, 196, 15, 0.2)', text: '#F39C12' };
      default:
        return { bg: theme.border, text: theme.textSecondary };
    }
  };

  const getStatusLabel = (status) => {
    switch (status) {
      case 'completed':
        return 'Hoàn thành';
      case 'in_progress':
        return 'Đang thực hiện';
      case 'pending':
        return 'Chờ xử lý';
      default:
        return 'Không xác định';
    }
  };

  const statusStyle = getStatusColor(item.status);

  return (
    <TouchableOpacity
      style={[styles.card, { backgroundColor: theme.card }]}
      onPress={onPress}
    >
      <View style={styles.cardHeader}>
        <Text
          style={[styles.taskLabel, { color: theme.text }]}
          numberOfLines={1}
        >
          {item.taskLabel}
        </Text>
        <View style={[styles.statusBadge, { backgroundColor: statusStyle.bg }]}>
          <Text style={[styles.statusText, { color: statusStyle.text }]}>
            {getStatusLabel(item.status)}
          </Text>
        </View>
      </View>
      <View style={styles.cardBody}>
        <Text style={[styles.projectName, { color: theme.textSecondary }]}>
          Dự án: {item.projectName}
        </Text>
        <Text style={[styles.assignedTo, { color: theme.textSecondary }]}>
          Phụ trách: {item.assignedToName}
        </Text>
      </View>
    </TouchableOpacity>
  );
};

const TaskReportScreen = ({ navigation }) => {
  const { currentUser } = useAuth();
  const { theme } = useTheme();

  // Common states
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // States for Manager View
  const [myTasks, setMyTasks] = useState([]);
  const [staffPendingTasks, setStaffPendingTasks] = useState([]);
  const [staffCompletedTasks, setStaffCompletedTasks] = useState([]);

  // State for manager tabs
  const [activeManagerView, setActiveManagerView] = useState('my_tasks'); // 'my_tasks', 'staff_pending', 'staff_completed'

  // States for Staff View
  const [tasks, setTasks] = useState([]);
  const [filteredTasks, setFilteredTasks] = useState([]);
  const [activeFilter, setActiveFilter] = useState('all');

  const isManager = ['giam_doc', 'pho_giam_doc', 'admin'].includes(
    currentUser?.role
  );

  const fetchManagerTasks = async () => {
    setLoading(true);
    setError(null);
    try {
      const tasksCollection = collection(db, 'tasks');

      // 1. My tasks (pending or in-progress)
      const myTasksQuery = query(
        tasksCollection,
        where('assignedToId', '==', currentUser.uid),
        where('status', 'in', ['pending', 'in_progress'])
      );
      const myTasksSnapshot = await getDocs(myTasksQuery);
      setMyTasks(
        myTasksSnapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }))
      );

      // 2. Staff pending tasks
      const staffPendingQuery = query(
        tasksCollection,
        where('assignedToId', '!=', currentUser.uid),
        where('status', 'in', ['pending', 'in_progress'])
      );
      const staffPendingSnapshot = await getDocs(staffPendingQuery);
      setStaffPendingTasks(
        staffPendingSnapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }))
      );

      // 3. Staff completed tasks
      const staffCompletedQuery = query(
        tasksCollection,
        where('assignedToId', '!=', currentUser.uid),
        where('status', '==', 'completed')
      );
      const staffCompletedSnapshot = await getDocs(staffCompletedQuery);
      setStaffCompletedTasks(
        staffCompletedSnapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        }))
      );
    } catch (err) {
      console.error('Error fetching manager tasks:', err);
      setError('Không thể tải báo cáo công việc.');
    } finally {
      setLoading(false);
    }
  };

  const fetchStaffTasks = async () => {
    setLoading(true);
    setError(null);
    try {
      const tasksCollection = collection(db, 'tasks');
      const tasksQuery = query(
        tasksCollection,
        where('assignedToId', '==', currentUser.uid),
        orderBy('updatedAt', 'desc')
      );

      const querySnapshot = await getDocs(tasksQuery);
      const fetchedTasks = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));
      setTasks(fetchedTasks);
      setFilteredTasks(fetchedTasks);
    } catch (err) {
      console.error('Error fetching tasks:', err);
      setError('Không thể tải danh sách công việc.');
    } finally {
      setLoading(false);
    }
  };

  useFocusEffect(
    useCallback(() => {
      if (isManager) {
        fetchManagerTasks();
      } else {
        fetchStaffTasks();
      }
    }, [currentUser, isManager])
  );

  useEffect(() => {
    if (!isManager) {
      if (activeFilter === 'all') {
        setFilteredTasks(tasks);
      } else {
        const filtered = tasks.filter((task) => task.status === activeFilter);
        setFilteredTasks(filtered);
      }
    }
  }, [activeFilter, tasks, isManager]);

  const handleTaskPress = (item) => {
    if (isManager) {
      // Managers go to the full project detail screen
      navigation.navigate('ProjectDetail', { projectId: item.projectId });
    } else {
      // Staff go to the dedicated, simplified task detail screen
      navigation.navigate('TaskDetail', {
        projectId: item.projectId,
        taskKey: item.taskKey,
      });
    }
  };

  // -- RENDER METHODS --

  if (loading) {
    return (
      <View
        style={[styles.centerContainer, { backgroundColor: theme.background }]}
      >
        <ActivityIndicator size="large" color={theme.primary} />
      </View>
    );
  }

  if (error) {
    return (
      <View
        style={[styles.centerContainer, { backgroundColor: theme.background }]}
      >
        <Text style={{ color: theme.text }}>{error}</Text>
      </View>
    );
  }

  const renderTaskList = (data) => {
    if (data.length === 0) {
      return (
        <View style={styles.emptySection}>
          <Text style={{ color: theme.textSecondary }}>
            Không có công việc nào.
          </Text>
        </View>
      );
    }
    return data.map((item) => (
      <TaskCard
        key={item.id}
        item={item}
        onPress={() => handleTaskPress(item)}
        theme={theme}
      />
    ));
  };

  // Manager View
  if (isManager) {
    const renderManagerContent = () => {
      switch (activeManagerView) {
        case 'staff_pending':
          return renderTaskList(staffPendingTasks);
        case 'staff_completed':
          return renderTaskList(staffCompletedTasks);
        case 'my_tasks':
        default:
          return renderTaskList(myTasks);
      }
    };

    return (
      <SafeAreaView
        style={[styles.container, { backgroundColor: theme.background }]}
      >
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Báo cáo Công việc
        </Text>

        {/* Manager Tabs */}
        <View style={styles.managerTabContainer}>
          <TouchableOpacity
            style={[
              styles.managerTab,
              { backgroundColor: theme.card },
              activeManagerView === 'my_tasks' && {
                backgroundColor: theme.primary,
              },
            ]}
            onPress={() => setActiveManagerView('my_tasks')}
          >
            <Text
              style={[
                styles.managerTabText,
                { color: theme.text },
                activeManagerView === 'my_tasks' && { color: '#FFFFFF' },
              ]}
            >
              Việc của tôi
            </Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={[
              styles.managerTab,
              { backgroundColor: theme.card },
              activeManagerView === 'staff_pending' && {
                backgroundColor: theme.primary,
              },
            ]}
            onPress={() => setActiveManagerView('staff_pending')}
          >
            <Text
              style={[
                styles.managerTabText,
                { color: theme.text },
                activeManagerView === 'staff_pending' && { color: '#FFFFFF' },
              ]}
            >
              NV Đang Làm
            </Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={[
              styles.managerTab,
              { backgroundColor: theme.card },
              activeManagerView === 'staff_completed' && {
                backgroundColor: theme.primary,
              },
            ]}
            onPress={() => setActiveManagerView('staff_completed')}
          >
            <Text
              style={[
                styles.managerTabText,
                { color: theme.text },
                activeManagerView === 'staff_completed' && { color: '#FFFFFF' },
              ]}
            >
              Đã Hoàn Thành
            </Text>
          </TouchableOpacity>
        </View>

        <ScrollView contentContainerStyle={styles.listContainer}>
          {renderManagerContent()}
        </ScrollView>
      </SafeAreaView>
    );
  }

  // Staff View
  const renderFilterButtons = () => {
    const filters = [
      { key: 'all', label: 'Tất cả' },
      { key: 'in_progress', label: 'Đang làm' },
      { key: 'completed', label: 'Hoàn thành' },
      { key: 'pending', label: 'Chờ xử lý' },
    ];

    return (
      <View style={styles.filterContainer}>
        {filters.map((filter) => (
          <TouchableOpacity
            key={filter.key}
            style={[
              styles.filterButton,
              {
                backgroundColor:
                  activeFilter === filter.key ? theme.primary : theme.card,
              },
            ]}
            onPress={() => setActiveFilter(filter.key)}
          >
            <Text
              style={[
                styles.filterText,
                { color: activeFilter === filter.key ? '#fff' : theme.text },
              ]}
            >
              {filter.label}
            </Text>
          </TouchableOpacity>
        ))}
      </View>
    );
  };

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <Text style={[styles.headerTitle, { color: theme.text }]}>
        Công việc của bạn
      </Text>
      {renderFilterButtons()}
      <FlatList
        data={filteredTasks}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <TaskCard
            item={item}
            onPress={() => handleTaskPress(item)}
            theme={theme}
          />
        )}
        contentContainerStyle={styles.listContainer}
        ListEmptyComponent={() => (
          <View style={styles.centerContainer}>
            <Text style={{ color: theme.textSecondary }}>
              Không có công việc nào.
            </Text>
          </View>
        )}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1 },
  centerContainer: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  headerTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    padding: 16,
    paddingBottom: 8,
  },
  listContainer: { paddingHorizontal: 16, paddingBottom: 16 },
  card: {
    padding: 16,
    borderRadius: 12,
    marginVertical: 8,
    borderWidth: 1,
    borderColor: '#eee',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
  },
  cardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  taskLabel: { fontSize: 18, fontWeight: 'bold', flexShrink: 1 },
  statusBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 10,
    marginLeft: 8,
  },
  statusText: { fontSize: 12, fontWeight: '600' },
  cardBody: {},
  projectName: { fontSize: 14, marginBottom: 4 },
  assignedTo: { fontSize: 14 },
  filterContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    paddingHorizontal: 16,
    marginBottom: 8,
  },
  filterButton: {
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 16,
  },
  filterText: {
    fontWeight: '500',
  },
  // Styles for Manager View
  managerTabContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    paddingHorizontal: 16,
    marginBottom: 16,
  },
  managerTab: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 20,
    alignItems: 'center',
    marginHorizontal: 4,
  },
  managerTabText: {
    fontWeight: 'bold',
  },
  section: {
    marginBottom: 24,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  emptySection: {
    padding: 16,
    alignItems: 'center',
    backgroundColor: '#f9f9f9',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#eee',
  },
});

export default TaskReportScreen;

// src/screens/UserManagementScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  Modal,
  TextInput,
  ActivityIndicator,
  Alert,
  Image,
  SafeAreaView,
  ScrollView,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import {
  collection,
  getDocs,
  doc,
  updateDoc,
  query,
  orderBy,
  getDoc,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';
import * as ImagePicker from 'expo-image-picker';
import { getStorage, ref, uploadBytes, getDownloadURL } from 'firebase/storage';

const UserManagementScreen = () => {
  const { theme } = useTheme();
  const { currentUser } = useAuth();
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [selectedUser, setSelectedUser] = useState(null);
  const [editModalVisible, setEditModalVisible] = useState(false);
  const [editData, setEditData] = useState({
    displayName: '',
    email: '',
    role: '',
    photoURL: '',
    monthlySalary: '',
    phoneNumber: '',
    address: '',
    notes: '',
  });
  const [savingUser, setSavingUser] = useState(false);
  const [uploadingImage, setUploadingImage] = useState(false);

  // Role options for dropdown
  const roleOptions = [
    { value: 'giam_doc', label: 'Giám đốc' },
    { value: 'pho_giam_doc', label: 'Phó Giám đốc' },
    { value: 'ke_toan', label: 'Kế toán' },
    { value: 'ky_su', label: 'Kỹ sư' },
    { value: 'thuong_mai', label: 'Thương mại' },
    { value: 'cong_nhan', label: 'Công nhân' },
    { value: 'user', label: 'Người dùng' },
  ];

  // Load users
  useEffect(() => {
    const fetchUsers = async () => {
      try {
        setLoading(true);
        const usersRef = collection(db, 'users');
        const q = query(usersRef, orderBy('displayName'));
        const snapshot = await getDocs(q);
        const usersList = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        }));
        setUsers(usersList);
      } catch (error) {
        console.error('Error loading users:', error);
        Alert.alert('Lỗi', 'Không thể tải danh sách người dùng');
      } finally {
        setLoading(false);
      }
    };

    fetchUsers();
  }, []);

  // Handle user selection for editing
  const handleEditUser = (user) => {
    setSelectedUser(user);
    setEditData({
      displayName: user.displayName || '',
      email: user.email || '',
      role: user.role || 'user',
      photoURL: user.photoURL || '',
      monthlySalary: user.monthlySalary ? String(user.monthlySalary) : '',
      phoneNumber: user.phoneNumber || '',
      address: user.address || '',
      notes: user.notes || '',
    });
    setEditModalVisible(true);
  };

  // Save user changes
  const saveUserChanges = async () => {
    if (!selectedUser) return;

    try {
      setSavingUser(true);

      // Validate required fields
      if (!editData.displayName.trim()) {
        Alert.alert('Lỗi', 'Tên người dùng không được để trống');
        return;
      }

      // Convert salary to number if provided
      const userData = {
        ...editData,
        monthlySalary: editData.monthlySalary
          ? parseFloat(editData.monthlySalary)
          : null,
      };

      // Update user in Firestore
      const userRef = doc(db, 'users', selectedUser.id);
      await updateDoc(userRef, userData);

      // Update local state
      setUsers((prevUsers) =>
        prevUsers.map((u) =>
          u.id === selectedUser.id ? { ...u, ...userData } : u
        )
      );

      // Close modal
      setEditModalVisible(false);
      setSelectedUser(null);
      Alert.alert('Thành công', 'Đã cập nhật thông tin người dùng');
    } catch (error) {
      console.error('Error updating user:', error);
      Alert.alert('Lỗi', 'Không thể cập nhật thông tin người dùng');
    } finally {
      setSavingUser(false);
    }
  };

  // Pick and upload profile image
  const pickImage = async () => {
    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        aspect: [1, 1],
        quality: 0.7,
      });

      if (!result.canceled && result.assets && result.assets[0]) {
        uploadImage(result.assets[0].uri);
      }
    } catch (error) {
      console.error('Error picking image:', error);
      Alert.alert('Lỗi', 'Không thể chọn ảnh');
    }
  };

  // Upload image to Firebase Storage
  const uploadImage = async (uri) => {
    try {
      setUploadingImage(true);

      // Convert image to blob
      const response = await fetch(uri);
      const blob = await response.blob();

      // Upload to Firebase Storage
      const storage = getStorage();
      const fileExtension = uri.split('.').pop();
      const fileName = `profile_${
        selectedUser.id
      }_${Date.now()}.${fileExtension}`;
      const storageRef = ref(storage, `profiles/${fileName}`);

      await uploadBytes(storageRef, blob);
      const downloadURL = await getDownloadURL(storageRef);

      // Update edit data with new image URL
      setEditData((prev) => ({
        ...prev,
        photoURL: downloadURL,
      }));
    } catch (error) {
      console.error('Error uploading image:', error);
      Alert.alert('Lỗi', 'Không thể tải lên ảnh');
    } finally {
      setUploadingImage(false);
    }
  };

  // Render user item in list
  const renderUserItem = ({ item }) => {
    const isCurrentUser = item.id === currentUser?.uid;

    return (
      <TouchableOpacity
        style={[styles.userCard, { backgroundColor: theme.card }]}
        onPress={() => handleEditUser(item)}
      >
        <View style={styles.userCardLeft}>
          {item.photoURL ? (
            <Image source={{ uri: item.photoURL }} style={styles.avatar} />
          ) : (
            <View
              style={[
                styles.avatarPlaceholder,
                { backgroundColor: theme.primaryLight },
              ]}
            >
              <Text style={[styles.avatarText, { color: theme.primary }]}>
                {(item.displayName || item.email || '?')[0].toUpperCase()}
              </Text>
            </View>
          )}
        </View>

        <View style={styles.userCardMiddle}>
          <Text style={[styles.userName, { color: theme.text }]}>
            {item.displayName || item.email || 'Không có tên'}
            {isCurrentUser && ' (Bạn)'}
          </Text>
          <Text style={[styles.userRole, { color: theme.textSecondary }]}>
            {getRoleLabel(item.role)}
          </Text>
          {item.monthlySalary && (
            <Text style={[styles.userSalary, { color: theme.textMuted }]}>
              {formatCurrency(item.monthlySalary)} VND/tháng
            </Text>
          )}
        </View>

        <View style={styles.userCardRight}>
          <Ionicons name="chevron-forward" size={20} color={theme.textMuted} />
        </View>
      </TouchableOpacity>
    );
  };

  // Helper function to get role label
  const getRoleLabel = (role) => {
    const option = roleOptions.find((o) => o.value === role);
    return option ? option.label : 'Người dùng';
  };

  // Format currency
  const formatCurrency = (value) => {
    return new Intl.NumberFormat('vi-VN').format(value);
  };

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      {/* Header */}
      <View style={[styles.header, { backgroundColor: theme.card }]}>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Quản lý Nhân viên
        </Text>
      </View>

      {/* User list */}
      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
            Đang tải danh sách người dùng...
          </Text>
        </View>
      ) : (
        <FlatList
          data={users}
          renderItem={renderUserItem}
          keyExtractor={(item) => item.id}
          contentContainerStyle={styles.listContent}
          ListEmptyComponent={
            <View style={styles.emptyContainer}>
              <Ionicons name="people" size={40} color={theme.textMuted} />
              <Text style={[styles.emptyText, { color: theme.textMuted }]}>
                Không có người dùng nào
              </Text>
            </View>
          }
        />
      )}

      {/* Edit user modal */}
      <Modal
        visible={editModalVisible}
        transparent
        animationType="slide"
        onRequestClose={() => setEditModalVisible(false)}
      >
        <View style={styles.modalBackdrop}>
          <View style={[styles.modalContent, { backgroundColor: theme.card }]}>
            <View style={styles.modalHeader}>
              <Text style={[styles.modalTitle, { color: theme.text }]}>
                Chỉnh sửa thông tin
              </Text>
              <TouchableOpacity
                onPress={() => setEditModalVisible(false)}
                style={styles.closeButton}
              >
                <Ionicons name="close" size={24} color={theme.textMuted} />
              </TouchableOpacity>
            </View>

            <ScrollView style={styles.modalScrollView}>
              {/* Profile image */}
              <View style={styles.profileImageContainer}>
                {uploadingImage ? (
                  <ActivityIndicator size="large" color={theme.primary} />
                ) : editData.photoURL ? (
                  <Image
                    source={{ uri: editData.photoURL }}
                    style={styles.profileImage}
                  />
                ) : (
                  <View
                    style={[
                      styles.profileImagePlaceholder,
                      { backgroundColor: theme.primaryLight },
                    ]}
                  >
                    <Text
                      style={[
                        styles.profileImageText,
                        { color: theme.primary },
                      ]}
                    >
                      {(editData.displayName || '?')[0].toUpperCase()}
                    </Text>
                  </View>
                )}

                <TouchableOpacity
                  style={[
                    styles.changePhotoButton,
                    { backgroundColor: theme.primary },
                  ]}
                  onPress={pickImage}
                >
                  <Ionicons name="camera" size={18} color="#fff" />
                  <Text style={styles.changePhotoText}>Đổi ảnh</Text>
                </TouchableOpacity>
              </View>

              {/* Form fields */}
              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>Tên</Text>
                <TextInput
                  style={[
                    styles.input,
                    { borderColor: theme.border, color: theme.text },
                  ]}
                  value={editData.displayName}
                  onChangeText={(text) =>
                    setEditData((prev) => ({ ...prev, displayName: text }))
                  }
                  placeholder="Tên người dùng"
                  placeholderTextColor={theme.textMuted}
                />
              </View>

              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>Email</Text>
                <TextInput
                  style={[
                    styles.input,
                    { borderColor: theme.border, color: theme.text },
                  ]}
                  value={editData.email}
                  onChangeText={(text) =>
                    setEditData((prev) => ({ ...prev, email: text }))
                  }
                  placeholder="Email"
                  placeholderTextColor={theme.textMuted}
                  keyboardType="email-address"
                />
              </View>

              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>
                  Vai trò
                </Text>
                <View
                  style={[
                    styles.pickerContainer,
                    { borderColor: theme.border },
                  ]}
                >
                  {roleOptions.map((option) => (
                    <TouchableOpacity
                      key={option.value}
                      style={[
                        styles.roleOption,
                        editData.role === option.value && [
                          styles.selectedRole,
                          { backgroundColor: theme.primary + '20' },
                        ],
                      ]}
                      onPress={() =>
                        setEditData((prev) => ({ ...prev, role: option.value }))
                      }
                    >
                      <Text
                        style={[
                          styles.roleOptionText,
                          { color: theme.text },
                          editData.role === option.value && {
                            color: theme.primary,
                            fontWeight: '600',
                          },
                        ]}
                      >
                        {option.label}
                      </Text>
                    </TouchableOpacity>
                  ))}
                </View>
              </View>

              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>
                  Lương tháng (VND)
                </Text>
                <TextInput
                  style={[
                    styles.input,
                    { borderColor: theme.border, color: theme.text },
                  ]}
                  value={editData.monthlySalary}
                  onChangeText={(text) => {
                    // Only allow numbers
                    const filtered = text.replace(/[^0-9]/g, '');
                    setEditData((prev) => ({
                      ...prev,
                      monthlySalary: filtered,
                    }));
                  }}
                  placeholder="Lương tháng"
                  placeholderTextColor={theme.textMuted}
                  keyboardType="numeric"
                />
              </View>

              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>
                  Số điện thoại
                </Text>
                <TextInput
                  style={[
                    styles.input,
                    { borderColor: theme.border, color: theme.text },
                  ]}
                  value={editData.phoneNumber}
                  onChangeText={(text) =>
                    setEditData((prev) => ({ ...prev, phoneNumber: text }))
                  }
                  placeholder="Số điện thoại"
                  placeholderTextColor={theme.textMuted}
                  keyboardType="phone-pad"
                />
              </View>

              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>
                  Địa chỉ
                </Text>
                <TextInput
                  style={[
                    styles.input,
                    { borderColor: theme.border, color: theme.text },
                  ]}
                  value={editData.address}
                  onChangeText={(text) =>
                    setEditData((prev) => ({ ...prev, address: text }))
                  }
                  placeholder="Địa chỉ"
                  placeholderTextColor={theme.textMuted}
                />
              </View>

              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>
                  Ghi chú
                </Text>
                <TextInput
                  style={[
                    styles.textArea,
                    { borderColor: theme.border, color: theme.text },
                  ]}
                  value={editData.notes}
                  onChangeText={(text) =>
                    setEditData((prev) => ({ ...prev, notes: text }))
                  }
                  placeholder="Ghi chú"
                  placeholderTextColor={theme.textMuted}
                  multiline
                  numberOfLines={4}
                  textAlignVertical="top"
                />
              </View>
            </ScrollView>

            <View style={styles.modalFooter}>
              <TouchableOpacity
                style={[styles.cancelButton, { borderColor: theme.border }]}
                onPress={() => setEditModalVisible(false)}
              >
                <Text style={{ color: theme.text }}>Hủy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.saveButton, { backgroundColor: theme.primary }]}
                onPress={saveUserChanges}
                disabled={savingUser}
              >
                {savingUser ? (
                  <ActivityIndicator size="small" color="#fff" />
                ) : (
                  <Text style={styles.saveButtonText}>Lưu thay đổi</Text>
                )}
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    elevation: 2,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 12,
  },
  listContent: {
    padding: 12,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 40,
  },
  emptyText: {
    marginTop: 12,
    fontSize: 16,
  },
  userCard: {
    flexDirection: 'row',
    padding: 12,
    marginBottom: 8,
    borderRadius: 8,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  userCardLeft: {
    marginRight: 12,
  },
  avatar: {
    width: 50,
    height: 50,
    borderRadius: 25,
  },
  avatarPlaceholder: {
    width: 50,
    height: 50,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
  },
  avatarText: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  userCardMiddle: {
    flex: 1,
    justifyContent: 'center',
  },
  userName: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 4,
  },
  userRole: {
    fontSize: 14,
    marginBottom: 2,
  },
  userSalary: {
    fontSize: 12,
  },
  userCardRight: {
    justifyContent: 'center',
  },
  modalBackdrop: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    width: '90%',
    maxHeight: '90%',
    borderRadius: 12,
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  closeButton: {
    padding: 4,
  },
  modalScrollView: {
    padding: 16,
  },
  profileImageContainer: {
    alignItems: 'center',
    marginBottom: 20,
  },
  profileImage: {
    width: 100,
    height: 100,
    borderRadius: 50,
    marginBottom: 10,
  },
  profileImagePlaceholder: {
    width: 100,
    height: 100,
    borderRadius: 50,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 10,
  },
  profileImageText: {
    fontSize: 36,
    fontWeight: 'bold',
  },
  changePhotoButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
  },
  changePhotoText: {
    color: '#fff',
    marginLeft: 6,
    fontWeight: '500',
  },
  formGroup: {
    marginBottom: 16,
  },
  label: {
    marginBottom: 6,
    fontWeight: '500',
  },
  input: {
    borderWidth: 1,
    borderRadius: 8,
    padding: 10,
    fontSize: 16,
  },
  textArea: {
    borderWidth: 1,
    borderRadius: 8,
    padding: 10,
    fontSize: 16,
    height: 100,
  },
  pickerContainer: {
    borderWidth: 1,
    borderRadius: 8,
    padding: 6,
  },
  roleOption: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 4,
    marginBottom: 2,
  },
  selectedRole: {
    fontWeight: 'bold',
  },
  roleOptionText: {
    fontSize: 16,
  },
  modalFooter: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  cancelButton: {
    borderWidth: 1,
    borderRadius: 8,
    paddingVertical: 10,
    paddingHorizontal: 16,
    marginRight: 12,
  },
  saveButton: {
    borderRadius: 8,
    paddingVertical: 10,
    paddingHorizontal: 24,
  },
  saveButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
});

export default UserManagementScreen;

/**
 * Gets the Vietnamese display label for a task key.
 * @param {string} taskKey The key of the task (e.g., "material_cutting").
 * @param {any} taskData The data object for the task, used for the custom "other" task.
 * @returns {string} The display label for the task.
 */
export const getTaskDisplayLabel = (taskKey, taskData) => {
  const taskLabels = {
    material_separation: 'Bóc tách vật tư',
    quotation: 'Báo giá',
    material_purchasing: 'Mua vật tư & phụ kiện',
    material_cutting: 'Cắt phôi',
    assembly: 'Lắp ráp',
    painting: 'Sơn',
    shipping: 'Vận chuyển',
    other: taskData?.name || 'Công việc khác',
  };
  return taskLabels[taskKey] || taskKey.replace(/_/g, ' ');
};

/**
 * Gets the Vietnamese display label for a task status.
 * @param {string} status The status key (e.g., "in_progress").
 * @returns {string} The display label for the status.
 */
export const getStatusDisplayLabel = (status) => {
  const statusLabels = {
    completed: 'Hoàn thành',
    in_progress: 'Đang thực hiện',
    pending: 'Chờ xử lý',
  };
  return statusLabels[status] || 'Không xác định';
};

/**
 * Gets the color code associated with a task status.
 * @param {string} status The status key (e.g., "in_progress").
 * @param {object} theme The application theme object.
 * @returns {string} The color hex code.
 */
export const getStatusColor = (status, theme) => {
  switch (status) {
    case 'completed':
      return theme.success || '#28a745';
    case 'in_progress':
      return theme.info || '#17a2b8';
    case 'pending':
      return theme.warning || '#ffc107';
    default:
      return theme.textMuted || '#6c757d';
  }
};

export const APP_DRIVE_ROOT_FOLDER_ID = '1ZN8CxmHgAC2yzDqDVaJWxKSrpD4OjFUT'; // TODO: Set to THP_APP_DATA_ROOT folder ID
export const SERVICE_ACCOUNT_KEY_PATH =
  '../../service-account-credentials.json';

/**
 * @fileoverview Cloud Function to generate a contract from a Google Docs template.
 *
 * @description
 * This function implements a professional "Native Table Insertion" approach for generating
 * contracts. It creates a properly formatted table directly using Google Docs API.
 *
 * HƯỚNG DẪN CẤU HÌNH TEMPLATE GOOGLE DOCS (QUAN TRỌNG):
 *
 * 1. **Chuẩn bị Template:**
 *    - Tạo một file Google Docs để làm mẫu hợp đồng.
 *    - Đặt các placeholder cho các trường văn bản đơn giản, ví dụ: {companyName}, {customerAddress}, {grandTotal}.
 *
 * 2. **Chuẩn bị phần Bảng Vật Tư:**
 *    - Chỉ cần đặt một placeholder đơn giản: {{MATERIALS_TABLE}}
 *    - Placeholder này sẽ được thay thế bằng một bảng thực sự được tạo bởi Google Docs API.
 *    - Bảng sẽ tự động điều chỉnh kích thước dựa trên số lượng vật tư.
 *
 * 3. **Lấy ID Template:**
 *    - Mở file template Google Docs, copy ID từ URL.
 *      (Ví dụ: trong `.../d/THIS_IS_THE_ID/edit`, `THIS_IS_THE_ID` chính là ID).
 *    - Cập nhật biến `CONTRACT_TEMPLATE_ID` bên dưới bằng ID này.
 */
import * as functions from 'firebase-functions/v1';
import * as path from 'path';
import * as admin from 'firebase-admin';
// Import kiểu dữ liệu, không import thư viện thực tế
import type { docs_v1 } from 'googleapis';

// --- CONFIGURATION ---
// TODO: Thay thế bằng ID của file Google Docs template của bạn
const CONTRACT_TEMPLATE_ID = '1d0ERJFmbBmhqe4CcaMi02EBi20BXYCgZeasMCbT6ULc'; // ID TEMPLATE CẦN ĐƯỢC CẬP NHẬT

// --- TYPE DEFINITIONS ---
// Định nghĩa cấu trúc cho một hàng vật tư
interface MaterialItem {
  name: string;
  material: string;
  unit: string;
  quantity: number | string;
  unitPrice: number | string;
  totalPrice: number | string;
  weight?: number | string; // Thêm trọng lượng để tính đơn giá
  [key: string]: any;
}

// Định nghĩa cấu trúc cho dữ liệu hợp đồng được gửi từ client
interface ContractData {
  materials?: MaterialItem[];
  subTotal?: number;
  vatPercentage?: number;
  vatAmount?: number;
  grandTotal?: number;
  [key: string]: any; // Cho phép các trường khác
}

/**
 * Chuyển số thành chữ tiếng Việt
 * @param n Số cần chuyển đổi
 * @returns Chuỗi biểu diễn số bằng chữ tiếng Việt
 */
function convertNumberToVnWords(n: number): string {
  if (n === null || n === undefined) return '';
  const num = Math.floor(n);
  if (num === 0) return 'Bằng chữ: Không đồng chẵn.';
  const units = ['', ' nghìn', ' triệu', ' tỷ', ' nghìn tỷ', ' triệu tỷ'];
  const numbers = [
    'không',
    'một',
    'hai',
    'ba',
    'bốn',
    'năm',
    'sáu',
    'bảy',
    'tám',
    'chín',
  ];
  const convertGroup = (group: number): string => {
    let result = '';
    const tram = Math.floor(group / 100);
    const chuc = Math.floor((group % 100) / 10);
    const donvi = group % 10;
    if (tram > 0) {
      result += numbers[tram] + ' trăm';
      if (chuc === 0 && donvi !== 0) result += ' linh';
    }
    if (chuc > 1) {
      result += (tram > 0 ? ' ' : '') + numbers[chuc] + ' mươi';
      if (donvi === 1) result += ' mốt';
    } else if (chuc === 1) {
      result += (tram > 0 ? ' ' : '') + 'mười';
    }
    if (donvi > 0 && chuc !== 1) {
      if (donvi === 5 && chuc > 0) {
        result += (result.length > 0 ? ' ' : '') + 'lăm';
      } else if (donvi === 4 && chuc > 1) {
        result += (result.length > 0 ? ' ' : '') + 'tư';
      } else {
        result += (result.length > 0 ? ' ' : '') + numbers[donvi];
      }
    } else if (donvi > 0 && chuc === 1) {
      if (donvi === 5) {
        result += ' lăm';
      } else {
        result += ' ' + numbers[donvi];
      }
    }
    return result;
  };
  if (num === 0) return 'Không';
  let result = '';
  let i = 0;
  let tempNum = num;
  while (tempNum > 0) {
    let groupValue = tempNum % 1000;
    if (groupValue > 0) {
      let groupText = convertGroup(groupValue);
      result = groupText + units[i] + (result ? ' ' + result : '');
    }
    tempNum = Math.floor(tempNum / 1000);
    i++;
  }
  result = result.trim();
  return (
    'Bằng chữ: ' +
    result.charAt(0).toUpperCase() +
    result.slice(1) +
    ' đồng chẵn.'
  );
}

/**
 * Generates a contract by populating a Google Docs template using the "Native Table Insertion" approach.
 * This approach creates a properly formatted table directly using Google Docs API.
 */
export const generateContract = functions
  .region('us-central1')
  .runWith({
    timeoutSeconds: 300,
    memory: '1GB',
  })
  .https.onCall(async (data, context) => {
    // 1. ========= INITIALIZATION & VALIDATION =========
    // Import googleapis chỉ khi hàm được gọi
    const { google } = await import('googleapis');

    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Bạn phải đăng nhập để thực hiện chức năng này.'
      );
    }

    const { contractData, fileName, projectId } = data;
    const typedContractData = contractData as ContractData;

    if (!typedContractData || !fileName || !projectId) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Dữ liệu đầu vào không hợp lệ (thiếu contractData, fileName, hoặc projectId).'
      );
    }

    try {
      // Initialize Google APIs
      const auth = new google.auth.GoogleAuth({
        keyFile: path.join(__dirname, '../tanyb-fe4bf-4fbd5c01b6c7.json'),
        scopes: [
          'https://www.googleapis.com/auth/drive',
          'https://www.googleapis.com/auth/documents',
        ],
      });
      const drive = google.drive({ version: 'v3', auth });
      const docs = google.docs({ version: 'v1', auth });

      // Get project folder info from Firestore
      const db = admin.firestore();
      const projectDoc = await db.collection('projects').doc(projectId).get();
      const projectData = projectDoc.data();

      if (!projectData || !projectData.driveFolderId) {
        throw new functions.https.HttpsError(
          'failed-precondition',
          'Không tìm thấy thông tin thư mục Drive của dự án.'
        );
      }

      // Find 'hopdong' subfolder in project folder
      const hopdongFolderResponse = await drive.files.list({
        q: `name='hopdong' and '${projectData.driveFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
        fields: 'files(id)',
      });

      let hopdongFolderId;
      if (
        hopdongFolderResponse.data.files &&
        hopdongFolderResponse.data.files.length > 0
      ) {
        hopdongFolderId = hopdongFolderResponse.data.files[0].id;
      } else {
        // Create 'hopdong' folder if it doesn't exist
        const folderResponse = await drive.files.create({
          requestBody: {
            name: 'hopdong',
            mimeType: 'application/vnd.google-apps.folder',
            parents: [projectData.driveFolderId],
          },
          fields: 'id',
        });
        hopdongFolderId = folderResponse.data.id;
      }

      // Copy the template document
      const copiedFileResponse = await drive.files.copy({
        fileId: CONTRACT_TEMPLATE_ID,
        requestBody: {
          name: fileName,
          parents: [hopdongFolderId],
        },
      });
      const newDocId = copiedFileResponse.data.id;
      if (!newDocId) {
        throw new Error('Không thể sao chép file template Google Docs.');
      }

      functions.logger.info(`Đã tạo file tạm từ template, ID: ${newDocId}`);

      // 2. ========= TEXT REPLACEMENTS =========
      const requests: docs_v1.Schema$Request[] = [];

      // Xử lý tất cả các trường thông thường (không bao gồm bảng vật tư)
      const { materials, ...textFields } = typedContractData;

      Object.entries(textFields).forEach(([key, value]) => {
        // Đảm bảo key có dạng {key} để phù hợp với placeholder trong template
        const placeholderKey =
          key.startsWith('{') && key.endsWith('}') ? key : `{${key}}`;

        // Chuyển đổi value thành chuỗi, đảm bảo null/undefined trở thành chuỗi rỗng
        const replacementText = value != null ? String(value) : '';

        requests.push({
          replaceAllText: {
            containsText: {
              text: placeholderKey,
              matchCase: true,
            },
            replaceText: replacementText,
          },
        });
      });

      // 3. ========= APPLY TEXT REPLACEMENTS =========
      if (requests.length > 0) {
        await docs.documents.batchUpdate({
          documentId: newDocId,
          requestBody: { requests },
        });
        functions.logger.info(
          `Đã thực hiện ${requests.length} yêu cầu thay thế văn bản.`
        );
      }

      // 4. ========= FIND TABLE PLACEHOLDER POSITION =========
      // Lấy nội dung tài liệu để tìm vị trí của placeholder {{MATERIALS_TABLE}}
      const document = await docs.documents.get({
        documentId: newDocId,
      });

      // Tìm vị trí của placeholder {{MATERIALS_TABLE}}
      let placeholderIndex: number | null = null;

      if (document.data.body?.content) {
        for (const element of document.data.body.content) {
          if (element.paragraph && element.paragraph.elements) {
            for (const paraElement of element.paragraph.elements) {
              if (
                paraElement.textRun &&
                paraElement.textRun.content &&
                paraElement.textRun.content.includes('{{MATERIALS_TABLE}}')
              ) {
                placeholderIndex = paraElement.startIndex || null;
                break;
              }
            }
            if (placeholderIndex !== null) break;
          }
        }
      }

      if (placeholderIndex === null) {
        functions.logger.warn(
          'Không tìm thấy placeholder {{MATERIALS_TABLE}} trong tài liệu.'
        );
      } else {
        functions.logger.info(
          `Đã tìm thấy placeholder {{MATERIALS_TABLE}} tại vị trí: ${placeholderIndex}`
        );

        // 5. ========= CREATE AND INSERT TABLE =========
        const materialsArray = materials || [];
        // +1 cho hàng header
        const numRows = materialsArray.length + 1;
        const numColumns = 7; // STT, Vật Tư/Hàng Hóa, VL, ĐVT, SL, Đơn giá, Thành Tiền

        functions.logger.info(
          `Chuẩn bị tạo bảng với ${numRows} hàng và ${numColumns} cột.`
        );

        // Yêu cầu để xóa placeholder và tạo bảng trống
        const createTableRequests: docs_v1.Schema$Request[] = [
          {
            deleteContentRange: {
              range: {
                startIndex: placeholderIndex,
                endIndex: placeholderIndex + '{{MATERIALS_TABLE}}'.length,
              },
            },
          },
          {
            insertTable: {
              location: { index: placeholderIndex },
              rows: numRows,
              columns: numColumns,
            },
          },
        ];

        // Thực thi tạo bảng
        await docs.documents.batchUpdate({
          documentId: newDocId,
          requestBody: { requests: createTableRequests },
        });
        functions.logger.info(
          'Đã xóa placeholder và tạo bảng trống thành công.'
        );

        // 6. ========= POPULATE TABLE WITH DATA (ĐÃ SỬA LỖI) =========
        // Lấy lại tài liệu để có cấu trúc bảng mới nhất và các chỉ số chính xác
        const docWithTable = await docs.documents.get({
          documentId: newDocId,
        });

        // Tìm bảng vừa tạo
        let tableElement: docs_v1.Schema$Table | undefined;
        let tableStartLocation: number | undefined;

        if (docWithTable.data.body?.content) {
          for (const element of docWithTable.data.body.content) {
            // Tìm bảng có startIndex gần với vị trí placeholder ban đầu
            if (
              element.table &&
              element.startIndex &&
              Math.abs(element.startIndex - placeholderIndex) < 10
            ) {
              tableElement = element.table;
              tableStartLocation = element.startIndex;
              functions.logger.info(
                `Đã tìm thấy bảng tại vị trí: ${element.startIndex}`
              );
              break;
            }
          }
        }

        if (!tableElement || !tableElement.tableRows || !tableStartLocation) {
          throw new Error('Không tìm thấy bảng vừa tạo để điền dữ liệu.');
        }

        // *** THÊM MỚI: Định dạng chiều rộng cột ***
        const columnWidths = [
          { index: 0, width: 30 }, // STT
          { index: 1, width: 190 }, // Vật Tư, Hàng Hóa
          { index: 2, width: 60 }, // VL
          { index: 3, width: 40 }, // ĐVT
          { index: 4, width: 30 }, // SL
          { index: 5, width: 70 }, // Đơn giá
          { index: 6, width: 70 }, // Thành Tiền
        ];

        const setWidthRequests: docs_v1.Schema$Request[] = columnWidths.map(
          (col) => ({
            updateTableColumnProperties: {
              tableStartLocation: { index: tableStartLocation },
              columnIndices: [col.index],
              tableColumnProperties: {
                width: { magnitude: col.width, unit: 'PT' },
                widthType: 'FIXED_WIDTH',
              },
              fields: 'width,widthType',
            },
          })
        );

        await docs.documents.batchUpdate({
          documentId: newDocId,
          requestBody: { requests: setWidthRequests },
        });
        functions.logger.info('Đã định dạng chiều rộng các cột thành công.');

        // *** THAY ĐỔI: Chuẩn bị dữ liệu chỉ cho bảng vật tư ***
        const headers = [
          'STT',
          'Vật Tư, Hàng Hóa',
          'VL',
          'ĐVT',
          'SL',
          'Đơn giá',
          'Thành Tiền',
        ];
        const tableData: string[][] = [headers];

        materialsArray.forEach((material, index) => {
          // Tính đơn giá dựa trên khối lượng và đơn giá/kg
          const weight = Number(material.weight || 0);
          const unitPricePerKg = Number(material.unitPrice || 0);
          const calculatedUnitPrice = weight * unitPricePerKg;
          const quantity = Number(material.quantity || 0);
          const totalPrice = quantity * calculatedUnitPrice;

          // Sử dụng toán tử ba ngôi để kiểm tra giá trị bằng 0
          tableData.push([
            (index + 1).toString(),
            material.name || '',
            material.material || '',
            material.unit || 'cái',
            quantity > 0 ? String(quantity) : '', // Để trống nếu SL = 0
            calculatedUnitPrice > 0
              ? Math.floor(calculatedUnitPrice).toLocaleString('vi-VN')
              : '', // Để trống nếu Đơn giá = 0
            totalPrice > 0
              ? Math.floor(totalPrice).toLocaleString('vi-VN')
              : '', // Để trống nếu Thành tiền = 0
          ]);
        });

        functions.logger.info(
          `Đã chuẩn bị dữ liệu cho ${tableData.length} hàng`
        );

        const dataFillRequests: docs_v1.Schema$Request[] = [];

        // Thiết lập font chữ Times New Roman, màu đen, cỡ 12 cho toàn bộ bảng
        if (tableStartLocation) {
          // Thay vì thiết lập font cho toàn bộ bảng với một lệnh, chúng ta sẽ thiết lập font cho từng ô khi chèn dữ liệu
          functions.logger.info(
            'Sẽ thiết lập font chữ cho từng ô khi chèn dữ liệu'
          );
        }

        // *** LỖI ĐƯỢC SỬA TẠI ĐÂY: LẶP NGƯỢC TỪ CUỐI LÊN ĐẦU ***
        for (let r = tableData.length - 1; r >= 0; r--) {
          const rowData = tableData[r];
          for (let c = rowData.length - 1; c >= 0; c--) {
            const cellData = rowData[c];
            if (!cellData) continue; // Bỏ qua ô trống

            const cell = tableElement.tableRows[r]?.tableCells?.[c];
            if (!cell?.content?.[0]?.paragraph?.elements?.[0]?.startIndex) {
              functions.logger.warn(`Không tìm thấy vị trí cho ô [${r}, ${c}]`);
              continue;
            }

            const cellStartIndex =
              cell.content[0].paragraph.elements[0].startIndex;
            functions.logger.info(
              `Điền "${cellData}" vào ô [${r}, ${c}] tại vị trí ${cellStartIndex}`
            );

            // 1. Thêm yêu cầu chèn văn bản
            dataFillRequests.push({
              insertText: {
                location: { index: cellStartIndex },
                text: cellData,
              },
            });

            // 2. Thêm yêu cầu định dạng
            const textRange = {
              startIndex: cellStartIndex,
              endIndex: cellStartIndex + cellData.length,
            };

            // Thiết lập font chữ Times New Roman, màu đen, cỡ 12 cho từng ô
            dataFillRequests.push({
              updateTextStyle: {
                range: textRange,
                textStyle: {
                  weightedFontFamily: { fontFamily: 'Times New Roman' },
                  fontSize: { magnitude: 12, unit: 'PT' },
                  foregroundColor: {
                    color: {
                      rgbColor: { red: 0, green: 0, blue: 0 },
                    },
                  },
                },
                fields: 'weightedFontFamily,fontSize,foregroundColor',
              },
            });

            // In đậm cho hàng tiêu đề và các hàng tổng cộng
            // In đậm cho hàng tiêu đề và các hàng tổng cộng
            // Chỉ in đậm cho hàng tiêu đề
            if (r === 0) {
              // <--- ĐÃ SỬA
              dataFillRequests.push({
                updateTextStyle: {
                  range: textRange,
                  textStyle: { bold: true },
                  fields: 'bold',
                },
              });
            }

            // Căn giữa cho tất cả các ô (theo yêu cầu)
            dataFillRequests.push({
              updateParagraphStyle: {
                range: textRange,
                paragraphStyle: { alignment: 'CENTER' },
                fields: 'alignment',
              },
            });

            // Căn giữa theo chiều dọc
            dataFillRequests.push({
              updateTableCellStyle: {
                tableRange: {
                  tableCellLocation: {
                    tableStartLocation: { index: tableStartLocation || 0 },
                    rowIndex: r,
                    columnIndex: c,
                  },
                  rowSpan: 1,
                  columnSpan: 1,
                },
                tableCellStyle: {
                  contentAlignment: 'MIDDLE',
                },
                fields: 'contentAlignment',
              },
            });
          }
        }

        // Định dạng màu nền và viền cho bảng
        if (tableStartLocation) {
          // Màu nền cho hàng tiêu đề
          dataFillRequests.push({
            updateTableCellStyle: {
              tableRange: {
                tableCellLocation: {
                  tableStartLocation: { index: tableStartLocation },
                  rowIndex: 0,
                  columnIndex: 0,
                },
                rowSpan: 1,
                columnSpan: numColumns,
              },
              tableCellStyle: {
                backgroundColor: {
                  // Màu xanh nhạt giống trong template
                  color: {
                    rgbColor: { red: 0.737, green: 0.867, blue: 0.898 },
                  },
                },
              },
              fields: 'backgroundColor',
            },
          });

          // Viền cho toàn bộ bảng
          dataFillRequests.push({
            updateTableCellStyle: {
              tableRange: {
                tableCellLocation: {
                  tableStartLocation: { index: tableStartLocation },
                  rowIndex: 0,
                  columnIndex: 0,
                },
                rowSpan: numRows,
                columnSpan: numColumns,
              },
              tableCellStyle: {
                borderBottom: {
                  color: { color: { rgbColor: { red: 0, green: 0, blue: 0 } } },
                  width: { magnitude: 1, unit: 'PT' },
                  dashStyle: 'SOLID',
                },
                borderTop: {
                  color: { color: { rgbColor: { red: 0, green: 0, blue: 0 } } },
                  width: { magnitude: 1, unit: 'PT' },
                  dashStyle: 'SOLID',
                },
                borderLeft: {
                  color: { color: { rgbColor: { red: 0, green: 0, blue: 0 } } },
                  width: { magnitude: 1, unit: 'PT' },
                  dashStyle: 'SOLID',
                },
                borderRight: {
                  color: { color: { rgbColor: { red: 0, green: 0, blue: 0 } } },
                  width: { magnitude: 1, unit: 'PT' },
                  dashStyle: 'SOLID',
                },
              },
              fields: 'borderBottom,borderTop,borderLeft,borderRight',
            },
          });
        }

        // Thực thi tất cả các yêu cầu điền và định dạng dữ liệu
        if (dataFillRequests.length > 0) {
          await docs.documents.batchUpdate({
            documentId: newDocId,
            requestBody: { requests: dataFillRequests },
          });
          functions.logger.info(
            `Đã điền và định dạng dữ liệu cho ${tableData.length} hàng.`
          );
        }

        // 7. ========= INSERT SUMMARY SECTION (BẢNG TỔNG KẾT) =========
        // Lấy lại tài liệu để xác định vị trí cuối của bảng vật tư
        const docWithTableFilled = await docs.documents.get({
          documentId: newDocId,
        });

        let tableEndIndex: number | undefined;
        if (docWithTableFilled.data.body?.content) {
          for (const element of docWithTableFilled.data.body.content) {
            if (
              element.table &&
              element.startIndex &&
              element.endIndex &&
              Math.abs(element.startIndex - (tableStartLocation || 0)) < 10
            ) {
              tableEndIndex = element.endIndex;
              functions.logger.info(
                `Tìm thấy vị trí kết thúc của bảng vật tư: ${tableEndIndex}`
              );
              break;
            }
          }
        }

        if (!tableEndIndex) {
          throw new Error('Không tìm thấy vị trí kết thúc bảng vật tư');
        }

        // Tính toán giá trị tổng kết - tự tính toán mọi giá trị, không dùng giá trị từ input
        // Hardcode VAT rate là 10%
        const vatPercentage = 10;

        // Tính tổng tiền hàng từ danh sách vật tư
        let subTotal = 0;
        materialsArray.forEach((material) => {
          // Tính lại đơn giá và thành tiền để đảm bảo tính đúng
          const weight = Number(material.weight || 0);
          const unitPricePerKg = Number(material.unitPrice || 0);
          const calculatedUnitPrice = weight * unitPricePerKg;
          const quantity = Number(material.quantity || 0);
          const totalPrice = quantity * calculatedUnitPrice;
          subTotal += totalPrice;
        });

        // Tính thuế VAT và tổng tiền thanh toán
        const vatAmount = (subTotal * vatPercentage) / 100;
        const grandTotal = subTotal + vatAmount;

        // Tính half_total SAU KHI đã tính toán xong grandTotal
        const halfTotal = Math.floor(grandTotal * 0.5);
        // Tạo chuỗi half_total chỉ sau khi biết chắc chắn halfTotal là số hợp lệ
        const halfTotalFormatted = halfTotal.toLocaleString('vi-VN');
        const halfTotalText = `${halfTotalFormatted} đ (${convertNumberToVnWords(
          halfTotal
        )})`;

        // Thực hiện thay thế half_total trong văn bản
        const halfTotalRequests: docs_v1.Schema$Request[] = [
          {
            replaceAllText: {
              containsText: { text: '{half_total}', matchCase: false },
              replaceText: halfTotalText,
            },
          },
        ];

        // Áp dụng thay thế half_total
        if (halfTotalRequests.length > 0) {
          await docs.documents.batchUpdate({
            documentId: newDocId,
            requestBody: { requests: halfTotalRequests },
          });
          functions.logger.info('Đã thay thế half_total thành công.');
        }

        // Tự tạo chuỗi "bằng chữ" từ tổng tiền đã tính (bỏ phần thập phân)
        const amountInWords = convertNumberToVnWords(Math.floor(grandTotal));

        // Tạo bảng tổng kết (2 cột, 4 hàng)
        const summaryTableRequests: docs_v1.Schema$Request[] = [
          {
            insertTable: {
              location: { index: tableEndIndex },
              rows: 4,
              columns: 2,
            },
          },
        ];

        await docs.documents.batchUpdate({
          documentId: newDocId,
          requestBody: { requests: summaryTableRequests },
        });
        functions.logger.info('Đã tạo bảng tổng kết sau bảng vật tư');

        // Lấy lại tài liệu để định vị bảng tổng kết vừa tạo
        const docWithSummaryTable = await docs.documents.get({
          documentId: newDocId,
        });

        let summaryTable: docs_v1.Schema$Table | undefined;
        let summaryTableStartIndex: number | undefined;

        if (docWithSummaryTable.data.body?.content) {
          for (const element of docWithSummaryTable.data.body.content) {
            if (
              element.table &&
              element.startIndex &&
              element.startIndex > (tableEndIndex || 0) - 5
            ) {
              // Lấy bảng đầu tiên sau bảng vật tư
              summaryTable = element.table;
              summaryTableStartIndex = element.startIndex;
              functions.logger.info(
                `Tìm thấy bảng tổng kết tại vị trí: ${element.startIndex}`
              );
              break;
            }
          }
        }

        if (!summaryTable || !summaryTableStartIndex) {
          throw new Error('Không tìm thấy bảng tổng kết sau khi tạo');
        }

        // Chuẩn bị dữ liệu cho bảng tổng kết
        const summaryData = [
          [
            'CỘNG TIỀN HÀNG:',
            Math.floor(subTotal).toLocaleString('vi-VN') + ' đ',
          ],
          [
            `THUẾ GTGT ${vatPercentage}%:`,
            Math.floor(vatAmount).toLocaleString('vi-VN') + ' đ',
          ],
          [
            'TỔNG TIỀN THANH TOÁN:',
            Math.floor(grandTotal).toLocaleString('vi-VN') + ' đ',
          ],
          [amountInWords], // Chỉ chứa một phần tử để gộp ô
        ];

        // Tạo các yêu cầu để điền dữ liệu và định dạng bảng tổng kết
        const summaryFillRequests: docs_v1.Schema$Request[] = [];

        // Lặp ngược để điền dữ liệu từ cuối lên đầu (tránh lỗi vị trí)
        for (let r = summaryData.length - 1; r >= 0; r--) {
          for (let c = summaryData[r].length - 1; c >= 0; c--) {
            const cellData = summaryData[r][c];
            if (!cellData) continue;

            const cell = summaryTable.tableRows?.[r]?.tableCells?.[c];
            if (!cell?.content?.[0]?.paragraph?.elements?.[0]?.startIndex) {
              functions.logger.warn(
                `Không tìm thấy vị trí cho ô tổng kết [${r}, ${c}]`
              );
              continue;
            }

            const cellStartIndex =
              cell.content[0].paragraph.elements[0].startIndex;
            functions.logger.info(
              `Điền dữ liệu "${cellData}" vào ô tổng kết [${r}, ${c}] tại vị trí ${cellStartIndex}`
            );

            // Chèn văn bản
            summaryFillRequests.push({
              insertText: {
                location: { index: cellStartIndex },
                text: cellData,
              },
            });

            const textRange = {
              startIndex: cellStartIndex,
              endIndex: cellStartIndex + cellData.length,
            };

            // Định dạng font, màu sắc và in đậm
            summaryFillRequests.push({
              updateTextStyle: {
                range: textRange,
                textStyle: {
                  weightedFontFamily: { fontFamily: 'Times New Roman' },
                  fontSize: { magnitude: 12, unit: 'PT' },
                  bold: r < 3, // Chỉ in đậm 3 dòng đầu tiên (0, 1, 2), không in đậm dòng "Bằng chữ:" (3)
                  foregroundColor: {
                    color: {
                      rgbColor: { red: 0, green: 0, blue: 0 },
                    },
                  },
                },
                fields: 'weightedFontFamily,fontSize,bold,foregroundColor',
              },
            });

            // Căn lề
            let alignment: 'END' | 'START' = 'START';
            if (c === 1) {
              // Cột giá trị căn phải
              alignment = 'END';
            }
            // Dòng "Bằng chữ" căn trái
            if (r === 3) {
              alignment = 'START';
            }

            summaryFillRequests.push({
              updateParagraphStyle: {
                range: textRange,
                paragraphStyle: { alignment: alignment },
                fields: 'alignment',
              },
            });
          }
        }

        // Gộp ô cho dòng "Bằng chữ"
        summaryFillRequests.push({
          mergeTableCells: {
            tableRange: {
              tableCellLocation: {
                tableStartLocation: { index: summaryTableStartIndex },
                rowIndex: 3, // Hàng cuối cùng (bằng chữ)
                columnIndex: 0,
              },
              rowSpan: 1,
              columnSpan: 2,
            },
          },
        });

        // Xóa viền của bảng tổng kết để nó hòa vào văn bản
        summaryFillRequests.push({
          updateTableCellStyle: {
            tableRange: {
              tableCellLocation: {
                tableStartLocation: { index: summaryTableStartIndex },
                rowIndex: 0,
                columnIndex: 0,
              },
              rowSpan: 4,
              columnSpan: 2,
            },
            tableCellStyle: {
              borderBottom: {
                width: { magnitude: 0, unit: 'PT' },
                dashStyle: 'SOLID',
                color: { color: { rgbColor: {} } },
              },
              borderTop: {
                width: { magnitude: 0, unit: 'PT' },
                dashStyle: 'SOLID',
                color: { color: { rgbColor: {} } },
              },
              borderLeft: {
                width: { magnitude: 0, unit: 'PT' },
                dashStyle: 'SOLID',
                color: { color: { rgbColor: {} } },
              },
              borderRight: {
                width: { magnitude: 0, unit: 'PT' },
                dashStyle: 'SOLID',
                color: { color: { rgbColor: {} } },
              },
            },
            fields: 'borderBottom,borderTop,borderLeft,borderRight',
          },
        });

        // Thực thi các yêu cầu điền và định dạng cho bảng tổng kết
        if (summaryFillRequests.length > 0) {
          await docs.documents.batchUpdate({
            documentId: newDocId,
            requestBody: { requests: summaryFillRequests },
          });
          functions.logger.info(
            'Đã điền và định dạng bảng tổng kết thành công'
          );
        }
      }

      // 8. ========= RETURN DOCX INFO =========
      // Cấp quyền xem cho Google Doc để người dùng có link có thể xem
      await drive.permissions.create({
        fileId: newDocId,
        requestBody: { role: 'reader', type: 'anyone' },
      });

      const docUrl = `https://docs.google.com/document/d/${newDocId}/edit`;
      functions.logger.info(`Tạo hợp đồng thành công. Doc URL: ${docUrl}`);

      // Trả về URL của Google Doc và ID
      return {
        docUrl,
        docId: newDocId,
      };
    } catch (error) {
      functions.logger.error('Lỗi nghiêm trọng khi tạo hợp đồng:', error);
      if (error instanceof Error) {
        throw new functions.https.HttpsError(
          'internal',
          `Không thể tạo hợp đồng: ${error.message}`
        );
      }
      throw new functions.https.HttpsError(
        'internal',
        'Đã xảy ra lỗi không xác định khi tạo hợp đồng.'
      );
    }
  });

import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';
import { getDriveClient } from './utils/driveClient';
import { APP_DRIVE_ROOT_FOLDER_ID } from './config';

const db = admin.firestore();

/**
 * Callable: createProjectFolders
 * - Input: { projectId: string }
 * - Creates a Drive folder for the project inside the app root and
 *   sub-folders [baogia, hopdong, PO, QC_Reports].
 * - Saves driveFolderId, driveFolderUrl back to Firestore.
 */
export const createProjectFolders = functions
  .region('asia-southeast1')
  .runWith({ timeoutSeconds: 300, memory: '1GB' })
  .https.onCall(async (data, context) => {
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Bạn cần đăng nhập.'
      );
    }

    const { projectId } = data as { projectId?: string };
    if (!projectId) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thiếu projectId'
      );
    }

    const projectRef = db.collection('projects').doc(projectId);
    const projectSnap = await projectRef.get();
    if (!projectSnap.exists) {
      throw new functions.https.HttpsError('not-found', 'Không tìm thấy dự án');
    }

    const projectData = projectSnap.data()!;
    if (projectData.driveFolderId) {
      // Folder đã tồn tại, trả về ngay
      return {
        success: true,
        driveFolderId: projectData.driveFolderId,
        driveFolderUrl: projectData.driveFolderUrl,
        skipped: true,
      };
    }

    try {
      const drive = await getDriveClient();

      // Sanitize name (không ký tự đặc biệt mà Drive cấm)
      const cleanName = (projectData.name || projectId).replace(
        /[\\/:*?"<>|]/g,
        '_'
      );

      // 1. Tạo thư mục dự án bên trong ROOT
      const projectFolderRes = await drive.files.create({
        requestBody: {
          name: cleanName,
          mimeType: 'application/vnd.google-apps.folder',
          parents: [APP_DRIVE_ROOT_FOLDER_ID],
        },
        fields: 'id, webViewLink',
      });

      const projectFolderId = projectFolderRes.data.id!;

      // 2. Tạo sub-folders
      const subNames = ['baogia', 'hopdong', 'PO', 'QC_Reports'];
      await Promise.all(
        subNames.map((sub) =>
          drive.files.create({
            requestBody: {
              name: sub,
              mimeType: 'application/vnd.google-apps.folder',
              parents: [projectFolderId],
            },
          })
        )
      );

      // 3. Ghi Firestore
      await projectRef.update({
        driveFolderId: projectFolderId,
        driveFolderUrl: projectFolderRes.data.webViewLink,
        driveCreatedAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      return {
        success: true,
        driveFolderId: projectFolderId,
        driveFolderUrl: projectFolderRes.data.webViewLink,
        skipped: false,
      };
    } catch (err: any) {
      console.error('createProjectFolders error:', err);
      throw new functions.https.HttpsError(
        'internal',
        err.message || 'Lỗi tạo thư mục dự án'
      );
    }
  });

import * as functions from 'firebase-functions/v2';
import * as admin from 'firebase-admin';
import { google } from 'googleapis';
import * as path from 'path';
import * as XLSX from 'xlsx';
import { Timestamp } from 'firebase-admin/firestore';

const db = admin.firestore();
const SECRET_TOKEN = 'THP_FINANCE_SECRET_TOKEN'; // Should match Apps Script token

// Function to format currency for display
function formatCurrency(amount: number): string {
  return new Intl.NumberFormat('vi-VN', {
    style: 'currency',
    currency: 'VND',
  }).format(amount);
}

// Column mapping for Excel file
const colMap = {
  date: 0, // A - Ngày CT
  docNumber: 1, // B - BB SỐ
  invoiceNumber: 2, // C - Hóa đơn
  supplier: 3, // D - TÊN ĐƠN VỊ
  description: 4, // E - DIỄN GIẢI
  unit: 5, // F - ĐVT
  quantity: 6, // G - SỐ LƯỢNG
  price: 7, // H - ĐƠN GIÁ
  vat: 8, // I - VAT
  totalAmount: 9, // J - THÀNH TIỀN
  paidAmount: 10, // K - ĐÃ THANH TOÁN
  remainingAmount: 11, // L - CÒN LẠI
};

// Function to convert Excel date serial number to JS Date
function excelDateToJSDate(excelDate: number): Date {
  // Excel's epoch starts on 1/1/1900
  const millisecondsPerDay = 24 * 60 * 60 * 1000;
  // Excel incorrectly assumes 1900 is a leap year, so we adjust by 1 day for dates after 2/28/1900
  const dayAdjust = excelDate > 59 ? 1 : 0;
  const jsDate = new Date(
    Math.round((excelDate - dayAdjust - 25569) * millisecondsPerDay)
  );
  return jsDate;
}

// Function to clean text values
function cleanText(text: any): string {
  if (!text) return '';
  return String(text).trim().replace(/\s+/g, ' ');
}

// Function to extract numeric value from cell
function extractNumber(value: any): number {
  if (typeof value === 'number') return value;
  if (!value) return 0;

  const numStr = String(value).replace(/[^\d.-]/g, '');
  return numStr ? parseFloat(numStr) : 0;
}

// Function to check if a row is a transaction row
function isTransactionRow(row: any[], currentSupplier: string | null): boolean {
  // Check if date column has a value and we have a current supplier
  return row[colMap.date] && currentSupplier !== null;
}

// Function to check if a row is a supplier header row
function isSupplierRow(row: any[]): boolean {
  const supplierValue = row[colMap.supplier];
  return (
    supplierValue &&
    (String(supplierValue).startsWith('NCC - ') ||
      String(supplierValue).startsWith('KH - '))
  );
}

// Function to check if a row is a total row
function isTotalRow(row: any[]): boolean {
  return row[0] === 'CỘNG';
}

// Function to extract supplier name from cell
function extractSupplierName(cell: any): string {
  if (!cell) return '';
  const text = String(cell);
  if (text.startsWith('NCC - ')) {
    return text.substring(6).trim();
  } else if (text.startsWith('KH - ')) {
    return text.substring(5).trim();
  }
  return text.trim();
}

/**
 * Cloud Function to process payable ledger Excel file from Google Drive
 */
export const processPayableLedgerFromDrive = functions.https.onRequest(
  {
    region: 'asia-southeast1',
    timeoutSeconds: 300, // 5 minutes timeout for large files
  },
  async (req, res) => {
    try {
      // Verify authorization token
      const authHeader = req.headers.authorization;
      if (!authHeader || authHeader !== `Bearer ${SECRET_TOKEN}`) {
        console.error('Invalid or missing authorization token');
        res.status(401).send({ error: 'Unauthorized' });
        return;
      }

      // Get fileId from request body
      const { fileId } = req.body;
      if (!fileId) {
        console.error('No fileId provided in request body');
        res.status(400).send({ error: 'Missing fileId parameter' });
        return;
      }

      console.log(`Processing file with ID: ${fileId}`);

      // Initialize Google Drive API
      const auth = new google.auth.GoogleAuth({
        keyFile: path.join(__dirname, '../tanyb-fe4bf-4fbd5c01b6c7.json'),
        scopes: ['https://www.googleapis.com/auth/drive'],
      });
      const drive = google.drive({ version: 'v3', auth });

      // Download file from Google Drive
      const response = await drive.files.get(
        {
          fileId: fileId,
          alt: 'media',
        },
        { responseType: 'arraybuffer' }
      );

      // Get file metadata to extract filename
      const fileMetadata = await drive.files.get({
        fileId: fileId,
        fields: 'name,createdTime,modifiedTime',
      });

      const fileName = fileMetadata.data.name || 'Unknown File';
      console.log(`Downloaded file: ${fileName}`);

      // Parse Excel file
      const workbook = XLSX.read(response.data, { type: 'array' });
      const firstSheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[firstSheetName];

      // Convert to array of arrays
      const rows = XLSX.utils.sheet_to_json(worksheet, {
        header: 1,
      }) as any[][];

      console.log(`Total rows in Excel file: ${rows.length}`);

      // Process rows
      const transactions = [];
      let currentSupplier: string | null = null;
      let isPayable = true; // Default to payable (phải trả)

      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        if (!row || row.length === 0) continue;

        // Check if this is a header row that indicates the type of ledger
        if (
          row.some(
            (cell) =>
              cell && String(cell).includes('SỔ CHI TIẾT CÔNG NỢ PHẢI THU')
          )
        ) {
          isPayable = false;
          currentSupplier = null;
          continue;
        } else if (
          row.some(
            (cell) =>
              cell && String(cell).includes('SỔ CHI TIẾT CÔNG NỢ PHẢI TRẢ')
          )
        ) {
          isPayable = true;
          currentSupplier = null;
          continue;
        }

        // Check if this is a supplier row
        if (isSupplierRow(row)) {
          currentSupplier = extractSupplierName(row[colMap.supplier]);
          continue;
        }

        // Check if this is a total row
        if (isTotalRow(row)) {
          currentSupplier = null;
          continue;
        }

        // Skip header rows
        if (row[0] === 'Ngày CT' || row[0] === 'Ngày') continue;

        // Process transaction row
        if (isTransactionRow(row, currentSupplier)) {
          let transactionDate: Date;

          // Handle date format (could be Excel serial date or string)
          if (typeof row[colMap.date] === 'number') {
            transactionDate = excelDateToJSDate(row[colMap.date]);
          } else if (typeof row[colMap.date] === 'string') {
            // Try to parse date string (DD/MM/YYYY format)
            const dateParts = String(row[colMap.date]).split('/');
            if (dateParts.length === 3) {
              transactionDate = new Date(
                parseInt(dateParts[2]),
                parseInt(dateParts[1]) - 1,
                parseInt(dateParts[0])
              );
            } else {
              // Default to current date if parsing fails
              transactionDate = new Date();
            }
          } else {
            // Default to current date if no valid date
            transactionDate = new Date();
          }

          const transaction = {
            type: isPayable ? 'payable' : 'receivable',
            supplier: currentSupplier || '',
            transactionDate: Timestamp.fromDate(transactionDate),
            docNumber: cleanText(row[colMap.docNumber]),
            invoiceNumber: cleanText(row[colMap.invoiceNumber]),
            description: cleanText(row[colMap.description]),
            amount: extractNumber(row[colMap.totalAmount]),
            paidAmount: extractNumber(row[colMap.paidAmount]),
            remainingAmount: extractNumber(row[colMap.remainingAmount]),
            unit: cleanText(row[colMap.unit]),
            quantity: extractNumber(row[colMap.quantity]),
            price: extractNumber(row[colMap.price]),
            vat: extractNumber(row[colMap.vat]),
            fileId: fileId,
            fileName: fileName,
            processedAt: Timestamp.now(),
          };

          transactions.push(transaction);
        }
      }

      console.log(`Extracted ${transactions.length} transactions`);

      // Save transactions to Firestore using batch write
      const batch = db.batch();

      for (const transaction of transactions) {
        // Generate a unique ID based on supplier, date, and document number
        const idComponents = [
          transaction.supplier,
          transaction.transactionDate.toDate().toISOString().split('T')[0],
          transaction.docNumber || 'nodoc',
          transaction.description
            ? transaction.description.substring(0, 20)
            : 'nodesc',
        ];
        const uniqueId = idComponents.join('_').replace(/[^a-zA-Z0-9_]/g, '');

        const docRef = db.collection('payable_transactions').doc(uniqueId);
        batch.set(docRef, transaction, { merge: true });
      }

      await batch.commit();
      console.log(
        `Successfully saved ${transactions.length} transactions to Firestore`
      );

      // Update the last processed timestamp in a metadata document
      await db.collection('system').doc('financialProcessorMetadata').set(
        {
          lastProcessedAt: Timestamp.now(),
          lastProcessedFile: fileName,
          lastProcessedFileId: fileId,
          transactionsProcessed: transactions.length,
        },
        { merge: true }
      );

      res.status(200).send({
        success: true,
        message: `Successfully processed ${transactions.length} transactions from ${fileName}`,
      });
    } catch (error: any) {
      console.error('Error processing payable ledger:', error);
      res.status(500).send({
        error: 'Failed to process payable ledger',
        details: error.message,
      });
    }
  }
);

/**
 * Orchestrator function to trigger Excel processing from a folder
 * This is a callable function that can be invoked from the client
 */
export const triggerExcelProcessing = functions.https.onCall(
  {
    region: 'asia-southeast1',
    timeoutSeconds: 300, // 5 phút timeout cho file lớn
  },
  async () => {
    try {
      console.log('triggerExcelProcessing called');

      // Initialize Google Drive API
      const auth = new google.auth.GoogleAuth({
        keyFile: path.join(__dirname, '../tanyb-fe4bf-4fbd5c01b6c7.json'),
        scopes: ['https://www.googleapis.com/auth/drive'],
      });
      const drive = google.drive({ version: 'v3', auth });

      // Define the folder ID where Excel files are stored
      const FOLDER_ID = '1Ci_BHZx0-Uhv2xg5IzwLPn05yPAUXOOU';

      // Search for Excel files in the specified folder
      const response = await drive.files.list({
        q: `'${FOLDER_ID}' in parents and (mimeType='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' or mimeType='application/vnd.ms-excel') and trashed=false`,
        orderBy: 'modifiedTime desc',
        pageSize: 1, // Get only the latest file
        fields: 'files(id,name,modifiedTime)',
      });

      const files = response.data.files;
      if (!files || files.length === 0) {
        throw new functions.https.HttpsError(
          'not-found',
          'No Excel files found in the specified folder'
        );
      }

      const latestFile = files[0];
      console.log(
        `Found latest file: ${latestFile.name} (ID: ${latestFile.id})`
      );

      // Download file from Google Drive
      const fileResponse = await drive.files.get(
        {
          fileId: latestFile.id!,
          alt: 'media',
        },
        { responseType: 'arraybuffer' }
      );

      console.log(`Downloaded file Excel: ${latestFile.name}`);

      // Parse Excel file
      const workbook = XLSX.read(fileResponse.data, { type: 'buffer' });

      let totalReceivable = 0; // Tổng phải thu
      let totalPayable = 0; // Tổng phải trả

      // Process "PHẢI TRẢ" sheet
      const payableSheetName = findSheetByPattern(workbook, [
        'PHẢI TRẢ',
        'PHAI TRA',
        'PAYABLE',
      ]);
      if (payableSheetName) {
        console.log(`Processing PHẢI TRẢ sheet: ${payableSheetName}`);
        totalPayable = processSheetForTotal(workbook, payableSheetName);
        console.log(`Total PAYABLE: ${totalPayable}`);
      } else {
        console.log('No PHẢI TRẢ sheet found');
      }

      // Process "PHẢI THU" sheet
      const receivableSheetName = findSheetByPattern(workbook, [
        'PHẢI THU',
        'PHAI THU',
        'RECEIVABLE',
      ]);
      if (receivableSheetName) {
        console.log(`Processing PHẢI THU sheet: ${receivableSheetName}`);
        totalReceivable = processSheetForTotal(workbook, receivableSheetName);
        console.log(`Total RECEIVABLE: ${totalReceivable}`);
      } else {
        console.log('No PHẢI THU sheet found');
      }

      // Calculate net position
      const netPosition = totalReceivable - totalPayable;

      // Create summary object
      const summary = {
        totalReceivable,
        totalPayable,
        netPosition,
        lastUpdated: Timestamp.now(),
        fileName: latestFile.name!,
        fileId: latestFile.id!,
        formattedTotals: {
          totalReceivable: formatCurrency(totalReceivable),
          totalPayable: formatCurrency(totalPayable),
          netPosition: formatCurrency(netPosition),
        },
      };

      // Save summary to Firestore
      console.log('Saving data to Firestore...');
      await db
        .collection('summaries')
        .doc('directorDashboard')
        .set(summary, { merge: true });

      // Update metadata
      await db.collection('system').doc('financialProcessorMetadata').set(
        {
          lastProcessedAt: Timestamp.now(),
          lastProcessedFile: latestFile.name,
          lastProcessedFileId: latestFile.id,
          summaryDataProcessed: true,
          totalReceivable,
          totalPayable,
        },
        { merge: true }
      );

      console.log('Excel processing completed successfully!');

      // Return success result
      return {
        success: true,
        message: `Successfully processed data from file ${latestFile.name}`,
        fileName: latestFile.name,
        fileId: latestFile.id,
        summary,
      };
    } catch (error: any) {
      console.error('Error in triggerExcelProcessing:', error);

      // Re-throw HttpsError as-is, convert others to internal error
      if (error instanceof functions.https.HttpsError) {
        throw error;
      }

      throw new functions.https.HttpsError(
        'internal',
        `Failed to process Excel file: ${error.message}`
      );
    }
  }
);

/**
 * Find sheet name based on pattern
 * @param workbook - XLSX workbook
 * @param patterns - Array of patterns to look for
 * @returns Sheet name if found, undefined otherwise
 */
function findSheetByPattern(
  workbook: XLSX.WorkBook,
  patterns: string[]
): string | undefined {
  for (const sheetName of workbook.SheetNames) {
    const normalizedName = sheetName.normalize('NFC').toUpperCase();
    for (const pattern of patterns) {
      if (normalizedName.includes(pattern)) {
        return sheetName;
      }
    }
  }
  return undefined;
}

/**
 * Process a sheet to get total value based on column B = "CỘNG" and get value from column L
 * @param workbook - XLSX workbook
 * @param sheetName - Sheet name to process
 * @returns Total value
 */
function processSheetForTotal(
  workbook: XLSX.WorkBook,
  sheetName: string
): number {
  const sheet = workbook.Sheets[sheetName];
  const data = XLSX.utils.sheet_to_json<any>(sheet, { header: 'A' });

  let total = 0;
  let sums: number[] = [];

  console.log(`Total rows in sheet ${sheetName}: ${data.length}`);

  // Loop through each row to find rows with column B as "CỘNG"
  for (const row of data) {
    // Check if column B (mapped to key 'B') is "CỘNG"
    if (row['B'] === 'CỘNG') {
      // Get value from column L
      const value = parseFloat(row['L'] || 0);
      if (!isNaN(value)) {
        sums.push(value);
        console.log(`Found CỘNG value: ${value}`);
      }
    }
  }

  // Calculate total from all found values
  total = sums.reduce((acc, curr) => acc + curr, 0);
  console.log(`Values found: ${sums.join(', ')}`);
  console.log(`Total: ${total}`);

  return total;
}

//functions/src/index.ts
/* eslint-disable max-len */
/**
 * Import function triggers from their respective submodules:
 *
 * import {onCall} from "firebase-functions/v2/https";
 * import {onDocumentWritten} from "firebase-functions/v2/firestore";
 *
 * See a full list of supported triggers at https://firebase.google.com/docs/functions
 */

import * as admin from 'firebase-admin';
import * as functions from 'firebase-functions/v1';

// Initialize Firebase Admin FIRST
admin.initializeApp();

// Export functions from other files
export * from './materialImporter';
export * from './projectTriggers';
export * from './taskTriggers';
export * from './excelGenerator';
export * from './pdfGenerator';
export * from './contractGenerator';
export * from './financialProcessor';
export * from './scheduledFunctions';
export * from './uploadFileToDrive';
export * from './poExcelGenerator';
export * from './poReceiptConfirmation';
export * from './savePOReceiptConfirmation';
export * from './createProjectFolders';
// Do not export from quotationExcelGenerator.ts since it's already exported from excelGenerator

// Import và export các hàm quản lý kho
export * from './inventoryManager';

// Thêm importInventoryFromExcel
export const importInventoryFromExcel = functions
  .region('asia-southeast1')
  .https.onCall(async (data: any, context: functions.https.CallableContext) => {
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Người dùng cần đăng nhập để sử dụng chức năng này.'
      );
    }

    const { driveFileId, accessToken } = data;
    if (!driveFileId || !accessToken) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thiếu file ID hoặc access token.'
      );
    }

    try {
      // 1. Khởi tạo Google API client
      const { google } = require('googleapis');
      const auth = new google.auth.OAuth2();
      auth.setCredentials({ access_token: accessToken });
      const drive = google.drive({ version: 'v3', auth });

      // 2. Tải file từ Google Drive
      const response = await drive.files.get(
        { fileId: driveFileId, alt: 'media' },
        { responseType: 'arraybuffer' }
      );

      // 3. Parse file Excel với XLSX
      const XLSX = require('xlsx');
      const workbook = XLSX.read(Buffer.from(response.data), {
        type: 'buffer',
      });

      // Lấy sheet đầu tiên
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      const rawData = XLSX.utils.sheet_to_json(worksheet, {
        header: 1,
        defval: null,
      });

      // 4. Tìm hàng tiêu đề (thường là hàng đầu tiên)
      let headerRow = rawData[0];
      let startRow = 1;

      // Nếu hàng đầu không có dữ liệu đúng, thử tìm hàng tiêu đề hợp lệ
      if (!headerRow || headerRow.length < 2) {
        for (let i = 0; i < 5; i++) {
          if (rawData[i] && rawData[i].length >= 2) {
            headerRow = rawData[i];
            startRow = i + 1;
            break;
          }
        }
      }

      if (!headerRow) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Không tìm thấy hàng tiêu đề trong file Excel.'
        );
      }

      // 5. Ánh xạ các cột dựa trên tiêu đề
      const findColumnIndex = (names: string[]) => {
        for (let i = 0; i < headerRow.length; i++) {
          const cell = headerRow[i];
          if (cell && typeof cell === 'string') {
            const cellValue = cell.toLowerCase();
            if (names.some((name) => cellValue.includes(name.toLowerCase()))) {
              return i;
            }
          }
        }
        return -1;
      };

      const columnMap = {
        code: findColumnIndex(['Mã vật tư', 'Mã', 'Code']),
        name: findColumnIndex(['Tên vật tư', 'Tên', 'Name']),
        description: findColumnIndex(['Mô tả', 'Description']),
        category: findColumnIndex(['Danh mục', 'Category']),
        unit: findColumnIndex(['Đơn vị tính', 'Unit']),
        stockQuantity: findColumnIndex(['Số lượng', 'Quantity']),
        minQuantity: findColumnIndex(['Số lượng tối thiểu', 'Min Quantity']),
        price: findColumnIndex(['Đơn giá', 'Price']),
        material: findColumnIndex(['Vật liệu', 'Material']),
        weight: findColumnIndex(['Khối lượng', 'Weight']),
      };

      // 6. Chuẩn bị kết quả
      const result = {
        total: 0,
        added: 0,
        updated: 0,
        skipped: 0,
        errors: [] as Array<{ row: number; message: string }>,
      };

      // 7. Lấy danh sách danh mục để ánh xạ
      const categoriesSnapshot = await admin
        .firestore()
        .collection('inventory_categories')
        .get();

      const categoriesMap: Record<string, string> = {};
      categoriesSnapshot.docs.forEach((doc) => {
        const category = doc.data();
        if (category.name) {
          categoriesMap[category.name.toLowerCase()] = doc.id;
        }
      });

      // 8. Xử lý từng hàng dữ liệu
      for (let i = startRow; i < rawData.length; i++) {
        const row = rawData[i];

        // Bỏ qua hàng trống
        if (!row || row.length === 0) continue;

        // Kiểm tra code và name
        const code = row[columnMap.code];
        const name = row[columnMap.name];

        if (!code || !name) {
          result.skipped++;
          continue;
        }

        try {
          // Chuẩn bị dữ liệu vật tư
          const itemData: any = {
            code: String(code),
            name: String(name),
          };

          // Thêm các trường tùy chọn nếu có
          if (columnMap.description !== -1 && row[columnMap.description]) {
            itemData.description = String(row[columnMap.description]);
          }

          // Xử lý danh mục
          if (columnMap.category !== -1 && row[columnMap.category]) {
            const categoryName = String(row[columnMap.category]).toLowerCase();
            if (categoriesMap[categoryName]) {
              itemData.categoryId = categoriesMap[categoryName];
            }
          }

          if (columnMap.unit !== -1 && row[columnMap.unit]) {
            itemData.unit = String(row[columnMap.unit]);
          }

          if (
            columnMap.stockQuantity !== -1 &&
            row[columnMap.stockQuantity] !== null
          ) {
            const quantity = parseFloat(String(row[columnMap.stockQuantity]));
            if (!isNaN(quantity)) {
              itemData.stockQuantity = quantity;
            }
          }

          if (
            columnMap.minQuantity !== -1 &&
            row[columnMap.minQuantity] !== null
          ) {
            const minQty = parseFloat(String(row[columnMap.minQuantity]));
            if (!isNaN(minQty)) {
              itemData.minQuantity = minQty;
            }
          }

          if (columnMap.price !== -1 && row[columnMap.price] !== null) {
            const price = parseFloat(String(row[columnMap.price]));
            if (!isNaN(price)) {
              itemData.price = price;
            }
          }

          if (columnMap.material !== -1 && row[columnMap.material]) {
            itemData.material = String(row[columnMap.material]);
          }

          if (columnMap.weight !== -1 && row[columnMap.weight] !== null) {
            const weight = parseFloat(String(row[columnMap.weight]));
            if (!isNaN(weight)) {
              itemData.weight = weight;
            }
          }

          // Tính tổng giá trị nếu có số lượng và đơn giá
          if (itemData.stockQuantity && itemData.price) {
            itemData.totalPrice = itemData.stockQuantity * itemData.price;
          }

          // 9. Kiểm tra vật tư đã tồn tại chưa
          const db = admin.firestore();
          const querySnapshot = await db
            .collection('inventory')
            .where('code', '==', itemData.code)
            .get();

          if (!querySnapshot.empty) {
            // Cập nhật vật tư đã tồn tại
            const docId = querySnapshot.docs[0].id;
            await db
              .collection('inventory')
              .doc(docId)
              .update({
                ...itemData,
                updatedAt: admin.firestore.FieldValue.serverTimestamp(),
              });
            result.updated++;
          } else {
            // Thêm vật tư mới
            await db.collection('inventory').add({
              ...itemData,
              createdAt: admin.firestore.FieldValue.serverTimestamp(),
              updatedAt: admin.firestore.FieldValue.serverTimestamp(),
            });
            result.added++;
          }

          result.total++;
        } catch (err: any) {
          console.error(`Lỗi khi xử lý hàng ${i}:`, err);
          result.errors.push({
            row: i + 1,
            message: err.message || 'Lỗi không xác định',
          });
          result.skipped++;
        }
      }

      return result;
    } catch (error: any) {
      console.error('Error importing inventory from Excel:', error);

      if (error.code === 401 || error.code === 403) {
        throw new functions.https.HttpsError(
          'permission-denied',
          'Token truy cập Google Drive không hợp lệ hoặc đã hết hạn.'
        );
      }

      throw new functions.https.HttpsError(
        'internal',
        'Lỗi khi xử lý file Excel.',
        error.message
      );
    }
  });

// The functions below are already exported by the '*' exports above.
// They are kept here for clarity but can be removed if they cause issues.
// export { projectWorkflowManager } from './taskTriggers';
// export { onProjectDeleted, onProjectCreate } from './projectTriggers';

import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';
import { CallableContext } from 'firebase-functions/v1/https';

// Interface định nghĩa cấu trúc vật tư trong kho
export interface InventoryItem {
  id?: string;
  name: string;
  code: string;
  description?: string;
  categoryId: string;
  unit: string;
  stockQuantity: number;
  minQuantity?: number;
  price?: number;
  lastUpdated: admin.firestore.Timestamp;
  locationId?: string;
  weight?: number; // Khối lượng (kg)
  material?: string; // Vật liệu
  imageUrl?: string; // URL hình ảnh
  supplier?: string; // Nhà cung cấp chính
  properties?: { [key: string]: any }; // Thuộc tính tuỳ chỉnh
}

// Interface định nghĩa giao dịch nhập/xuất kho
export interface InventoryTransaction {
  id?: string;
  type: 'IN' | 'OUT' | 'ADJUST' | 'TRANSFER'; // Loại giao dịch
  itemId: string;
  quantity: number;
  date: admin.firestore.Timestamp;
  note?: string;
  documentNumber?: string; // Số phiếu/chứng từ
  projectId?: string; // ID dự án (nếu xuất cho dự án)
  supplierId?: string; // ID nhà cung cấp (nếu nhập từ NCC)
  price?: number; // Giá tại thời điểm giao dịch
  userId: string; // Người tạo giao dịch
  locationId?: string; // Vị trí kho
  destinationLocationId?: string; // Vị trí đích (nếu chuyển kho)
  status: 'PENDING' | 'COMPLETED' | 'CANCELLED';
  approvedBy?: string; // Người phê duyệt
  attachmentUrls?: string[]; // Tài liệu đính kèm
}

// Interface định nghĩa danh mục vật tư
export interface InventoryCategory {
  id?: string;
  name: string;
  description?: string;
  parentId?: string; // Danh mục cha (nếu có)
}

// Interface định nghĩa vị trí kho
export interface InventoryLocation {
  id?: string;
  name: string;
  address?: string;
  description?: string;
  isActive: boolean;
}

/**
 * Thêm vật tư mới vào kho
 */
export const addInventoryItem = functions
  .region('asia-southeast1')
  .https.onCall(async (data: InventoryItem, context: CallableContext) => {
    // Kiểm tra xác thực
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Bạn cần đăng nhập để thực hiện chức năng này.'
      );
    }

    try {
      // Kiểm tra dữ liệu đầu vào
      if (!data.name || !data.code || !data.categoryId || !data.unit) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Thiếu thông tin vật tư bắt buộc.'
        );
      }

      // Kiểm tra mã vật tư đã tồn tại chưa
      const codeSnapshot = await admin
        .firestore()
        .collection('inventory')
        .where('code', '==', data.code)
        .get();

      if (!codeSnapshot.empty) {
        throw new functions.https.HttpsError(
          'already-exists',
          'Mã vật tư đã tồn tại trong hệ thống.'
        );
      }

      // Chuẩn bị dữ liệu để lưu
      const newItem: InventoryItem = {
        ...data,
        stockQuantity: data.stockQuantity || 0,
        lastUpdated: admin.firestore.Timestamp.now(),
      };

      // Lưu vào Firestore
      const docRef = await admin
        .firestore()
        .collection('inventory')
        .add(newItem);

      // Nếu có số lượng ban đầu > 0, tạo giao dịch nhập kho
      if (data.stockQuantity > 0) {
        await admin.firestore().collection('inventory_transactions').add({
          type: 'IN',
          itemId: docRef.id,
          quantity: data.stockQuantity,
          date: admin.firestore.Timestamp.now(),
          note: 'Nhập kho ban đầu',
          userId: context.auth.uid,
          status: 'COMPLETED',
        });
      }

      return {
        success: true,
        id: docRef.id,
        message: 'Thêm vật tư thành công',
      };
    } catch (error: any) {
      console.error('Lỗi thêm vật tư:', error);
      throw new functions.https.HttpsError(
        'internal',
        `Lỗi thêm vật tư: ${error.message}`
      );
    }
  });

/**
 * Cập nhật thông tin vật tư
 */
export const updateInventoryItem = functions
  .region('asia-southeast1')
  .https.onCall(
    async (
      data: { itemId: string; itemData: Partial<InventoryItem> },
      context: CallableContext
    ) => {
      // Kiểm tra xác thực
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'Bạn cần đăng nhập để thực hiện chức năng này.'
        );
      }

      try {
        const { itemId, itemData } = data;

        // Kiểm tra dữ liệu đầu vào
        if (!itemId) {
          throw new functions.https.HttpsError(
            'invalid-argument',
            'Thiếu ID vật tư cần cập nhật.'
          );
        }

        // Không cho phép cập nhật số lượng trực tiếp
        if ('stockQuantity' in itemData) {
          delete itemData.stockQuantity;
        }

        // Cập nhật thời gian
        const updateData = {
          ...itemData,
          lastUpdated: admin.firestore.Timestamp.now(),
        };

        // Cập nhật vào Firestore
        await admin
          .firestore()
          .collection('inventory')
          .doc(itemId)
          .update(updateData);

        return {
          success: true,
          message: 'Cập nhật vật tư thành công',
        };
      } catch (error: any) {
        console.error('Lỗi cập nhật vật tư:', error);
        throw new functions.https.HttpsError(
          'internal',
          `Lỗi cập nhật vật tư: ${error.message}`
        );
      }
    }
  );

/**
 * Tạo giao dịch nhập/xuất kho
 */
export const createInventoryTransaction = functions
  .region('asia-southeast1')
  .https.onCall(
    async (data: InventoryTransaction, context: CallableContext) => {
      // Kiểm tra xác thực
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'Bạn cần đăng nhập để thực hiện chức năng này.'
        );
      }

      // Bắt đầu transaction để đảm bảo tính nhất quán dữ liệu
      const db = admin.firestore();

      try {
        return await db.runTransaction(async (transaction) => {
          // Kiểm tra dữ liệu đầu vào
          if (
            !data.itemId ||
            !data.quantity ||
            !data.type ||
            data.quantity <= 0
          ) {
            throw new functions.https.HttpsError(
              'invalid-argument',
              'Dữ liệu giao dịch không hợp lệ.'
            );
          }

          // Lấy thông tin vật tư hiện tại
          const itemRef = db.collection('inventory').doc(data.itemId);
          const itemDoc = await transaction.get(itemRef);

          if (!itemDoc.exists) {
            throw new functions.https.HttpsError(
              'not-found',
              'Không tìm thấy vật tư trong kho.'
            );
          }

          const currentItem = itemDoc.data() as InventoryItem;
          let newQuantity = currentItem.stockQuantity;

          // Tính toán số lượng mới dựa trên loại giao dịch
          if (data.type === 'IN') {
            newQuantity += data.quantity;
          } else if (data.type === 'OUT') {
            if (currentItem.stockQuantity < data.quantity) {
              throw new functions.https.HttpsError(
                'failed-precondition',
                'Số lượng trong kho không đủ để xuất.'
              );
            }
            newQuantity -= data.quantity;
          } else if (data.type === 'ADJUST') {
            newQuantity = data.quantity; // Điều chỉnh trực tiếp
          } else if (data.type === 'TRANSFER') {
            // Đối với chuyển kho, số lượng không đổi tổng nhưng cần kiểm tra
            if (!data.destinationLocationId) {
              throw new functions.https.HttpsError(
                'invalid-argument',
                'Thiếu thông tin vị trí kho đích.'
              );
            }

            if (currentItem.stockQuantity < data.quantity) {
              throw new functions.https.HttpsError(
                'failed-precondition',
                'Số lượng trong kho không đủ để chuyển.'
              );
            }
            // Số lượng xử lý trong các bước tiếp theo
          }

          // Chuẩn bị dữ liệu giao dịch để lưu
          const transactionData: InventoryTransaction = {
            ...data,
            userId: context.auth.uid,
            date: data.date || admin.firestore.Timestamp.now(),
            status: data.status || 'COMPLETED',
          };

          // Lưu giao dịch vào Firestore
          const transactionRef = db.collection('inventory_transactions').doc();
          transaction.set(transactionRef, transactionData);

          // Cập nhật số lượng trong kho (trừ trường hợp chuyển kho)
          if (data.type !== 'TRANSFER') {
            transaction.update(itemRef, {
              stockQuantity: newQuantity,
              lastUpdated: admin.firestore.Timestamp.now(),
            });
          } else {
            // Xử lý chuyển kho - logic phức tạp hơn có thể thêm sau
            console.log('Xử lý chuyển kho - cần bổ sung logic');
          }

          return {
            success: true,
            transactionId: transactionRef.id,
            message: 'Giao dịch kho thành công',
            newQuantity,
          };
        });
      } catch (error: any) {
        console.error('Lỗi tạo giao dịch kho:', error);
        throw new functions.https.HttpsError(
          'internal',
          `Lỗi tạo giao dịch kho: ${error.message}`
        );
      }
    }
  );

/**
 * Lấy báo cáo tồn kho
 */
export const getInventoryReport = functions
  .region('asia-southeast1')
  .https.onCall(
    async (
      data: {
        categoryId?: string;
        locationId?: string;
        lowStock?: boolean;
      },
      context: CallableContext
    ) => {
      // Kiểm tra xác thực
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'Bạn cần đăng nhập để thực hiện chức năng này.'
        );
      }

      try {
        // Tạo truy vấn cơ bản
        let query: FirebaseFirestore.Query<FirebaseFirestore.DocumentData> =
          admin.firestore().collection('inventory');

        // Áp dụng các bộ lọc
        if (data.categoryId) {
          query = query.where('categoryId', '==', data.categoryId);
        }

        if (data.locationId) {
          query = query.where('locationId', '==', data.locationId);
        }

        const snapshot = await query.get();
        const items = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        }));

        // Lọc hàng tồn thấp nếu yêu cầu
        let result = items;
        if (data.lowStock) {
          result = items.filter((item) => {
            const typedItem = item as unknown as InventoryItem;
            return typedItem.stockQuantity <= (typedItem.minQuantity || 0);
          });
        }

        return {
          success: true,
          items: result,
        };
      } catch (error: any) {
        console.error('Lỗi lấy báo cáo tồn kho:', error);
        throw new functions.https.HttpsError(
          'internal',
          `Lỗi lấy báo cáo tồn kho: ${error.message}`
        );
      }
    }
  );

/**
 * Quản lý danh mục vật tư
 */
export const manageInventoryCategory = functions
  .region('asia-southeast1')
  .https.onCall(
    async (
      data: {
        action: 'add' | 'update' | 'delete';
        categoryData?: InventoryCategory;
        categoryId?: string;
      },
      context: CallableContext
    ) => {
      // Kiểm tra xác thực
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'Bạn cần đăng nhập để thực hiện chức năng này.'
        );
      }

      try {
        const { action, categoryData, categoryId } = data;
        const db = admin.firestore();

        if (action === 'add' && categoryData) {
          // Thêm danh mục mới
          const docRef = await db
            .collection('inventory_categories')
            .add(categoryData);
          return {
            success: true,
            id: docRef.id,
            message: 'Thêm danh mục thành công',
          };
        } else if (action === 'update' && categoryData && categoryId) {
          // Cập nhật danh mục
          // Chuyển đổi categoryData thành object với các cặp key-value thông thường
          const updateData: { [key: string]: any } = {};

          if (categoryData.name !== undefined)
            updateData.name = categoryData.name;
          if (categoryData.description !== undefined)
            updateData.description = categoryData.description;
          if (categoryData.parentId !== undefined)
            updateData.parentId = categoryData.parentId;

          await db
            .collection('inventory_categories')
            .doc(categoryId)
            .update(updateData);
          return {
            success: true,
            message: 'Cập nhật danh mục thành công',
          };
        } else if (action === 'delete' && categoryId) {
          // Kiểm tra xem danh mục có đang được sử dụng không
          const itemsUsingCategory = await db
            .collection('inventory')
            .where('categoryId', '==', categoryId)
            .limit(1)
            .get();

          // Kiểm tra xem có danh mục con nào không
          const childCategories = await db
            .collection('inventory_categories')
            .where('parentId', '==', categoryId)
            .limit(1)
            .get();

          if (!itemsUsingCategory.empty) {
            throw new functions.https.HttpsError(
              'failed-precondition',
              'Không thể xóa danh mục đang có vật tư sử dụng.'
            );
          }

          if (!childCategories.empty) {
            throw new functions.https.HttpsError(
              'failed-precondition',
              'Không thể xóa danh mục có chứa danh mục con.'
            );
          }

          // Xóa danh mục
          await db.collection('inventory_categories').doc(categoryId).delete();
          return {
            success: true,
            message: 'Xóa danh mục thành công',
          };
        } else {
          throw new functions.https.HttpsError(
            'invalid-argument',
            'Dữ liệu đầu vào không hợp lệ.'
          );
        }
      } catch (error: any) {
        console.error('Lỗi quản lý danh mục:', error);
        throw new functions.https.HttpsError(
          'internal',
          `Lỗi quản lý danh mục: ${error.message}`
        );
      }
    }
  );

/**
 * Thống kê sử dụng vật tư theo dự án
 */
export const getProjectMaterialUsage = functions
  .region('asia-southeast1')
  .https.onCall(
    async (
      data: {
        projectId: string;
        startDate?: string;
        endDate?: string;
      },
      context: CallableContext
    ) => {
      // Kiểm tra xác thực
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'Bạn cần đăng nhập để thực hiện chức năng này.'
        );
      }

      try {
        const { projectId, startDate, endDate } = data;
        if (!projectId) {
          throw new functions.https.HttpsError(
            'invalid-argument',
            'Thiếu ID dự án.'
          );
        }

        // Tạo truy vấn cơ bản - chỉ lấy giao dịch xuất kho cho dự án
        let query = admin
          .firestore()
          .collection('inventory_transactions')
          .where('type', '==', 'OUT')
          .where('projectId', '==', projectId);

        // Áp dụng lọc ngày nếu có
        if (startDate) {
          const startTimestamp = admin.firestore.Timestamp.fromDate(
            new Date(startDate)
          );
          query = query.where('date', '>=', startTimestamp);
        }

        if (endDate) {
          const endTimestamp = admin.firestore.Timestamp.fromDate(
            new Date(endDate)
          );
          query = query.where('date', '<=', endTimestamp);
        }

        // Thực hiện truy vấn
        const snapshot = await query.get();
        const transactions = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        }));

        // Nhóm theo vật tư và tính tổng
        const materialUsage: Record<string, any> = {};
        for (const transaction of transactions) {
          const typedTrans = transaction as unknown as InventoryTransaction;
          if (!materialUsage[typedTrans.itemId]) {
            // Lấy thông tin chi tiết về vật tư
            const itemDoc = await admin
              .firestore()
              .collection('inventory')
              .doc(typedTrans.itemId)
              .get();

            if (!itemDoc.exists) continue;

            const itemData = itemDoc.data() as InventoryItem;
            materialUsage[typedTrans.itemId] = {
              itemId: typedTrans.itemId,
              name: itemData.name,
              code: itemData.code,
              unit: itemData.unit,
              material: itemData.material,
              totalQuantity: 0,
              totalCost: 0,
              transactions: [],
            };
          }

          // Cộng số lượng và chi phí
          materialUsage[typedTrans.itemId].totalQuantity +=
            typedTrans.quantity || 0;
          materialUsage[typedTrans.itemId].totalCost +=
            (typedTrans.price || 0) * (typedTrans.quantity || 0);

          // Thêm giao dịch vào danh sách
          materialUsage[typedTrans.itemId].transactions.push({
            id: typedTrans.id,
            date: typedTrans.date,
            quantity: typedTrans.quantity,
            price: typedTrans.price,
            note: typedTrans.note,
          });
        }

        return {
          success: true,
          projectId,
          materials: Object.values(materialUsage),
        };
      } catch (error: any) {
        console.error('Lỗi thống kê sử dụng vật tư:', error);
        throw new functions.https.HttpsError(
          'internal',
          `Lỗi thống kê sử dụng vật tư: ${error.message}`
        );
      }
    }
  );

import * as functions from 'firebase-functions/v1';
import { google } from 'googleapis';
import * as XLSX from 'xlsx';
import { CallableContext } from 'firebase-functions/v1/https';

// admin đã được khởi tạo ở file index.ts chính

export const importMaterialsFromDrive = functions
  .region('asia-southeast1')
  .https.onCall(async (data: any, context: CallableContext) => {
    // === QUAY LẠI CÁCH XÁC THỰC CHUẨN ===
    if (!context.auth) {
      // Nếu context.auth không tồn tại, có nghĩa là Firebase không thể xác thực người dùng.
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Yêu cầu phải được thực hiện khi đã đăng nhập.'
      );
    }
    // Từ đây, bạn có thể tin tưởng context.auth.uid
    console.log(`Request from authenticated user: ${context.auth.uid}`);

    const { driveFileId, accessToken } = data;
    if (!driveFileId || !accessToken) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thiếu file ID hoặc access token.'
      );
    }

    try {
      // 1. Setup Google API client
      const auth = new google.auth.OAuth2();
      auth.setCredentials({ access_token: accessToken });
      const drive = google.drive({ version: 'v3', auth });

      // 2. Tải và parse file
      const response = await drive.files.get(
        { fileId: driveFileId, alt: 'media' },
        { responseType: 'arraybuffer' }
      );
      const workbook = XLSX.read(Buffer.from(response.data as any), {
        type: 'buffer',
      });
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      const rawData: any[][] = XLSX.utils.sheet_to_json(worksheet, {
        header: 1,
      });

      const parsedMaterials: any[] = [];
      for (let i = 4; i < rawData.length; i++) {
        const row: any[] = rawData[i];
        if (!row || !row[1] || typeof row[8] !== 'number') {
          continue;
        }
        const materialItem = {
          stt: row[0],
          name: row[1] || '',
          material: row[2] || '',
          quyCach: row[3] && row[4] ? `${row[3]}x${row[4]}` : '',
          unit: row[6] || '',
          quantity: parseFloat(String(row[7])) || 0,
          weight: parseFloat(String(row[8])) || 0,
          unitPrice: 0,
          totalPrice: 0,
        };
        parsedMaterials.push(materialItem);
      }

      // Trả về kết quả
      return { materials: parsedMaterials };
    } catch (error: any) {
      console.error('Error importing materials from Drive:', error);
      // Lỗi từ Google API, có thể do accessToken hết hạn
      if (error.code === 401 || error.code === 403) {
        throw new functions.https.HttpsError(
          'permission-denied',
          'Token truy cập Google Drive không hợp lệ hoặc đã hết hạn.'
        );
      }
      throw new functions.https.HttpsError(
        'internal',
        'Lỗi không xác định khi xử lý file.',
        error.message
      );
    }
  });

import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';
import * as path from 'path';

// Chỉ import 'googleapis' bên trong hàm khi cần
// import { google } from 'googleapis';

// Get reference to Firebase Storage
const storage = admin.storage().bucket();

/**
 * Callable function that takes a Google Sheet ID and exports it as PDF using Google Drive API
 * then uploads the PDF to Firebase Storage and returns a public URL
 */
export const exportSheetToPdf = functions
  .region('us-central1') // Explicitly specify the region
  .runWith({
    timeoutSeconds: 300,
    memory: '1GB',
  })
  .https.onCall(async (data, context) => {
    // Lazy load the googleapis library
    const { google } = await import('googleapis');

    // Check authentication
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Bạn cần đăng nhập để sử dụng tính năng này.'
      );
    }

    // Validate input parameters
    const { spreadsheetId, fileName, projectId, accessToken } = data;
    if (!spreadsheetId) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thiếu ID của Google Sheet.'
      );
    }

    if (!fileName) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thiếu tên file cho PDF.'
      );
    }

    if (!projectId) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thiếu ID dự án.'
      );
    }

    try {
      let auth: any;
      // Build auth/sheets depending on whether we have an end-user token
      if (accessToken) {
        const userAuth = new google.auth.OAuth2();
        userAuth.setCredentials({ access_token: accessToken });
        auth = userAuth;
      } else {
        auth = new google.auth.GoogleAuth({
          keyFile: path.join(__dirname, '../tanyb-fe4bf-4fbd5c01b6c7.json'),
          scopes: [
            'https://www.googleapis.com/auth/drive.readonly',
            'https://www.googleapis.com/auth/spreadsheets.readonly',
          ],
        });
      }

      const sheets = google.sheets({ version: 'v4', auth });

      // Step 1: Get the data from column A to determine the last row with content
      const sheetsResponse = await sheets.spreadsheets.values.get({
        spreadsheetId,
        range: 'A:A', // Only examine column A to determine the last row
      });

      // Calculate the last row with content
      const values = sheetsResponse.data.values || [];
      let lastRow = 0;

      // Find the last non-empty row
      for (let i = 0; i < values.length; i++) {
        if (values[i] && values[i][0]) {
          lastRow = i + 1; // Convert to 1-indexed
        }
      }

      // Add buffer rows to ensure we capture all content
      const bufferRows = 6;
      const dynamicRange = `A1:G${lastRow + bufferRows}`;

      functions.logger.info(
        `Calculated dynamic range: ${dynamicRange} (last row: ${lastRow})`
      );

      // Step 2: Build a custom export URL that limits the print area to columns A:G and rows 1 → lastRow + buffer.
      // Google Sheets accepts the parameters r1, r2, c1, c2 (0-based, r2/c2 are exclusive) together with a gid that identifies the sheet.
      const sheetMeta = await sheets.spreadsheets.get({
        spreadsheetId,
        fields: 'sheets(properties(sheetId))',
      });

      const sheetId = sheetMeta.data.sheets?.[0]?.properties?.sheetId ?? 0;

      const r1 = 0; // start row (0-based)
      // Guarantee export always reaches at least the bottom of the template (row 36)
      const MIN_TEMPLATE_ROWS = 36;
      const r2 = Math.max(lastRow + bufferRows, MIN_TEMPLATE_ROWS); // end row (exclusive)
      const c1 = 0; // column A (0-based)
      // Include column H (index 7) so the right-hand border of the template is preserved
      const c2 = 8; // exclusive end index

      const exportUrl =
        `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export` +
        `?format=pdf` +
        `&gid=${sheetId}` +
        `&portrait=true` +
        `&size=a4` +
        `&scale=2` +
        `&gridlines=false` +
        `&sheetnames=false` +
        `&printtitle=true` +
        `&pagenum=UNDEFINED` +
        `&r1=${r1}&r2=${r2}&c1=${c1}&c2=${c2}`;

      functions.logger.info(`Export URL: ${exportUrl}`);

      // Use the authenticated HTTP client to download the PDF as a stream
      const authClient =
        typeof auth.getClient === 'function' ? await auth.getClient() : auth;
      const pdfResponse = await authClient.request({
        url: exportUrl,
        method: 'GET',
        responseType: 'stream',
      });

      const pdfStream = (pdfResponse as any).data as NodeJS.ReadableStream;

      if (!pdfStream) {
        throw new functions.https.HttpsError(
          'internal',
          'Không thể xuất file PDF từ Google Sheet.'
        );
      }

      // Get project folder info from Firestore
      const projectDoc = await admin
        .firestore()
        .collection('projects')
        .doc(projectId)
        .get();
      const projectData = projectDoc.data();

      if (!projectData || !projectData.driveFolderId) {
        throw new functions.https.HttpsError(
          'failed-precondition',
          'Không tìm thấy thông tin thư mục Drive của dự án.'
        );
      }

      // Find 'baogia' subfolder in project folder
      const baogiaFolderResponse = await authClient.request({
        url: 'https://www.googleapis.com/drive/v3/files',
        method: 'GET',
        params: {
          q: `name='baogia' and '${projectData.driveFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
          fields: 'files(id)',
        },
      });

      // Type casting for the response
      interface DriveFilesResponse {
        files?: { id: string }[];
      }

      const responseData = baogiaFolderResponse.data as DriveFilesResponse;

      let baogiaFolderId;
      if (responseData.files && responseData.files.length > 0) {
        baogiaFolderId = responseData.files[0].id;
      } else {
        // Create 'baogia' folder if it doesn't exist
        const driveClient = google.drive({
          version: 'v3',
          auth: authClient,
        });
        const folderResponse = await driveClient.files.create({
          requestBody: {
            name: 'baogia',
            mimeType: 'application/vnd.google-apps.folder',
            parents: [projectData.driveFolderId],
          },
          fields: 'id',
        });
        baogiaFolderId = folderResponse.data.id;
      }

      // Define sanitized filename first
      const sanitizedFileName = fileName.replace(/[^a-z0-9.]/gi, '_');

      // Save PDF to Google Drive folder if baogiaFolderId exists
      if (baogiaFolderId) {
        try {
          // Upload PDF to Drive (in background, don't await)
          const driveClient = google.drive({
            version: 'v3',
            auth: authClient,
          });

          // Clone the stream since we need to use it twice (Drive and Storage)
          const pdfClone = require('stream').Readable.from(pdfStream);

          driveClient.files
            .create({
              requestBody: {
                name: `${sanitizedFileName}.pdf`,
                mimeType: 'application/pdf',
                parents: [baogiaFolderId],
              },
              media: {
                mimeType: 'application/pdf',
                body: pdfClone,
              },
            })
            .catch((error) => {
              console.error('Error uploading PDF to Drive:', error);
            });
        } catch (error) {
          console.error('Error setting up Drive upload:', error);
        }
      }

      // Define the destination path in Firebase Storage (keep existing functionality)
      const destinationPath = `quotation-pdfs/${projectId}/${sanitizedFileName}.pdf`;
      const file = storage.file(destinationPath);

      // Create a write stream to Firebase Storage
      const writeStream = file.createWriteStream({
        metadata: {
          contentType: 'application/pdf',
        },
      });

      // Handle potential errors in the pipeline
      let pipelineError: Error | null = null;

      // Pipe the PDF data from Google Drive to Firebase Storage
      pdfStream
        .on('error', (err: Error) => {
          pipelineError = err;
          functions.logger.error('Error streaming PDF from Drive:', err);
        })
        .pipe(writeStream);

      // Return a promise that resolves when the upload is complete
      return new Promise((resolve, reject) => {
        writeStream.on('finish', async () => {
          if (pipelineError) {
            reject(
              new functions.https.HttpsError('internal', pipelineError.message)
            );
            return;
          }

          try {
            // Generate a signed URL instead of making the file public
            // This is compatible with Uniform Bucket-Level Access
            const [signedUrl] = await file.getSignedUrl({
              action: 'read',
              expires: '01-01-2124', // Set a very long expiration date (e.g., 100 years)
            });

            resolve({
              pdfUrl: signedUrl,
              lastRow,
              dynamicRange,
              usedUrl: exportUrl,
            });
          } catch (err) {
            functions.logger.error('Error generating signed URL:', err);
            reject(
              new functions.https.HttpsError(
                'internal',
                'Không thể tạo URL công khai cho file PDF.'
              )
            );
          }
        });

        writeStream.on('error', (err) => {
          functions.logger.error('Error writing to Firebase Storage:', err);
          reject(
            new functions.https.HttpsError(
              'internal',
              `Lỗi khi lưu file PDF: ${err.message}`
            )
          );
        });
      });
    } catch (error) {
      functions.logger.error('Error in exportSheetToPdf:', error);
      throw new functions.https.HttpsError(
        'internal',
        `Lỗi khi xuất file PDF: ${
          error instanceof Error ? error.message : 'Unknown error'
        }`
      );
    }
  });

import * as functions from 'firebase-functions/v1';
import { google, sheets_v4 } from 'googleapis';
import { CallableContext } from 'firebase-functions/v1/https';
import * as admin from 'firebase-admin';

// Define PO data interface
interface ExcelPurchaseOrderData {
  metadata: {
    projectName?: string;
    supplierName?: string;
    supplierAddress?: string;
    supplierPhone?: string;
    supplierEmail?: string;
    supplierTaxCode?: string;
    supplierContactPerson?: string;
    poNumber?: string;
    proposalNumber?: string;
    poDate?: string;
    deliveryTime?: string;
    paymentTerms?: string;
  };
  materials: {
    no: number;
    name: string;
    unit: string;
    quantity: number;
    unitPrice: number;
    total: number;
    material?: string;
    specs?: string;
  }[];
  summary: {
    subTotal: number;
    vatPercentage: number;
    vatAmount: number;
    grandTotal: number;
  };
}

// ----- CONFIGURATION -----
const TEMPLATE_FILE_ID = '1z0MBboGASBZ8rE68x-_ykMVt4YjFcuTZG9RcVWBcZF0'; // Updated PO template ID
const START_ROW_MATERIALS = 18; // Data starts at row 18 in the new template

// ----- MAIN FUNCTION -----
export const generateExcelPurchaseOrder = functions
  .region('asia-southeast1')
  .runWith({ timeoutSeconds: 300, memory: '512MB' })
  .https.onCall(
    async (
      data: {
        formattedData: ExcelPurchaseOrderData;
        projectId: string;
        accessToken: string;
      },
      context: CallableContext
    ) => {
      // Add detailed logging for debugging
      console.log('PO Generator called with projectId:', data.projectId);
      console.log(
        'Auth context:',
        context.auth ? 'Authenticated' : 'Not authenticated'
      );
      console.log('Access token provided:', data.accessToken ? 'Yes' : 'No');

      // Check if we have the required data
      const { formattedData, projectId, accessToken } = data;

      // Validate required parameters
      if (!formattedData) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Invalid data.'
        );
      }
      if (!projectId) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Project ID is required.'
        );
      }

      // Check for accessToken (required for Google API access)
      if (!accessToken) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'Google access token is required.'
        );
      }

      console.log(
        'PO Generator: Received valid request for project:',
        projectId
      );

      try {
        // Use the provided access token for Google API authentication
        const auth = new google.auth.OAuth2();
        auth.setCredentials({ access_token: accessToken });

        const drive = google.drive({ version: 'v3', auth });
        const sheets = google.sheets({ version: 'v4', auth });

        const db = admin.firestore();
        const projectDoc = await db.collection('projects').doc(projectId).get();
        const projectData = projectDoc.data();

        if (!projectData || !projectData.driveFolderId) {
          throw new functions.https.HttpsError(
            'failed-precondition',
            'Project Drive folder information not found.'
          );
        }

        // Find or create 'PO' subfolder in the project folder
        const poFolderResponse = await drive.files.list({
          q: `name='PO' and '${projectData.driveFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
          fields: 'files(id)',
        });

        let poFolderId;
        if (
          poFolderResponse.data.files &&
          poFolderResponse.data.files.length > 0
        ) {
          poFolderId = poFolderResponse.data.files[0].id;
        } else {
          const folderResponse = await drive.files.create({
            requestBody: {
              name: 'PO',
              mimeType: 'application/vnd.google-apps.folder',
              parents: [projectData.driveFolderId],
            },
            fields: 'id',
          });
          poFolderId = folderResponse.data.id;
        }

        const newFileName = `Đặt hàng - ${
          formattedData.metadata.supplierName || 'NCC'
        } - ${new Date().toLocaleDateString('vi-VN').replace(/\//g, '-')}`;

        const copiedFileResponse = await drive.files.copy({
          fileId: TEMPLATE_FILE_ID,
          requestBody: { name: newFileName, parents: [poFolderId] },
        });

        const newFileId = copiedFileResponse.data.id;
        if (!newFileId) throw new Error('Cannot copy template file.');

        const spreadsheet = await sheets.spreadsheets.get({
          spreadsheetId: newFileId,
          fields: 'sheets.properties',
        });
        const firstSheet = spreadsheet.data.sheets?.[0];
        const sheetId = firstSheet?.properties?.sheetId;
        if (sheetId === undefined || sheetId === null) {
          throw new Error('Cannot determine sheetId of the first sheet');
        }

        const requests: sheets_v4.Schema$Request[] = [];

        // ---- NEW METADATA MAPPING TO MATCH THE TEMPLATE ----
        const poDate = new Date();
        const dateString = `HCM, Ngày ${poDate.getDate()} tháng ${
          poDate.getMonth() + 1
        } năm ${poDate.getFullYear()}`;

        // Helper to create update requests
        const createCellUpdateRequest = (
          value: any,
          rowIndex: number,
          columnIndex: number
        ) => ({
          updateCells: {
            rows: [
              {
                values: [{ userEnteredValue: { stringValue: String(value) } }],
              },
            ],
            fields: 'userEnteredValue',
            start: { sheetId, rowIndex, columnIndex },
          },
        });

        // Project and Date
        requests.push(
          createCellUpdateRequest(
            formattedData.metadata.projectName || '',
            1,
            9 // Column J (index 9) for cell J2
          )
        );
        requests.push(createCellUpdateRequest(dateString, 5, 4)); // E6

        // Supplier Info - Updated to write to the correct cells
        requests.push(
          createCellUpdateRequest(
            formattedData.metadata.supplierName || '',
            8,
            3
          )
        ); // D9

        // Merge cells for supplier name D9:F10
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 8,
              endRowIndex: 10,
              startColumnIndex: 3,
              endColumnIndex: 6,
            },
            mergeType: 'MERGE_ALL',
          },
        });

        // Address in D11:F11
        requests.push(
          createCellUpdateRequest(
            formattedData.metadata.supplierAddress || '',
            10,
            3
          )
        ); // D11

        // Merge cells for address D11:F11
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 10,
              endRowIndex: 11,
              startColumnIndex: 3,
              endColumnIndex: 6,
            },
            mergeType: 'MERGE_ALL',
          },
        });

        // Tax code in D12:F12
        requests.push(
          createCellUpdateRequest(
            formattedData.metadata.supplierTaxCode || '',
            11,
            3
          )
        ); // D12

        // Merge cells for tax code D12:F12
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 11,
              endRowIndex: 12,
              startColumnIndex: 3,
              endColumnIndex: 6,
            },
            mergeType: 'MERGE_ALL',
          },
        });

        // Contact person in D13:F13
        requests.push(
          createCellUpdateRequest(
            formattedData.metadata.supplierContactPerson || '',
            12,
            3
          )
        ); // D13

        // Merge cells for contact person D13:F13
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 12,
              endRowIndex: 13,
              startColumnIndex: 3,
              endColumnIndex: 6,
            },
            mergeType: 'MERGE_ALL',
          },
        });

        // Email stays in original location
        requests.push(
          createCellUpdateRequest(
            formattedData.metadata.supplierEmail || '',
            13,
            2
          )
        ); // C14

        // Phone in D15:F15
        requests.push(
          createCellUpdateRequest(
            formattedData.metadata.supplierPhone || '',
            14,
            3
          )
        ); // D15

        // Merge cells for phone D15:F15
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 14,
              endRowIndex: 15,
              startColumnIndex: 3,
              endColumnIndex: 6,
            },
            mergeType: 'MERGE_ALL',
          },
        });

        // PO Info - I9
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: formattedData.metadata.poNumber || '',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue',
            start: { sheetId, rowIndex: 8, columnIndex: 8 }, // I9
          },
        });
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 8,
              endRowIndex: 9,
              startColumnIndex: 8, // I
              endColumnIndex: 10, // J
            }, // I9:J9
            mergeType: 'MERGE_ALL',
          },
        });

        // Proposal Number - I10
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: formattedData.metadata.proposalNumber || '',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue',
            start: { sheetId, rowIndex: 9, columnIndex: 8 }, // I10
          },
        });
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 9,
              endRowIndex: 10,
              startColumnIndex: 8, // I
              endColumnIndex: 10, // J
            }, // I10:J10
            mergeType: 'MERGE_ALL',
          },
        });

        // Delivery time moved to I12
        requests.push(
          createCellUpdateRequest(
            formattedData.metadata.deliveryTime || '',
            11,
            8
          )
        ); // I12
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 11,
              endRowIndex: 12,
              startColumnIndex: 8,
              endColumnIndex: 10,
            }, // I12:J12
            mergeType: 'MERGE_ALL',
          },
        });

        requests.push(
          createCellUpdateRequest(
            formattedData.metadata.paymentTerms || '',
            12,
            9
          )
        ); // J13

        // ---- MATERIALS TABLE ----
        // Add table header for materials - starting from column C (index 2)
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: { stringValue: 'STT' },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      borders: {
                        top: { style: 'SOLID' },
                        bottom: { style: 'SOLID' },
                        left: { style: 'SOLID' },
                        right: { style: 'SOLID' },
                      },
                    },
                  },
                  {
                    userEnteredValue: { stringValue: 'Mô Tả Hàng Hóa' },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      borders: {
                        top: { style: 'SOLID' },
                        bottom: { style: 'SOLID' },
                        left: { style: 'SOLID' },
                        right: { style: 'SOLID' },
                      },
                    },
                  },
                  {
                    userEnteredValue: { stringValue: 'Yêu Cầu Kỹ Thuật' },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      borders: {
                        top: { style: 'SOLID' },
                        bottom: { style: 'SOLID' },
                        left: { style: 'SOLID' },
                        right: { style: 'SOLID' },
                      },
                    },
                  },
                  {
                    userEnteredValue: { stringValue: 'ĐVT' },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      borders: {
                        top: { style: 'SOLID' },
                        bottom: { style: 'SOLID' },
                        left: { style: 'SOLID' },
                        right: { style: 'SOLID' },
                      },
                    },
                  },
                  {
                    userEnteredValue: { stringValue: 'Số Lượng' },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      borders: {
                        top: { style: 'SOLID' },
                        bottom: { style: 'SOLID' },
                        left: { style: 'SOLID' },
                        right: { style: 'SOLID' },
                      },
                    },
                  },
                  {
                    userEnteredValue: { stringValue: 'Đơn giá (VND)' },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      borders: {
                        top: { style: 'SOLID' },
                        bottom: { style: 'SOLID' },
                        left: { style: 'SOLID' },
                        right: { style: 'SOLID' },
                      },
                    },
                  },
                  {
                    userEnteredValue: { stringValue: 'Thành Tiền (VND)' },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      borders: {
                        top: { style: 'SOLID' },
                        bottom: { style: 'SOLID' },
                        left: { style: 'SOLID' },
                        right: { style: 'SOLID' },
                      },
                    },
                  },
                  {
                    userEnteredValue: { stringValue: 'Ghi chú' },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      borders: {
                        top: { style: 'SOLID' },
                        bottom: { style: 'SOLID' },
                        left: { style: 'SOLID' },
                        right: { style: 'SOLID' },
                      },
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: {
              sheetId,
              rowIndex: START_ROW_MATERIALS - 2,
              columnIndex: 2,
            },
          },
        });

        const materialRows = formattedData.materials.map((material) => ({
          values: [
            {
              userEnteredValue: { numberValue: material.no },
              userEnteredFormat: {
                horizontalAlignment: 'CENTER',
                verticalAlignment: 'MIDDLE',
                borders: {
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                },
              },
            },
            {
              // Description
              userEnteredValue: { stringValue: material.name },
              userEnteredFormat: {
                horizontalAlignment: 'LEFT',
                verticalAlignment: 'MIDDLE',
                borders: {
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                },
              },
            },
            {
              // Technical spec
              userEnteredValue: { stringValue: material.specs || '' },
              userEnteredFormat: {
                horizontalAlignment: 'CENTER',
                verticalAlignment: 'MIDDLE',
                borders: {
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                },
              },
            },
            {
              // Unit
              userEnteredValue: { stringValue: material.unit },
              userEnteredFormat: {
                horizontalAlignment: 'CENTER',
                verticalAlignment: 'MIDDLE',
                borders: {
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                },
              },
            },
            {
              // Quantity
              userEnteredValue: { numberValue: material.quantity },
              userEnteredFormat: {
                horizontalAlignment: 'RIGHT',
                verticalAlignment: 'MIDDLE',
                borders: {
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                },
              },
            },
            {
              // Unit price
              userEnteredValue: { numberValue: material.unitPrice },
              userEnteredFormat: {
                numberFormat: { type: 'NUMBER', pattern: '#,##0' },
                horizontalAlignment: 'RIGHT',
                verticalAlignment: 'MIDDLE',
                borders: {
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                },
              },
            },
            {
              // Total
              userEnteredValue: { numberValue: material.total },
              userEnteredFormat: {
                numberFormat: { type: 'NUMBER', pattern: '#,##0' },
                horizontalAlignment: 'RIGHT',
                verticalAlignment: 'MIDDLE',
                borders: {
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                },
              },
            },
            {
              // Note column blank
              userEnteredValue: { stringValue: '' },
              userEnteredFormat: {
                borders: {
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                },
              },
            },
          ],
        }));

        if (materialRows.length > 0) {
          requests.push({
            insertDimension: {
              range: {
                sheetId,
                dimension: 'ROWS',
                startIndex: START_ROW_MATERIALS - 1,
                endIndex: START_ROW_MATERIALS - 1 + materialRows.length,
              },
              inheritFromBefore: true,
            },
          });
          requests.push({
            updateCells: {
              rows: materialRows,
              fields: 'userEnteredValue,userEnteredFormat',
              start: {
                sheetId,
                rowIndex: START_ROW_MATERIALS - 1,
                columnIndex: 2,
              },
            },
          });
        }

        // ---- SUMMARY SECTION ----
        const summaryStartRow =
          START_ROW_MATERIALS + formattedData.materials.length + 3; // Add some spacing
        const createSummaryRow = (
          label: string,
          value: number | null,
          isBold: boolean,
          rowOffset: number
        ) => {
          // 1. Write Label to Column B
          requests.push({
            updateCells: {
              rows: [
                {
                  values: [
                    {
                      userEnteredValue: { stringValue: label },
                      userEnteredFormat: {
                        textFormat: { bold: isBold },
                        horizontalAlignment: 'RIGHT',
                        verticalAlignment: 'MIDDLE',
                      },
                    },
                  ],
                },
              ],
              fields: 'userEnteredValue,userEnteredFormat',
              start: {
                sheetId,
                rowIndex: summaryStartRow + rowOffset,
                columnIndex: 1, // Column B
              },
            },
          });

          // 2. Write Value to Column I
          if (value !== null) {
            requests.push({
              updateCells: {
                rows: [
                  {
                    values: [
                      {
                        userEnteredValue: { numberValue: value },
                        userEnteredFormat: {
                          numberFormat: { type: 'NUMBER', pattern: '#,##0' },
                          textFormat: { bold: isBold },
                          horizontalAlignment: 'RIGHT',
                          verticalAlignment: 'MIDDLE',
                        },
                      },
                    ],
                  },
                ],
                fields: 'userEnteredValue,userEnteredFormat',
                start: {
                  sheetId,
                  rowIndex: summaryStartRow + rowOffset,
                  columnIndex: 8, // Column I
                },
              },
            });
          }

          // 3. Merge label cells (B to H)
          requests.push({
            mergeCells: {
              range: {
                sheetId,
                startRowIndex: summaryStartRow + rowOffset,
                endRowIndex: summaryStartRow + rowOffset + 1,
                startColumnIndex: 1, // Column B
                endColumnIndex: 8, // Column H
              },
              mergeType: 'MERGE_ALL',
            },
          });

          // 4. Merge value cells (I to J)
          requests.push({
            mergeCells: {
              range: {
                sheetId,
                startRowIndex: summaryStartRow + rowOffset,
                endRowIndex: summaryStartRow + rowOffset + 1,
                startColumnIndex: 8, // Column I
                endColumnIndex: 10, // Column J
              },
              mergeType: 'MERGE_ALL',
            },
          });
        };

        createSummaryRow(
          'Tổng Số Tiền Chưa Bao Gồm thuế GTGT (VAT)',
          formattedData.summary.subTotal,
          false,
          0
        );
        createSummaryRow(
          `Thuế VAT ${formattedData.summary.vatPercentage}%`,
          formattedData.summary.vatAmount,
          false,
          1
        );
        createSummaryRow(
          'Tổng Số Tiền Bao Gồm thuế GTGT (VAT)',
          formattedData.summary.grandTotal,
          true,
          2
        );

        // Amount in words row (merge B:J)
        const amountInWordsRow = summaryStartRow + 3;
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: `(Bằng chữ: ${convertNumberToVnWords(
                        formattedData.summary.grandTotal
                      )})`,
                    },
                    userEnteredFormat: {
                      textFormat: { bold: true, italic: true },
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: amountInWordsRow, columnIndex: 1 },
          },
        });
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: amountInWordsRow,
              endRowIndex: amountInWordsRow + 2, // Span 2 rows
              startColumnIndex: 1,
              endColumnIndex: 10,
            },
            mergeType: 'MERGE_ALL',
          },
        });

        // ---- TERMS AND CONDITIONS SECTION ----
        const termsStartRow = amountInWordsRow + 3;
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: '* ĐIỀU KHOẢN VÀ YÊU CẦU BỔ SUNG:',
                    },
                    userEnteredFormat: { textFormat: { bold: true } },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: termsStartRow, columnIndex: 1 },
          },
        });
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: termsStartRow,
              endRowIndex: termsStartRow + 1,
              startColumnIndex: 1,
              endColumnIndex: 10,
            },
            mergeType: 'MERGE_ALL',
          },
        });

        const termsConditions = [
          {
            no: 1,
            text: 'Đơn giá không bao gồm phí vận chuyển theo địa chỉ giao hàng đề cập trong Đơn Đặt Hàng này.',
          },
          {
            no: 2,
            text: 'Nhà cung cấp chuẩn bị và kí biên bản giao nhận, cùng với Đơn đặt hàng này khi giao hàng.',
          },
          {
            no: 3,
            text: 'Tất cả hàng hóa mới 100%. Nhà cung cấp phải trình chứng chỉ chất lượng và xuất xứ (copy) khi được yêu cầu',
          },
        ];

        termsConditions.forEach((term, idx) => {
          requests.push({
            updateCells: {
              rows: [
                {
                  values: [
                    {
                      userEnteredValue: { numberValue: term.no },
                      userEnteredFormat: {
                        textFormat: { bold: true },
                        horizontalAlignment: 'CENTER',
                      },
                    },
                    {
                      userEnteredValue: { stringValue: term.text },
                      userEnteredFormat: {
                        textFormat: {
                          foregroundColor: { red: 1, green: 0, blue: 0 },
                        },
                        horizontalAlignment: 'LEFT',
                      },
                    },
                  ],
                },
              ],
              fields: 'userEnteredValue,userEnteredFormat',
              start: {
                sheetId,
                rowIndex: termsStartRow + 1 + idx,
                columnIndex: 1,
              },
            },
          });
          requests.push({
            mergeCells: {
              range: {
                sheetId,
                startRowIndex: termsStartRow + 1 + idx,
                endRowIndex: termsStartRow + 2 + idx,
                startColumnIndex: 2,
                endColumnIndex: 10,
              },
              mergeType: 'MERGE_ALL',
            },
          });
        });

        // Add space between terms and signatures
        const signatureStartRow = termsStartRow + termsConditions.length + 3;

        // ---- SIGNATURES SECTION (CORRECT & ROBUST IMPLEMENTATION) ----

        // --- BÊN MUA HÀNG (BÊN A) ---
        // 1. Ghi chữ "Đại diện bên Mua hàng (Bên A)" vào cột B
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: 'Đại diện bên Mua hàng (Bên A)',
                    },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: signatureStartRow, columnIndex: 1 }, // Cột B
          },
        });

        // 2. Gộp ô cho Bên A (B đến F)
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: signatureStartRow,
              endRowIndex: signatureStartRow + 1,
              startColumnIndex: 1, // Từ Cột B
              endColumnIndex: 6, // Đến Cột F
            },
            mergeType: 'MERGE_ALL',
          },
        });

        // --- BÊN BÁN HÀNG (BÊN B) ---
        // 3. Ghi chữ "Đại diện bên Bán hàng (Bên B)" vào cột G
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: 'Đại diện bên Bán hàng (Bên B)',
                    },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: signatureStartRow, columnIndex: 6 }, // Cột G
          },
        });

        // 4. Gộp ô cho Bên B (G đến K)
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: signatureStartRow,
              endRowIndex: signatureStartRow + 1,
              startColumnIndex: 6, // Từ Cột G
              endColumnIndex: 11, // Đến Cột K
            },
            mergeType: 'MERGE_ALL',
          },
        });

        // Add empty space for signatures (about 7 rows)
        for (let i = 0; i < 7; i++) {
          requests.push({
            updateCells: {
              rows: [{ values: [{ userEnteredValue: { stringValue: '' } }] }],
              fields: 'userEnteredValue',
              start: {
                sheetId,
                rowIndex: signatureStartRow + 1 + i,
                columnIndex: 0,
              },
            },
          });
        }

        // Apply all updates to the spreadsheet
        await sheets.spreadsheets.batchUpdate({
          spreadsheetId: newFileId,
          requestBody: { requests },
        });

        // Set permissions to make the file accessible
        await drive.permissions.create({
          fileId: newFileId,
          requestBody: { role: 'reader', type: 'anyone' },
        });

        // ----- SAVE PO METADATA TO FIRESTORE -----
        await admin
          .firestore()
          .collection('purchase_orders')
          .add({
            projectId,
            supplierName: formattedData.metadata.supplierName || '',
            poNumber: formattedData.metadata.poNumber || '',
            deliveryTime: formattedData.metadata.deliveryTime || '',
            fileId: newFileId,
            fileUrl: `https://docs.google.com/spreadsheets/d/${newFileId}/edit`,
            status: 'created',
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            formattedData,
          });

        return {
          success: true,
          fileId: newFileId,
          fileUrl: `https://docs.google.com/spreadsheets/d/${newFileId}/edit`,
          message: 'Purchase Order generated successfully',
        };
      } catch (error) {
        console.error('Error details in generateExcelPurchaseOrder:', error);
        throw new functions.https.HttpsError(
          'internal',
          'Error creating purchase order. Check logs for details.',
          error
        );
      }
    }
  );

// ----- HELPER FUNCTIONS -----
function convertNumberToVnWords(n: number): string {
  const t = [
    'không',
    'một',
    'hai',
    'ba',
    'bốn',
    'năm',
    'sáu',
    'bảy',
    'tám',
    'chín',
  ];
  const r = (num: number): string => {
    if (num === 0) return '';
    if (num < 10) return t[num];
    if (num < 100) {
      return (
        t[Math.floor(num / 10)] +
        ' mươi ' +
        (num % 10 === 1
          ? 'mốt'
          : num % 10 === 5
          ? 'lăm'
          : num % 10 !== 0
          ? t[num % 10]
          : '')
      );
    }
    if (num < 1000) {
      return (
        t[Math.floor(num / 100)] +
        ' trăm ' +
        (num % 100 < 10 && num % 100 > 0 ? 'lẻ ' + t[num % 100] : r(num % 100))
      );
    }
    if (num < 1000000) {
      return (
        r(Math.floor(num / 1000)) +
        ' nghìn ' +
        (num % 1000 < 100 && num % 1000 > 0
          ? 'không trăm ' + r(num % 1000)
          : r(num % 1000))
      );
    }
    if (num < 1000000000) {
      return (
        r(Math.floor(num / 1000000)) +
        ' triệu ' +
        (num % 1000000 === 0 ? '' : r(num % 1000000))
      );
    }
    return (
      r(Math.floor(num / 1000000000)) +
      ' tỷ ' +
      (num % 1000000000 === 0 ? '' : r(num % 1000000000))
    );
  };

  return r(Math.floor(n)) + ' đồng';
}

import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';
import { google } from 'googleapis';
import * as path from 'path';
import { Readable } from 'stream';

// Helper to detect quota/rate-limit errors
function isQuotaError(error: any): boolean {
  if (!error) return false;
  const status = error.code || error.status;
  const message = (error.message || '').toLowerCase();
  return (
    status === 403 ||
    status === 429 ||
    message.includes('quota') ||
    message.includes('rate limit') ||
    message.includes('user rate limit exceeded') ||
    message.includes('quota exceeded')
  );
}

// Exponential-backoff retry helper
async function withRetry<T>(
  fn: () => Promise<T>,
  retries = 5,
  delay = 1000
): Promise<T> {
  try {
    return await fn();
  } catch (err) {
    if (retries > 0 && isQuotaError(err)) {
      console.log(
        `Quota error – retrying in ${delay} ms, attempts left ${retries}`
      );
      await new Promise((res) => setTimeout(res, delay));
      return withRetry(fn, retries - 1, delay * 2);
    }
    throw err;
  }
}

// Build Drive client either with service account or user OAuth token
const buildDriveClient = async (accessToken?: string) => {
  if (accessToken) {
    const auth = new google.auth.OAuth2();
    auth.setCredentials({ access_token: accessToken });
    return google.drive({ version: 'v3', auth });
  }
  const auth = new google.auth.GoogleAuth({
    keyFile: path.join(__dirname, '../tanyb-fe4bf-4fbd5c01b6c7.json'),
    scopes: ['https://www.googleapis.com/auth/drive'],
  });
  return google.drive({ version: 'v3', auth });
};

/**
 * confirmPOReceipt
 * Allows QA/QC to upload photos confirming that materials in a PO have been received.
 * - Uploads images to Drive under <Project>/PO_Receipts/<PO_ID>
 * - Updates purchase_orders doc: status -> "received", receivedAt, receiptPhotos[]
 */
export const confirmPOReceipt = functions
  .region('asia-southeast1')
  .runWith({ timeoutSeconds: 300, memory: '1GB' })
  .https.onCall(async (data, context) => {
    const {
      poId,
      projectId,
      files,
      remarks = '',
      accessToken,
    } = data as {
      poId?: string;
      projectId?: string;
      files?: Array<{ fileName: string; mimeType: string; base64Data: string }>;
      remarks?: string;
      accessToken?: string;
    };

    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Bạn cần đăng nhập'
      );
    }

    if (!poId || !projectId || !files || files.length === 0) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thiếu tham số bắt buộc'
      );
    }

    try {
      const db = admin.firestore();
      const poRef = db.collection('purchase_orders').doc(poId);
      const poSnap = await poRef.get();
      if (!poSnap.exists) {
        throw new functions.https.HttpsError('not-found', 'Không tìm thấy PO');
      }

      const projectSnap = await db.collection('projects').doc(projectId).get();
      const projectData = projectSnap.data();
      if (!projectData || !projectData.driveFolderId) {
        throw new functions.https.HttpsError(
          'failed-precondition',
          'Không tìm thấy folder Drive dự án'
        );
      }

      const drive = await buildDriveClient(accessToken);

      // Find or create QC_Reports folder inside project folder
      const receiptFolderRes = await withRetry(() =>
        drive.files.list({
          q: `name='QC_Reports' and '${projectData.driveFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
          fields: 'files(id)',
          spaces: 'drive',
        })
      );

      let qcFolderId = receiptFolderRes.data.files?.[0]?.id;
      if (!qcFolderId) {
        const createFolder = await withRetry(() =>
          drive.files.create({
            requestBody: {
              name: 'QC_Reports',
              mimeType: 'application/vnd.google-apps.folder',
              parents: [projectData.driveFolderId],
            },
            fields: 'id',
          })
        );
        qcFolderId = createFolder.data.id!;
      }

      // Upload each file
      const uploaded: Array<{
        fileId: string;
        webViewLink: string;
        mimeType: string;
      }> = [];
      for (const f of files) {
        // Add PO ID prefix to filename for better identification
        const poFileName = `PO_${poId}_${f.fileName}`;
        const buffer = Buffer.from(f.base64Data, 'base64');
        const stream = Readable.from(buffer);
        const fileRes = await withRetry(() =>
          drive.files.create({
            requestBody: {
              name: poFileName,
              mimeType: f.mimeType,
              parents: [qcFolderId],
            },
            media: { mimeType: f.mimeType, body: stream },
            fields: 'id,webViewLink,mimeType,webContentLink',
          })
        );

        await withRetry(() =>
          drive.permissions.create({
            fileId: fileRes.data.id!,
            requestBody: { role: 'reader', type: 'anyone' },
          })
        );

        uploaded.push({
          fileId: fileRes.data.id!,
          webViewLink: fileRes.data.webViewLink!,
          mimeType: fileRes.data.mimeType!,
        });
      }

      // Update PO document
      await poRef.update({
        status: 'received',
        receivedAt: admin.firestore.FieldValue.serverTimestamp(),
        receiptPhotos: uploaded,
        receiptRemarks: remarks,
      });

      return { success: true, uploaded };
    } catch (err: any) {
      console.error('confirmPOReceipt error', err);
      throw new functions.https.HttpsError(
        'internal',
        err.message || 'Lỗi xử lý xác nhận PO'
      );
    }
  });

import {
  onDocumentDeleted,
  onDocumentCreated,
} from 'firebase-functions/v2/firestore';
import * as admin from 'firebase-admin';
import { google } from 'googleapis';
import * as path from 'path';

const db = admin.firestore();
const ROOT_FOLDER_ID = '18OrAEBSuZzz-AFbqlitz5gUxpsdunXjX'; // Baogia root folder ID

/**
 * Creates a Google Drive folder structure for a new project
 */
export const onProjectCreate = onDocumentCreated(
  {
    document: 'projects/{projectId}',
    region: 'asia-southeast1',
  },
  async (event) => {
    const { projectId } = event.params;
    const projectData = event.data?.data();
    if (!projectData) {
      console.log(`No data found for project ${projectId}.`);
      return;
    }

    console.log(`Creating Drive folders for new project: ${projectData.name}`);

    try {
      // Initialize Google Drive API
      const auth = new google.auth.GoogleAuth({
        keyFile: path.join(__dirname, '../tanyb-fe4bf-4fbd5c01b6c7.json'),
        scopes: ['https://www.googleapis.com/auth/drive'],
      });
      const drive = google.drive({ version: 'v3', auth });

      // Get current date for folder structure (YYYY/MM/DD)
      const createdDate = projectData.createdAt?.toDate() || new Date();
      const year = createdDate.getFullYear().toString();
      const month = (createdDate.getMonth() + 1).toString().padStart(2, '0');
      const day = createdDate.getDate().toString().padStart(2, '0');

      // Clean project name for use in folder name (remove invalid chars)
      const cleanProjectName = projectData.name.replace(/[\/\\:*?"<>|]/g, '_');

      // Step 1: Find or create year folder
      const yearFolder = await findOrCreateFolder(drive, year, ROOT_FOLDER_ID);
      if (!yearFolder) {
        throw new Error(`Failed to create year folder ${year}`);
      }

      // Step 2: Find or create month folder
      const monthFolder = await findOrCreateFolder(drive, month, yearFolder.id);
      if (!monthFolder) {
        throw new Error(`Failed to create month folder ${month}`);
      }

      // Step 3: Find or create day folder
      const dayFolder = await findOrCreateFolder(drive, day, monthFolder.id);
      if (!dayFolder) {
        throw new Error(`Failed to create day folder ${day}`);
      }

      // Step 4: Create project folder
      const projectFolder = await createFolder(
        drive,
        cleanProjectName,
        dayFolder.id
      );
      if (!projectFolder) {
        throw new Error(`Failed to create project folder ${cleanProjectName}`);
      }

      // Step 5: Create subfolders (baogia, hopdong)
      // Create and track subfolder IDs for logging
      const baogiaFolder = await createFolder(
        drive,
        'baogia',
        projectFolder.id
      );
      const hopdongFolder = await createFolder(
        drive,
        'hopdong',
        projectFolder.id
      );

      console.log(
        `Created subfolders: baogia (${baogiaFolder.id}) and hopdong (${hopdongFolder.id})`
      );

      // Step 6: Update project document with folder IDs
      await db.collection('projects').doc(projectId).update({
        driveFolderId: projectFolder.id,
        driveFolderUrl: projectFolder.webViewLink,
        driveCreatedAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      console.log(
        `Successfully created Drive folders for project ${projectId}.`
      );
    } catch (error) {
      console.error(
        `Error creating Drive folders for project ${projectId}:`,
        error
      );
    }
  }
);

/**
 * Deletes all tasks associated with a project when the project is deleted.
 */
export const onProjectDeleted = onDocumentDeleted(
  {
    document: 'projects/{projectId}',
    region: 'asia-southeast1',
  },
  async (event) => {
    const { projectId } = event.params;
    console.log(`Project ${projectId} deleted. Deleting associated tasks...`);

    const tasksRef = db.collection('tasks');
    const query = tasksRef.where('projectId', '==', projectId);

    try {
      const snapshot = await query.get();
      if (snapshot.empty) {
        console.log(`No tasks found for project ${projectId}.`);
        return;
      }

      const batch = db.batch();
      snapshot.docs.forEach((doc) => {
        batch.delete(doc.ref);
      });

      await batch.commit();
      console.log(
        `Successfully deleted ${snapshot.size} tasks for project ${projectId}.`
      );
    } catch (error) {
      console.error(`Error deleting tasks for project ${projectId}:`, error);
    }
  }
);

/**
 * Helper function to find a folder by name in a parent folder or create it if it doesn't exist
 */
async function findOrCreateFolder(drive, folderName, parentFolderId) {
  // Search for folder
  const response = await drive.files.list({
    q: `name='${folderName}' and '${parentFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
    fields: 'files(id, name, webViewLink)',
  });

  // If folder exists, return it
  if (response.data.files && response.data.files.length > 0) {
    return response.data.files[0];
  }

  // Otherwise create new folder
  return createFolder(drive, folderName, parentFolderId);
}

/**
 * Helper function to create a new folder
 */
async function createFolder(drive, folderName, parentFolderId) {
  const folderMetadata = {
    name: folderName,
    mimeType: 'application/vnd.google-apps.folder',
    parents: [parentFolderId],
  };

  const folder = await drive.files.create({
    requestBody: folderMetadata,
    fields: 'id, name, webViewLink',
  });

  return folder.data;
}

import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';
import * as XLSX from 'xlsx';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { CallableContext } from 'firebase-functions/v1/https';

// Get references to services (but don't reinitialize admin)
const storage = admin.storage();
const bucket = storage.bucket();

// Interface for the Excel formatted data
interface ExcelQuotationData {
  metadata: {
    companyName: string;
    companyAddress: string;
    companyPhone: string;
    companyEmail: string;
    taxCode: string;
    customerName: string;
    customerAddress: string;
    quotationNumber: string;
    quotationDate: string;
    projectName: string;
    quoteValidity: string;
  };
  materials: Array<{
    no: number;
    name: string;
    unit: string;
    quantity: number;
    unitPrice: number;
    total: number;
  }>;
  summary: {
    subTotal: number;
    discountPercentage: number;
    discountAmount: number;
    vatPercentage: number;
    vatAmount: number;
    grandTotal: number;
    amountInWords: string;
  };
}

/**
 * Generates an Excel file based on the quotation data and template
 * @param {ExcelQuotationData} formattedData The formatted data for Excel
 * @returns {Buffer} The Excel file as a buffer
 */
function generateExcelFile(formattedData: ExcelQuotationData): Buffer {
  // Create a new workbook and worksheet
  const workbook = XLSX.utils.book_new();
  const worksheet = XLSX.utils.aoa_to_sheet([]);

  // Set column widths
  const colWidths = [
    { wch: 5 }, // A - STT
    { wch: 40 }, // B - Tên gọi
    { wch: 15 }, // C - Vật liệu
    { wch: 10 }, // D - ĐVT
    { wch: 10 }, // E - SL
    { wch: 15 }, // F - Đơn giá
    { wch: 20 }, // G - Thành Tiền
    { wch: 15 }, // H
  ];
  worksheet['!cols'] = colWidths;

  // Add company logo placeholder in cell A1-B8
  // Logo would be added manually or could be implemented with additional code

  // Populate header section based on the template screenshot - Right side header (Company info)
  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['CÔNG TY TNHH SẢN XUẤT CƠ KHÍ THƯƠNG MẠI']],
    { origin: 'D1' }
  );

  XLSX.utils.sheet_add_aoa(worksheet, [['DỊCH VỤ TÂN HÒA PHÁT']], {
    origin: 'D2',
  });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['ĐC: Số 7 Quốc lộ 1A ,KP3B,Phường Thanh Lộc,Quận']],
    { origin: 'D3' }
  );

  XLSX.utils.sheet_add_aoa(worksheet, [['12,TP.HCM']], { origin: 'D4' });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['MST: 0315155409', 'Web:cokhitanhoaphat.com.vn']],
    { origin: 'D5' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Email :chomcauinoxtanhoaphat.com.vn']],
    { origin: 'D6' }
  );

  XLSX.utils.sheet_add_aoa(worksheet, [['Hotline 24/7: 0978.268.559']], {
    origin: 'D7',
  });

  // Add quotation title
  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['BẢNG BÁO GIÁ KIỂM XÁC NHẬN ĐẶT HÀNG']],
    { origin: 'B3' }
  );

  // Add quotation info - Date and number
  XLSX.utils.sheet_add_aoa(worksheet, [['Ngày']], { origin: 'F4' });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [[formattedData.metadata.quotationDate]],
    { origin: 'G4' }
  );

  XLSX.utils.sheet_add_aoa(worksheet, [['SỐ']], { origin: 'F5' });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [[formattedData.metadata.quotationNumber]],
    { origin: 'G5' }
  );

  // Add customer info section starting at B10
  XLSX.utils.sheet_add_aoa(worksheet, [['KÍNH GỬI:']], { origin: 'B9' });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Địa chỉ:', formattedData.metadata.customerAddress]],
    { origin: 'B10' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Tel', ':', '', '', 'MST', ':', '', 'FAX']],
    { origin: 'B11' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Email', ':', '', '', 'Attn', ':', '', 'Mobile:']],
    { origin: 'B12' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [
      [
        'Trước hết Công Ty Tân Hòa Phát xin chân thành cảm ơn sự quan tâm & hợp tác của Quý Khách. Chúng tôi xin gửi tới Quý khách báo giá các chủng loại sau:',
      ],
    ],
    { origin: 'B14' }
  );

  // Add table header for materials
  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['STT', 'Tên gọi', 'Vật liệu', 'ĐVT', 'SL', 'Đơn giá', 'Thành Tiền']],
    { origin: 'B16' }
  );

  // Add material rows
  let currentRow = 17;
  formattedData.materials.forEach((item) => {
    XLSX.utils.sheet_add_aoa(
      worksheet,
      [
        [
          item.no,
          item.name,
          '',
          item.unit,
          item.quantity,
          item.unitPrice,
          item.total,
        ],
      ],
      { origin: `B${currentRow}` }
    );
    currentRow++;
  });

  // Add summary section after materials
  // Calculate appropriate summary row position based on materials
  const summaryStartRow = Math.max(currentRow + 1, 17); // Ensure at least some space after last material

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Tổng cộng', formattedData.summary.subTotal]],
    { origin: `F${summaryStartRow}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Thuế VAT 10%', formattedData.summary.vatAmount]],
    { origin: `F${summaryStartRow + 1}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Tổng cộng đã bao gồm VAT 10%', formattedData.summary.grandTotal]],
    { origin: `F${summaryStartRow + 2}` }
  );

  // Add amount in words
  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Bằng chữ:', formattedData.summary.amountInWords]],
    { origin: `B${summaryStartRow + 4}` }
  );

  // Add ghi chú section
  XLSX.utils.sheet_add_aoa(worksheet, [['Ghi chú:']], {
    origin: `B${summaryStartRow + 6}`,
  });

  // Add terms and conditions
  let termsRow = summaryStartRow + 8;

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [
      [
        '1. Báo giá có hiệu lực trong 7 ngày. Hết hiệu lực xin liên hệ lại cho Công ty.',
      ],
    ],
    { origin: `C${termsRow}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['2. Thời gian giao hàng: 3 ngày ( không bao gồm chủ nhật, ngày lễ )']],
    { origin: `C${termsRow + 1}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['3. Giá đã bao gồm VAT và không bao gồm vận chuyển']],
    { origin: `C${termsRow + 2}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['4. Địa điểm giao hàng: kho bên Bán']],
    { origin: `C${termsRow + 3}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [
      [
        '5. Phương thức thanh toán: Quý Khách hàng vui lòng thanh toán bằng chuyển khoản để xuất hóa đơn:',
      ],
    ],
    { origin: `C${termsRow + 4}` }
  );

  XLSX.utils.sheet_add_aoa(worksheet, [['Tài khoản số: 27888866']], {
    origin: `C${termsRow + 5}`,
  });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Tên tài khoản: Công ty TNHH SX cơ khí TM-DV Tân Hòa Phát']],
    { origin: `C${termsRow + 6}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Ngân hàng TMCP Á Châu - Chi nhánh: Tam Hà, Thủ Đức']],
    { origin: `C${termsRow + 7}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Tạm ứng 50%, Thanh toán 50% trước khi nhận hàng']],
    { origin: `C${termsRow + 8}` }
  );

  // Add the worksheet to the workbook
  XLSX.utils.book_append_sheet(workbook, worksheet, 'Báo giá');

  // Generate Excel file as buffer
  const excelBuffer = XLSX.write(workbook, {
    type: 'buffer',
    bookType: 'xlsx',
  });
  return excelBuffer;
}

/**
 * Firebase Callable Function that generates an Excel quotation
 * Uploads the Excel to Firebase Storage and returns a public URL
 */
export const generateExcelQuotation = functions
  .runWith({
    timeoutSeconds: 300, // Increased timeout
    memory: '512MB', // Increased memory
  })
  .https.onCall(
    async (
      data: {
        formattedData: ExcelQuotationData;
        projectId: string;
      },
      context: CallableContext
    ) => {
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'Bạn cần đăng nhập để sử dụng tính năng này.'
        );
      }

      const { formattedData, projectId } = data;

      if (!formattedData) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Không tìm thấy dữ liệu báo giá.'
        );
      }

      if (!projectId) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Không tìm thấy ID dự án.'
        );
      }

      try {
        // Generate Excel buffer
        const excelBuffer = generateExcelFile(formattedData);

        // Save to temp file
        const quotationNumber = formattedData.metadata.quotationNumber.replace(
          /\//g,
          '-'
        );
        const tempExcelPath = path.join(os.tmpdir(), `${quotationNumber}.xlsx`);
        fs.writeFileSync(tempExcelPath, excelBuffer);

        // Upload to Firebase Storage
        const fileName = `excel_quotations/${projectId}/${quotationNumber}.xlsx`;
        const file = bucket.file(fileName);

        await file.save(fs.readFileSync(tempExcelPath), {
          metadata: {
            contentType:
              'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
          },
        });

        // Clean up temp file
        fs.unlinkSync(tempExcelPath);

        // Make the file publicly accessible
        await file.makePublic();

        // Return the public URL
        const excelUrl = `https://storage.googleapis.com/${bucket.name}/${fileName}`;
        return { excelUrl };
      } catch (error: any) {
        console.error('Error generating Excel:', error);
        throw new functions.https.HttpsError(
          'internal',
          `Lỗi tạo file Excel: ${error.message || 'Unknown error'}`,
          error
        );
      }
    }
  );

import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';

/**
 * savePOReceiptConfirmation
 * Updates the purchase order document with receipt confirmation data
 * This function only updates the Firestore document, it doesn't upload any files
 * It now also automatically adds received items to inventory
 */
export const savePOReceiptConfirmation = functions
  .region('asia-southeast1')
  .runWith({ timeoutSeconds: 60, memory: '256MB' })
  .https.onCall(async (data, context) => {
    // Authentication check
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Bạn cần đăng nhập'
      );
    }

    const {
      poId,
      projectId,
      filesToSave,
      remarks = '',
    } = data as {
      poId?: string;
      projectId?: string;
      filesToSave?: Array<{
        id: string;
        name: string;
        url: string;
        mimeType?: string;
      }>;
      remarks?: string;
    };

    // Validate required parameters
    if (!poId || !projectId || !filesToSave) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thiếu tham số bắt buộc'
      );
    }

    try {
      const db = admin.firestore();
      const poRef = db.collection('purchase_orders').doc(poId);
      const poSnap = await poRef.get();

      if (!poSnap.exists) {
        throw new functions.https.HttpsError('not-found', 'Không tìm thấy PO');
      }

      const poData = poSnap.data();

      // Get current user info for transaction records
      const userDoc = await db.collection('users').doc(context.auth.uid).get();
      const userName = userDoc.exists
        ? userDoc.data()?.displayName || 'Người dùng'
        : 'Người dùng';

      // Update PO document
      await poRef.update({
        status: 'received',
        receivedAt: admin.firestore.FieldValue.serverTimestamp(),
        receiptPhotos: filesToSave,
        receiptRemarks: remarks,
        updatedBy: context.auth.uid,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      // Automatically add received items to inventory
      if (poData && poData.materials && Array.isArray(poData.materials)) {
        console.log(
          `Processing ${poData.materials.length} materials for inventory`
        );

        for (const material of poData.materials) {
          try {
            // First, check if the item already exists in inventory by code or name
            let inventoryQuery: FirebaseFirestore.Query<FirebaseFirestore.DocumentData> =
              db.collection('inventory');

            // If the material has a code, search by code which is more reliable
            if (material.code) {
              inventoryQuery = inventoryQuery.where(
                'code',
                '==',
                material.code
              );
            } else if (material.name) {
              inventoryQuery = inventoryQuery.where(
                'name',
                '==',
                material.name
              );
            } else {
              // Skip items without code or name
              console.log('Skipping material without code or name');
              continue;
            }

            const inventorySnap = await inventoryQuery.get();

            if (inventorySnap.empty) {
              // Item doesn't exist - create new inventory item
              console.log(`Creating new inventory item: ${material.name}`);

              const newItemData = {
                name: material.name,
                code:
                  material.code ||
                  `AUTO-${Date.now()}-${Math.round(Math.random() * 1000)}`,
                description: material.description || '',
                material: material.material || '',
                categoryId: material.categoryId || '',
                unit: material.unit || 'cái',
                stockQuantity: material.quantity || 0,
                minQuantity: 0,
                price: material.price || 0,
                weight: material.weight || 0,
                totalPrice: (material.quantity || 0) * (material.price || 0),
                createdAt: admin.firestore.FieldValue.serverTimestamp(),
                updatedAt: admin.firestore.FieldValue.serverTimestamp(),
              };

              const newItemRef = await db
                .collection('inventory')
                .add(newItemData);

              // Create a transaction record for this new item
              await db.collection('inventory_transactions').add({
                itemId: newItemRef.id,
                type: 'in',
                quantity: material.quantity || 0,
                date: admin.firestore.FieldValue.serverTimestamp(),
                reason: `Nhận hàng từ PO: ${poData.poNumber || poId}`,
                createdBy: context.auth.uid,
                createdByName: userName,
                projectId: projectId,
                poId: poId,
              });
            } else {
              // Item exists - update quantity
              const itemDoc = inventorySnap.docs[0];
              const itemData = itemDoc.data();
              const currentQuantity = itemData.stockQuantity || 0;
              const newQuantity = currentQuantity + (material.quantity || 0);

              console.log(
                `Updating existing inventory item ${itemDoc.id}: ${itemData.name}, adding ${material.quantity} to current ${currentQuantity}`
              );

              // Update the inventory item with new quantity
              await db
                .collection('inventory')
                .doc(itemDoc.id)
                .update({
                  stockQuantity: newQuantity,
                  updatedAt: admin.firestore.FieldValue.serverTimestamp(),
                  // Update price if the new one is provided and different
                  ...(material.price && material.price !== itemData.price
                    ? { price: material.price }
                    : {}),
                  // Update totalPrice based on new quantity and price
                  totalPrice:
                    newQuantity * (material.price || itemData.price || 0),
                });

              // Create a transaction record for this update
              await db.collection('inventory_transactions').add({
                itemId: itemDoc.id,
                type: 'in',
                quantity: material.quantity || 0,
                date: admin.firestore.FieldValue.serverTimestamp(),
                reason: `Nhận hàng từ PO: ${poData.poNumber || poId}`,
                createdBy: context.auth.uid,
                createdByName: userName,
                projectId: projectId,
                poId: poId,
              });
            }
          } catch (itemError) {
            // Log error but continue with other items
            console.error(
              `Error processing inventory item ${material.name}:`,
              itemError
            );
          }
        }
      }

      return {
        success: true,
        message: 'PO đã được xác nhận và vật tư đã được thêm vào kho tự động.',
      };
    } catch (err: any) {
      console.error('savePOReceiptConfirmation error', err);
      throw new functions.https.HttpsError(
        'internal',
        err.message || 'Lỗi xử lý xác nhận PO'
      );
    }
  });

import * as functions from 'firebase-functions/v2';
import * as admin from 'firebase-admin';
import { Timestamp } from 'firebase-admin/firestore';

const db = admin.firestore();

/**
 * Scheduled function to aggregate financial data for the director's dashboard
 * Runs daily at 1:00 AM Vietnam time
 */
export const aggregateDashboardData = functions.scheduler.onSchedule(
  {
    schedule: '0 1 * * *',
    timeZone: 'Asia/Ho_Chi_Minh',
    region: 'asia-southeast1',
  },
  async (context) => {
    try {
      console.log('Starting dashboard data aggregation');

      // Get all payable transactions
      const payableSnapshot = await db.collection('payable_transactions').get();
      const transactions = payableSnapshot.docs.map((doc) => doc.data());

      // Calculate total accounts payable (phải trả)
      const payableTransactions = transactions.filter(
        (t) => t.type === 'payable'
      );
      const totalAccountsPayable = payableTransactions.reduce(
        (sum, t) => sum + (t.remainingAmount || 0),
        0
      );

      // Calculate total accounts receivable (phải thu)
      const receivableTransactions = transactions.filter(
        (t) => t.type === 'receivable'
      );
      const totalAccountsReceivable = receivableTransactions.reduce(
        (sum, t) => sum + (t.remainingAmount || 0),
        0
      );

      // Calculate net debt position (negative means company owes more than it's owed)
      const netDebtPosition = totalAccountsReceivable - totalAccountsPayable;

      // Calculate top 5 suppliers by outstanding amount (phải trả)
      const supplierTotals: Record<string, number> = {};
      payableTransactions.forEach((t) => {
        if (!supplierTotals[t.supplier]) {
          supplierTotals[t.supplier] = 0;
        }
        supplierTotals[t.supplier] += t.remainingAmount || 0;
      });

      const top5Payable = Object.entries(supplierTotals)
        .map(([supplier, amount]) => ({ supplier, amount }))
        .sort((a, b) => b.amount - a.amount)
        .slice(0, 5)
        .map((item) => ({
          ...item,
          // Convert to millions for display
          amountInMillions:
            Math.round((Number(item.amount) / 1000000) * 100) / 100,
        }));

      // Calculate top 5 customers by outstanding amount (phải thu)
      const customerTotals: Record<string, number> = {};
      receivableTransactions.forEach((t) => {
        if (!customerTotals[t.supplier]) {
          // supplier field is used for both suppliers and customers
          customerTotals[t.supplier] = 0;
        }
        customerTotals[t.supplier] += t.remainingAmount || 0;
      });

      const top5Receivable = Object.entries(customerTotals)
        .map(([customer, amount]) => ({ customer, amount }))
        .sort((a, b) => b.amount - a.amount)
        .slice(0, 5)
        .map((item) => ({
          ...item,
          // Convert to millions for display
          amountInMillions:
            Math.round((Number(item.amount) / 1000000) * 100) / 100,
        }));

      // Save aggregated data to Firestore
      await db
        .collection('summaries')
        .doc('directorDashboard')
        .set({
          totalAccountsPayable,
          totalAccountsReceivable,
          netDebtPosition,
          top5Payable,
          top5Receivable,
          lastUpdated: Timestamp.now(),
          formattedTotals: {
            totalAccountsPayable: formatCurrency(totalAccountsPayable),
            totalAccountsReceivable: formatCurrency(totalAccountsReceivable),
            netDebtPosition: formatCurrency(netDebtPosition),
          },
        });

      console.log('Dashboard data aggregation completed successfully');
    } catch (error) {
      console.error('Error aggregating dashboard data:', error);
      throw error;
    }
  }
);

/**
 * Format currency for display (VND)
 */
function formatCurrency(amount: number): string {
  return new Intl.NumberFormat('vi-VN', {
    style: 'currency',
    currency: 'VND',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(amount);
}

//functions/src/taskTriggers.ts
import { onDocumentWritten } from 'firebase-functions/v2/firestore';
import * as admin from 'firebase-admin';

const db = admin.firestore();

// --- Helper Functions ---

/**
 * Fetches users from Firestore based on their role.
 * @param {string | string[]} roles The role or roles to query for.
 * @returns {Promise<any[]>} An array of user objects.
 */
const getUsersByRole = async (roles: string | string[]): Promise<any[]> => {
  const rolesArray = Array.isArray(roles) ? roles : [roles];
  if (rolesArray.length === 0) return [];
  try {
    const usersRef = db.collection('users');
    // Firestore "in" query supports up to 10 elements. If more are needed,
    // multiple queries would be required. For now, this is sufficient.
    const querySnapshot = await usersRef.where('role', 'in', rolesArray).get();
    return querySnapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
  } catch (error) {
    console.error(`Error fetching users by role: ${roles}`, error);
    return [];
  }
};

/**
 * Sends a push notification to a list of users.
 * @param {any[]} users An array of user objects, must include fcmToken.
 * @param {string} title The notification title.
 * @param {string} body The notification body.
 * @returns {Promise<any>} A promise that resolves when all messages are sent.
 */
const sendNotificationToUsers = (
  users: any[],
  title: string,
  body: string
): Promise<any> => {
  const tokens = users.map((user) => user.fcmToken).filter((token) => token); // Filter out users without tokens

  if (tokens.length === 0) {
    return Promise.resolve();
  }
  // FCM"s sendToDevice supports up to 1000 tokens.
  return admin.messaging().sendToDevice(tokens, {
    notification: { title, body, sound: 'default' },
  });
};

/**
 * Fetches a user"s display name from their UID.
 * @param {string} uid The user"s ID.
 * @returns {Promise<string>} The user"s name or a fallback string.
 */
const getUserName = async (uid: string): Promise<string> => {
  if (!uid) return 'Hệ thống';
  try {
    const userRecord = await admin.auth().getUser(uid);
    return userRecord.displayName || userRecord.email || 'Người dùng không tên';
  } catch (error) {
    console.error(`Error fetching user data for UID: ${uid}`, error);
    return 'Người dùng không tồn tại';
  }
};

/**
 * Gets the human-readable label for a task key.
 * @param {string} taskKey The key of the task (e.g., "material_cutting").
 * @param {any} taskData The data object for the task, used for custom task names.
 * @returns {string} The display label for the task.
 */
const getTaskLabel = (taskKey: string, taskData: any): string => {
  const taskLabels: { [key: string]: string } = {
    material_separation: 'Bóc tách vật tư',
    quotation: 'Báo giá',
    material_purchasing: 'Mua vật tư & phụ kiện',
    material_cutting: 'Cắt phôi',
    assembly: 'Lắp ráp',
    painting: 'Sơn',
    shipping: 'Vận chuyển',
    other: taskData?.name || 'Công việc khác',
  };
  return taskLabels[taskKey] || 'Công việc không xác định';
};

/**
 * Denormalizes a single task into the top-level "tasks" collection.
 * @param {string} projectId The project ID.
 * @param {string} projectName The project name.
 * @param {string} projectStatus The project status.
 * @param {string} taskKey The key of the task.
 * @param {any} taskData The data of the task.
 * @returns {Promise<any>} A promise that resolves when the write is complete.
 */
const denormalizeTask = async (
  projectId: string,
  projectName: string,
  projectStatus: string,
  taskKey: string,
  taskData: any
) => {
  const assignedToId = taskData.assignedTo || null;
  const assignedToName = await getUserName(assignedToId);
  const denormalizedTask = {
    projectId,
    projectName,
    projectStatus,
    taskKey,
    taskLabel: getTaskLabel(taskKey, taskData),
    status: taskData.status || 'pending',
    assignedToId,
    assignedToName,
    startDate: taskData.startDate || null,
    endDate: taskData.endDate || null,
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
  };
  const docId = `${projectId}_${taskKey}`;
  return db
    .collection('tasks')
    .doc(docId)
    .set(denormalizedTask, { merge: true });
};

// --- Main Cloud Function Trigger ---

export const projectWorkflowManager = onDocumentWritten(
  {
    document: 'projects/{projectId}',
    region: 'asia-southeast1',
  },
  async (event) => {
    const { projectId } = event.params;
    const beforeData = event.data?.before.data();
    const afterData = event.data?.after.data();

    if (!afterData) {
      console.log(`Project ${projectId} deleted. No action taken.`);
      return null;
    }

    const projectName = afterData.name || 'Dự án không tên';
    const updates: { [key: string]: any } = {};
    const notificationPromises: Promise<any>[] = [];

    // --- Workflow Triggers ---

    // Trigger 1: Project Creation
    if (!beforeData) {
      const engineers = await getUsersByRole('ky_su');
      if (engineers.length > 0) {
        const engineerToAssign = engineers[0];
        updates['tasks.material_separation.assignedTo'] = engineerToAssign.id;
        notificationPromises.push(
          sendNotificationToUsers(
            [engineerToAssign],
            'Nhiệm vụ mới',
            `Bạn được giao nhiệm vụ "Tách vật liệu" cho dự án mới: ${projectName}.`
          )
        );
      }
    }

    // ---- NEW WORKFLOW LOGIC ----
    const beforeStages: any[] = beforeData?.workflowStages || [];
    const afterStages: any[] = afterData.workflowStages || [];

    // Detect status change to completed for material_separation
    const justCompleted = afterStages.find((stageAfter) => {
      if (stageAfter.processKey !== 'material_separation') return false;
      const beforeStage = beforeStages.find(
        (s) => s.stageId === stageAfter.stageId
      );
      return (
        beforeStage?.status !== 'completed' && stageAfter.status === 'completed'
      );
    });

    if (justCompleted) {
      // Find next stage by order
      const nextStage = afterStages
        .filter((s) => s.order > justCompleted.order)
        .sort((a, b) => a.order - b.order)[0];

      if (nextStage && nextStage.processKey === 'quotation') {
        const usersToNotify = await getUsersByRole(['thuong_mai', 'giam_doc']);
        const salesUser = usersToNotify.find((u) => u.role === 'thuong_mai');

        if (salesUser) {
          // update array element
          const newStages = afterStages.map((s) =>
            s.stageId === nextStage.stageId
              ? { ...s, assignedToId: salesUser.id }
              : s
          );
          updates['workflowStages'] = newStages;
        }

        notificationPromises.push(
          sendNotificationToUsers(
            usersToNotify,
            'Yêu cầu báo giá',
            `Kỹ sư đã hoàn thành bóc tách vật liệu cho dự án ${projectName}. Vui lòng tiến hành báo giá.`
          )
        );
      }
    }

    // Trigger 3: Project Approved -> Assign Purchasing & Cutting
    if (
      beforeData?.status === 'pending' &&
      afterData.status === 'in-progress'
    ) {
      // a. Assign Material Purchasing
      const purchasingUsers = await getUsersByRole(['thuong_mai', 'ke_toan']);
      const salesUser = purchasingUsers.find((u) => u.role === 'thuong_mai');
      if (salesUser) {
        updates['tasks.material_purchasing.assignedTo'] = salesUser.id;
      }
      notificationPromises.push(
        sendNotificationToUsers(
          purchasingUsers,
          'Yêu cầu mua vật tư',
          `Dự án ${projectName} đã được duyệt. Vui lòng tiến hành mua vật tư.`
        )
      );

      // b. Assign Material Cutting
      const cuttingEngineers = await getUsersByRole('ky_su_cat_phoi');
      if (cuttingEngineers.length > 0) {
        const engineerToAssign = cuttingEngineers[0];
        updates['tasks.material_cutting.assignedTo'] = engineerToAssign.id;
        notificationPromises.push(
          sendNotificationToUsers(
            [engineerToAssign],
            'Nhiệm vụ mới',
            `Bạn được giao nhiệm vụ "Cắt phôi" cho dự án ${projectName}.`
          )
        );
      }
    }

    // Trigger 4: Material Cutting Completed -> Assign Assembly & Painting
    if (
      beforeData?.tasks.material_cutting?.status !== 'completed' &&
      afterData.tasks.material_cutting?.status === 'completed'
    ) {
      const viceDirectors = await getUsersByRole('pho_giam_doc');
      if (viceDirectors.length > 0) {
        const userToAssign = viceDirectors[0];
        updates['tasks.assembly.assignedTo'] = userToAssign.id;
        updates['tasks.painting.assignedTo'] = userToAssign.id;
        notificationPromises.push(
          sendNotificationToUsers(
            viceDirectors,
            'Yêu cầu giám sát',
            `Công đoạn Cắt phôi đã xong. Vui lòng giám sát và thực hiện Lắp ráp & Sơn cho dự án ${projectName}.`
          )
        );
      }
    }

    // Trigger 5: Assembly & Painting Completed -> Assign Shipping
    if (
      afterData.tasks.assembly?.status === 'completed' &&
      afterData.tasks.painting?.status === 'completed' &&
      (beforeData?.tasks.assembly?.status !== 'completed' ||
        beforeData?.tasks.painting?.status !== 'completed')
    ) {
      const usersToNotify = await getUsersByRole(['ke_toan', 'pho_giam_doc']);
      const accountant = usersToNotify.find((u) => u.role === 'ke_toan');

      if (accountant) {
        updates['tasks.shipping.assignedTo'] = accountant.id;
      }
      notificationPromises.push(
        sendNotificationToUsers(
          usersToNotify,
          'Yêu cầu vận chuyển',
          `Dự án ${projectName} đã sẵn sàng. Vui lòng sắp xếp vận chuyển.`
        )
      );
    }

    // --- Denormalization Logic (runs on any task change) ---
    const denormalizationPromises: Promise<any>[] = [];
    const beforeTasks = beforeData?.tasks || {};
    const afterTasks = afterData.tasks || {};

    for (const taskKey in afterTasks) {
      if (
        Object.prototype.hasOwnProperty.call(afterTasks, taskKey) &&
        JSON.stringify(beforeTasks[taskKey]) !==
          JSON.stringify(afterTasks[taskKey])
      ) {
        denormalizationPromises.push(
          denormalizeTask(
            projectId,
            projectName,
            afterData.status,
            taskKey,
            afterTasks[taskKey]
          )
        );
      }
    }

    // --- Execute Updates and Notifications ---
    const allPromises: Promise<any>[] = [
      ...notificationPromises,
      ...denormalizationPromises,
    ];

    if (Object.keys(updates).length > 0 && event.data) {
      // Add timestamp to avoid recursive triggers for the same update
      updates['workflowUpdatedAt'] =
        admin.firestore.FieldValue.serverTimestamp();
      allPromises.push(event.data.after.ref.update(updates));
    }

    return Promise.all(allPromises);
  }
);

import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';
import { google } from 'googleapis';
import * as path from 'path';
import { Readable } from 'stream';

const db = admin.firestore();

// Helper to build an authenticated Drive client
const getDriveClient = async () => {
  const auth = new google.auth.GoogleAuth({
    keyFile: path.join(__dirname, '../tanyb-fe4bf-4fbd5c01b6c7.json'),
    scopes: ['https://www.googleapis.com/auth/drive'],
  });
  return google.drive({ version: 'v3', auth });
};

/**
 * Callable Function: uploadFileToDrive
 * Uploads a base64 file to the "QC_Reports" subfolder of the project's Drive folder.
 * Returns the fileId and webViewLink.
 */
export const uploadFileToDrive = functions
  .region('asia-southeast1')
  .runWith({ timeoutSeconds: 300, memory: '1GB' })
  .https.onCall(async (data, context) => {
    // Authentication check
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Bạn cần đăng nhập để sử dụng tính năng này.'
      );
    }

    const { projectId, fileName, mimeType, base64Data } = data as {
      projectId?: string;
      fileName?: string;
      mimeType?: string;
      base64Data?: string;
    };

    // Validate parameters
    if (!projectId || !fileName || !mimeType || !base64Data) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thiếu tham số (projectId, fileName, mimeType hoặc base64Data)'
      );
    }

    try {
      const projectSnap = await db.collection('projects').doc(projectId).get();
      const projectData = projectSnap.data();

      if (!projectData || !projectData.driveFolderId) {
        throw new functions.https.HttpsError(
          'failed-precondition',
          'Không tìm thấy thư mục Drive của dự án.'
        );
      }

      const drive = await getDriveClient();

      // Step 1: Find or create QC_Reports subfolder
      const folderQuery = await drive.files.list({
        q: `name='QC_Reports' and '${projectData.driveFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
        fields: 'files(id, name)',
        spaces: 'drive',
      });

      let qcFolderId: string | undefined;
      if (folderQuery.data.files && folderQuery.data.files.length > 0) {
        qcFolderId = folderQuery.data.files[0].id;
      } else {
        const folderRes = await drive.files.create({
          requestBody: {
            name: 'QC_Reports',
            mimeType: 'application/vnd.google-apps.folder',
            parents: [projectData.driveFolderId],
          },
          fields: 'id',
        });
        qcFolderId = folderRes.data.id;
      }

      if (!qcFolderId) {
        throw new functions.https.HttpsError(
          'internal',
          'Không thể tạo hoặc tìm QC_Reports folder.'
        );
      }

      // Step 2: Upload file
      const buffer = Buffer.from(base64Data, 'base64');
      const stream = Readable.from(buffer);

      const createRes = await drive.files.create({
        requestBody: {
          name: fileName,
          mimeType,
          parents: [qcFolderId],
        },
        media: {
          mimeType,
          body: stream,
        },
        fields: 'id, webViewLink, thumbnailLink, mimeType, webContentLink',
      });

      const newFile = createRes.data;

      // Step 3: Set permissions
      await drive.permissions.create({
        fileId: newFile.id!,
        requestBody: {
          role: 'reader',
          type: 'anyone',
        },
      });

      return {
        success: true,
        fileId: newFile.id,
        webViewLink: newFile.webViewLink,
        thumbnailLink: newFile.thumbnailLink || newFile.webContentLink || '',
        mimeType: newFile.mimeType,
      };
    } catch (error: any) {
      console.error('Error uploading file to Drive:', error);
      throw new functions.https.HttpsError(
        'internal',
        error.message || 'Không thể tải lên file Google Drive.'
      );
    }
  });

/**
 * Callable Function: deleteFileFromDrive
 * Deletes a file on Google Drive by fileId.
 */
export const deleteFileFromDrive = functions
  .region('asia-southeast1')
  .runWith({ timeoutSeconds: 60, memory: '256MB' })
  .https.onCall(async (data, context) => {
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Bạn cần đăng nhập.'
      );
    }

    const { fileId } = data as { fileId?: string };
    if (!fileId) {
      throw new functions.https.HttpsError('invalid-argument', 'Thiếu fileId.');
    }

    try {
      const drive = await getDriveClient();
      await drive.files.delete({ fileId });
      return { success: true };
    } catch (error: any) {
      console.error('Error deleting file from Drive:', error);
      throw new functions.https.HttpsError(
        'internal',
        error.message || 'Không thể xóa file Google Drive.'
      );
    }
  });

import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';
import { google } from 'googleapis';
import { Readable } from 'stream';

const db = admin.firestore();

export const uploadFileToDriveUser = functions
  .region('asia-southeast1')
  .runWith({ timeoutSeconds: 300, memory: '1GB' })
  .https.onCall(async (data, context) => {
    const { accessToken, projectId, fileName, mimeType, base64Data } = data as {
      accessToken?: string;
      projectId?: string;
      fileName?: string;
      mimeType?: string;
      base64Data?: string;
    };

    console.log(
      `[uploadFileToDriveUser] Starting upload for project ${projectId}, file: ${fileName}`
    );

    if (!accessToken) {
      console.error('[uploadFileToDriveUser] Missing accessToken');
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Thiếu accessToken'
      );
    }
    if (!projectId || !fileName || !mimeType || !base64Data) {
      console.error('[uploadFileToDriveUser] Missing required parameters');
      throw new functions.https.HttpsError('invalid-argument', 'Thiếu tham số');
    }

    try {
      const projectSnap = await db.collection('projects').doc(projectId).get();
      const projectData = projectSnap.data();
      if (!projectData || !projectData.driveFolderId) {
        console.error(
          `[uploadFileToDriveUser] Project folder not found for project ${projectId}`
        );
        throw new functions.https.HttpsError(
          'failed-precondition',
          'Không tìm thấy thư mục Drive của dự án.'
        );
      }

      console.log(
        `[uploadFileToDriveUser] Found project folder ID: ${projectData.driveFolderId}`
      );
      console.log(
        `[uploadFileToDriveUser] Project name: ${projectData.name || 'Unknown'}`
      );
      console.log(
        `[uploadFileToDriveUser] Project code: ${projectData.code || 'Unknown'}`
      );

      // Build Drive client with user's OAuth token
      const auth = new google.auth.OAuth2();
      auth.setCredentials({ access_token: accessToken });
      const drive = google.drive({ version: 'v3', auth });

      // Verify access token works by getting user info
      try {
        console.log(`[uploadFileToDriveUser] Verifying access token validity`);
        const aboutResponse = await drive.about.get({
          fields: 'user',
        });
        console.log(
          `[uploadFileToDriveUser] Access token valid for user: ${
            aboutResponse.data.user?.displayName || 'Unknown'
          }`
        );
      } catch (tokenError) {
        console.error(
          `[uploadFileToDriveUser] Access token verification failed:`,
          tokenError
        );
        throw new functions.https.HttpsError(
          'unauthenticated',
          'Google access token không hợp lệ hoặc đã hết hạn.'
        );
      }

      // Verify we can access the project folder
      try {
        console.log(
          `[uploadFileToDriveUser] Verifying access to project folder`
        );
        const folderInfo = await drive.files.get({
          fileId: projectData.driveFolderId,
          fields: 'id,name,mimeType',
        });
        console.log(
          `[uploadFileToDriveUser] Project folder accessible: ${folderInfo.data.name}`
        );
      } catch (folderError) {
        console.error(
          `[uploadFileToDriveUser] Cannot access project folder:`,
          folderError
        );
        throw new functions.https.HttpsError(
          'permission-denied',
          'Không có quyền truy cập thư mục dự án. Vui lòng kiểm tra quyền truy cập Google Drive.'
        );
      }

      console.log(
        `[uploadFileToDriveUser] Looking for QC_Reports folder in project folder`
      );
      // Find or create QC_Reports folder
      const listRes = await drive.files.list({
        q: `name='QC_Reports' and '${projectData.driveFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
        fields: 'files(id,name,parents)',
        spaces: 'drive',
      });

      console.log(
        `[uploadFileToDriveUser] QC_Reports folder search result:`,
        JSON.stringify(listRes.data.files)
      );

      let qcFolderId = listRes.data.files?.[0]?.id;

      if (!qcFolderId) {
        console.log(
          `[uploadFileToDriveUser] QC_Reports folder not found, creating new one`
        );
        const folderRes = await drive.files.create({
          requestBody: {
            name: 'QC_Reports',
            mimeType: 'application/vnd.google-apps.folder',
            parents: [projectData.driveFolderId],
          },
          fields: 'id,name,parents',
        });

        qcFolderId = folderRes.data.id!;
        console.log(
          `[uploadFileToDriveUser] Created new QC_Reports folder with ID: ${qcFolderId}`
        );
        console.log(
          `[uploadFileToDriveUser] New folder details:`,
          JSON.stringify(folderRes.data)
        );
      } else {
        console.log(
          `[uploadFileToDriveUser] Found existing QC_Reports folder with ID: ${qcFolderId}`
        );
      }

      // Verify we can access the QC_Reports folder
      try {
        console.log(
          `[uploadFileToDriveUser] Verifying access to QC_Reports folder`
        );
        const folderInfo = await drive.files.get({
          fileId: qcFolderId,
          fields: 'id,name,mimeType,parents',
        });
        console.log(
          `[uploadFileToDriveUser] QC_Reports folder accessible: ${folderInfo.data.name}`
        );
        console.log(
          `[uploadFileToDriveUser] QC_Reports folder parent: ${folderInfo.data.parents?.[0]}`
        );

        // Verify this folder is actually in the project folder
        if (folderInfo.data.parents?.[0] !== projectData.driveFolderId) {
          console.warn(
            `[uploadFileToDriveUser] WARNING: QC_Reports folder is not in the project folder!`
          );
          console.warn(
            `[uploadFileToDriveUser] Expected parent: ${projectData.driveFolderId}, Actual parent: ${folderInfo.data.parents?.[0]}`
          );
        }
      } catch (folderError) {
        console.error(
          `[uploadFileToDriveUser] Cannot access QC_Reports folder:`,
          folderError
        );
        throw new functions.https.HttpsError(
          'permission-denied',
          'Không có quyền truy cập thư mục QC_Reports. Vui lòng kiểm tra quyền truy cập Google Drive.'
        );
      }

      console.log(
        `[uploadFileToDriveUser] Preparing file upload to QC_Reports folder`
      );
      const buffer = Buffer.from(base64Data, 'base64');
      const stream = Readable.from(buffer);
      console.log(
        `[uploadFileToDriveUser] File buffer size: ${buffer.length} bytes`
      );

      // Log the file information before upload
      console.log(`[uploadFileToDriveUser] Uploading file with parameters:
        Name: ${fileName}
        MimeType: ${mimeType}
        Target folder: ${qcFolderId}
        File size: ${buffer.length} bytes`);

      const fileRes = await drive.files.create({
        requestBody: { name: fileName, mimeType, parents: [qcFolderId] },
        media: { mimeType, body: stream },
        fields:
          'id, webViewLink, thumbnailLink, mimeType, webContentLink, parents',
      });

      console.log(
        `[uploadFileToDriveUser] File uploaded successfully with ID: ${fileRes.data.id}`
      );
      console.log(
        `[uploadFileToDriveUser] File webViewLink: ${fileRes.data.webViewLink}`
      );
      console.log(
        `[uploadFileToDriveUser] File parent folder: ${fileRes.data.parents?.[0]}`
      );

      // Verify file was uploaded to correct folder
      if (fileRes.data.parents?.[0] !== qcFolderId) {
        console.warn(
          `[uploadFileToDriveUser] WARNING: File was not uploaded to the QC_Reports folder!`
        );
        console.warn(
          `[uploadFileToDriveUser] Expected parent: ${qcFolderId}, Actual parent: ${fileRes.data.parents?.[0]}`
        );
      }

      await drive.permissions.create({
        fileId: fileRes.data.id!,
        requestBody: { role: 'reader', type: 'anyone' },
      });
      console.log(`[uploadFileToDriveUser] Permissions set to public for file`);

      // Get file metadata to verify it exists
      try {
        const fileMetadata = await drive.files.get({
          fileId: fileRes.data.id!,
          fields: 'id,name,webViewLink,parents',
        });
        console.log(
          `[uploadFileToDriveUser] File verification - Name: ${fileMetadata.data.name}, Parent: ${fileMetadata.data.parents?.[0]}`
        );

        // List files in the QC_Reports folder to verify the file is there
        console.log(
          `[uploadFileToDriveUser] Listing files in QC_Reports folder to verify...`
        );
        const filesInFolder = await drive.files.list({
          q: `'${qcFolderId}' in parents and trashed=false`,
          fields: 'files(id,name)',
          spaces: 'drive',
        });

        console.log(
          `[uploadFileToDriveUser] Files in QC_Reports folder:`,
          JSON.stringify(filesInFolder.data.files)
        );

        // Check if our file is in the list
        const fileInFolder = filesInFolder.data.files?.find(
          (f) => f.id === fileRes.data.id
        );
        if (fileInFolder) {
          console.log(
            `[uploadFileToDriveUser] Confirmed file exists in QC_Reports folder`
          );
        } else {
          console.warn(
            `[uploadFileToDriveUser] WARNING: File not found in QC_Reports folder list!`
          );
        }
      } catch (verifyErr) {
        console.error(
          `[uploadFileToDriveUser] Error verifying file: ${verifyErr}`
        );
      }

      return {
        success: true,
        fileId: fileRes.data.id,
        webViewLink: fileRes.data.webViewLink,
        thumbnailLink:
          fileRes.data.thumbnailLink || fileRes.data.webContentLink,
        mimeType: fileRes.data.mimeType,
        fileName: fileName,
      };
    } catch (err: any) {
      console.error('[uploadFileToDriveUser] Error:', err);
      throw new functions.https.HttpsError(
        'internal',
        err.message || 'Lỗi nội bộ'
      );
    }
  });

// functions/src/index.ts

import * as functions from 'firebase-functions/v1';
import { google, sheets_v4 } from 'googleapis';
import { CallableContext } from 'firebase-functions/v1/https';
import * as admin from 'firebase-admin';

// Giả sử bạn đã định nghĩa kiểu này trong file types.ts
interface ExcelQuotationData {
  metadata: {
    projectName?: string;
    customerName?: string;
    customerAddress?: string;
    customerPhone?: string;
    customerEmail?: string;
    customerTaxCode?: string;
    customerContactPerson?: string;
    quotationNumber?: string;
    quoteValidity?: string;
    deliveryTime?: string;
  };
  materials: {
    isNote?: boolean; // Flag to identify note rows
    no: number;
    name: string;
    unit: string;
    quantity: number;
    unitPrice: number;
    total: number;
    material?: string;
    weight?: number; // Thêm trường weight để lưu khối lượng vật tư
  }[];
  summary: {
    subTotal: number;
    vatPercentage: number;
    vatAmount: number;
    grandTotal: number;
  };
}

// ----- CẤU HÌNH -----
const TEMPLATE_FILE_ID = '18CYrE8IHHbqNBc-FWrQw5kGnyLW31VDJOA4a1tusu4M';
// @ts-ignore - Keep for backward compatibility
const DESTINATION_FOLDER_ID = '18OrAEBSuZzz-AFbqlitz5gUxpsdunXjX';
const START_ROW_MATERIALS = 10; // Dựa theo ảnh, có vẻ là dòng 10
// URL ảnh chữ ký từ Firebase Storage - đã xóa bỏ
// const SIGNATURE_IMAGE_URL =
//   'https://storage.googleapis.com/tanyb-fe4bf.firebasestorage.app/signature.png';

// ----- HÀM CHÍNH -----
export const generateExcelQuotation = functions
  .region('asia-southeast1')
  .runWith({ timeoutSeconds: 300, memory: '512MB' })
  .https.onCall(
    async (
      data: {
        formattedData: ExcelQuotationData;
        projectId: string;
        accessToken: string;
      },
      context: CallableContext
    ) => {
      // ... (Phần xác thực và kiểm tra data giữ nguyên)
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'Bạn cần đăng nhập.'
        );
      }
      const { formattedData, projectId, accessToken } = data;
      if (!formattedData) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Dữ liệu không hợp lệ.'
        );
      }

      if (!projectId) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Thiếu ID dự án.'
        );
      }

      if (!accessToken) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Thiếu accessToken Google của người dùng.'
        );
      }

      // Sử dụng OAuth2 client của googleapis với accessToken người dùng
      const auth = new google.auth.OAuth2();
      auth.setCredentials({ access_token: accessToken });

      const drive = google.drive({ version: 'v3', auth });
      const sheets = google.sheets({ version: 'v4', auth });

      // Lấy thông tin dự án từ Firestore để tìm thư mục Drive
      const db = admin.firestore();
      const projectDoc = await db.collection('projects').doc(projectId).get();
      const projectData = projectDoc.data();

      if (!projectData || !projectData.driveFolderId) {
        throw new functions.https.HttpsError(
          'failed-precondition',
          'Không tìm thấy thông tin thư mục Drive của dự án.'
        );
      }

      try {
        // Tìm thư mục con 'baogia' trong thư mục dự án
        const baogiaFolderResponse = await drive.files.list({
          q: `name='baogia' and '${projectData.driveFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
          fields: 'files(id)',
        });

        // Nếu không tìm thấy thư mục baogia, tạo mới
        let baogiaFolderId;
        if (
          baogiaFolderResponse.data.files &&
          baogiaFolderResponse.data.files.length > 0
        ) {
          baogiaFolderId = baogiaFolderResponse.data.files[0].id;
        } else {
          // Tạo thư mục baogia nếu chưa có
          const folderResponse = await drive.files.create({
            requestBody: {
              name: 'baogia',
              mimeType: 'application/vnd.google-apps.folder',
              parents: [projectData.driveFolderId],
            },
            fields: 'id',
          });
          baogiaFolderId = folderResponse.data.id;
        }

        const newFileName = `Báo giá - ${
          formattedData.metadata.projectName || 'Dự án'
        } - ${new Date().toLocaleDateString('vi-VN').replace(/\//g, '-')}`;
        const copiedFileResponse = await drive.files.copy({
          fileId: TEMPLATE_FILE_ID,
          requestBody: { name: newFileName, parents: [baogiaFolderId] },
        });

        const newFileId = copiedFileResponse.data.id;
        if (!newFileId) throw new Error('Không thể sao chép file template.');

        const spreadsheet = await sheets.spreadsheets.get({
          spreadsheetId: newFileId,
          fields: 'sheets.properties',
        });
        const firstSheet = spreadsheet.data.sheets?.[0];
        const sheetId = firstSheet?.properties?.sheetId;
        if (sheetId === undefined || sheetId === null) {
          throw new Error('Không thể xác định sheetId của sheet đầu tiên');
        }

        // Tính toán vị trí các dòng
        const lastMaterialRow =
          START_ROW_MATERIALS + Math.max(0, formattedData.materials.length - 1);
        const totalRow = lastMaterialRow + 2;
        const vatRow = totalRow + 1;
        const totalWithVatRow = vatRow + 1;
        const amountInWordsRow = totalWithVatRow + 1;
        const blankRowAfterWords = amountInWordsRow + 1; // Dòng trống
        const notesRow = blankRowAfterWords + 1;
        const footerStartRow = notesRow + 1;
        const signatureRow = footerStartRow + 6;

        const requests: sheets_v4.Schema$Request[] = [];

        // Hủy bỏ merge cell ở vùng có thể gây lỗi
        requests.push({
          unmergeCells: {
            range: {
              sheetId,
              startRowIndex: START_ROW_MATERIALS - 1,
              endRowIndex: START_ROW_MATERIALS + 150, // Mở rộng vùng làm việc
              startColumnIndex: 0,
              endColumnIndex: 7,
            },
          },
        });

        // Xóa nội dung cũ trong vùng làm việc động để tránh dữ liệu thừa từ template
        requests.push({
          updateCells: {
            range: {
              sheetId,
              startRowIndex: START_ROW_MATERIALS - 1,
              endRowIndex: START_ROW_MATERIALS + 150, // Phải khớp với vùng unmerge
              startColumnIndex: 0,
              endColumnIndex: 7,
            },
            fields: 'userEnteredValue', // Chỉ xóa giá trị, giữ định dạng
          },
        });

        // Unmerge header rows 4-6 to avoid partial merge errors
        requests.push({
          unmergeCells: {
            range: {
              sheetId,
              startRowIndex: 3, // rows A4, A5, A6 index
              endRowIndex: 6,
              startColumnIndex: 0,
              endColumnIndex: 7,
            },
          },
        });

        // Cập nhật tên khách hàng vào ô A4
        // Merge cells A4-G4 for company name
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 3,
              endRowIndex: 4,
              startColumnIndex: 0,
              endColumnIndex: 7,
            },
          },
        });

        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: `KÍNH GỬI: ${
                        formattedData.metadata.customerName || ''
                      }`,
                    },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      verticalAlignment: 'MIDDLE',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: 3, columnIndex: 0 }, // A4 (0-indexed)
          },
        });

        // Add border to company name
        requests.push({
          updateBorders: {
            range: {
              sheetId,
              startRowIndex: 3,
              endRowIndex: 4,
              startColumnIndex: 0,
              endColumnIndex: 7,
            },
            top: { style: 'SOLID' },
            bottom: { style: 'SOLID' },
            left: { style: 'SOLID' },
            right: { style: 'SOLID' },
          },
        });

        // KHÔNG MERGE cells A5-G5 cho địa chỉ nữa
        // Thêm label "Địa chỉ:" vào A5
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: { stringValue: 'Địa chỉ:' },
                    userEnteredFormat: {
                      verticalAlignment: 'MIDDLE',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: 4, columnIndex: 0 }, // A5
          },
        });

        // Ghi địa chỉ vào ô B5 (không merge)
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: formattedData.metadata.customerAddress || '',
                    },
                    userEnteredFormat: {
                      wrapStrategy: 'WRAP',
                      verticalAlignment: 'MIDDLE',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: 4, columnIndex: 1 }, // B5
          },
        });

        // Merge cells B5:G5 sau khi đã thiết lập giá trị thành công
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 4,
              endRowIndex: 5,
              startColumnIndex: 1,
              endColumnIndex: 7,
            },
          },
        });

        // Add border to address row
        requests.push({
          updateBorders: {
            range: {
              sheetId,
              startRowIndex: 4,
              endRowIndex: 5,
              startColumnIndex: 0,
              endColumnIndex: 7,
            },
            top: { style: 'SOLID' },
            bottom: { style: 'SOLID' },
            left: { style: 'SOLID' },
            right: { style: 'SOLID' },
          },
        });

        // Cập nhật thông tin liên hệ khách hàng vào các ô tương ứng
        // Số điện thoại vào ô B6
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: formattedData.metadata.customerPhone || '',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue',
            start: { sheetId, rowIndex: 5, columnIndex: 1 }, // B6 (0-indexed)
          },
        });

        // Email vào ô B7 (với định dạng màu đen)
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: formattedData.metadata.customerEmail || '',
                    },
                    userEnteredFormat: {
                      textFormat: {
                        foregroundColor: { red: 0, green: 0, blue: 0 }, // Màu đen
                      },
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: 6, columnIndex: 1 }, // B7 (0-indexed)
          },
        });

        // Mã số thuế vào ô C6
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: 'MST:',
                    },
                    userEnteredFormat: {
                      textFormat: { bold: false }, // Bỏ bôi đậm
                      horizontalAlignment: 'LEFT',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: 5, columnIndex: 2 }, // C6
          },
        });

        // Tax code vào ô D6
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: formattedData.metadata.customerTaxCode || '',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue',
            start: { sheetId, rowIndex: 5, columnIndex: 3 }, // D6 (0-indexed)
          },
        });

        // Người liên hệ vào ô C7
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: 'Attn:',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue',
            start: { sheetId, rowIndex: 6, columnIndex: 2 }, // C7 (0-indexed)
          },
        });

        // Thêm tên người liên hệ vào ô D7
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue:
                        formattedData.metadata.customerContactPerson || '',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue',
            start: { sheetId, rowIndex: 6, columnIndex: 3 }, // D7 (0-indexed)
          },
        });

        if (formattedData.materials.length > 0) {
          const materialsRows: sheets_v4.Schema$RowData[] = [];
          let sttCounter = 1;

          formattedData.materials.forEach((material) => {
            const nameIsNoteMerge = (material.name || '')
              .toUpperCase()
              .includes('GHI CHÚ');
            const startsWithPlus = (material.name || '').trim().startsWith('+');
            const isNoteRow =
              material.isNote ||
              nameIsNoteMerge ||
              startsWithPlus ||
              ((!material.unit || material.unit === '') &&
                (material.quantity === null ||
                  material.quantity === undefined ||
                  material.quantity === 0) &&
                (!material.material || material.material === ''));

            // 额外检查其他特殊行格式
            const isSpecialRow =
              (material.name && material.name.includes('-----')) ||
              (material.name &&
                material.name.toLowerCase().includes('tổng phụ')) ||
              (material.name &&
                material.name.toLowerCase().includes('tạm tính'));

            // 所有需要特殊处理的行
            const shouldFormatAsNote = isNoteRow || isSpecialRow;

            if (shouldFormatAsNote) {
              // 根据行类型调整格式
              if (isSpecialRow) {
                // 对于特殊行（如总计小计等），使用特殊格式
                let bgColor = { red: 1, green: 1, blue: 0.9 }; // 默认浅黄色
                let fontStyle = { bold: true, italic: false };
                let alignment = 'CENTER';

                // 可以根据不同类型的特殊行设置不同的样式
                if (
                  material.name &&
                  material.name.toLowerCase().includes('tổng phụ')
                ) {
                  bgColor = { red: 0.9, green: 0.9, blue: 1 }; // 浅蓝色
                  alignment = 'RIGHT';
                } else if (
                  material.name &&
                  material.name.toLowerCase().includes('tạm tính')
                ) {
                  bgColor = { red: 0.9, green: 1, blue: 0.9 }; // 浅绿色
                  alignment = 'RIGHT';
                }

                materialsRows.push({
                  values: [
                    {
                      userEnteredValue: { stringValue: material.name || '' },
                      userEnteredFormat: {
                        textFormat: fontStyle,
                        horizontalAlignment: alignment,
                        verticalAlignment: 'MIDDLE',
                        backgroundColor: bgColor,
                      },
                    },
                    {},
                    {},
                    {},
                    {},
                    {},
                  ],
                });
              } else {
                // 原始备注行格式保持不变
                materialsRows.push({
                  values: [
                    {
                      userEnteredValue: { stringValue: material.name || '' },
                      userEnteredFormat: {
                        textFormat: { italic: true },
                        horizontalAlignment: 'LEFT',
                        verticalAlignment: 'MIDDLE',
                        backgroundColor: { red: 1, green: 1, blue: 0.9 },
                      },
                    },
                    {},
                    {},
                    {},
                    {},
                    {},
                  ],
                });
              }
            } else {
              materialsRows.push({
                values: [
                  {
                    userEnteredValue: { numberValue: sttCounter++ },
                    userEnteredFormat: {
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                    },
                  },
                  {
                    userEnteredValue: { stringValue: material.name || '' },
                    userEnteredFormat: {
                      horizontalAlignment: 'LEFT',
                      verticalAlignment: 'MIDDLE',
                    },
                  },
                  {
                    userEnteredValue: { stringValue: material.material || '' },
                    userEnteredFormat: {
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                    },
                  },
                  {
                    userEnteredValue: { stringValue: material.unit || '' },
                    userEnteredFormat: {
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                    },
                  },
                  {
                    userEnteredValue: {
                      numberValue: material.quantity ?? 0,
                    },
                    userEnteredFormat: {
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                    },
                  },
                  {
                    userEnteredValue: material.unitPrice
                      ? { numberValue: material.unitPrice }
                      : { stringValue: '' },
                    userEnteredFormat: {
                      numberFormat: { type: 'NUMBER', pattern: '#,##0' },
                      textFormat: { bold: material.unitPrice ? true : false },
                      verticalAlignment: 'MIDDLE',
                    },
                  },
                  {
                    userEnteredValue: material.total
                      ? { numberValue: material.total }
                      : { stringValue: '' },
                    userEnteredFormat: {
                      numberFormat: { type: 'NUMBER', pattern: '#,##0' },
                      textFormat: { bold: material.total ? true : false },
                      verticalAlignment: 'MIDDLE',
                    },
                  },
                ],
              });
            }
          });
          requests.push({
            updateCells: {
              rows: materialsRows,
              fields: 'userEnteredValue,userEnteredFormat',
              start: {
                sheetId,
                rowIndex: START_ROW_MATERIALS - 1,
                columnIndex: 0,
              },
            },
          });

          // Add merge requests for note rows and special rows between notes and total
          formattedData.materials.forEach((material, index) => {
            const nameIsNoteMerge = (material.name || '')
              .toUpperCase()
              .includes('GHI CHÚ');
            const startsWithPlusMerge = (material.name || '')
              .trim()
              .startsWith('+');

            // 扩展合并条件，包括备注行和需要合并的特殊行
            const isNoteRow =
              material.isNote ||
              nameIsNoteMerge ||
              startsWithPlusMerge ||
              ((!material.unit || material.unit === '') &&
                (material.quantity === null ||
                  material.quantity === undefined ||
                  material.quantity === 0) &&
                (!material.material || material.material === ''));

            // 需要合并的特殊行条件：备注行或其他需合并的特殊格式行
            const shouldMergeFullRow =
              isNoteRow ||
              // 这里可以添加其他需要合并的特殊行的判断条件
              (material.name && material.name.includes('-----')) ||
              (material.name &&
                material.name.toLowerCase().includes('tổng phụ')) ||
              (material.name &&
                material.name.toLowerCase().includes('tạm tính'));

            if (shouldMergeFullRow) {
              const noteRowIndex = START_ROW_MATERIALS - 1 + index;
              requests.push({
                mergeCells: {
                  range: {
                    sheetId,
                    startRowIndex: noteRowIndex,
                    endRowIndex: noteRowIndex + 1,
                    startColumnIndex: 0, // Column A
                    endColumnIndex: 7, // Up to column G (7 columns total)
                  },
                  mergeType: 'MERGE_ALL',
                },
              });
            }
          });
        }

        // --- Bắt đầu phần định dạng Footer ---
        const blueBg = { red: 200 / 255, green: 204 / 255, blue: 228 / 255 }; // #c8cce4
        const yellowBg = { red: 255 / 255, green: 255 / 255, blue: 204 / 255 };
        const boldRight = {
          horizontalAlignment: 'RIGHT',
          textFormat: { bold: true, fontSize: 11 },
          backgroundColor: blueBg,
        };
        const boldRightValue = {
          ...boldRight,
          numberFormat: { type: 'NUMBER', pattern: '#,##0' },
        };
        const boldCenterYellow = {
          horizontalAlignment: 'CENTER',
          verticalAlignment: 'MIDDLE',
          textFormat: { bold: true, italic: true, fontSize: 11 },
          backgroundColor: yellowBg,
        };

        // Tổng cộng, VAT, Tổng có VAT (kéo dài đến cột G - index 6)
        const summaryEndColumn = 7; // Cột G
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: totalRow - 1,
              endRowIndex: totalRow,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn - 1,
            },
          },
        });
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: { stringValue: 'Tổng cộng' },
                    userEnteredFormat: boldRight,
                  },
                  {},
                  {},
                  {},
                  {},
                  {},
                  {
                    userEnteredValue: {
                      numberValue: formattedData.summary.subTotal,
                    },
                    userEnteredFormat: boldRightValue,
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: totalRow - 1, columnIndex: 0 },
          },
        });
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: vatRow - 1,
              endRowIndex: vatRow,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn - 1,
            },
          },
        });
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: `Thuế VAT ${formattedData.summary.vatPercentage}%`,
                    },
                    userEnteredFormat: boldRight,
                  },
                  {},
                  {},
                  {},
                  {},
                  {},
                  {
                    userEnteredValue: {
                      numberValue: formattedData.summary.vatAmount,
                    },
                    userEnteredFormat: boldRightValue,
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: vatRow - 1, columnIndex: 0 },
          },
        });
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: totalWithVatRow - 1,
              endRowIndex: totalWithVatRow,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn - 1,
            },
          },
        });
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: 'Tổng cộng đã bao gồm VAT 10%',
                    },
                    userEnteredFormat: boldRight,
                  },
                  {},
                  {},
                  {},
                  {},
                  {},
                  {
                    userEnteredValue: {
                      numberValue: formattedData.summary.grandTotal,
                    },
                    userEnteredFormat: boldRightValue,
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: totalWithVatRow - 1, columnIndex: 0 },
          },
        });

        // Bằng chữ
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: amountInWordsRow - 1,
              endRowIndex: amountInWordsRow,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn,
            },
          },
        });
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: convertNumberToVnWords(
                        formattedData.summary.grandTotal
                      ),
                    },
                    userEnteredFormat: boldCenterYellow,
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: amountInWordsRow - 1, columnIndex: 0 },
          },
        });

        // **FIX 3: Merge và kẻ viền dòng trống**
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: blankRowAfterWords - 1,
              endRowIndex: blankRowAfterWords,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn,
            },
          },
        });

        // Ghi chú
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: notesRow - 1,
              endRowIndex: notesRow,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn,
            },
          },
        });
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue:
                        'Ghi chú: Các điều khoản khác vui lòng xem bên dưới.',
                    },
                    userEnteredFormat: {
                      textFormat: { bold: true, italic: true },
                      padding: { left: 10 },
                    },
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: notesRow - 1, columnIndex: 0 },
          },
        });

        // Phần điều khoản
        const termsTextPart1 =
          `1. Báo giá có hiệu lực trong ${
            formattedData.metadata.quoteValidity || '7 ngày'
          }. Hết hiệu lực xin liên hệ lại cho Công ty.\n` +
          `2. Thời gian giao hàng: ${
            formattedData.metadata.deliveryTime || '3 ngày'
          } ( không bao gồm chủ nhật, ngày lễ )\n` +
          `3. Giá đã bao gồm VAT và chưa bao gồm vận chuyển\n` +
          `4. Địa điểm giao hàng: Xưởng THP\n` +
          `5. Phương thức thanh toán: Thanh toán bằng chuyển khoản\n` +
          `    Tài khoản số: 27888866\n` +
          `    Tên tài khoản: Công ty TNHH SX cơ khí TM-DV Tân Hòa Phát\n` +
          `    Ngân hàng TMCP Á Châu - Chi nhánh Bình Tây\n`;
        const termsTextPart2 = `    Tạm ứng 50%, Thanh toán 50% trước khi nhận hàng`;

        // Mở rộng merge cell cho điều khoản
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: footerStartRow - 1,
              endRowIndex: footerStartRow + 5,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn,
            },
          },
        });

        // Phần điều khoản thông thường
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: termsTextPart1,
                    },
                    userEnteredFormat: {
                      wrapStrategy: 'WRAP',
                      verticalAlignment: 'TOP',
                      padding: { left: 20 },
                    },
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: footerStartRow - 1, columnIndex: 0 },
          },
        });

        // Phần điều khoản màu đỏ (tạm ứng)
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: termsTextPart2,
                    },
                    userEnteredFormat: {
                      wrapStrategy: 'WRAP',
                      verticalAlignment: 'TOP',
                      padding: { left: 20 },
                      textFormat: {
                        foregroundColor: { red: 1, green: 0, blue: 0 },
                        bold: true,
                      },
                    },
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: footerStartRow + 4, columnIndex: 0 },
          },
        });

        // Vùng chữ ký
        const buyerSignatureEndCol = 4; // Cột D

        // Đầu tiên xóa nội dung đang có ở vùng chữ ký để tránh lặp lại
        requests.push({
          updateCells: {
            range: {
              sheetId,
              startRowIndex: signatureRow - 1,
              endRowIndex: signatureRow + 5,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn,
            },
            fields: 'userEnteredValue',
          },
        });

        // Thiết lập lại "Xác Nhận Bên Mua"
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: signatureRow - 1,
              endRowIndex: signatureRow,
              startColumnIndex: 0,
              endColumnIndex: buyerSignatureEndCol,
            },
          },
        });

        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: { stringValue: 'Xác Nhận Bên Mua' },
                    userEnteredFormat: {
                      horizontalAlignment: 'CENTER',
                      textFormat: { bold: true },
                    },
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: signatureRow - 1, columnIndex: 0 },
          },
        });

        // Vùng để ký bên mua
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: signatureRow,
              endRowIndex: signatureRow + 5,
              startColumnIndex: 0,
              endColumnIndex: buyerSignatureEndCol,
            },
          },
        });

        // Thêm border cho khu vực ký của Bên Mua
        requests.push({
          updateBorders: {
            range: {
              sheetId,
              startRowIndex: signatureRow - 1, // Bắt đầu từ header "Xác Nhận Bên Mua"
              endRowIndex: signatureRow + 5, // Kết thúc sau khu vực để chữ ký
              startColumnIndex: 0,
              endColumnIndex: buyerSignatureEndCol,
            },
            top: { style: 'SOLID' },
            bottom: { style: 'SOLID' },
            left: { style: 'SOLID' },
            right: { style: 'SOLID' },
            innerHorizontal: { style: 'SOLID' },
            innerVertical: { style: 'SOLID' },
          },
        });

        // Thiết lập "Xác Nhận Bên Bán"
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: signatureRow - 1,
              endRowIndex: signatureRow,
              startColumnIndex: buyerSignatureEndCol,
              endColumnIndex: summaryEndColumn,
            },
          },
        });

        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: { stringValue: 'Xác Nhận Bên Bán' },
                    userEnteredFormat: {
                      horizontalAlignment: 'CENTER',
                      textFormat: { bold: true },
                    },
                  },
                ],
              },
            ],
            fields: '*',
            start: {
              sheetId,
              rowIndex: signatureRow - 1,
              columnIndex: buyerSignatureEndCol,
            },
          },
        });

        // Vùng chữ ký bên bán và hình ảnh chữ ký
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: signatureRow,
              endRowIndex: signatureRow + 5,
              startColumnIndex: buyerSignatureEndCol,
              endColumnIndex: summaryEndColumn,
            },
          },
        });

        // **FIX 1: Chèn ảnh chữ ký từ Firebase Storage**
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: signatureRow,
              endRowIndex: signatureRow + 5,
              startColumnIndex: buyerSignatureEndCol,
              endColumnIndex: summaryEndColumn,
            },
          },
        });

        // Chèn ảnh chữ ký từ Firebase Storage URL - Sửa cú pháp dấu phẩy thành dấu chấm phẩy
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      formulaValue: `=A1`, // Xóa ảnh chữ ký và sử dụng reference trống A1
                    },
                    userEnteredFormat: {
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                    },
                  },
                ],
              },
            ],
            fields: '*',
            start: {
              sheetId,
              rowIndex: signatureRow,
              columnIndex: buyerSignatureEndCol,
            },
          },
        });

        // Thêm ngày tháng tự động vào báo giá ở ô G2 với căn giữa ngang và dọc
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      formulaValue: '=TODAY()',
                    },
                    userEnteredFormat: {
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      numberFormat: { type: 'DATE', pattern: 'dd/MM/yyyy' },
                    },
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: 1, columnIndex: 6 }, // Cell G2
          },
        });

        // Thêm border cho ô G2
        requests.push({
          updateBorders: {
            range: {
              sheetId,
              startRowIndex: 1,
              endRowIndex: 2,
              startColumnIndex: 6,
              endColumnIndex: 7,
            },
            top: { style: 'SOLID' },
            bottom: { style: 'SOLID' },
            left: { style: 'SOLID' },
            right: { style: 'SOLID' },
          },
        });

        // **FIX 2 & 4: Kẻ bảng chính xác, loại bỏ border thừa**
        // Instead of one global border, apply borders individually for each row
        // to correctly handle note rows (which should not have innerVertical borders)
        if (formattedData.materials.length > 0) {
          // First apply border to the header row
          requests.push({
            updateBorders: {
              range: {
                sheetId,
                startRowIndex: START_ROW_MATERIALS - 2, // Header row
                endRowIndex: START_ROW_MATERIALS - 1,
                startColumnIndex: 0,
                endColumnIndex: summaryEndColumn,
              },
              top: { style: 'SOLID' },
              bottom: { style: 'SOLID' },
              left: { style: 'SOLID' },
              right: { style: 'SOLID' },
              innerVertical: { style: 'SOLID' },
            },
          });

          // Then apply borders for each material row individually
          formattedData.materials.forEach((material, index) => {
            const rowStartIndex = START_ROW_MATERIALS - 1 + index;
            const rowEndIndex = rowStartIndex + 1;

            const nameIsNoteBorder = (material.name || '')
              .toUpperCase()
              .includes('GHI CHÚ');
            const startsWithPlusBorder = (material.name || '')
              .trim()
              .startsWith('+');
            const isNoteRow =
              material.isNote ||
              nameIsNoteBorder ||
              startsWithPlusBorder ||
              ((!material.unit || material.unit === '') &&
                (material.quantity === null ||
                  material.quantity === undefined ||
                  material.quantity === 0) &&
                (!material.material || material.material === ''));

            // 扩展特殊行判断条件，与上面的合并逻辑保持一致
            const shouldMergeForBorder =
              isNoteRow ||
              (material.name && material.name.includes('-----')) ||
              (material.name &&
                material.name.toLowerCase().includes('tổng phụ')) ||
              (material.name &&
                material.name.toLowerCase().includes('tạm tính'));

            if (shouldMergeForBorder) {
              // For note rows, only apply outer borders (no inner vertical borders)
              requests.push({
                updateBorders: {
                  range: {
                    sheetId,
                    startRowIndex: rowStartIndex,
                    endRowIndex: rowEndIndex,
                    startColumnIndex: 0,
                    endColumnIndex: summaryEndColumn,
                  },
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                  // No innerVertical for note rows
                },
              });
            } else {
              // For regular rows, apply full borders including inner vertical lines
              requests.push({
                updateBorders: {
                  range: {
                    sheetId,
                    startRowIndex: rowStartIndex,
                    endRowIndex: rowEndIndex,
                    startColumnIndex: 0,
                    endColumnIndex: summaryEndColumn,
                  },
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                  innerVertical: { style: 'SOLID' },
                },
              });
            }
          });
        }

        // Kẻ bảng tổng kết
        requests.push({
          updateBorders: {
            range: {
              sheetId,
              startRowIndex: totalRow - 1,
              endRowIndex: notesRow,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn,
            },
            top: { style: 'SOLID' },
            bottom: { style: 'SOLID' },
            left: { style: 'SOLID' },
            right: { style: 'SOLID' },
            innerHorizontal: { style: 'SOLID' },
          },
        });

        // Kẻ bảng điều khoản
        requests.push({
          updateBorders: {
            range: {
              sheetId,
              startRowIndex: notesRow,
              endRowIndex: signatureRow - 1,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn,
            },
            top: { style: 'SOLID' },
            bottom: { style: 'SOLID' },
            left: { style: 'SOLID' },
            right: { style: 'SOLID' },
          },
        });

        // Kẻ bảng chữ ký (quan trọng: không kẻ innerVertical)
        requests.push({
          updateBorders: {
            range: {
              sheetId,
              startRowIndex: signatureRow - 1,
              endRowIndex: signatureRow + 5,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn,
            },
            top: { style: 'SOLID' },
            bottom: { style: 'SOLID' },
            left: { style: 'SOLID' },
            right: { style: 'SOLID' },
            innerHorizontal: { style: 'SOLID' },
          },
        });

        // Xóa nội dung ở các dòng phía dưới để tránh hiển thị văn bản dư thừa từ template
        requests.push({
          updateCells: {
            range: {
              sheetId,
              startRowIndex: signatureRow + 6,
              endRowIndex: signatureRow + 20, // Xóa đến dòng +20 để đảm bảo xóa hết
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn,
            },
            fields: 'userEnteredValue',
          },
        });

        // Gửi tất cả các request định dạng
        await sheets.spreadsheets.batchUpdate({
          spreadsheetId: newFileId,
          requestBody: { requests },
        });

        // Cấp quyền và trả về URL
        await drive.permissions.create({
          fileId: newFileId,
          requestBody: { role: 'reader', type: 'anyone' },
        });
        const fileResponse = await drive.files.get({
          fileId: newFileId,
          fields: 'webViewLink',
        });

        return {
          success: true,
          excelUrl: fileResponse.data.webViewLink,
          spreadsheetId: newFileId, // Thêm spreadsheetId vào kết quả trả về
        };
      } catch (error: any) {
        console.error(
          'Lỗi khi tạo báo giá:',
          error.response ? error.response.data.error : error.message
        );
        throw new functions.https.HttpsError(
          'internal',
          `Lỗi khi tạo file trên Google Drive: ${error.message}`
        );
      }
    }
  );

// Hàm convertNumberToVnWords giữ nguyên
function convertNumberToVnWords(n: number): string {
  if (n === null || n === undefined) return '';
  const num = Math.floor(n);
  if (num === 0) return 'Bằng chữ: Không đồng chẵn.';
  const units = ['', ' nghìn', ' triệu', ' tỷ', ' nghìn tỷ', ' triệu tỷ'];
  const numbers = [
    'không',
    'một',
    'hai',
    'ba',
    'bốn',
    'năm',
    'sáu',
    'bảy',
    'tám',
    'chín',
  ];
  const convertGroup = (group: number): string => {
    let result = '';
    const tram = Math.floor(group / 100);
    const chuc = Math.floor((group % 100) / 10);
    const donvi = group % 10;
    if (tram > 0) {
      result += numbers[tram] + ' trăm';
      if (chuc === 0 && donvi !== 0) result += ' linh';
    }
    if (chuc > 1) {
      result += (tram > 0 ? ' ' : '') + numbers[chuc] + ' mươi';
      if (donvi === 1) result += ' mốt';
    } else if (chuc === 1) {
      result += (tram > 0 ? ' ' : '') + 'mười';
    }
    if (donvi > 0 && chuc !== 1) {
      if (donvi === 5 && chuc > 0) {
        result += (result.length > 0 ? ' ' : '') + 'lăm';
      } else if (donvi === 4 && chuc > 1) {
        result += (result.length > 0 ? ' ' : '') + 'tư';
      } else {
        result += (result.length > 0 ? ' ' : '') + numbers[donvi];
      }
    } else if (donvi > 0 && chuc === 1) {
      if (donvi === 5) {
        result += ' lăm';
      } else {
        result += ' ' + numbers[donvi];
      }
    }
    return result;
  };
  if (num === 0) return 'Không';
  let result = '';
  let i = 0;
  let tempNum = num;
  while (tempNum > 0) {
    let groupValue = tempNum % 1000;
    if (groupValue > 0) {
      let groupText = convertGroup(groupValue);
      result = groupText + units[i] + (result ? ' ' + result : '');
    }
    tempNum = Math.floor(tempNum / 1000);
    i++;
  }
  result = result.trim();
  return (
    'Bằng chữ: ' +
    result.charAt(0).toUpperCase() +
    result.slice(1) +
    ' đồng chẵn.'
  );
}

import * as XLSX from 'xlsx';
import { ExcelQuotationData } from './types';

/**
 * Generates an Excel file based on the quotation data and template
 * @param {ExcelQuotationData} formattedData The formatted data for Excel
 * @returns {Buffer} The Excel file as a buffer
 */
export function generateExcelFile(formattedData: ExcelQuotationData): Buffer {
  // Create a new workbook and worksheet
  const workbook = XLSX.utils.book_new();
  const worksheet = XLSX.utils.aoa_to_sheet([]);

  // Set column widths
  const colWidths = [
    { wch: 5 }, // A
    { wch: 40 }, // B
    { wch: 10 }, // C
    { wch: 10 }, // D
    { wch: 15 }, // E
    { wch: 20 }, // F
    { wch: 20 }, // G
  ];
  worksheet['!cols'] = colWidths;

  // Add company header info (column E)
  addCompanyHeader(worksheet, formattedData);

  // Add quotation information (header and basic info)
  addQuotationHeader(worksheet, formattedData);

  // Add customer information
  addCustomerInfo(worksheet, formattedData);

  // Add materials table
  const materialEndRow = addMaterialsTable(worksheet, formattedData);

  // Add financial summary section
  const summaryEndRow = addFinancialSummary(
    worksheet,
    formattedData,
    materialEndRow
  );

  // Add terms and conditions
  addTermsAndConditions(worksheet, summaryEndRow);

  // Add the worksheet to the workbook
  XLSX.utils.book_append_sheet(workbook, worksheet, 'Báo giá');

  // Generate Excel file as buffer
  const excelBuffer = XLSX.write(workbook, {
    type: 'buffer',
    bookType: 'xlsx',
  });
  return excelBuffer;
}

/**
 * Add company header information to the worksheet
 */
function addCompanyHeader(
  worksheet: XLSX.WorkSheet,
  formattedData: ExcelQuotationData
): void {
  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['CÔNG TY TNHH SẢN XUẤT CƠ KHÍ THƯƠNG MẠI']],
    { origin: 'E1' }
  );

  XLSX.utils.sheet_add_aoa(worksheet, [['DỊCH VỤ TÂN HÒA PHÁT']], {
    origin: 'E2',
  });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['ĐC: Số 7 Quốc lộ 1A ,KP3B,Phường Thanh Lộc,Quận']],
    { origin: 'E3' }
  );

  XLSX.utils.sheet_add_aoa(worksheet, [['12,TP.HCM']], { origin: 'E4' });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['MST: 0315155409', 'Web:cokhitanhoaphat.com.vn']],
    { origin: 'E5' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Email :chomcauinoxtanhoaphat.com.vn']],
    { origin: 'E6' }
  );

  XLSX.utils.sheet_add_aoa(worksheet, [['Hotline 24/7: 0978.268.559']], {
    origin: 'E7',
  });
}

/**
 * Add quotation title and basic information
 */
function addQuotationHeader(
  worksheet: XLSX.WorkSheet,
  formattedData: ExcelQuotationData
): void {
  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['BẢNG BÁO GIÁ KIỂM XÁC NHẬN ĐẶT HÀNG']],
    { origin: 'B9' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Ngày'], [formattedData.metadata.quotationDate]],
    { origin: 'F10' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['SỐ'], [formattedData.metadata.quotationNumber]],
    { origin: 'F11' }
  );
}

/**
 * Add customer information section
 */
function addCustomerInfo(
  worksheet: XLSX.WorkSheet,
  formattedData: ExcelQuotationData
): void {
  XLSX.utils.sheet_add_aoa(worksheet, [['KÍNH GỬI:']], { origin: 'B12' });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Địa chỉ:', formattedData.metadata.customerAddress]],
    { origin: 'B13' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Tel', ':', '', '', 'MST', ':', '', 'FAX']],
    { origin: 'B14' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Email', ':', '', '', 'Attn', ':', '', 'Mobile:']],
    { origin: 'B15' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [
      [
        'Trước hết Công Ty Tân Hòa Phát xin chân thành cảm ơn sự quan tâm & hợp tác của Quý Khách. Chúng tôi xin gửi tới Quý khách báo giá các chủng loại sau:',
      ],
    ],
    { origin: 'B16' }
  );
}

/**
 * Add materials table to the worksheet
 * @returns The row number after the materials table
 */
function addMaterialsTable(
  worksheet: XLSX.WorkSheet,
  formattedData: ExcelQuotationData
): number {
  // Add table header for materials
  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['STT', 'Tên gọi', 'Vật liệu', 'ĐVT', 'SL', 'Đơn giá', 'Thành Tiền']],
    { origin: 'B18' }
  );

  // Add material rows
  let currentRow = 19;
  formattedData.materials.forEach((item) => {
    XLSX.utils.sheet_add_aoa(
      worksheet,
      [
        [
          item.no,
          item.name,
          '',
          item.unit,
          item.quantity,
          item.unitPrice,
          item.total,
        ],
      ],
      { origin: `B${currentRow}` }
    );
    currentRow++;
  });

  return currentRow + 2; // Add 2 rows gap
}

/**
 * Add financial summary section
 * @returns The row number after the summary section
 */
function addFinancialSummary(
  worksheet: XLSX.WorkSheet,
  formattedData: ExcelQuotationData,
  startRow: number
): number {
  // Add summary section after materials
  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['', '', '', '', 'Tổng cộng:', '', formattedData.summary.subTotal]],
    { origin: `B${startRow}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [
      [
        '',
        '',
        '',
        '',
        `Chiết khấu (${formattedData.summary.discountPercentage}%):`,
        '',
        formattedData.summary.discountAmount,
      ],
    ],
    { origin: `B${startRow + 1}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [
      [
        '',
        '',
        '',
        '',
        `Thuế VAT (${formattedData.summary.vatPercentage}%):`,
        '',
        formattedData.summary.vatAmount,
      ],
    ],
    { origin: `B${startRow + 2}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['', '', '', '', 'TỔNG CỘNG:', '', formattedData.summary.grandTotal]],
    { origin: `B${startRow + 3}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Bằng chữ:', formattedData.summary.amountInWords]],
    { origin: `B${startRow + 5}` }
  );

  return startRow + 8; // Return row after summary section
}

/**
 * Add terms and conditions section
 */
function addTermsAndConditions(
  worksheet: XLSX.WorkSheet,
  startRow: number
): void {
  XLSX.utils.sheet_add_aoa(worksheet, [['Ghi chú:']], {
    origin: `B${startRow}`,
  });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [
      [
        '1. Báo giá có hiệu lực trong 7 ngày. Hết hiệu lực xin liên hệ lại cho Công ty.',
      ],
    ],
    { origin: `C${startRow + 2}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['2. Thời gian giao hàng: 3 ngày ( không bao gồm chủ nhật, ngày lễ )']],
    { origin: `C${startRow + 3}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['3. Giá đã bao gồm VAT và không bao gồm vận chuyển']],
    { origin: `C${startRow + 4}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['4. Địa điểm giao hàng: kho bên Bán']],
    { origin: `C${startRow + 5}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [
      [
        '5. Phương thức thanh toán: Quý Khách hàng vui lòng thanh toán bằng chuyển khoản để xuất hóa đơn:',
      ],
    ],
    { origin: `C${startRow + 6}` }
  );

  XLSX.utils.sheet_add_aoa(worksheet, [['Tài khoản số: 27888866']], {
    origin: `C${startRow + 7}`,
  });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Tên tài khoản: Công ty TNHH SX cơ khí TM-DV Tân Hòa Phát']],
    { origin: `C${startRow + 8}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Ngân hàng TMCP Á Châu - Chi nhánh: Tam Hà, Thủ Đức']],
    { origin: `C${startRow + 9}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Tạm ứng 50%, Thanh toán 50% trước khi nhận hàng']],
    { origin: `C${startRow + 10}` }
  );
}

/**
 * Interface for Excel formatted quotation data
 */
export interface ExcelQuotationData {
  metadata: {
    companyName: string;
    companyAddress: string;
    companyPhone: string;
    companyEmail: string;
    taxCode: string;
    customerName: string;
    customerAddress: string;
    quotationNumber: string;
    quotationDate: string;
    projectName: string;
    quoteValidity: string;
  };
  materials: Array<{
    no: number;
    name: string;
    unit: string;
    quantity: number;
    unitPrice: number;
    total: number;
  }>;
  summary: {
    subTotal: number;
    discountPercentage: number;
    discountAmount: number;
    vatPercentage: number;
    vatAmount: number;
    grandTotal: number;
    amountInWords: string;
  };
}

// types for dynamic workflow system
export interface ProcessTemplate {
  /** Readable Vietnamese name, e.g. "Cắt Laser" */
  processName: string;
  /** Unique machine-readable key, e.g. "laser_cutting" */
  processKey: string;
  /** Optional high-level category, e.g. "Tạo phôi" */
  category?: string;
}

export interface WorkflowStage {
  /** Firestore document id of the selected template */
  stageId: string;
  processKey: string;
  processName: string;
  /** Smaller number appears first */
  order: number;
  /** pending | in_progress | completed */
  status: 'pending' | 'in_progress' | 'completed';
  /** uid of the assigned employee (can be empty) */
  assignedToId?: string;
}

import { google } from 'googleapis';
import * as path from 'path';
import { SERVICE_ACCOUNT_KEY_PATH } from '../config';

/**
 * Returns an authenticated Google Drive client using the unified service account.
 */
export const getDriveClient = async () => {
  const auth = new google.auth.GoogleAuth({
    keyFile: path.join(__dirname, SERVICE_ACCOUNT_KEY_PATH),
    scopes: ['https://www.googleapis.com/auth/drive'],
  });
  return google.drive({ version: 'v3', auth });
};

