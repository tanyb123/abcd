--- START: src\api\aiChatService.js ---
/**
 * AI Chat Service using Gemini API directly with OpenRouter fallback
 * H·ªó tr·ª£ chat v·ªõi AI ƒë·ªÉ tham kh·∫£o v·ªÅ d·ª± √°n v√† x·ª≠ l√Ω file ƒë√≠nh k√®m
 */

// API keys
const GEMINI_API_KEY = 'AIzaSyAaCTmvZ4uHzQCrrAnatsaTrEzSRsESZVE';
const OPENROUTER_API_KEY =
  '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';

// API endpoints
const GEMINI_API_URL =
  'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent';
const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';

// Model configuration
const DEFAULT_MODEL = 'gemini-2.5-pro';
const FALLBACK_MODEL = 'google/gemini-2.5-pro';

// Data sources for contextual enrichment
import { getQuotationsByProject } from './quotationService';

// Helper: extract plain text from Gemini response parts
const extractTextFromGemini = (data) => {
  try {
    const parts = data?.candidates?.[0]?.content?.parts || [];
    return parts
      .map((p) => (typeof p?.text === 'string' ? p.text : ''))
      .join('')
      .trim();
  } catch (e) {
    return '';
  }
};

/**
 * X·ª≠ l√Ω file ƒë√≠nh k√®m ƒë·ªÉ g·ª≠i ƒë·∫øn AI
 * @param {Array} attachments - M·∫£ng file ƒë√≠nh k√®m
 * @returns {Object} Th√¥ng tin file ƒë√£ x·ª≠ l√Ω
 */
const processAttachments = (attachments) => {
  if (!attachments || attachments.length === 0) {
    return null;
  }

  const processedAttachments = {
    images: [],
    documents: [],
    summary: '',
  };

  attachments.forEach((attachment) => {
    if (attachment.type === 'image') {
      processedAttachments.images.push({
        name: attachment.name,
        size: attachment.size,
        uri: attachment.uri,
        type: 'image',
      });
    } else {
      processedAttachments.documents.push({
        name: attachment.name,
        size: attachment.size,
        type: 'document',
        extension: attachment.name.split('.').pop()?.toLowerCase(),
      });
    }
  });

  // T·∫°o m√¥ t·∫£ t·ªïng h·ª£p v·ªÅ file ƒë√≠nh k√®m
  if (processedAttachments.images.length > 0) {
    processedAttachments.summary += `[ƒê√≠nh k√®m ${processedAttachments.images.length} ·∫£nh] `;
  }
  if (processedAttachments.documents.length > 0) {
    processedAttachments.summary += `[ƒê√≠nh k√®m ${
      processedAttachments.documents.length
    } t√†i li·ªáu: ${processedAttachments.documents
      .map((doc) => doc.name)
      .join(', ')}] `;
  }

  return processedAttachments;
};

/**
 * T·∫°o prompt m√¥ t·∫£ file ƒë√≠nh k√®m
 * @param {Object} attachments - Th√¥ng tin file ƒë√≠nh k√®m
 * @returns {string} M√¥ t·∫£ file ƒë√≠nh k√®m
 */
const createAttachmentPrompt = (attachments) => {
  if (!attachments) return '';

  let prompt = '\n\n**File ƒë√≠nh k√®m:**\n';

  if (attachments.images.length > 0) {
    prompt += `- ·∫¢nh (${attachments.images.length} file): `;
    attachments.images.forEach((img, index) => {
      prompt += `${img.name} (${(img.size / 1024).toFixed(1)} KB)`;
      if (index < attachments.images.length - 1) prompt += ', ';
    });
    prompt += '\n';
  }

  if (attachments.documents.length > 0) {
    prompt += `- T√†i li·ªáu (${attachments.documents.length} file): `;
    attachments.documents.forEach((doc, index) => {
      prompt += `${doc.name} (${(doc.size / 1024).toFixed(1)} KB, ${
        doc.extension?.toUpperCase() || 'Unknown'
      })`;
      if (index < attachments.documents.length - 1) prompt += ', ';
    });
    prompt += '\n';
  }

  prompt += '\n**H∆∞·ªõng d·∫´n x·ª≠ l√Ω file ƒë√≠nh k√®m:**\n';
  prompt += '- N·∫øu c√≥ ·∫£nh, h√£y m√¥ t·∫£ n·ªôi dung ·∫£nh v√† ƒë∆∞a ra nh·∫≠n x√©t ph√π h·ª£p\n';
  prompt +=
    '- N·∫øu c√≥ t√†i li·ªáu, h√£y ƒë∆∞a ra l·ªùi khuy√™n v·ªÅ c√°ch x·ª≠ l√Ω ho·∫∑c ph√¢n t√≠ch t√†i li·ªáu\n';
  prompt +=
    '- K·∫øt h·ª£p th√¥ng tin t·ª´ file ƒë√≠nh k√®m v·ªõi c√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng ƒë·ªÉ ƒë∆∞a ra c√¢u tr·∫£ l·ªùi to√†n di·ªán\n';

  return prompt;
};

/**
 * G·ª≠i tin nh·∫Øn ƒë·∫øn AI s·ª≠ d·ª•ng Gemini API tr·ª±c ti·∫øp
 * @param {Array} messages - M·∫£ng tin nh·∫Øn (role: 'user' | 'assistant', content: string)
 * @param {string} model - Model AI (m·∫∑c ƒë·ªãnh: gemini-2.0-flash)
 * @param {Object} options - T√πy ch·ªçn b·ªï sung
 * @returns {Promise<Object>} Ph·∫£n h·ªìi t·ª´ AI
 */
export const sendMessageToGemini = async (
  messages,
  model = DEFAULT_MODEL,
  options = {}
) => {
  try {
    // Chuy·ªÉn ƒë·ªïi format t·ª´ OpenRouter sang Gemini
    const contents = messages.map((msg) => ({
      role: msg.role === 'user' ? 'user' : 'model',
      parts: [{ text: msg.content }],
    }));

    const doRequest = async () => {
      const requestBody = {
        contents: contents,
        generationConfig: {
          // Increase default cap; allow override via options
          maxOutputTokens: options.maxTokens || 10000,
          temperature: options.temperature || 0.7,
          topP: 0.8,
          topK: 40,
        },
      };

      console.log('Sending request to Gemini API:', {
        url: GEMINI_API_URL,
        model,
        maxTokens: requestBody.generationConfig.maxOutputTokens,
        messageCount: messages.length,
      });

      const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('Gemini API error:', response.status, errorText);
        throw new Error(`Gemini API error: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      console.log('Gemini API response:', data);
      return data;
    };
    // First request
    let data = await doRequest();

    if (!data?.candidates?.[0]?.content) {
      throw new Error('Invalid response format from Gemini API');
    }

    let resultText = extractTextFromGemini(data);
    let finishReason = data?.candidates?.[0]?.finishReason;

    // Aggregate usage across continuations
    const usageAgg = {
      promptTokens: data.usageMetadata?.promptTokenCount || 0,
      completionTokens: data.usageMetadata?.completionTokenCount || 0,
      totalTokens: data.usageMetadata?.totalTokenCount || 0,
    };

    // Auto-continue if truncated by token limit
    const allowAutoContinue = options.autoContinue !== false; // default true
    let continues = 0;
    const maxContinues = options.maxContinues || 3;

    while (
      allowAutoContinue &&
      finishReason === 'MAX_TOKENS' &&
      continues < maxContinues
    ) {
      continues += 1;

      // Build follow-up conversation: include previous assistant output and ask to continue
      const followupMessages = [
        ...messages,
        { role: 'assistant', content: resultText },
        {
          role: 'user',
          content:
            'H√£y ti·∫øp t·ª•c ph·∫ßn tr·∫£ l·ªùi ƒëang dang d·ªü ·ªü tr√™n. ƒê·ª´ng l·∫∑p l·∫°i n·ªôi dung ƒë√£ tr·∫£ l·ªùi, ch·ªâ vi·∫øt ph·∫ßn c√≤n l·∫°i.',
        },
      ];

      // Convert to Gemini format for the next call
      const followupContents = followupMessages.map((msg) => ({
        role: msg.role === 'user' ? 'user' : 'model',
        parts: [{ text: msg.content }],
      }));

      // Rebind contents for the next request
      contents.splice(0, contents.length, ...followupContents);

      const moreData = await doRequest();

      const moreText = extractTextFromGemini(moreData);
      resultText += moreText ? `\n${moreText}` : '';
      finishReason = moreData?.candidates?.[0]?.finishReason;

      usageAgg.promptTokens += moreData.usageMetadata?.promptTokenCount || 0;
      usageAgg.completionTokens +=
        moreData.usageMetadata?.completionTokenCount || 0;
      usageAgg.totalTokens += moreData.usageMetadata?.totalTokenCount || 0;
    }

    return {
      success: true,
      data,
      message: resultText,
      model,
      usage: usageAgg,
      finishReason,
      continued: continues > 0,
      continues,
    };
  } catch (error) {
    console.error('Error calling Gemini API:', error);
    throw error;
  }
};

/**
 * G·ª≠i tin nh·∫Øn ƒë·∫øn AI s·ª≠ d·ª•ng OpenRouter API (fallback)
 * @param {Array} messages - M·∫£ng tin nh·∫Øn (role: 'user' | 'assistant', content: string)
 * @param {string} model - Model AI (m·∫∑c ƒë·ªãnh: google/gemini-2.5-pro)
 * @param {Object} options - T√πy ch·ªçn b·ªï sung
 * @returns {Promise<Object>} Ph·∫£n h·ªìi t·ª´ AI
 */
export const sendMessageToOpenRouter = async (
  messages,
  model = FALLBACK_MODEL,
  options = {}
) => {
  try {
    const doRequest = async (payloadMessages) => {
      const requestBody = {
        model: model,
        messages: payloadMessages,
        max_tokens: options.maxTokens || 10000,
        temperature: options.temperature || 0.7,
        stream: false,
        tools: options.tools || undefined,
        tool_choice: options.toolChoice || undefined,
      };

      console.log('Sending request to OpenRouter API (fallback):', {
        model,
        messageCount: payloadMessages.length,
        maxTokens: requestBody.max_tokens,
      });

      const response = await fetch(OPENROUTER_API_URL, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${OPENROUTER_API_KEY}`,
          'HTTP-Referer': 'https://thpapp.com',
          'X-Title': 'THP App - AI Assistant',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('OpenRouter API error:', response.status, errorText);
        throw new Error(
          `OpenRouter API error: ${response.status} - ${errorText}`
        );
      }

      const data = await response.json();
      console.log('OpenRouter API response:', data);
      return data;
    };

    // First request
    let data = await doRequest(messages);

    if (!data?.choices?.[0]?.message) {
      throw new Error('Invalid response format from OpenRouter API');
    }

    let resultText = data.choices[0].message.content || '';
    let finishReason = data.choices[0].finish_reason;
    const usageAgg = {
      promptTokens: data.usage?.prompt_tokens || 0,
      completionTokens: data.usage?.completion_tokens || 0,
      totalTokens: data.usage?.total_tokens || 0,
    };

    const allowAutoContinue = options.autoContinue !== false;
    let continues = 0;
    const maxContinues = options.maxContinues || 3;

    while (
      allowAutoContinue &&
      finishReason === 'length' &&
      continues < maxContinues
    ) {
      continues += 1;
      const followup = [
        ...messages,
        { role: 'assistant', content: resultText },
        {
          role: 'user',
          content: 'H√£y ti·∫øp t·ª•c ph·∫ßn tr·∫£ l·ªùi ·ªü tr√™n, kh√¥ng l·∫∑p l·∫°i.',
        },
      ];
      const more = await doRequest(followup);
      const moreText = more?.choices?.[0]?.message?.content || '';
      resultText += moreText ? `\n${moreText}` : '';
      finishReason = more?.choices?.[0]?.finish_reason;
      usageAgg.promptTokens += more.usage?.prompt_tokens || 0;
      usageAgg.completionTokens += more.usage?.completion_tokens || 0;
      usageAgg.totalTokens += more.usage?.total_tokens || 0;
    }

    return {
      success: true,
      data,
      message: resultText,
      model: data.model,
      usage: usageAgg,
      finishReason,
      continued: continues > 0,
      continues,
    };
  } catch (error) {
    console.error('Error calling OpenRouter API:', error);
    throw error;
  }
};

/**
 * G·ª≠i tin nh·∫Øn ƒë·∫øn AI v·ªõi fallback t·ª± ƒë·ªông
 * @param {Array} messages - M·∫£ng tin nh·∫Øn (role: 'user' | 'assistant', content: string)
 * @param {string} model - Model AI
 * @param {Object} options - T√πy ch·ªçn b·ªï sung
 * @returns {Promise<Object>} Ph·∫£n h·ªìi t·ª´ AI
 */
export const sendMessageToAI = async (
  messages,
  model = DEFAULT_MODEL,
  options = {}
) => {
  try {
    // Th·ª≠ Gemini API tr∆∞·ªõc
    console.log('Trying Gemini API first...');
    return await sendMessageToGemini(messages, model, options);
  } catch (error) {
    console.log('Gemini API failed, trying OpenRouter as fallback...');
    try {
      // N·∫øu Gemini th·∫•t b·∫°i, s·ª≠ d·ª•ng OpenRouter
      return await sendMessageToOpenRouter(messages, FALLBACK_MODEL, options);
    } catch (fallbackError) {
      console.error('Both APIs failed:', {
        gemini: error.message,
        openrouter: fallbackError.message,
      });
      throw new Error(
        `C·∫£ hai API ƒë·ªÅu th·∫•t b·∫°i. Gemini: ${error.message}, OpenRouter: ${fallbackError.message}`
      );
    }
  }
};

/**
 * T·∫°o prompt context cho d·ª± √°n
 * @param {Object} project - Th√¥ng tin d·ª± √°n
 * @returns {string} Prompt context
 */
export const createProjectContextPrompt = (project) => {
  if (!project) return '';

  let contextPrompt = `B·∫°n l√† tr·ª£ l√Ω AI chuy√™n nghi·ªáp c·ªßa C√¥ng ty C∆° Kh√≠ T√¢n H√≤a Ph√°t - m·ªôt c√¥ng ty chuy√™n s·∫£n xu·∫•t b·ªìn c√¥ng nghi·ªáp t·∫°i Th√†nh ph·ªë H·ªì Ch√≠ Minh. B·∫°n c√≥ ki·∫øn th·ª©c s√¢u r·ªông v·ªÅ ng√†nh c∆° kh√≠, s·∫£n xu·∫•t b·ªìn c√¥ng nghi·ªáp v√† qu·∫£n l√Ω d·ª± √°n s·∫£n xu·∫•t.

**Th√¥ng tin c√¥ng ty:**
- T√™n c√¥ng ty: C∆° Kh√≠ T√¢n H√≤a Ph√°t
- Lƒ©nh v·ª±c: S·∫£n xu·∫•t b·ªìn c√¥ng nghi·ªáp
- ƒê·ªãa ƒëi·ªÉm: Th√†nh ph·ªë H·ªì Ch√≠ Minh
- Chuy√™n m√¥n: C∆° kh√≠, h√†n, gia c√¥ng kim lo·∫°i, s·∫£n xu·∫•t thi·∫øt b·ªã c√¥ng nghi·ªáp

**Th√¥ng tin d·ª± √°n:**
- T√™n d·ª± √°n: ${project.name || 'Kh√¥ng c√≥ t√™n'}
- M√¥ t·∫£: ${project.description || 'Kh√¥ng c√≥ m√¥ t·∫£'}
- Tr·∫°ng th√°i: ${project.status || 'Kh√¥ng x√°c ƒë·ªãnh'}
- Kh√°ch h√†ng: ${project.customerName || 'Kh√¥ng c√≥ th√¥ng tin'}
- Ng√†y b·∫Øt ƒë·∫ßu: ${project.startDate || 'Kh√¥ng x√°c ƒë·ªãnh'}
- Ng√†y k·∫øt th√∫c d·ª± ki·∫øn: ${project.endDate || 'Kh√¥ng x√°c ƒë·ªãnh'}`;

  // Th√™m th√¥ng tin v·ªÅ c√°c c√¥ng ƒëo·∫°n s·∫£n xu·∫•t
  if (project.workflowStages && project.workflowStages.length > 0) {
    contextPrompt += `\n\n**C√°c c√¥ng ƒëo·∫°n s·∫£n xu·∫•t:**
${project.workflowStages
  .map(
    (stage) =>
      `- ${stage.name || stage.processKey}: ${stage.status || 'Ch∆∞a x√°c ƒë·ªãnh'}`
  )
  .join('\n')}`;
  }

  // Th√™m th√¥ng tin v·ªÅ ng√¢n s√°ch n·∫øu c√≥
  if (project.budget) {
    contextPrompt += `\n\n**Ng√¢n s√°ch d·ª± √°n:** ${project.budget}`;
  }

  // Th√™m th√¥ng tin v·ªÅ nh√¢n vi√™n n·∫øu c√≥
  if (project.workers && project.workers.length > 0) {
    contextPrompt += `\n\n**Nh√¢n vi√™n tham gia:** ${project.workers.length} ng∆∞·ªùi`;
  }

  contextPrompt += `

**H∆∞·ªõng d·∫´n tr·∫£ l·ªùi:**
- Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát v·ªõi phong c√°ch chuy√™n nghi·ªáp c·ªßa m·ªôt tr·ª£ l√Ω c√¥ng ty c∆° kh√≠
- S·ª≠ d·ª•ng thu·∫≠t ng·ªØ k·ªπ thu·∫≠t ph√π h·ª£p v·ªõi ng√†nh c∆° kh√≠ v√† s·∫£n xu·∫•t b·ªìn c√¥ng nghi·ªáp
- ƒê∆∞a ra l·ªùi khuy√™n c·ª• th·ªÉ, th·ª±c t·∫ø d·ª±a tr√™n kinh nghi·ªám s·∫£n xu·∫•t c√¥ng nghi·ªáp
- Th·ªÉ hi·ªán s·ª± am hi·ªÉu v·ªÅ quy tr√¨nh s·∫£n xu·∫•t, ti√™u chu·∫©n ch·∫•t l∆∞·ª£ng v√† an to√†n lao ƒë·ªông
- N·∫øu c·∫ßn th√™m th√¥ng tin, h√£y y√™u c·∫ßu ng∆∞·ªùi d√πng cung c·∫•p m·ªôt c√°ch l·ªãch s·ª±
- Lu√¥n gi·ªØ gi·ªçng ƒëi·ªáu chuy√™n nghi·ªáp, ƒë√°ng tin c·∫≠y nh∆∞ m·ªôt chuy√™n gia trong lƒ©nh v·ª±c c∆° kh√≠
- Khi ƒë·ªÅ c·∫≠p ƒë·∫øn c√°c v·∫•n ƒë·ªÅ k·ªπ thu·∫≠t, h√£y gi·∫£i th√≠ch r√µ r√†ng v√† d·ªÖ hi·ªÉu

H√£y tr·∫£ l·ªùi c√°c c√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng v·ªÅ d·ª± √°n n√†y m·ªôt c√°ch h·ªØu √≠ch, ch√≠nh x√°c v√† th·ªÉ hi·ªán s·ª± chuy√™n nghi·ªáp c·ªßa C√¥ng ty C∆° Kh√≠ T√¢n H√≤a Ph√°t.`;

  return contextPrompt;
};

/**
 * G·ª≠i c√¢u h·ªèi v·ªÅ d·ª± √°n ƒë·∫øn AI
 * @param {string} question - C√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng
 * @param {Object} project - Th√¥ng tin d·ª± √°n
 * @param {Array} chatHistory - L·ªãch s·ª≠ chat
 * @param {Array} attachments - File ƒë√≠nh k√®m (t√πy ch·ªçn)
 * @returns {Promise<Object>} Ph·∫£n h·ªìi t·ª´ AI
 */
export const askAboutProject = async (
  question,
  project,
  chatHistory = [],
  attachments = []
) => {
  try {
    // X·ª≠ l√Ω file ƒë√≠nh k√®m
    const processedAttachments = processAttachments(attachments);

    // T·∫°o context prompt
    let contextPrompt = createProjectContextPrompt(project);

    // Th√™m l·ªãch s·ª≠ b√°o gi√° m·ªõi nh·∫•t (ch·ªâ khi l·∫ßn ƒë·∫ßu m·ªü chat c·ªßa d·ª± √°n)
    const recentHistory = chatHistory.slice(-15);
    if (project?.id && recentHistory.length === 0) {
      try {
        const quotations = await getQuotationsByProject(project.id);
        const latestQuotations = (quotations || []).slice(0, 1).map((q) => ({
          id: q.id,
          title: q.title || q.name || undefined,
          customerName: q.customerName || q.customer?.name || undefined,
          totalAmount: q.totalAmount || q.total || undefined,
          currency: q.currency || 'VND',
          itemsCount: Array.isArray(q.items) ? q.items.length : undefined,
          pdfUrl: q.pdfUrl || undefined,
          createdAt:
            (q.createdAt?.toDate?.() && q.createdAt.toDate().toISOString()) ||
            q.createdAt ||
            undefined,
        }));

        if (latestQuotations.length > 0) {
          const quotationContext = `\n\n**B√°o gi√° g·∫ßn nh·∫•t (JSON):**\n${JSON.stringify(
            latestQuotations[0],
            null,
            2
          )}`;
          contextPrompt += quotationContext;
        }
      } catch (e) {
        console.warn('Kh√¥ng th·ªÉ l·∫•y l·ªãch s·ª≠ b√°o gi√° ƒë·ªÉ th√™m context:', e);
      }
    }

    // X√¢y d·ª±ng messages array
    const messages = [];

    // Th√™m system message v·ªõi context
    if (contextPrompt) {
      messages.push({
        role: 'system',
        content: contextPrompt,
      });
    }

    // Th√™m l·ªãch s·ª≠ chat (gi·ªõi h·∫°n 15 tin nh·∫Øn g·∫ßn nh·∫•t ƒë·ªÉ tr√°nh qu√° d√†i)
    messages.push(...recentHistory);

    // T·∫°o n·ªôi dung tin nh·∫Øn v·ªõi file ƒë√≠nh k√®m
    let userContent = question;
    if (processedAttachments) {
      userContent += createAttachmentPrompt(processedAttachments);
    }

    // Th√™m c√¢u h·ªèi hi·ªán t·∫°i
    messages.push({
      role: 'user',
      content: userContent,
    });

    console.log('Sending project question to AI:', {
      projectName: project?.name,
      questionLength: question.length,
      historyLength: recentHistory.length,
      hasAttachments: !!processedAttachments,
      attachmentCount: attachments.length,
    });

    // G·ª≠i ƒë·∫øn AI
    const response = await sendMessageToAI(messages, DEFAULT_MODEL, {
      maxTokens: 10000,
      temperature: 0.7,
    });
    return response;
  } catch (error) {
    console.error('Error asking about project:', error);
    return {
      success: false,
      error: error.message,
      message: 'C√≥ l·ªói x·∫£y ra khi g·ª≠i c√¢u h·ªèi v·ªÅ d·ª± √°n',
    };
  }
};

/**
 * G·ª≠i c√¢u h·ªèi chung ƒë·∫øn AI (kh√¥ng li√™n quan ƒë·∫øn d·ª± √°n c·ª• th·ªÉ)
 * @param {string} question - C√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng
 * @param {Array} chatHistory - L·ªãch s·ª≠ chat
 * @param {Array} attachments - File ƒë√≠nh k√®m (t√πy ch·ªçn)
 * @returns {Promise<Object>} Ph·∫£n h·ªìi t·ª´ AI
 */
export const askGeneralQuestion = async (
  question,
  chatHistory = [],
  attachments = []
) => {
  try {
    // X·ª≠ l√Ω file ƒë√≠nh k√®m
    const processedAttachments = processAttachments(attachments);

    const systemMessage = {
      role: 'system',
      content:
        'B·∫°n l√† tr·ª£ l√Ω AI chuy√™n nghi·ªáp c·ªßa C√¥ng ty C∆° Kh√≠ T√¢n H√≤a Ph√°t - chuy√™n s·∫£n xu·∫•t b·ªìn c√¥ng nghi·ªáp t·∫°i TP.HCM. B·∫°n c√≥ ki·∫øn th·ª©c s√¢u r·ªông v·ªÅ ng√†nh c∆° kh√≠, s·∫£n xu·∫•t c√¥ng nghi·ªáp v√† qu·∫£n l√Ω d·ª± √°n. Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát v·ªõi phong c√°ch chuy√™n nghi·ªáp, s·ª≠ d·ª•ng thu·∫≠t ng·ªØ k·ªπ thu·∫≠t ph√π h·ª£p v√† ƒë∆∞a ra l·ªùi khuy√™n th·ª±c t·∫ø d·ª±a tr√™n kinh nghi·ªám s·∫£n xu·∫•t c√¥ng nghi·ªáp.',
    };

    const messages = [systemMessage];

    // Th√™m l·ªãch s·ª≠ chat g·∫ßn nh·∫•t
    const recentHistory = chatHistory.slice(-10);
    messages.push(...recentHistory);

    // T·∫°o n·ªôi dung tin nh·∫Øn v·ªõi file ƒë√≠nh k√®m
    let userContent = question;
    if (processedAttachments) {
      userContent += createAttachmentPrompt(processedAttachments);
    }

    // Th√™m c√¢u h·ªèi hi·ªán t·∫°i
    messages.push({
      role: 'user',
      content: userContent,
    });

    console.log('Sending general question to AI:', {
      questionLength: question.length,
      historyLength: recentHistory.length,
      hasAttachments: !!processedAttachments,
      attachmentCount: attachments.length,
    });

    const response = await sendMessageToAI(messages, DEFAULT_MODEL, {
      maxTokens: 10000,
      temperature: 0.7,
    });
    return response;
  } catch (error) {
    console.error('Error asking general question:', error);
    return {
      success: false,
      error: error.message,
      message: 'C√≥ l·ªói x·∫£y ra khi g·ª≠i c√¢u h·ªèi',
    };
  }
};

/**
 * T·∫°o c√¢u h·ªèi g·ª£i √Ω cho ng∆∞·ªùi d√πng
 * @param {Object} project - Th√¥ng tin d·ª± √°n
 * @returns {Array} Danh s√°ch c√¢u h·ªèi g·ª£i √Ω
 */
export const getSuggestedQuestions = (project = null) => {
  if (project) {
    return [
      `D·ª± √°n "${project.name}" ƒëang ·ªü giai ƒëo·∫°n n√†o?`,
      'C·∫ßn l√†m g√¨ ƒë·ªÉ ƒë·∫©y nhanh ti·∫øn ƒë·ªô d·ª± √°n?',
      'C√≥ v·∫•n ƒë·ªÅ g√¨ c·∫ßn l∆∞u √Ω trong d·ª± √°n n√†y?',
      'L√†m th·∫ø n√†o ƒë·ªÉ t·ªëi ∆∞u h√≥a quy tr√¨nh s·∫£n xu·∫•t?',
      'C·∫ßn chu·∫©n b·ªã g√¨ cho giai ƒëo·∫°n ti·∫øp theo?',
    ];
  }

  return [
    'L√†m th·∫ø n√†o ƒë·ªÉ qu·∫£n l√Ω d·ª± √°n s·∫£n xu·∫•t b·ªìn c√¥ng nghi·ªáp hi·ªáu qu·∫£?',
    'C√°c ti√™u chu·∫©n ch·∫•t l∆∞·ª£ng trong s·∫£n xu·∫•t b·ªìn c√¥ng nghi·ªáp?',
    'Quy tr√¨nh h√†n v√† gia c√¥ng kim lo·∫°i cho b·ªìn c√¥ng nghi·ªáp?',
    'C√°ch x·ª≠ l√Ω r·ªßi ro an to√†n lao ƒë·ªông trong s·∫£n xu·∫•t c∆° kh√≠?',
    'L√†m th·∫ø n√†o ƒë·ªÉ t·ªëi ∆∞u h√≥a chi ph√≠ s·∫£n xu·∫•t c∆° kh√≠?',
  ];
};


--- END: src\api\aiChatService.js ---


--- START: src\api\attendanceService.js ---
// src/api/attendanceService.js

import {
  doc,
  getDoc,
  setDoc,
  updateDoc,
  serverTimestamp,
  collection,
  query,
  where,
  getDocs,
  orderBy,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';

/**
 * Utility to get YYYY-MM-DD formatted date string in local timezone.
 * @param {Date} [dateObj]
 */
const formatDate = (dateObj = new Date()) => {
  const year = dateObj.getFullYear();
  const month = String(dateObj.getMonth() + 1).padStart(2, '0');
  const day = String(dateObj.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};

/**
 * Build document reference for a user & date (defaults to today)
 */
const attendanceDocRef = (userId, dateStr = formatDate()) =>
  doc(db, 'attendance', `${userId}_${dateStr}`);

/**
 * Fetch today (or specific date) attendance for a user
 * @param {string} userId
 * @param {string} [dateStr] formatted YYYY-MM-DD
 */
export const getAttendance = async (userId, dateStr = formatDate()) => {
  const ref = attendanceDocRef(userId, dateStr);
  const snap = await getDoc(ref);
  if (snap.exists()) {
    return { id: snap.id, ...snap.data() };
  }
  return null;
};

/**
 * Clock in: set clockIn timestamp if not already set.
 * Returns updated attendance document.
 */
export const clockIn = async (userId, timestamp = new Date()) => {
  const dateStr = formatDate(timestamp);
  const ref = attendanceDocRef(userId, dateStr);
  const data = {
    clockIn: timestamp,
    updatedAt: serverTimestamp(),
  };

  const existing = await getDoc(ref);
  if (existing.exists()) {
    // Only set clockIn if not yet recorded
    if (!existing.data().clockIn) {
      // Lo·∫°i b·ªè c√°c field c√≥ gi√° tr·ªã undefined ƒë·ªÉ tr√°nh l·ªói Firestore
      const cleanData = Object.fromEntries(
        Object.entries(data).filter(([_, value]) => value !== undefined)
      );
      await updateDoc(ref, cleanData);
    }
  } else {
    data.createdAt = serverTimestamp();
    await setDoc(ref, data);
  }
  return (await getDoc(ref)).data();
};

/**
 * Clock out: set clockOut timestamp.
 */
export const clockOut = async (userId, timestamp = new Date()) => {
  const dateStr = formatDate(timestamp);
  const ref = attendanceDocRef(userId, dateStr);
  const data = {
    clockOut: timestamp,
    updatedAt: serverTimestamp(),
  };
  const existing = await getDoc(ref);
  if (existing.exists()) {
    // Lo·∫°i b·ªè c√°c field c√≥ gi√° tr·ªã undefined ƒë·ªÉ tr√°nh l·ªói Firestore
    const cleanData = Object.fromEntries(
      Object.entries(data).filter(([_, value]) => value !== undefined)
    );
    await updateDoc(ref, cleanData);
  } else {
    // In case user forget to clock in, create new doc
    await setDoc(ref, {
      userId,
      date: dateStr,
      clockOut: timestamp,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
    });
  }
  return (await getDoc(ref)).data();
};

/**
 * Add / update overtime hours (floating number of hours)
 */
export const addOvertime = async (userId, hours, timestamp = new Date()) => {
  const dateStr = formatDate(timestamp);
  const ref = attendanceDocRef(userId, dateStr);
  const existing = await getDoc(ref);
  if (existing.exists()) {
    const data = {
      overtime: hours,
      updatedAt: serverTimestamp(),
    };
    // Lo·∫°i b·ªè c√°c field c√≥ gi√° tr·ªã undefined ƒë·ªÉ tr√°nh l·ªói Firestore
    const cleanData = Object.fromEntries(
      Object.entries(data).filter(([_, value]) => value !== undefined)
    );
    await updateDoc(ref, cleanData);
  } else {
    await setDoc(ref, {
      userId,
      date: dateStr,
      overtime: hours,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
    });
  }
  return (await getDoc(ref)).data();
};

/**
 * Mark presence boolean for the day (mass attendance)
 */
export const setPresence = async (
  userId,
  present = true,
  timestamp = new Date()
) => {
  const dateStr = formatDate(timestamp);
  const ref = attendanceDocRef(userId, dateStr);
  const existing = await getDoc(ref);
  if (existing.exists()) {
    const data = {
      present,
      updatedAt: serverTimestamp(),
    };
    // Lo·∫°i b·ªè c√°c field c√≥ gi√° tr·ªã undefined ƒë·ªÉ tr√°nh l·ªói Firestore
    const cleanData = Object.fromEntries(
      Object.entries(data).filter(([_, value]) => value !== undefined)
    );
    await updateDoc(ref, cleanData);
  } else {
    await setDoc(ref, {
      userId,
      date: dateStr,
      present,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
    });
  }
  return (await getDoc(ref)).data();
};

/**
 * Utility to determine current status for UI
 * Returns: 'none' | 'clocked_in' | 'clocked_out'
 */
export const getAttendanceStatus = (attendanceDoc) => {
  if (!attendanceDoc) return 'none';
  if (attendanceDoc.clockIn && !attendanceDoc.clockOut) return 'clocked_in';
  if (attendanceDoc.clockIn && attendanceDoc.clockOut) return 'clocked_out';
  return 'none';
};
/**
 * Get attendance history for a user by month and year
 * @param {string} userId
 * @param {number} year
 * @param {number} month (1-12)
 * @returns {Array} Array of attendance records
 */
export const getAttendanceHistory = async (userId, year, month) => {
  try {
    // T·∫°o range date cho th√°ng
    const startDate = new Date(year, month - 1, 1);
    const endDate = new Date(year, month, 0); // Ng√†y cu·ªëi c√πng c·ªßa th√°ng

    // Format dates ƒë·ªÉ t√¨m documents
    const startDateStr = formatDate(startDate);
    const endDateStr = formatDate(endDate);

    // T·∫°o query ƒë·ªÉ l·∫•y t·∫•t c·∫£ attendance records trong th√°ng
    const attendanceRef = collection(db, 'attendance');

    // L·∫•y t·∫•t c·∫£ documents v√† filter theo date range
    const querySnapshot = await getDocs(attendanceRef);
    const attendanceRecords = [];

    querySnapshot.forEach((doc) => {
      const data = doc.data();

      // Ki·ªÉm tra xem document c√≥ thu·ªôc user n√†y kh√¥ng
      if (data.userId === userId || doc.id.startsWith(userId + '_')) {
        // Tr√≠ch xu·∫•t ng√†y t·ª´ document ID (format: userId_YYYY-MM-DD)
        let docDate = data.date;
        if (!docDate && doc.id.includes('_')) {
          const datePart = doc.id.split('_')[1];
          if (datePart && datePart.match(/^\d{4}-\d{2}-\d{2}$/)) {
            docDate = datePart;
          }
        }

        // Ki·ªÉm tra xem document c√≥ thu·ªôc th√°ng c·∫ßn t√¨m kh√¥ng
        if (docDate && docDate >= startDateStr && docDate <= endDateStr) {
          attendanceRecords.push({
            id: doc.id,
            ...data,
            clockIn: data.clockIn,
            clockOut: data.clockOut,
            overtime: data.overtime || 0,
            date: docDate,
          });
        }
      }
    });

    // S·∫Øp x·∫øp theo ng√†y
    attendanceRecords.sort((a, b) => a.date.localeCompare(b.date));

    return attendanceRecords;
  } catch (error) {
    console.error('Error getting attendance history:', error);
    throw error;
  }
};

/**
 * Get attendance summary for a user by month and year
 * @param {string} userId
 * @param {number} year
 * @param {number} month (1-12)
 * @returns {Object} Summary object with total days, hours, overtime
 */
export const getAttendanceSummary = async (userId, year, month) => {
  try {
    const history = await getAttendanceHistory(userId, year, month);

    const summary = {
      totalDays: history.length,
      totalHours: 0,
      totalOvertime: 0,
      averageHoursPerDay: 0,
    };

    history.forEach((record) => {
      if (record.clockIn && record.clockOut) {
        const startTime = record.clockIn.toDate
          ? record.clockIn.toDate()
          : new Date(record.clockIn);
        const endTime = record.clockOut.toDate
          ? record.clockOut.toDate()
          : new Date(record.clockOut);
        const hours = (endTime - startTime) / (1000 * 60 * 60);
        summary.totalHours += hours;
      }

      if (record.overtime) {
        summary.totalOvertime += record.overtime;
      }
    });

    if (summary.totalDays > 0) {
      summary.averageHoursPerDay = summary.totalHours / summary.totalDays;
    }

    return summary;
  } catch (error) {
    console.error('Error getting attendance summary:', error);
    throw error;
  }
};



--- END: src\api\attendanceService.js ---


--- START: src\api\customerImportService.js ---
import { getFunctions, httpsCallable } from 'firebase/functions';
import { GoogleSignin } from '@react-native-google-signin/google-signin';

const functions = getFunctions();

// L·∫•y danh s√°ch file customer t·ª´ Google Drive
export const getCustomerFiles = async () => {
  try {
    // 1. L·∫•y accessToken t·ª´ GoogleSignin
    const tokens = await GoogleSignin.getTokens();
    const { accessToken } = tokens;

    if (!accessToken) {
      throw new Error(
        'Kh√¥ng th·ªÉ l·∫•y ƒë∆∞·ª£c access token c·ªßa Google. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.'
      );
    }

    // 2. G·ªçi Cloud Function v·ªõi accessToken
    const getCustomerFilesFunction = httpsCallable(
      functions,
      'getCustomerFiles'
    );
    const result = await getCustomerFilesFunction({ accessToken });

    console.log('üìÅ Danh s√°ch file customer:', result.data);
    return result.data;
  } catch (error) {
    console.error('‚ùå L·ªói khi l·∫•y danh s√°ch file customer:', error);
    throw error;
  }
};

// Import kh√°ch h√†ng t·ª´ Excel file
export const importCustomersFromExcel = async (fileId) => {
  try {
    console.log('üöÄ B·∫Øt ƒë·∫ßu import kh√°ch h√†ng t·ª´ file:', fileId);

    // 1. L·∫•y accessToken t·ª´ GoogleSignin
    const tokens = await GoogleSignin.getTokens();
    const { accessToken } = tokens;

    if (!accessToken) {
      throw new Error(
        'Kh√¥ng th·ªÉ l·∫•y ƒë∆∞·ª£c access token c·ªßa Google. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.'
      );
    }

    // 2. G·ªçi Cloud Function v·ªõi accessToken
    const importCustomersFunction = httpsCallable(
      functions,
      'importCustomersFromExcel'
    );
    const result = await importCustomersFunction({
      driveFileId: fileId,
      accessToken,
    });

    console.log('‚úÖ K·∫øt qu·∫£ import kh√°ch h√†ng:', result.data);
    return result.data;
  } catch (error) {
    console.error('‚ùå L·ªói khi import kh√°ch h√†ng:', error);
    throw error;
  }
};


--- END: src\api\customerImportService.js ---


--- START: src\api\customerService.js ---
//src/api/customerService.js
import {
  collection,
  addDoc,
  updateDoc,
  deleteDoc,
  doc,
  query,
  orderBy,
  getDocs,
  getDoc,
  where,
  serverTimestamp,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';

/**
 * T·∫°o kh√°ch h√†ng m·ªõi
 * @param {Object} customerData - D·ªØ li·ªáu kh√°ch h√†ng
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng t·∫°o kh√°ch h√†ng
 * @returns {Promise<Object>} - Kh√°ch h√†ng ƒë√£ t·∫°o k√®m ID
 */
export const createCustomer = async (customerData, userId) => {
  try {
    const docRef = await addDoc(collection(db, 'customers'), {
      ...customerData,
      createdAt: serverTimestamp(),
      createdBy: userId,
      updatedAt: serverTimestamp(),
    });

    return {
      id: docRef.id,
      ...customerData,
    };
  } catch (error) {
    throw error;
  }
};

/**
 * L·∫•y t·∫•t c·∫£ kh√°ch h√†ng
 * @returns {Promise<Array>} - M·∫£ng kh√°ch h√†ng
 */
export const getCustomers = async () => {
  try {
    const customersRef = collection(db, 'customers');
    const q = query(customersRef, orderBy('createdAt', 'desc'));
    const querySnapshot = await getDocs(q);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    throw error;
  }
};

/**
 * L·∫•y kh√°ch h√†ng theo ID
 * @param {string} customerId - ID kh√°ch h√†ng
 * @returns {Promise<Object|null>} - D·ªØ li·ªáu kh√°ch h√†ng ho·∫∑c null n·∫øu kh√¥ng t√¨m th·∫•y
 */
export const getCustomerById = async (customerId) => {
  try {
    const customerRef = doc(db, 'customers', customerId);
    const customerSnapshot = await getDoc(customerRef);

    if (customerSnapshot.exists()) {
      return {
        id: customerSnapshot.id,
        ...customerSnapshot.data(),
      };
    } else {
      return null;
    }
  } catch (error) {
    throw error;
  }
};

/**
 * C·∫≠p nh·∫≠t th√¥ng tin kh√°ch h√†ng
 * @param {string} customerId - ID kh√°ch h√†ng
 * @param {Object} customerData - D·ªØ li·ªáu kh√°ch h√†ng c·∫≠p nh·∫≠t
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng c·∫≠p nh·∫≠t kh√°ch h√†ng
 * @returns {Promise<void>}
 */
export const updateCustomer = async (customerId, customerData, userId) => {
  try {
    // Lo·∫°i b·ªè c√°c field c√≥ gi√° tr·ªã undefined ƒë·ªÉ tr√°nh l·ªói Firestore
    const cleanData = Object.fromEntries(
      Object.entries(customerData).filter(([_, value]) => value !== undefined)
    );

    const customerRef = doc(db, 'customers', customerId);
    await updateDoc(customerRef, {
      ...cleanData,
      updatedAt: serverTimestamp(),
      updatedBy: userId,
    });
  } catch (error) {
    console.error('L·ªói khi c·∫≠p nh·∫≠t kh√°ch h√†ng:', error);
    throw error;
  }
};

/**
 * X√≥a kh√°ch h√†ng
 * @param {string} customerId - ID kh√°ch h√†ng
 * @returns {Promise<void>}
 */
export const deleteCustomer = async (customerId) => {
  try {
    const customerRef = doc(db, 'customers', customerId);
    await deleteDoc(customerRef);
  } catch (error) {
    throw error;
  }
};

/**
 * T√¨m ki·∫øm kh√°ch h√†ng theo t√™n ho·∫∑c ng∆∞·ªùi li√™n h·ªá
 * @param {string} searchTerm - T·ª´ kh√≥a t√¨m ki·∫øm
 * @returns {Promise<Array>} - M·∫£ng kh√°ch h√†ng ph√π h·ª£p
 */
export const searchCustomers = async (searchTerm) => {
  try {
    const customersRef = collection(db, 'customers');
    const nameQuery = query(
      customersRef,
      where('name', '>=', searchTerm),
      where('name', '<=', searchTerm + '\uf8ff')
    );
    const contactQuery = query(
      customersRef,
      where('contactPerson', '>=', searchTerm),
      where('contactPerson', '<=', searchTerm + '\uf8ff')
    );

    const [nameSnapshot, contactSnapshot] = await Promise.all([
      getDocs(nameQuery),
      getDocs(contactQuery),
    ]);

    // K·∫øt h·ª£p k·∫øt qu·∫£ v√† lo·∫°i b·ªè tr√πng l·∫∑p
    const results = new Map();

    nameSnapshot.docs.forEach((doc) => {
      results.set(doc.id, { id: doc.id, ...doc.data() });
    });

    contactSnapshot.docs.forEach((doc) => {
      if (!results.has(doc.id)) {
        results.set(doc.id, { id: doc.id, ...doc.data() });
      }
    });

    return Array.from(results.values());
  } catch (error) {
    throw error;
  }
};

/**
 * L·∫•y kh√°ch h√†ng theo lo·∫°i
 * @param {string} type - Lo·∫°i kh√°ch h√†ng (potential, regular, vip)
 * @returns {Promise<Array>} - M·∫£ng kh√°ch h√†ng thu·ªôc lo·∫°i ƒë√£ ch·ªâ ƒë·ªãnh
 */
export const getCustomersByType = async (type) => {
  try {
    const customersRef = collection(db, 'customers');
    const q = query(
      customersRef,
      where('type', '==', type),
      orderBy('createdAt', 'desc')
    );

    const querySnapshot = await getDocs(q);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    throw error;
  }
};


--- END: src\api\customerService.js ---


--- START: src\api\expenseService.js ---
import { db } from '../config/firebaseConfig';
import {
  collection,
  doc,
  addDoc,
  updateDoc,
  deleteDoc,
  getDoc,
  getDocs,
  query,
  where,
  orderBy,
  serverTimestamp,
} from 'firebase/firestore';

// L∆∞u chi ph√≠ d·ª± √°n
export const saveProjectExpense = async (projectId, expenseData) => {
  try {
    const expenseRef = await addDoc(collection(db, 'expenses'), {
      projectId,
      projectName: expenseData.projectName,
      materialCost: expenseData.materialCost || 0,
      laborCost: expenseData.laborCost || 0,
      accessoryCost: expenseData.accessoryCost || 0,
      totalCost: expenseData.totalCost || 0,
      materialBreakdown: expenseData.materialBreakdown || {},
      laborBreakdown: expenseData.laborBreakdown || [],
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
    });

    console.log('‚úÖ ƒê√£ l∆∞u chi ph√≠ d·ª± √°n:', projectId, expenseRef.id);
    return expenseRef.id;
  } catch (error) {
    console.error('‚ùå L·ªói khi l∆∞u chi ph√≠ d·ª± √°n:', error);
    throw error;
  }
};

// L·∫•y chi ph√≠ d·ª± √°n
export const getProjectExpense = async (projectId) => {
  try {
    const q = query(
      collection(db, 'expenses'),
      where('projectId', '==', projectId),
      orderBy('createdAt', 'desc')
    );

    const querySnapshot = await getDocs(q);
    if (querySnapshot.empty) {
      console.log('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y chi ph√≠ cho d·ª± √°n:', projectId);
      return null;
    }

    const expense = querySnapshot.docs[0].data();
    console.log('üìã Chi ph√≠ d·ª± √°n:', projectId, expense);
    return { id: querySnapshot.docs[0].id, ...expense };
  } catch (error) {
    console.error('‚ùå L·ªói khi l·∫•y chi ph√≠ d·ª± √°n:', error);
    throw error;
  }
};

// T·∫°o ho·∫∑c c·∫≠p nh·∫≠t chi ph√≠ theo projectId
export const upsertProjectExpense = async (projectId, expenseData) => {
  try {
    const q = query(
      collection(db, 'expenses'),
      where('projectId', '==', projectId)
    );
    const snap = await getDocs(q);
    if (!snap.empty) {
      const docId = snap.docs[0].id;
      await updateDoc(doc(db, 'expenses', docId), {
        projectId,
        projectName: expenseData.projectName,
        materialCost: expenseData.materialCost || 0,
        laborCost: expenseData.laborCost || 0,
        accessoryCost: expenseData.accessoryCost || 0,
        totalCost: expenseData.totalCost || 0,
        materialBreakdown: expenseData.materialBreakdown || {},
        laborBreakdown: expenseData.laborBreakdown || [],
        updatedAt: serverTimestamp(),
      });
      console.log('‚ôªÔ∏è ƒê√£ c·∫≠p nh·∫≠t chi ph√≠ d·ª± √°n:', projectId, docId);
      return docId;
    }
    // N·∫øu ch∆∞a c√≥ -> t·∫°o m·ªõi
    return await saveProjectExpense(projectId, expenseData);
  } catch (error) {
    console.error('‚ùå L·ªói upsert chi ph√≠ d·ª± √°n:', error);
    throw error;
  }
};

// L·∫•y t·∫•t c·∫£ chi ph√≠ trong th√°ng
export const getExpensesInMonth = async (year, month) => {
  try {
    const startDate = new Date(year, month - 1, 1);
    const endDate = new Date(year, month, 0, 23, 59, 59);

    console.log('üîç T√¨m chi ph√≠ trong th√°ng:', {
      year,
      month,
      startDate: startDate.toISOString(),
      endDate: endDate.toISOString(),
    });

    const q = query(
      collection(db, 'expenses'),
      where('createdAt', '>=', startDate),
      where('createdAt', '<=', endDate),
      orderBy('createdAt', 'desc')
    );

    const querySnapshot = await getDocs(q);
    const expenses = [];

    querySnapshot.forEach((doc) => {
      expenses.push({ id: doc.id, ...doc.data() });
    });

    console.log('üìä T·ªïng chi ph√≠ trong th√°ng:', expenses.length);
    return expenses;
  } catch (error) {
    console.error('‚ùå L·ªói khi l·∫•y chi ph√≠ trong th√°ng:', error);
    throw error;
  }
};

// C·∫≠p nh·∫≠t chi ph√≠ d·ª± √°n
export const updateProjectExpense = async (expenseId, updateData) => {
  try {
    const expenseRef = doc(db, 'expenses', expenseId);
    await updateDoc(expenseRef, {
      ...updateData,
      updatedAt: serverTimestamp(),
    });

    console.log('‚úÖ ƒê√£ c·∫≠p nh·∫≠t chi ph√≠:', expenseId);
  } catch (error) {
    console.error('‚ùå L·ªói khi c·∫≠p nh·∫≠t chi ph√≠:', error);
    throw error;
  }
};

// X√≥a chi ph√≠ d·ª± √°n
export const deleteProjectExpense = async (expenseId) => {
  try {
    await deleteDoc(doc(db, 'expenses', expenseId));
    console.log('‚úÖ ƒê√£ x√≥a chi ph√≠:', expenseId);
  } catch (error) {
    console.error('‚ùå L·ªói khi x√≥a chi ph√≠:', error);
    throw error;
  }
};

// X√≥a t·∫•t c·∫£ chi ph√≠ theo projectId (d√πng ƒë·ªÉ d·ªçn d·ªØ li·ªáu test)
export const deleteExpensesByProjectId = async (projectId) => {
  try {
    const q = query(
      collection(db, 'expenses'),
      where('projectId', '==', projectId)
    );
    const snap = await getDocs(q);
    const deletions = [];
    snap.forEach((d) => {
      deletions.push(deleteDoc(doc(db, 'expenses', d.id)));
    });
    await Promise.all(deletions);
    console.log(
      `üßπ ƒê√£ x√≥a ${deletions.length} chi ph√≠ cho projectId=${projectId}`
    );
    return deletions.length;
  } catch (error) {
    console.error('‚ùå L·ªói khi x√≥a chi ph√≠ theo projectId:', error);
    throw error;
  }
};


--- END: src\api\expenseService.js ---


--- START: src\api\fixedCostService.js ---
import {
  collection,
  doc,
  addDoc,
  updateDoc,
  deleteDoc,
  getDoc,
  getDocs,
  query,
  where,
  orderBy,
  serverTimestamp,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';

// L·∫•y t·∫•t c·∫£ chi ph√≠ c·ªë ƒë·ªãnh
export const getFixedCosts = async () => {
  try {
    const q = query(
      collection(db, 'fixed_costs'),
      orderBy('createdAt', 'desc')
    );
    const querySnapshot = await getDocs(q);
    const fixedCosts = [];
    querySnapshot.forEach((doc) => {
      fixedCosts.push({ id: doc.id, ...doc.data() });
    });
    return fixedCosts;
  } catch (error) {
    console.error('L·ªói khi l·∫•y danh s√°ch chi ph√≠ c·ªë ƒë·ªãnh:', error);
    throw error;
  }
};

// L·∫•y chi ph√≠ c·ªë ƒë·ªãnh theo ID
export const getFixedCostById = async (id) => {
  try {
    const docRef = doc(db, 'fixed_costs', id);
    const docSnap = await getDoc(docRef);
    if (docSnap.exists()) {
      return { id: docSnap.id, ...docSnap.data() };
    } else {
      return null;
    }
  } catch (error) {
    console.error('L·ªói khi l·∫•y chi ph√≠ c·ªë ƒë·ªãnh:', error);
    throw error;
  }
};

// Th√™m chi ph√≠ c·ªë ƒë·ªãnh m·ªõi
export const addFixedCost = async (fixedCostData, userId) => {
  try {
    const fixedCostToAdd = {
      ...fixedCostData,
      monthlyCost: Number(fixedCostData.monthlyCost || 0),
      createdAt: serverTimestamp(),
      createdBy: userId,
      updatedAt: serverTimestamp(),
      updatedBy: userId,
    };
    const cleanData = Object.fromEntries(
      Object.entries(fixedCostToAdd).filter(([_, value]) => value !== undefined)
    );
    const docRef = await addDoc(collection(db, 'fixed_costs'), cleanData);
    return docRef.id;
  } catch (error) {
    console.error('L·ªói khi th√™m chi ph√≠ c·ªë ƒë·ªãnh:', error);
    throw error;
  }
};

// C·∫≠p nh·∫≠t chi ph√≠ c·ªë ƒë·ªãnh
export const updateFixedCost = async (id, fixedCostData, userId) => {
  try {
    const fixedCostToUpdate = {
      ...fixedCostData,
      monthlyCost: Number(fixedCostData.monthlyCost || 0),
      updatedAt: serverTimestamp(),
      updatedBy: userId,
    };
    const cleanData = Object.fromEntries(
      Object.entries(fixedCostToUpdate).filter(
        ([_, value]) => value !== undefined
      )
    );
    const docRef = doc(db, 'fixed_costs', id);
    await updateDoc(docRef, cleanData);
  } catch (error) {
    console.error('L·ªói khi c·∫≠p nh·∫≠t chi ph√≠ c·ªë ƒë·ªãnh:', error);
    throw error;
  }
};

// X√≥a chi ph√≠ c·ªë ƒë·ªãnh
export const deleteFixedCost = async (id) => {
  try {
    const docRef = doc(db, 'fixed_costs', id);
    await deleteDoc(docRef);
  } catch (error) {
    console.error('L·ªói khi x√≥a chi ph√≠ c·ªë ƒë·ªãnh:', error);
    throw error;
  }
};

// L·∫•y t·ªïng chi ph√≠ c·ªë ƒë·ªãnh h√†ng th√°ng
export const getTotalMonthlyFixedCosts = async () => {
  try {
    const fixedCosts = await getFixedCosts();
    return fixedCosts.reduce(
      (total, cost) => total + Number(cost.monthlyCost || 0),
      0
    );
  } catch (error) {
    console.error('L·ªói khi t√≠nh t·ªïng chi ph√≠ c·ªë ƒë·ªãnh:', error);
    throw error;
  }
};

















--- END: src\api\fixedCostService.js ---


--- START: src\api\googleDriveService.js ---
//src/api/googleDriveService.js
import axios from 'axios';
import * as XLSX from 'xlsx';
import * as FileSystem from 'expo-file-system';

/**
 * L·∫•y danh s√°ch file t·ª´ Google Drive
 * @param {string} accessToken - Token x√°c th·ª±c Google
 * @param {string} folderId - ID th∆∞ m·ª•c c·∫ßn l·∫•y (t√πy ch·ªçn)
 * @returns {Promise<Array>} - M·∫£ng c√°c file/th∆∞ m·ª•c
 */
export const listFiles = async (accessToken, folderId = null) => {
  try {
    let url = 'https://www.googleapis.com/drive/v3/files';
    let params = {
      fields: 'files(id, name, mimeType, modifiedTime, size)',
      orderBy: 'modifiedTime desc',
    };

    // N·∫øu c√≥ folderId, l·ªçc theo th∆∞ m·ª•c
    if (folderId) {
      params.q = `'${folderId}' in parents and trashed = false`;
    } else {
      params.q = 'trashed = false';
    }

    const response = await axios.get(url, {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
      },
      params,
    });

    return response.data.files;
  } catch (error) {
    console.error('L·ªói khi l·∫•y danh s√°ch file t·ª´ Google Drive:', error);
    throw error;
  }
};

/**
 * T√¨m ki·∫øm file tr√™n Google Drive
 * @param {string} accessToken - Token x√°c th·ª±c Google
 * @param {string} query - T·ª´ kh√≥a t√¨m ki·∫øm
 * @returns {Promise<Array>} - M·∫£ng c√°c file ph√π h·ª£p
 */
export const searchFiles = async (accessToken, query) => {
  try {
    const url = 'https://www.googleapis.com/drive/v3/files';
    const params = {
      q: `name contains '${query}' and trashed = false`,
      fields: 'files(id, name, mimeType, modifiedTime, size)',
      orderBy: 'modifiedTime desc',
    };

    const response = await axios.get(url, {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
      },
      params,
    });

    return response.data.files;
  } catch (error) {
    console.error('L·ªói khi t√¨m ki·∫øm file tr√™n Google Drive:', error);
    throw error;
  }
};

/**
 * T·∫£i n·ªôi dung file t·ª´ Google Drive
 * @param {string} accessToken - Token x√°c th·ª±c Google
 * @param {string} fileId - ID c·ªßa file c·∫ßn t·∫£i
 * @returns {Promise<Object>} - D·ªØ li·ªáu file
 */
export const downloadFile = async (accessToken, fileId) => {
  try {
    // ƒê·∫ßu ti√™n l·∫•y th√¥ng tin file ƒë·ªÉ bi·∫øt ƒë·ªãnh d·∫°ng
    const fileInfoUrl = `https://www.googleapis.com/drive/v3/files/${fileId}?fields=name,mimeType`;
    const fileInfoResponse = await axios.get(fileInfoUrl, {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
    });

    const { name, mimeType } = fileInfoResponse.data;

    // T·∫£i n·ªôi dung file
    const downloadUrl = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`;
    const response = await axios.get(downloadUrl, {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
      responseType: 'arraybuffer',
    });

    return {
      name,
      mimeType,
      data: response.data,
    };
  } catch (error) {
    console.error('L·ªói khi t·∫£i file t·ª´ Google Drive:', error);
    throw error;
  }
};

/**
 * T·∫£i l√™n file l√™n Google Drive
 * @param {string} accessToken - Token x√°c th·ª±c Google
 * @param {File|Blob} file - File c·∫ßn t·∫£i l√™n
 * @param {string} folderId - ID th∆∞ m·ª•c ƒë√≠ch (t√πy ch·ªçn)
 * @returns {Promise<Object>} - Th√¥ng tin file ƒë√£ t·∫£i l√™n
 */
export const uploadFile = async (accessToken, file, folderId = null) => {
  try {
    const metadata = {
      name: file.name,
      mimeType: file.type,
    };

    // N·∫øu c√≥ folderId, ƒë·∫∑t file v√†o th∆∞ m·ª•c ƒë√≥
    if (folderId) {
      metadata.parents = [folderId];
    }

    // T·∫°o form data ƒë·ªÉ t·∫£i l√™n
    const form = new FormData();
    form.append(
      'metadata',
      new Blob([JSON.stringify(metadata)], { type: 'application/json' })
    );
    form.append('file', file);

    // T·∫£i l√™n file
    const response = await axios.post(
      'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart',
      form,
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          'Content-Type': 'multipart/form-data',
        },
      }
    );

    return response.data;
  } catch (error) {
    console.error('L·ªói khi t·∫£i file l√™n Google Drive:', error);
    throw error;
  }
};

/**
 * ƒê·ªçc n·ªôi dung file Excel t·ª´ Google Drive
 * @param {string} accessToken - Token x√°c th·ª±c Google
 * @param {string} fileId - ID c·ªßa file Excel
 * @returns {Promise<Object>} - D·ªØ li·ªáu ƒë√£ x·ª≠ l√Ω t·ª´ file Excel
 */
export const readExcelFile = async (accessToken, fileId) => {
  try {
    // T·∫£i file t·ª´ Google Drive
    const file = await downloadFile(accessToken, fileId);

    // Ki·ªÉm tra xem file c√≥ ph·∫£i l√† Excel kh√¥ng
    const isExcel =
      file.mimeType.includes('spreadsheet') ||
      file.mimeType.includes('excel') ||
      file.name.endsWith('.xlsx') ||
      file.name.endsWith('.xls');

    if (!isExcel) {
      throw new Error('File kh√¥ng ph·∫£i l√† Excel');
    }

    // X·ª≠ l√Ω file Excel v·ªõi th∆∞ vi·ªán xlsx
    const data = new Uint8Array(file.data);
    const workbook = XLSX.read(data, { type: 'array' });

    // L·∫•y sheet ƒë·∫ßu ti√™n
    const firstSheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[firstSheetName];

    // Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu sang d·∫°ng JSON
    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

    // N·∫øu c√≥ nhi·ªÅu sheet, l·∫•y t·∫•t c·∫£
    const allSheets = {};
    workbook.SheetNames.forEach((sheetName) => {
      const sheet = workbook.Sheets[sheetName];
      allSheets[sheetName] = XLSX.utils.sheet_to_json(sheet, { header: 1 });
    });

    return {
      fileName: file.name,
      firstSheet: jsonData,
      allSheets: allSheets,
      sheetNames: workbook.SheetNames,
    };
  } catch (error) {
    console.error('L·ªói khi ƒë·ªçc file Excel t·ª´ Google Drive:', error);
    throw error;
  }
};

/**
 * L∆∞u file Excel t·∫°m th·ªùi v√†o b·ªô nh·ªõ thi·∫øt b·ªã
 * @param {string} accessToken - Token x√°c th·ª±c Google
 * @param {string} fileId - ID c·ªßa file Excel
 * @returns {Promise<string>} - ƒê∆∞·ªùng d·∫´n ƒë·∫øn file ƒë√£ l∆∞u
 */
export const saveExcelFileLocally = async (accessToken, fileId) => {
  try {
    // T·∫£i file t·ª´ Google Drive
    const file = await downloadFile(accessToken, fileId);

    // T·∫°o t√™n file t·∫°m th·ªùi
    const tempFilePath = `${FileSystem.cacheDirectory}${file.name}`;

    // Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu th√†nh base64 ƒë·ªÉ l∆∞u v·ªõi FileSystem
    const base64Data = Buffer.from(file.data).toString('base64');

    // L∆∞u file v√†o b·ªô nh·ªõ t·∫°m
    await FileSystem.writeAsStringAsync(tempFilePath, base64Data, {
      encoding: FileSystem.EncodingType.Base64,
    });

    return tempFilePath;
  } catch (error) {
    console.error('L·ªói khi l∆∞u file Excel v√†o b·ªô nh·ªõ t·∫°m:', error);
    throw error;
  }
};

/**
 * T·∫°o th∆∞ m·ª•c m·ªõi tr√™n Google Drive
 * @param {string} accessToken - Token x√°c th·ª±c Google
 * @param {string} folderName - T√™n th∆∞ m·ª•c
 * @param {string} parentFolderId - ID th∆∞ m·ª•c cha (t√πy ch·ªçn)
 * @returns {Promise<Object>} - Th√¥ng tin th∆∞ m·ª•c ƒë√£ t·∫°o
 */
export const createFolder = async (
  accessToken,
  folderName,
  parentFolderId = null
) => {
  try {
    const metadata = {
      name: folderName,
      mimeType: 'application/vnd.google-apps.folder',
    };

    // N·∫øu c√≥ parentFolderId, ƒë·∫∑t th∆∞ m·ª•c v√†o th∆∞ m·ª•c cha ƒë√≥
    if (parentFolderId) {
      metadata.parents = [parentFolderId];
    }

    const response = await axios.post(
      'https://www.googleapis.com/drive/v3/files',
      metadata,
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
        },
      }
    );

    return response.data;
  } catch (error) {
    console.error('L·ªói khi t·∫°o th∆∞ m·ª•c tr√™n Google Drive:', error);
    throw error;
  }
};

/**
 * L·∫•y file Excel m·ªõi nh·∫•t t·ª´ th∆∞ m·ª•c c·ª• th·ªÉ v√† x·ª≠ l√Ω d·ªØ li·ªáu
 * @param {string} accessToken - Token x√°c th·ª±c Google
 * @param {string} folderId - ID th∆∞ m·ª•c c·∫ßn l·∫•y
 * @returns {Promise<Object>} - D·ªØ li·ªáu ƒë√£ x·ª≠ l√Ω t·ª´ file Excel m·ªõi nh·∫•t
 */
export const getLatestExcelFromFolder = async (accessToken, folderId) => {
  try {
    // L·∫•y danh s√°ch c√°c file trong th∆∞ m·ª•c, s·∫Øp x·∫øp theo th·ªùi gian s·ª≠a ƒë·ªïi m·ªõi nh·∫•t
    const files = await listFiles(accessToken, folderId);

    // L·ªçc ch·ªâ l·∫•y c√°c file Excel
    const excelFiles = files.filter(
      (file) =>
        file.mimeType.includes('spreadsheet') ||
        file.mimeType.includes('excel') ||
        file.name.endsWith('.xlsx') ||
        file.name.endsWith('.xls')
    );

    if (excelFiles.length === 0) {
      throw new Error('Kh√¥ng t√¨m th·∫•y file Excel n√†o trong th∆∞ m·ª•c');
    }

    // L·∫•y file m·ªõi nh·∫•t (ƒë√£ s·∫Øp x·∫øp theo modifiedTime desc)
    const latestExcelFile = excelFiles[0];
    console.log('ƒê√£ t√¨m th·∫•y file Excel m·ªõi nh·∫•t:', latestExcelFile.name);

    // ƒê·ªçc v√† x·ª≠ l√Ω file Excel
    const excelData = await readExcelFile(accessToken, latestExcelFile.id);

    return {
      fileInfo: latestExcelFile,
      data: excelData,
    };
  } catch (error) {
    console.error('L·ªói khi l·∫•y file Excel m·ªõi nh·∫•t:', error);
    throw error;
  }
};

/**
 * Ph√¢n t√≠ch d·ªØ li·ªáu t·ª´ file Excel c√¥ng n·ª£
 * @param {Object} excelData - D·ªØ li·ªáu Excel ƒë√£ ƒë·ªçc
 * @returns {Object} - D·ªØ li·ªáu c√¥ng n·ª£ ƒë√£ ph√¢n t√≠ch
 */
export const processDebtExcelData = (excelData) => {
  try {
    const sheets = excelData.allSheets;
    const result = {
      totalAccountsPayable: 0,
      totalAccountsReceivable: 0,
      top5Payable: [],
      top5Receivable: [],
      lastUpdated: new Date(),
    };

    // T√¨m sheet c√¥ng n·ª£ ph·∫£i tr·∫£
    const payableSheet = findSheetByName(sheets, [
      'Ph·∫£i Tr·∫£',
      'Phai Tra',
      'Accounts Payable',
      'C√¥ng N·ª£ Ph·∫£i Tr·∫£',
    ]);
    if (payableSheet) {
      const payableData = processPayableSheet(payableSheet);
      result.totalAccountsPayable = payableData.total;
      result.top5Payable = payableData.top5;
    }

    // T√¨m sheet c√¥ng n·ª£ ph·∫£i thu
    const receivableSheet = findSheetByName(sheets, [
      'Ph·∫£i Thu',
      'Phai Thu',
      'Accounts Receivable',
      'C√¥ng N·ª£ Ph·∫£i Thu',
    ]);
    if (receivableSheet) {
      const receivableData = processReceivableSheet(receivableSheet);
      result.totalAccountsReceivable = receivableData.total;
      result.top5Receivable = receivableData.top5;
    }

    // T√≠nh v·ªã th·∫ø c√¥ng n·ª£ r√≤ng
    result.netDebtPosition =
      result.totalAccountsReceivable - result.totalAccountsPayable;

    // ƒê·ªãnh d·∫°ng s·ªë ti·ªÅn
    result.formattedTotals = {
      totalAccountsPayable: formatCurrency(result.totalAccountsPayable),
      totalAccountsReceivable: formatCurrency(result.totalAccountsReceivable),
      netDebtPosition: formatCurrency(result.netDebtPosition),
    };

    return result;
  } catch (error) {
    console.error('L·ªói khi ph√¢n t√≠ch d·ªØ li·ªáu Excel c√¥ng n·ª£:', error);
    throw error;
  }
};

// H√†m tr·ª£ gi√∫p t√¨m sheet theo t√™n
const findSheetByName = (sheets, possibleNames) => {
  for (const sheetName in sheets) {
    if (
      possibleNames.some((name) =>
        sheetName.toLowerCase().includes(name.toLowerCase())
      )
    ) {
      return sheets[sheetName];
    }
  }
  return null;
};

// X·ª≠ l√Ω sheet c√¥ng n·ª£ ph·∫£i tr·∫£
const processPayableSheet = (sheetData) => {
  // T√¨m c√°c c·ªôt ch·ª©a th√¥ng tin nh√† cung c·∫•p v√† s·ªë ti·ªÅn
  const headerRow = sheetData.find((row) =>
    row.some(
      (cell) =>
        typeof cell === 'string' &&
        (cell.toLowerCase().includes('nh√† cung c·∫•p') ||
          cell.toLowerCase().includes('supplier') ||
          cell.toLowerCase().includes('t√™n'))
    )
  );

  if (!headerRow) return { total: 0, top5: [] };

  const supplierColIndex = headerRow.findIndex(
    (cell) =>
      typeof cell === 'string' &&
      (cell.toLowerCase().includes('nh√† cung c·∫•p') ||
        cell.toLowerCase().includes('supplier') ||
        cell.toLowerCase().includes('t√™n'))
  );

  const amountColIndex = headerRow.findIndex(
    (cell) =>
      typeof cell === 'string' &&
      (cell.toLowerCase().includes('s·ªë ti·ªÅn') ||
        cell.toLowerCase().includes('amount') ||
        cell.toLowerCase().includes('c√≤n n·ª£') ||
        cell.toLowerCase().includes('t·ªïng'))
  );

  if (supplierColIndex === -1 || amountColIndex === -1) {
    return { total: 0, top5: [] };
  }

  // L·∫•y d·ªØ li·ªáu t·ª´ c√°c h√†ng sau header
  const dataRows = sheetData.slice(sheetData.indexOf(headerRow) + 1);

  // L·ªçc c√°c h√†ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá
  const validRows = dataRows.filter(
    (row) =>
      row[supplierColIndex] &&
      row[amountColIndex] &&
      !isNaN(parseFloat(row[amountColIndex]))
  );

  // T√≠nh t·ªïng
  const total = validRows.reduce(
    (sum, row) => sum + parseFloat(row[amountColIndex]),
    0
  );

  // S·∫Øp x·∫øp theo s·ªë ti·ªÅn gi·∫£m d·∫ßn v√† l·∫•y top 5
  const sortedRows = [...validRows].sort(
    (a, b) => parseFloat(b[amountColIndex]) - parseFloat(a[amountColIndex])
  );

  const top5 = sortedRows.slice(0, 5).map((row) => ({
    supplier: row[supplierColIndex].toString(),
    amount: parseFloat(row[amountColIndex]),
    amountInMillions: parseFloat(
      (parseFloat(row[amountColIndex]) / 1000000).toFixed(1)
    ),
  }));

  return { total, top5 };
};

// X·ª≠ l√Ω sheet c√¥ng n·ª£ ph·∫£i thu (t∆∞∆°ng t·ª± nh∆∞ ph·∫£i tr·∫£)
const processReceivableSheet = (sheetData) => {
  // T√¨m c√°c c·ªôt ch·ª©a th√¥ng tin kh√°ch h√†ng v√† s·ªë ti·ªÅn
  const headerRow = sheetData.find((row) =>
    row.some(
      (cell) =>
        typeof cell === 'string' &&
        (cell.toLowerCase().includes('kh√°ch h√†ng') ||
          cell.toLowerCase().includes('customer') ||
          cell.toLowerCase().includes('t√™n'))
    )
  );

  if (!headerRow) return { total: 0, top5: [] };

  const customerColIndex = headerRow.findIndex(
    (cell) =>
      typeof cell === 'string' &&
      (cell.toLowerCase().includes('kh√°ch h√†ng') ||
        cell.toLowerCase().includes('customer') ||
        cell.toLowerCase().includes('t√™n'))
  );

  const amountColIndex = headerRow.findIndex(
    (cell) =>
      typeof cell === 'string' &&
      (cell.toLowerCase().includes('s·ªë ti·ªÅn') ||
        cell.toLowerCase().includes('amount') ||
        cell.toLowerCase().includes('c√≤n n·ª£') ||
        cell.toLowerCase().includes('t·ªïng'))
  );

  if (customerColIndex === -1 || amountColIndex === -1) {
    return { total: 0, top5: [] };
  }

  // L·∫•y d·ªØ li·ªáu t·ª´ c√°c h√†ng sau header
  const dataRows = sheetData.slice(sheetData.indexOf(headerRow) + 1);

  // L·ªçc c√°c h√†ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá
  const validRows = dataRows.filter(
    (row) =>
      row[customerColIndex] &&
      row[amountColIndex] &&
      !isNaN(parseFloat(row[amountColIndex]))
  );

  // T√≠nh t·ªïng
  const total = validRows.reduce(
    (sum, row) => sum + parseFloat(row[amountColIndex]),
    0
  );

  // S·∫Øp x·∫øp theo s·ªë ti·ªÅn gi·∫£m d·∫ßn v√† l·∫•y top 5
  const sortedRows = [...validRows].sort(
    (a, b) => parseFloat(b[amountColIndex]) - parseFloat(a[amountColIndex])
  );

  const top5 = sortedRows.slice(0, 5).map((row) => ({
    customer: row[customerColIndex].toString(),
    amount: parseFloat(row[amountColIndex]),
    amountInMillions: parseFloat(
      (parseFloat(row[amountColIndex]) / 1000000).toFixed(1)
    ),
  }));

  return { total, top5 };
};

// H√†m ƒë·ªãnh d·∫°ng ti·ªÅn t·ªá
const formatCurrency = (amount) => {
  return new Intl.NumberFormat('vi-VN', {
    style: 'currency',
    currency: 'VND',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(amount);
};

export default {
  listFiles,
  searchFiles,
  downloadFile,
  uploadFile,
  readExcelFile,
  saveExcelFileLocally,
  createFolder,
  getLatestExcelFromFolder,
  processDebtExcelData,
};


--- END: src\api\googleDriveService.js ---


--- START: src\api\inventoryService.js ---
import { firebase, functions } from '../config/firebaseConfig';
import { httpsCallable } from 'firebase/functions';
import { getDownloadURL, getStorage, ref, uploadBytes } from 'firebase/storage';
import googleDriveService from './googleDriveService';

/**
 * Service API ƒë·ªÉ t∆∞∆°ng t√°c v·ªõi Cloud Functions Inventory
 */
const InventoryService = {
  /**
   * Th√™m v·∫≠t t∆∞ m·ªõi
   * @param {Object} itemData - Th√¥ng tin v·∫≠t t∆∞
   * @returns {Promise<Object>}
   */
  async addInventoryItem(itemData) {
    try {
      console.log('=== INVENTORYSERVICE: B·∫ÆT ƒê·∫¶U TH√äM V·∫¨T T∆Ø ===');
      console.log('itemData nh·∫≠n ƒë∆∞·ª£c:', JSON.stringify(itemData, null, 2));

      const addInventoryItemFn = httpsCallable(functions, 'addInventoryItem');
      console.log('=== INVENTORYSERVICE: G·ªåI CLOUD FUNCTION ===');

      const result = await addInventoryItemFn(itemData);
      console.log('=== INVENTORYSERVICE: K·∫æT QU·∫¢ T·ª™ CLOUD FUNCTION ===');
      console.log('result:', result);
      console.log('result.data:', result.data);

      return result.data;
    } catch (error) {
      console.error('=== INVENTORYSERVICE: L·ªñI TH√äM V·∫¨T T∆Ø ===');
      console.error('Error object:', error);
      console.error('Error message:', error.message);
      console.error('Error code:', error.code);
      console.error('Error details:', error.details);
      console.error('=== END L·ªñI INVENTORYSERVICE ===');

      throw error;
    }
  },

  /**
   * C·∫≠p nh·∫≠t th√¥ng tin v·∫≠t t∆∞
   * @param {string} itemId - ID v·∫≠t t∆∞
   * @param {Object} itemData - Th√¥ng tin c·∫≠p nh·∫≠t
   * @returns {Promise<Object>}
   */
  async updateInventoryItem(itemId, itemData) {
    try {
      const updateInventoryItemFn = httpsCallable(
        functions,
        'updateInventoryItem'
      );
      const result = await updateInventoryItemFn({
        itemId,
        itemData,
      });
      return result.data;
    } catch (error) {
      console.error('L·ªói c·∫≠p nh·∫≠t v·∫≠t t∆∞:', error);
      throw error;
    }
  },

  /**
   * T·∫°o giao d·ªãch nh·∫≠p/xu·∫•t kho
   * @param {Object} transactionData - Th√¥ng tin giao d·ªãch
   * @returns {Promise<Object>}
   */
  async createTransaction(transactionData) {
    try {
      const createInventoryTransactionFn = httpsCallable(
        functions,
        'createInventoryTransaction'
      );
      const result = await createInventoryTransactionFn(transactionData);
      return result.data;
    } catch (error) {
      console.error('L·ªói t·∫°o giao d·ªãch kho:', error);
      throw error;
    }
  },

  /**
   * L·∫•y b√°o c√°o t·ªìn kho
   * @param {Object} filters - B·ªô l·ªçc b√°o c√°o
   * @returns {Promise<Object>}
   */
  async getInventoryReport(filters = {}) {
    try {
      const getInventoryReportFn = httpsCallable(
        functions,
        'getInventoryReport'
      );
      const result = await getInventoryReportFn(filters);
      return result.data;
    } catch (error) {
      console.error('L·ªói l·∫•y b√°o c√°o t·ªìn kho:', error);
      throw error;
    }
  },

  /**
   * Qu·∫£n l√Ω danh m·ª•c v·∫≠t t∆∞
   * @param {string} action - H√†nh ƒë·ªông: 'add', 'update', 'delete'
   * @param {Object} categoryData - Th√¥ng tin danh m·ª•c
   * @param {string} categoryId - ID danh m·ª•c (cho update/delete)
   * @returns {Promise<Object>}
   */
  async manageCategory(action, categoryData, categoryId) {
    try {
      const manageCategoryFn = httpsCallable(
        functions,
        'manageInventoryCategory'
      );
      const result = await manageCategoryFn({
        action,
        categoryData,
        categoryId,
      });
      return result.data;
    } catch (error) {
      console.error('L·ªói qu·∫£n l√Ω danh m·ª•c:', error);
      throw error;
    }
  },

  /**
   * L·∫•y th·ªëng k√™ s·ª≠ d·ª•ng v·∫≠t t∆∞ theo d·ª± √°n
   * @param {string} projectId - ID d·ª± √°n
   * @param {string} startDate - Ng√†y b·∫Øt ƒë·∫ßu (t√πy ch·ªçn)
   * @param {string} endDate - Ng√†y k·∫øt th√∫c (t√πy ch·ªçn)
   * @returns {Promise<Object>}
   */
  async getProjectMaterialUsage(projectId, startDate, endDate) {
    try {
      const getMaterialUsageFn = httpsCallable(
        functions,
        'getProjectMaterialUsage'
      );
      const result = await getMaterialUsageFn({
        projectId,
        startDate,
        endDate,
      });
      return result.data;
    } catch (error) {
      console.error('L·ªói l·∫•y th·ªëng k√™ s·ª≠ d·ª•ng v·∫≠t t∆∞:', error);
      throw error;
    }
  },

  /**
   * Upload h√¨nh ·∫£nh v·∫≠t t∆∞
   * @param {string} itemId - ID v·∫≠t t∆∞
   * @param {Blob} imageBlob - D·ªØ li·ªáu h√¨nh ·∫£nh
   * @returns {Promise<string>} - URL h√¨nh ·∫£nh
   */
  async uploadItemImage(itemId, imageBlob) {
    try {
      const storage = getStorage();
      const imageName = `inventory_items/${itemId}_${Date.now()}.jpg`;
      const storageRef = ref(storage, imageName);

      // Upload h√¨nh ·∫£nh
      await uploadBytes(storageRef, imageBlob);

      // L·∫•y URL download
      const downloadUrl = await getDownloadURL(storageRef);

      // C·∫≠p nh·∫≠t URL h√¨nh ·∫£nh v√†o th√¥ng tin v·∫≠t t∆∞
      await this.updateInventoryItem(itemId, { imageUrl: downloadUrl });

      return downloadUrl;
    } catch (error) {
      console.error('L·ªói upload h√¨nh ·∫£nh v·∫≠t t∆∞:', error);
      throw error;
    }
  },

  /**
   * L·∫•y danh s√°ch giao d·ªãch c·ªßa m·ªôt v·∫≠t t∆∞
   * @param {string} itemId - ID v·∫≠t t∆∞
   * @returns {Promise<Array>} - Danh s√°ch giao d·ªãch
   */
  async getItemTransactions(itemId) {
    try {
      const snapshot = await firebase
        .firestore()
        .collection('inventory_transactions')
        .where('itemId', '==', itemId)
        .orderBy('date', 'desc')
        .get();

      return snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));
    } catch (error) {
      console.error('L·ªói l·∫•y giao d·ªãch v·∫≠t t∆∞:', error);
      throw error;
    }
  },

  /**
   * L·∫•y th√¥ng tin chi ti·∫øt v·∫≠t t∆∞
   * @param {string} itemId - ID v·∫≠t t∆∞
   * @returns {Promise<Object>} - Th√¥ng tin v·∫≠t t∆∞
   */
  async getItemById(itemId) {
    try {
      const doc = await firebase
        .firestore()
        .collection('inventory')
        .doc(itemId)
        .get();

      if (!doc.exists) {
        throw new Error('Kh√¥ng t√¨m th·∫•y v·∫≠t t∆∞');
      }

      return {
        id: doc.id,
        ...doc.data(),
      };
    } catch (error) {
      console.error('L·ªói l·∫•y th√¥ng tin v·∫≠t t∆∞:', error);
      throw error;
    }
  },

  /**
   * L·∫•y th√¥ng tin chi ti·∫øt v·∫≠t t∆∞ (alias cho getItemById)
   * @param {string} itemId - ID v·∫≠t t∆∞
   * @returns {Promise<Object>} - Th√¥ng tin v·∫≠t t∆∞
   */
  async getInventoryItemById(itemId) {
    return this.getItemById(itemId);
  },

  /**
   * L·∫•y danh s√°ch t·∫•t c·∫£ v·ªã tr√≠ kho
   * @returns {Promise<Array>} - Danh s√°ch v·ªã tr√≠ kho
   */
  async getAllLocations() {
    try {
      const snapshot = await firebase
        .firestore()
        .collection('inventory_locations')
        .where('isActive', '==', true)
        .get();

      return snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));
    } catch (error) {
      console.error('L·ªói l·∫•y danh s√°ch v·ªã tr√≠ kho:', error);
      throw error;
    }
  },

  /**
   * Nh·∫≠p v·∫≠t t∆∞ t·ª´ file Excel m·ªõi nh·∫•t trong Google Drive folder
   * @param {string} accessToken - Google access token
   * @param {string} folderId - ID c·ªßa folder ch·ª©a file Excel
   * @returns {Promise<Object>} - K·∫øt qu·∫£ nh·∫≠p v·∫≠t t∆∞
   */
  async importInventoryFromDrive(accessToken, folderId) {
    try {
      // L·∫•y file Excel m·ªõi nh·∫•t t·ª´ folder
      const excelData = await googleDriveService.getLatestExcelFromFolder(
        accessToken,
        folderId
      );

      console.log('ƒêang x·ª≠ l√Ω file Excel:', excelData.fileInfo.name);

      // X·ª≠ l√Ω d·ªØ li·ªáu t·ª´ sheet ƒë·∫ßu ti√™n
      const sheetData = excelData.data.firstSheet;

      // T√¨m h√†ng ti√™u ƒë·ªÅ (th∆∞·ªùng l√† h√†ng ƒë·∫ßu ti√™n)
      const headerRow = sheetData[0];

      if (!headerRow) {
        throw new Error('File Excel kh√¥ng c√≥ d·ªØ li·ªáu');
      }

      // √Ånh x·∫° t√™n c·ªôt v·ªõi c√°c tr∆∞·ªùng d·ªØ li·ªáu
      const columnMap = {
        code: findColumnIndex(headerRow, ['M√£ v·∫≠t t∆∞', 'M√£', 'Code']),
        name: findColumnIndex(headerRow, ['T√™n v·∫≠t t∆∞', 'T√™n', 'Name']),
        description: findColumnIndex(headerRow, ['M√¥ t·∫£', 'Description']),
        category: findColumnIndex(headerRow, ['Danh m·ª•c', 'Category']),
        unit: findColumnIndex(headerRow, ['ƒê∆°n v·ªã t√≠nh', 'Unit']),
        stockQuantity: findColumnIndex(headerRow, ['S·ªë l∆∞·ª£ng', 'Quantity']),
        minQuantity: findColumnIndex(headerRow, [
          'S·ªë l∆∞·ª£ng t·ªëi thi·ªÉu',
          'Min Quantity',
        ]),
        price: findColumnIndex(headerRow, ['ƒê∆°n gi√°', 'Price']),
        material: findColumnIndex(headerRow, ['V·∫≠t li·ªáu', 'Material']),
        weight: findColumnIndex(headerRow, ['Kh·ªëi l∆∞·ª£ng', 'Weight']),
      };

      // N·∫øu kh√¥ng t√¨m th·∫•y c√°c c·ªôt b·∫Øt bu·ªôc
      if (columnMap.code === -1 || columnMap.name === -1) {
        throw new Error(
          'File Excel kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng. C·∫ßn c√≥ c·ªôt M√£ v·∫≠t t∆∞ v√† T√™n v·∫≠t t∆∞'
        );
      }

      // K·∫øt qu·∫£
      const result = {
        total: 0,
        added: 0,
        updated: 0,
        skipped: 0,
        errors: [],
      };

      // L·∫•y danh s√°ch danh m·ª•c ƒë·ªÉ √°nh x·∫° t√™n v·ªõi ID
      const categoriesSnapshot = await firebase
        .firestore()
        .collection('inventory_categories')
        .get();
      const categoriesMap = {};
      categoriesSnapshot.docs.forEach((doc) => {
        const category = doc.data();
        categoriesMap[category.name.toLowerCase()] = doc.id;
      });

      // X·ª≠ l√Ω t·ª´ng h√†ng d·ªØ li·ªáu (b·ªè qua h√†ng ƒë·∫ßu ti√™n l√† ti√™u ƒë·ªÅ)
      for (let i = 1; i < sheetData.length; i++) {
        const row = sheetData[i];

        // B·ªè qua h√†ng tr·ªëng
        if (!row || row.length === 0) continue;

        // N·∫øu kh√¥ng c√≥ m√£ ho·∫∑c t√™n, b·ªè qua
        if (!row[columnMap.code] || !row[columnMap.name]) {
          result.skipped++;
          continue;
        }

        try {
          // Chu·∫©n b·ªã d·ªØ li·ªáu v·∫≠t t∆∞
          const itemData = {
            code: row[columnMap.code]?.toString() || '',
            name: row[columnMap.name]?.toString() || '',
          };

          // Th√™m c√°c tr∆∞·ªùng t√πy ch·ªçn n·∫øu c√≥
          if (columnMap.description !== -1 && row[columnMap.description]) {
            itemData.description = row[columnMap.description].toString();
          }

          // X·ª≠ l√Ω danh m·ª•c
          if (columnMap.category !== -1 && row[columnMap.category]) {
            const categoryName = row[columnMap.category]
              .toString()
              .toLowerCase();
            if (categoriesMap[categoryName]) {
              itemData.categoryId = categoriesMap[categoryName];
            }
          }

          if (columnMap.unit !== -1 && row[columnMap.unit]) {
            itemData.unit = row[columnMap.unit].toString();
          }

          if (columnMap.stockQuantity !== -1 && row[columnMap.stockQuantity]) {
            const quantity = parseFloat(row[columnMap.stockQuantity]);
            if (!isNaN(quantity)) {
              itemData.stockQuantity = quantity;
            }
          }

          if (columnMap.minQuantity !== -1 && row[columnMap.minQuantity]) {
            const minQty = parseFloat(row[columnMap.minQuantity]);
            if (!isNaN(minQty)) {
              itemData.minQuantity = minQty;
            }
          }

          if (columnMap.price !== -1 && row[columnMap.price]) {
            const price = parseFloat(row[columnMap.price]);
            if (!isNaN(price)) {
              itemData.price = price;
            }
          }

          if (columnMap.material !== -1 && row[columnMap.material]) {
            itemData.material = row[columnMap.material].toString();
          }

          if (columnMap.weight !== -1 && row[columnMap.weight]) {
            const weight = parseFloat(row[columnMap.weight]);
            if (!isNaN(weight)) {
              itemData.weight = weight;
            }
          }

          // T√≠nh t·ªïng gi√° tr·ªã n·∫øu c√≥ s·ªë l∆∞·ª£ng v√† ƒë∆°n gi√°
          if (itemData.stockQuantity && itemData.price) {
            itemData.totalPrice = itemData.stockQuantity * itemData.price;
          }

          // Ki·ªÉm tra xem v·∫≠t t∆∞ ƒë√£ t·ªìn t·∫°i ch∆∞a d·ª±a v√†o m√£
          const existingItemsSnapshot = await firebase
            .firestore()
            .collection('inventory')
            .where('code', '==', itemData.code)
            .get();

          if (!existingItemsSnapshot.empty) {
            // C·∫≠p nh·∫≠t v·∫≠t t∆∞ ƒë√£ t·ªìn t·∫°i
            const docId = existingItemsSnapshot.docs[0].id;
            await firebase
              .firestore()
              .collection('inventory')
              .doc(docId)
              .update({
                ...itemData,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
              });
            result.updated++;
          } else {
            // Th√™m v·∫≠t t∆∞ m·ªõi
            await firebase
              .firestore()
              .collection('inventory')
              .add({
                ...itemData,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
              });
            result.added++;
          }

          result.total++;
        } catch (err) {
          console.error(`L·ªói khi x·ª≠ l√Ω h√†ng ${i}:`, err);
          result.errors.push({
            row: i,
            message: err.message,
          });
          result.skipped++;
        }
      }

      return result;
    } catch (error) {
      console.error('L·ªói khi nh·∫≠p v·∫≠t t∆∞ t·ª´ Google Drive:', error);
      throw error;
    }
  },
};

/**
 * T√¨m ch·ªâ m·ª•c c·ªôt d·ª±a v√†o danh s√°ch t√™n c√≥ th·ªÉ c√≥
 * @param {Array} headerRow - H√†ng ti√™u ƒë·ªÅ
 * @param {Array} possibleNames - Danh s√°ch t√™n c√≥ th·ªÉ c√≥
 * @returns {number} - Ch·ªâ m·ª•c c·ªôt, -1 n·∫øu kh√¥ng t√¨m th·∫•y
 */
function findColumnIndex(headerRow, possibleNames) {
  for (let i = 0; i < headerRow.length; i++) {
    const cell = headerRow[i];
    if (cell && typeof cell === 'string') {
      const cellValue = cell.toLowerCase();
      if (
        possibleNames.some((name) => cellValue.includes(name.toLowerCase()))
      ) {
        return i;
      }
    }
  }
  return -1;
}

export default InventoryService;


--- END: src\api\inventoryService.js ---


--- START: src\api\machineService.js ---
import {
  collection,
  doc,
  getDoc,
  getDocs,
  addDoc,
  updateDoc,
  deleteDoc,
  query,
  where,
  orderBy,
  serverTimestamp,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';

class MachineService {
  constructor() {
    this.db = db;
    this.colName = 'machines';
  }

  async listMachines(filters = {}) {
    try {
      const { keyword, status } = filters;
      let q = query(
        collection(this.db, this.colName),
        orderBy('createdAt', 'desc')
      );

      // Firestore kh√¥ng h·ªó tr·ª£ contains cho nhi·ªÅu field, n√™n filter keyword ·ªü client
      const snap = await getDocs(q);
      let items = snap.docs.map((d) => ({ id: d.id, ...d.data() }));

      if (status)
        items = items.filter(
          (m) => (m.status || '').toLowerCase() === status.toLowerCase()
        );
      if (keyword && keyword.trim()) {
        const k = keyword.trim().toLowerCase();
        items = items.filter((m) =>
          [m.code, m.name, m.location, m.vendor, m.model]
            .filter(Boolean)
            .some((v) => String(v).toLowerCase().includes(k))
        );
      }
      return items;
    } catch (e) {
      console.error('listMachines error', e);
      return [];
    }
  }

  async getMachine(id) {
    const ref = doc(this.db, this.colName, id);
    const snap = await getDoc(ref);
    if (!snap.exists()) return null;
    return { id: snap.id, ...snap.data() };
  }

  async createMachine(payload) {
    const ref = await addDoc(collection(this.db, this.colName), {
      code: payload.code || '',
      name: payload.name || '',
      model: payload.model || '',
      vendor: payload.vendor || '',
      location: payload.location || '',
      status: payload.status || 'active', // active | maintenance | broken | retired
      lastMaintenanceAt: payload.lastMaintenanceAt || null,
      nextMaintenanceAt: payload.nextMaintenanceAt || null,
      notes: payload.notes || '',
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
    });
    return { id: ref.id };
  }

  async updateMachine(id, payload) {
    const ref = doc(this.db, this.colName, id);
    await updateDoc(ref, { ...payload, updatedAt: serverTimestamp() });
  }

  async deleteMachine(id) {
    const ref = doc(this.db, this.colName, id);
    await deleteDoc(ref);
  }
}

export default new MachineService();


--- END: src\api\machineService.js ---


--- START: src\api\materialService.js ---
import {
  collection,
  doc,
  getDocs,
  getDoc,
  addDoc,
  updateDoc,
  deleteDoc,
  query,
  where,
  orderBy,
  serverTimestamp,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';

// L·∫•y danh s√°ch t·∫•t c·∫£ v·∫≠t li·ªáu
export const getMaterials = async () => {
  try {
    const materialsSnap = await getDocs(
      query(collection(db, 'materials'), orderBy('name'))
    );
    const materials = [];
    materialsSnap.forEach((doc) => {
      materials.push({ id: doc.id, ...doc.data() });
    });
    return materials;
  } catch (error) {
    console.error('L·ªói khi l·∫•y danh s√°ch v·∫≠t li·ªáu:', error);
    throw error;
  }
};

// L·∫•y v·∫≠t li·ªáu theo ID
export const getMaterialById = async (materialId) => {
  try {
    const materialRef = doc(db, 'materials', materialId);
    const materialSnap = await getDoc(materialRef);
    if (materialSnap.exists()) {
      return { id: materialSnap.id, ...materialSnap.data() };
    }
    return null;
  } catch (error) {
    console.error('L·ªói khi l·∫•y v·∫≠t li·ªáu:', error);
    throw error;
  }
};

// Th√™m v·∫≠t li·ªáu m·ªõi
export const addMaterial = async (materialData, userId) => {
  try {
    const materialToAdd = {
      ...materialData,
      pricePerKg: Number(materialData.pricePerKg || 0),
      createdAt: serverTimestamp(),
      createdBy: userId,
      updatedAt: serverTimestamp(),
      updatedBy: userId,
    };
    
    // Lo·∫°i b·ªè c√°c field c√≥ gi√° tr·ªã undefined
    const cleanData = Object.fromEntries(
      Object.entries(materialToAdd).filter(([_, value]) => value !== undefined)
    );
    
    const docRef = await addDoc(collection(db, 'materials'), cleanData);
    return docRef.id;
  } catch (error) {
    console.error('L·ªói khi th√™m v·∫≠t li·ªáu:', error);
    throw error;
  }
};

// C·∫≠p nh·∫≠t v·∫≠t li·ªáu
export const updateMaterial = async (materialId, materialData, userId) => {
  try {
    const materialToUpdate = {
      ...materialData,
      pricePerKg: Number(materialData.pricePerKg || 0),
      updatedAt: serverTimestamp(),
      updatedBy: userId,
    };
    
    // Lo·∫°i b·ªè c√°c field c√≥ gi√° tr·ªã undefined
    const cleanData = Object.fromEntries(
      Object.entries(materialToUpdate).filter(([_, value]) => value !== undefined)
    );
    
    const materialRef = doc(db, 'materials', materialId);
    await updateDoc(materialRef, cleanData);
  } catch (error) {
    console.error('L·ªói khi c·∫≠p nh·∫≠t v·∫≠t li·ªáu:', error);
    throw error;
  }
};

// X√≥a v·∫≠t li·ªáu
export const deleteMaterial = async (materialId) => {
  try {
    const materialRef = doc(db, 'materials', materialId);
    await deleteDoc(materialRef);
  } catch (error) {
    console.error('L·ªói khi x√≥a v·∫≠t li·ªáu:', error);
    throw error;
  }
};

// L·∫•y gi√° v·∫≠t li·ªáu theo t√™n
export const getMaterialPriceByName = async (materialName) => {
  try {
    const materialsSnap = await getDocs(
      query(
        collection(db, 'materials'),
        where('name', '==', materialName)
      )
    );
    
    if (!materialsSnap.empty) {
      const material = materialsSnap.docs[0].data();
      return material.pricePerKg || 0;
    }
    return 0;
  } catch (error) {
    console.error('L·ªói khi l·∫•y gi√° v·∫≠t li·ªáu:', error);
    return 0;
  }
};

// L·∫•y t·∫•t c·∫£ gi√° v·∫≠t li·ªáu
export const getAllMaterialPrices = async () => {
  try {
    const materials = await getMaterials();
    const prices = {};
    materials.forEach((material) => {
      prices[material.name] = material.pricePerKg || 0;
    });
    return prices;
  } catch (error) {
    console.error('L·ªói khi l·∫•y gi√° v·∫≠t li·ªáu:', error);
    return {};
  }
};




















--- END: src\api\materialService.js ---


--- START: src\api\monthlyCostReportService.js ---
import {
  collection,
  query,
  where,
  getDocs,
  orderBy,
  startOf,
  endOf,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';
import { getTotalMonthlyFixedCosts } from './fixedCostService';
import { getMaterialPriceByName } from './materialService';
import {
  getExpensesInMonth,
  deleteExpensesByProjectId,
} from './expenseService';
import { getUserById } from './userService';

// L·∫•y t·∫•t c·∫£ d·ª± √°n completed trong th√°ng/nƒÉm
export const getCompletedProjectsInMonth = async (year, month) => {
  try {
    const startDate = new Date(year, month - 1, 1); // Th√°ng b·∫Øt ƒë·∫ßu t·ª´ 0
    const endDate = new Date(year, month, 0); // Ng√†y cu·ªëi c·ªßa th√°ng

    console.log('üîç T√¨m d·ª± √°n ho√†n th√†nh:', {
      year,
      month,
      startDate: startDate.toISOString(),
      endDate: endDate.toISOString(),
    });

    // Th·ª≠ query ƒë∆°n gi·∫£n tr∆∞·ªõc
    const simpleQuery = query(
      collection(db, 'projects'),
      where('status', '==', 'completed')
    );

    const simpleSnapshot = await getDocs(simpleQuery);
    console.log('üìä T·ªïng s·ªë d·ª± √°n completed:', simpleSnapshot.size);

    const allCompletedProjects = [];
    simpleSnapshot.forEach((doc) => {
      const data = { id: doc.id, ...doc.data() };
      allCompletedProjects.push(data);
      console.log('üìã D·ª± √°n completed:', {
        id: doc.id,
        name: data.name,
        status: data.status,
        completedAt: data.completedAt,
        updatedAt: data.updatedAt,
      });
    });

    // L·ªçc theo th√°ng
    const filteredProjects = allCompletedProjects.filter((project) => {
      const projectDate =
        project.completedAt?.toDate?.() ||
        project.completedAt ||
        project.updatedAt?.toDate?.() ||
        project.updatedAt;
      if (!projectDate) {
        console.log('‚ö†Ô∏è D·ª± √°n kh√¥ng c√≥ completedAt:', project.name);
        return false;
      }

      const projectYear = projectDate.getFullYear();
      const projectMonth = projectDate.getMonth() + 1;

      const isInRange = projectYear === year && projectMonth === month;
      console.log('üìÖ Ki·ªÉm tra d·ª± √°n:', {
        name: project.name,
        projectDate: projectDate.toISOString(),
        projectYear,
        projectMonth,
        targetYear: year,
        targetMonth: month,
        isInRange,
      });

      return isInRange;
    });

    console.log('‚úÖ D·ª± √°n trong th√°ng:', filteredProjects.length);
    return filteredProjects;
  } catch (error) {
    console.error('‚ùå L·ªói khi l·∫•y d·ª± √°n ho√†n th√†nh:', error);
    throw error;
  }
};

// T√≠nh chi ph√≠ v·∫≠t li·ªáu cho m·ªôt d·ª± √°n
export const calculateProjectMaterialCost = async (projectId) => {
  try {
    // L·∫•y b√°o gi√° m·ªõi nh·∫•t c·ªßa d·ª± √°n
    const quotationsQuery = query(
      collection(db, 'quotations'),
      where('projectId', '==', projectId),
      orderBy('createdAt', 'desc')
    );
    const quotationsSnapshot = await getDocs(quotationsQuery);

    if (quotationsSnapshot.empty) return 0;

    const latestQuotation = quotationsSnapshot.docs[0].data();
    const materials = latestQuotation.materials || [];

    let totalMaterialCost = 0;
    const materialPrices = await getMaterialPriceByName();

    for (const material of materials) {
      const materialName = material.material?.toLowerCase() || '';
      const weight = Number(material.weight || 0);

      // T√¨m gi√° v·∫≠t li·ªáu
      let pricePerKg = 0;
      if (materialName.includes('sus304')) {
        pricePerKg = materialPrices.sus304 || 55000;
      } else if (materialName.includes('ss400')) {
        pricePerKg = materialPrices.ss400 || 17000;
      } else {
        // T√¨m trong danh s√°ch v·∫≠t li·ªáu ƒë√£ c·∫•u h√¨nh
        const foundMaterial = Object.entries(materialPrices).find(
          ([name, price]) => materialName.includes(name.toLowerCase())
        );
        if (foundMaterial) {
          pricePerKg = foundMaterial[1];
        }
      }

      totalMaterialCost += weight * pricePerKg;
    }

    return totalMaterialCost;
  } catch (error) {
    console.error('L·ªói khi t√≠nh chi ph√≠ v·∫≠t li·ªáu:', error);
    return 0;
  }
};

// T√≠nh chi ph√≠ nh√¢n c√¥ng cho m·ªôt d·ª± √°n
export const calculateProjectLaborCost = async (projectId) => {
  try {
    const sessionsQuery = query(
      collection(db, 'work_sessions'),
      where('projectId', '==', projectId)
    );
    const sessionsSnapshot = await getDocs(sessionsQuery);

    const sessions = [];
    sessionsSnapshot.forEach((doc) => {
      sessions.push({ id: doc.id, ...doc.data() });
    });

    const byWorker = new Map();
    for (const session of sessions.filter((s) => !!s.endTime)) {
      const workerId = session.workerId;
      if (!workerId) continue;

      const durationHours = Number(session.durationInHours || 0);
      const minutes = Math.round(durationHours * 60);

      const current = byWorker.get(workerId) || {
        workerId,
        workerName: session.workerName || 'Kh√¥ng t√™n',
        minutes: 0,
      };
      current.minutes += minutes;
      byWorker.set(workerId, current);
    }

    let totalLaborCost = 0;
    for (const [workerId, info] of byWorker.entries()) {
      // L·∫•y th√¥ng tin l∆∞∆°ng c·ªßa worker
      const userQuery = query(
        collection(db, 'users'),
        where('uid', '==', workerId)
      );
      const userSnapshot = await getDocs(userQuery);

      if (!userSnapshot.empty) {
        const userData = userSnapshot.docs[0].data();
        const dailySalary = Number(userData?.dailySalary || 0);
        const monthlySalary = Number(userData?.monthlySalary || 0);

        let hourlyRate = 0;
        if (dailySalary > 0) {
          hourlyRate = dailySalary / 8;
        } else if (monthlySalary > 0) {
          hourlyRate = monthlySalary / 30 / 8;
        }

        const cost = (hourlyRate * info.minutes) / 60;
        totalLaborCost += cost;
      }
    }

    return totalLaborCost;
  } catch (error) {
    console.error('L·ªói khi t√≠nh chi ph√≠ nh√¢n c√¥ng:', error);
    return 0;
  }
};

// T√≠nh chi ph√≠ ph·ª• ki·ªán cho m·ªôt d·ª± √°n
export const calculateProjectAccessoryCost = async (projectId) => {
  try {
    const projectQuery = query(
      collection(db, 'projects'),
      where('id', '==', projectId)
    );
    const projectSnapshot = await getDocs(projectQuery);

    if (!projectSnapshot.empty) {
      const projectData = projectSnapshot.docs[0].data();
      return Number(projectData?.accessoryPrice || 0);
    }
    return 0;
  } catch (error) {
    console.error('L·ªói khi t√≠nh chi ph√≠ ph·ª• ki·ªán:', error);
    return 0;
  }
};

// T√≠nh t·ªïng chi ph√≠ cho m·ªôt d·ª± √°n
export const calculateTotalProjectCost = async (projectId) => {
  try {
    const materialCost = await calculateProjectMaterialCost(projectId);
    const laborCost = await calculateProjectLaborCost(projectId);
    const accessoryCost = await calculateProjectAccessoryCost(projectId);

    return {
      materialCost,
      laborCost,
      accessoryCost,
      totalCost: materialCost + laborCost + accessoryCost,
    };
  } catch (error) {
    console.error('L·ªói khi t√≠nh t·ªïng chi ph√≠ d·ª± √°n:', error);
    return {
      materialCost: 0,
      laborCost: 0,
      accessoryCost: 0,
      totalCost: 0,
    };
  }
};

// T·∫°o b√°o c√°o chi ph√≠ h√†ng th√°ng
export const generateMonthlyCostReport = async (year, month) => {
  try {
    console.log('üöÄ B·∫Øt ƒë·∫ßu t·∫°o b√°o c√°o cho:', { year, month });

    // L·∫•y chi ph√≠ t·ª´ collection expenses trong th√°ng
    // X√≥a d·ªØ li·ªáu test n·∫øu t·ªìn t·∫°i
    try {
      const removed = await deleteExpensesByProjectId('test-project-id');
      if (removed > 0) {
        console.log('üßπ ƒê√£ d·ªçn d·ªØ li·ªáu test:', removed);
      }
    } catch (_) {}

    const expenses = (await getExpensesInMonth(year, month)).filter(
      (e) => e.projectId !== 'test-project-id'
    );
    console.log('üìä Chi ph√≠ trong th√°ng:', expenses.length);

    // T√≠nh t·ªïng chi ph√≠ d·ª± √°n
    let totalProjectCost = 0;
    const projectCosts = [];

    // G·ªôp theo projectId ƒë·ªÉ tr√°nh tr√πng kh√≥a (n·∫øu c√≥ nhi·ªÅu b·∫£n ghi trong th√°ng)
    const projectIdToExpense = new Map();
    for (const expense of expenses) {
      const existing = projectIdToExpense.get(expense.projectId);
      if (existing) {
        // N·∫øu tr√πng, gi·ªØ b·∫£n ghi t·ªïng l·ªõn nh·∫•t
        const merged = {
          ...existing,
          materialCost: Math.max(
            existing.materialCost || 0,
            expense.materialCost || 0
          ),
          laborCost: Math.max(existing.laborCost || 0, expense.laborCost || 0),
          accessoryCost: Math.max(
            existing.accessoryCost || 0,
            expense.accessoryCost || 0
          ),
          totalCost: Math.max(existing.totalCost || 0, expense.totalCost || 0),
        };
        projectIdToExpense.set(expense.projectId, merged);
        continue;
      }
      projectIdToExpense.set(expense.projectId, expense);
    }

    for (const expense of projectIdToExpense.values()) {
      const material = expense.materialCost || 0;
      const accessory = expense.accessoryCost || 0;
      const reportedTotal = material + accessory; // Lo·∫°i NH√ÇN C√îNG kh·ªèi b√°o c√°o th√°ng

      console.log('üí∞ Chi ph√≠ d·ª± √°n (report):', {
        projectName: expense.projectName,
        material,
        accessory,
        reportedTotal,
      });

      projectCosts.push({
        project: {
          id: expense.projectId,
          name: expense.projectName,
        },
        costBreakdown: {
          materialCost: material,
          accessoryCost: accessory,
          totalCost: reportedTotal,
        },
      });

      totalProjectCost += reportedTotal;
    }

    // L·∫•y chi ph√≠ c·ªë ƒë·ªãnh h√†ng th√°ng
    const fixedCosts = await getTotalMonthlyFixedCosts();
    console.log('üè¢ Chi ph√≠ c·ªë ƒë·ªãnh:', fixedCosts);

    // T√≠nh t·ªïng l∆∞∆°ng nh√¢n vi√™n trong th√°ng
    const salaryQuery = query(
      collection(db, 'users'),
      where('role', 'in', [
        'cong_nhan',
        'ky_su',
        'ke_toan',
        'thuong_mai',
        'pho_giam_doc',
        'giam_doc',
      ])
    );
    const salarySnapshot = await getDocs(salaryQuery);
    let totalSalary = 0;
    console.log('üë• Danh s√°ch nh√¢n vi√™n t√≠nh l∆∞∆°ng:');
    for (const doc of salarySnapshot.docs) {
      const user = doc.data();
      const dailySalary = Number(user.dailySalary || 0);
      const monthlySalary = Number(user.monthlySalary || 0);
      let userSalary = 0;

      if (dailySalary > 0) {
        // T√≠nh theo ng√†y ƒëi l√†m (c·∫ßn th√™m logic l·∫•y s·ªë ng√†y ƒëi l√†m)
        userSalary = dailySalary * 22; // Gi·∫£ s·ª≠ 22 ng√†y l√†m vi·ªác/th√°ng
        console.log(
          `  - ${
            user.name || user.displayName
          }: ${dailySalary.toLocaleString()}ƒë/ng√†y √ó 22 = ${userSalary.toLocaleString()}ƒë`
        );
      } else if (monthlySalary > 0) {
        userSalary = monthlySalary;
        console.log(
          `  - ${
            user.name || user.displayName
          }: ${monthlySalary.toLocaleString()}ƒë/th√°ng`
        );
      }

      totalSalary += userSalary;
    }
    console.log('üí∞ T·ªïng l∆∞∆°ng nh√¢n vi√™n:', totalSalary.toLocaleString());

    // T·ªïng chi ph√≠
    const totalMonthlyCost = totalProjectCost + fixedCosts + totalSalary;
    console.log('üíØ T·ªïng chi ph√≠:', {
      totalProjectCost,
      fixedCosts,
      totalSalary,
      totalMonthlyCost,
    });

    const result = {
      year,
      month,
      completedProjects: projectCosts,
      totalProjectCost,
      fixedCosts,
      totalSalary,
      totalMonthlyCost,
      projectCount: projectCosts.length,
    };

    console.log('‚úÖ K·∫øt qu·∫£ b√°o c√°o:', result);
    return result;
  } catch (error) {
    console.error('‚ùå L·ªói khi t·∫°o b√°o c√°o chi ph√≠ h√†ng th√°ng:', error);
    throw error;
  }
};


--- END: src\api\monthlyCostReportService.js ---


--- START: src\api\notificationService.js ---
// src/api/notificationService.js
import { db } from '../config/firebaseConfig';
import {
  collection,
  query,
  where,
  getDocs,
  orderBy,
  updateDoc,
  doc,
  limit,
} from 'firebase/firestore';

/**
 * Fetches notifications for a specific user, ordered by creation date.
 * @param {string} userId - The ID of the user.
 * @returns {Promise<Array>} A list of notifications.
 */
export const getUserNotifications = async (userId) => {
  if (!userId) return [];

  try {
    const q = query(
      collection(db, 'notifications'),
      where('userId', '==', userId),
      orderBy('createdAt', 'desc'),
      limit(30) // To avoid loading too many notifications at once
    );
    const snap = await getDocs(q);
    return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
  } catch (error) {
    console.error('Error fetching notifications:', error);
    return [];
  }
};

/**
 * Marks a specific notification as read.
 * @param {string} notificationId - The ID of the notification to update.
 * @returns {Promise<void>}
 */
export const markNotificationAsRead = async (notificationId) => {
  if (!notificationId) return;

  try {
    const ref = doc(db, 'notifications', notificationId);
    const data = { read: true };

    // Lo·∫°i b·ªè c√°c field c√≥ gi√° tr·ªã undefined ƒë·ªÉ tr√°nh l·ªói Firestore
    const cleanData = Object.fromEntries(
      Object.entries(data).filter(([_, value]) => value !== undefined)
    );

    await updateDoc(ref, cleanData);
  } catch (error) {
    console.error('Error marking notification as read:', error);
  }
};


--- END: src\api\notificationService.js ---


--- START: src\api\paymentService.js ---
// src/api/paymentService.js
import {
  collection,
  addDoc,
  getDoc,
  getDocs,
  doc,
  query,
  where,
  orderBy,
  updateDoc,
  runTransaction,
  serverTimestamp,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';

/**
 * T·∫°o m·ªôt y√™u c·∫ßu thanh to√°n m·ªõi
 * @param {Object} data - D·ªØ li·ªáu y√™u c·∫ßu thanh to√°n
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi t·∫°o y√™u c·∫ßu
 * @returns {Promise<string>} - ID c·ªßa y√™u c·∫ßu thanh to√°n ƒë√£ t·∫°o
 */
export const createPaymentRequest = async (data, userId) => {
  try {
    const paymentRequestData = {
      ...data,
      totalPaid: 0,
      status: 'pending',
      createdBy: userId,
      createdAt: serverTimestamp(),
    };

    const docRef = await addDoc(
      collection(db, 'payment_requests'),
      paymentRequestData
    );
    return docRef.id;
  } catch (error) {
    console.error('Error creating payment request:', error);
    throw error;
  }
};

/**
 * L·∫•y t·∫•t c·∫£ y√™u c·∫ßu thanh to√°n c·ªßa m·ªôt d·ª± √°n
 * @param {string} projectId - ID c·ªßa d·ª± √°n
 * @returns {Promise<Array>} - M·∫£ng y√™u c·∫ßu thanh to√°n
 */
export const getPaymentRequestsByProject = async (projectId) => {
  try {
    const q = query(
      collection(db, 'payment_requests'),
      where('projectId', '==', projectId),
      orderBy('issueDate', 'desc')
    );

    const querySnapshot = await getDocs(q);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    console.error('Error getting payment requests by project:', error);
    throw error;
  }
};

/**
 * L·∫•y chi ti·∫øt m·ªôt y√™u c·∫ßu thanh to√°n
 * @param {string} requestId - ID c·ªßa y√™u c·∫ßu thanh to√°n
 * @returns {Promise<Object|null>} - D·ªØ li·ªáu y√™u c·∫ßu thanh to√°n ho·∫∑c null n·∫øu kh√¥ng t√¨m th·∫•y
 */
export const getPaymentRequestById = async (requestId) => {
  try {
    const docRef = doc(db, 'payment_requests', requestId);
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
      // Get payment history
      const paymentsQuery = query(
        collection(db, 'payment_requests', requestId, 'payments'),
        orderBy('paymentDate', 'desc')
      );
      const paymentsSnapshot = await getDocs(paymentsQuery);
      const payments = paymentsSnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));

      return {
        id: docSnap.id,
        ...docSnap.data(),
        payments,
      };
    } else {
      return null;
    }
  } catch (error) {
    console.error('Error getting payment request:', error);
    throw error;
  }
};

/**
 * Ghi nh·∫≠n m·ªôt kho·∫£n thanh to√°n cho y√™u c·∫ßu
 * @param {string} requestId - ID c·ªßa y√™u c·∫ßu thanh to√°n
 * @param {Object} paymentData - D·ªØ li·ªáu thanh to√°n
 * @returns {Promise<string>} - ID c·ªßa thanh to√°n ƒë√£ t·∫°o
 */
export const logPayment = async (requestId, paymentData) => {
  try {
    const paymentRef = doc(db, 'payment_requests', requestId);
    const paymentDoc = await getDoc(paymentRef);

    if (!paymentDoc.exists()) {
      throw new Error('Kh√¥ng t√¨m th·∫•y y√™u c·∫ßu thanh to√°n');
    }

    return await runTransaction(db, async (transaction) => {
      // Get the current payment request
      const paymentRequest = paymentDoc.data();
      const amount = paymentRequest.amount || 0;
      const currentTotalPaid = paymentRequest.totalPaid || 0;
      const newPaymentAmount = paymentData.amountPaid || 0;

      // Calculate new total paid
      const newTotalPaid = currentTotalPaid + newPaymentAmount;

      // Determine new status
      let newStatus = paymentRequest.status;
      if (newTotalPaid >= amount) {
        newStatus = 'paid';
      } else if (newTotalPaid > 0) {
        newStatus = 'partially_paid';
      } else {
        // Check if payment is overdue
        const dueDate =
          paymentRequest.dueDate?.toDate?.() || paymentRequest.dueDate;
        if (dueDate && new Date() > dueDate) {
          newStatus = 'overdue';
        }
      }

      // Create payment record
      const paymentWithTimestamp = {
        ...paymentData,
        paymentDate: paymentData.paymentDate || serverTimestamp(),
        createdAt: serverTimestamp(),
      };

      // Add to subcollection
      const paymentDocRef = doc(
        collection(db, 'payment_requests', requestId, 'payments')
      );

      transaction.set(paymentDocRef, paymentWithTimestamp);

      // Update the main payment request
      transaction.update(paymentRef, {
        totalPaid: newTotalPaid,
        status: newStatus,
        updatedAt: serverTimestamp(),
      });

      return paymentDocRef.id;
    });
  } catch (error) {
    console.error('Error logging payment:', error);
    throw error;
  }
};

/**
 * C·∫≠p nh·∫≠t m√£ s·ªë h√≥a ƒë∆°n MISA
 * @param {string} requestId - ID c·ªßa y√™u c·∫ßu thanh to√°n
 * @param {string} invoiceNumber - M√£ s·ªë h√≥a ƒë∆°n MISA
 * @returns {Promise<void>}
 */
export const updateMisaInvoiceNumber = async (requestId, invoiceNumber) => {
  try {
    const requestRef = doc(db, 'payment_requests', requestId);

    const updateData = {
      misaInvoiceNumber: invoiceNumber,
      updatedAt: serverTimestamp(),
    };

    // Lo·∫°i b·ªè c√°c field c√≥ gi√° tr·ªã undefined ƒë·ªÉ tr√°nh l·ªói Firestore
    const cleanData = Object.fromEntries(
      Object.entries(updateData).filter(([_, value]) => value !== undefined)
    );

    await updateDoc(requestRef, cleanData);
  } catch (error) {
    console.error('Error updating MISA invoice number:', error);
    throw error;
  }
};

const PaymentService = {
  createPaymentRequest,
  getPaymentRequestsByProject,
  getPaymentRequestById,
  logPayment,
  updateMisaInvoiceNumber,
};

export default PaymentService;


--- END: src\api\paymentService.js ---


--- START: src\api\productionService.js ---
import {
  getFirestore,
  collection,
  doc,
  addDoc,
  updateDoc,
  getDocs,
  query,
  where,
  orderBy,
  limit,
  Timestamp,
  onSnapshot,
} from 'firebase/firestore';

class ProductionService {
  constructor() {
    this.db = getFirestore();
    this.workSessionsCollection = collection(this.db, 'work_sessions');
    this.projectsCollection = collection(this.db, 'projects');
    this.usersCollection = collection(this.db, 'users');
  }

  /**
   * B·∫Øt ƒë·∫ßu m·ªôt phi√™n l√†m vi·ªác m·ªõi
   * @param {string} workerId - UID c·ªßa c√¥ng nh√¢n
   * @param {string} workerName - T√™n c√¥ng nh√¢n
   * @param {string} projectId - ID d·ª± √°n
   * @param {string} projectName - T√™n d·ª± √°n
   * @param {string} stageId - ID c√¥ng ƒëo·∫°n
   * @param {string} stageName - T√™n c√¥ng ƒëo·∫°n
   * @returns {Promise<string>} sessionId c·ªßa phi√™n l√†m vi·ªác m·ªõi
   */
  async startWorkSession(
    workerId,
    workerName,
    projectId,
    projectName,
    stageId,
    stageName
  ) {
    try {
      // B∆∞·ªõc 1: Ki·ªÉm tra xem worker c√≥ session n√†o ƒëang ch·∫°y kh√¥ng
      const runningSession = await this.getRunningSessionForWorker(workerId);

      if (runningSession) {
        console.log(
          'Worker has running session, stopping it first:',
          runningSession.id
        );
        await this.stopWorkSession(runningSession.id);
      }

      // B∆∞·ªõc 2: T·∫°o session m·ªõi
      const now = Timestamp.now();
      const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format

      const sessionData = {
        workerId,
        workerName,
        projectId,
        projectName,
        stageId,
        stageName,
        startTime: now,
        endTime: null, // null = ƒëang ch·∫°y
        durationInHours: 0,
        isOvertime: this.isOvertimeHour(new Date()),
        date: today,
        createdAt: now,
        updatedAt: now,
      };

      const docRef = await addDoc(this.workSessionsCollection, sessionData);
      console.log('Started new work session:', docRef.id);

      return docRef.id;
    } catch (error) {
      console.error('Error starting work session:', error);
      throw error;
    }
  }

  /**
   * K·∫øt th√∫c m·ªôt phi√™n l√†m vi·ªác
   * @param {string} sessionId - ID c·ªßa phi√™n l√†m vi·ªác
   * @returns {Promise<number>} durationInHours c·ªßa phi√™n l√†m vi·ªác
   */
  async stopWorkSession(sessionId) {
    try {
      const sessionRef = doc(this.workSessionsCollection, sessionId);
      const now = Timestamp.now();

      // L·∫•y th√¥ng tin session ƒë·ªÉ t√≠nh duration
      const sessionDoc = await getDocs(
        query(this.workSessionsCollection, where('__name__', '==', sessionId))
      );

      if (sessionDoc.empty) {
        throw new Error('Session not found');
      }

      const sessionData = sessionDoc.docs[0].data();
      const startTime = sessionData.startTime.toDate();
      const endTime = now.toDate();

      // T√≠nh duration (c√≥ x·ª≠ l√Ω gi·ªù ngh·ªâ tr∆∞a)
      const durationInHours = this.calculateWorkDuration(startTime, endTime);

      // C·∫≠p nh·∫≠t session
      const updateData = {
        endTime: now,
        durationInHours,
        updatedAt: now,
      };

      // Lo·∫°i b·ªè c√°c field c√≥ gi√° tr·ªã undefined ƒë·ªÉ tr√°nh l·ªói Firestore
      const cleanData = Object.fromEntries(
        Object.entries(updateData).filter(([_, value]) => value !== undefined)
      );

      await updateDoc(sessionRef, cleanData);

      console.log(
        'Stopped work session:',
        sessionId,
        'Duration:',
        durationInHours,
        'hours'
      );
      return durationInHours;
    } catch (error) {
      console.error('Error stopping work session:', error);
      throw error;
    }
  }

  /**
   * L·∫•y phi√™n l√†m vi·ªác ƒëang ch·∫°y c·ªßa m·ªôt worker
   * @param {string} workerId - UID c·ªßa c√¥ng nh√¢n
   * @returns {Promise<Object|null>} Session ƒëang ch·∫°y ho·∫∑c null
   */
  async getRunningSessionForWorker(workerId) {
    try {
      const q = query(
        this.workSessionsCollection,
        where('workerId', '==', workerId),
        where('endTime', '==', null),
        orderBy('startTime', 'desc'),
        limit(1)
      );

      const querySnapshot = await getDocs(q);

      if (querySnapshot.empty) {
        return null;
      }

      const doc = querySnapshot.docs[0];
      return {
        id: doc.id,
        ...doc.data(),
      };
    } catch (error) {
      console.error('Error getting running session:', error);
      throw error;
    }
  }

  /**
   * L·∫•y danh s√°ch c√¥ng vi·ªác ƒë∆∞·ª£c giao cho m·ªôt worker
   * @param {string} workerId - UID c·ªßa c√¥ng nh√¢n
   * @returns {Promise<Array>} Danh s√°ch c√¥ng vi·ªác
   */
  async getTasksForWorker(workerId) {
    try {
      // Truy v·∫•n c√°c project stages ƒë∆∞·ª£c assign cho worker n√†y
      const projectsQuery = query(this.projectsCollection);
      const projectsSnapshot = await getDocs(projectsQuery);

      const tasks = [];

      for (const projectDoc of projectsSnapshot.docs) {
        const projectData = projectDoc.data();
        const workflowStages = projectData.workflowStages || [];

        // L·ªçc c√°c stages ƒë∆∞·ª£c assign cho worker n√†y
        const assignedStages = workflowStages.filter(
          (stage) =>
            stage.assignedWorkers && stage.assignedWorkers.includes(workerId)
        );

        for (const stage of assignedStages) {
          const taskData = {
            projectId: projectDoc.id,
            projectName: projectData.name,
            stageId: stage.stageId,
            stageName: stage.processName,
            stageStatus: stage.status,
            priority: stage.priority || 0,
            // Include media instruction data
            instructionImages: stage.instructionImages || [],
            instructionNotes: stage.instructionNotes || '',
            instructionAudio: stage.instructionAudio || null,
            hasInstructions: !!stage.instructionNotes,
            hasImages: !!(
              stage.instructionImages && stage.instructionImages.length > 0
            ),
            hasAudio: !!stage.instructionAudio,
          };

          // Debug logging
          console.log('ProductionService - Task data for worker:', {
            stageName: taskData.stageName,
            hasInstructions: taskData.hasInstructions,
            hasImages: taskData.hasImages,
            hasAudio: taskData.hasAudio,
            instructionImagesCount: taskData.instructionImages.length,
            instructionNotesLength: taskData.instructionNotes.length,
            instructionAudio: !!taskData.instructionAudio,
          });

          tasks.push(taskData);
        }
      }

      // S·∫Øp x·∫øp theo priority
      tasks.sort((a, b) => (b.priority || 0) - (a.priority || 0));

      return tasks;
    } catch (error) {
      console.error('Error getting tasks for worker:', error);
      throw error;
    }
  }

  /**
   * L·∫•y tr·∫°ng th√°i live c·ªßa to√†n b·ªô x∆∞·ªüng
   * @returns {Promise<Array>} Danh s√°ch tr·∫°ng th√°i t·∫•t c·∫£ workers
   */
  async getLiveFactoryStatus() {
    try {
      // L·∫•y t·∫•t c·∫£ users c√≥ role l√† worker
      const workersQuery = query(
        this.usersCollection,
        where('role', 'in', [
          'tho_han',
          'tho_co_khi',
          'tho_lap_rap',
          'cong_nhan',
        ])
      );
      const workersSnapshot = await getDocs(workersQuery);

      const factoryStatus = [];

      for (const workerDoc of workersSnapshot.docs) {
        const workerData = workerDoc.data();
        const workerId = workerDoc.id;

        // L·∫•y session ƒëang ch·∫°y c·ªßa worker n√†y
        const runningSession = await this.getRunningSessionForWorker(workerId);

        // ƒê·∫øm s·ªë c√¥ng vi·ªác m·ªõi ƒë∆∞·ª£c giao
        const tasks = await this.getTasksForWorker(workerId);
        const newTasksCount = tasks.filter(
          (task) => task.stageStatus === 'assigned'
        ).length;

        factoryStatus.push({
          workerId,
          workerName: workerData.displayName || workerData.email,
          workerRole: workerData.role,
          avatar: workerData.photoURL,
          status: runningSession ? 'working' : 'idle',
          currentTask: runningSession
            ? {
                projectName: runningSession.projectName,
                stageName: runningSession.stageName,
                startTime: runningSession.startTime,
                duration: this.calculateCurrentDuration(
                  runningSession.startTime.toDate()
                ),
              }
            : null,
          newTasksCount,
          lastActivity: runningSession ? runningSession.startTime : null,
        });
      }

      return factoryStatus;
    } catch (error) {
      console.error('Error getting live factory status:', error);
      throw error;
    }
  }

  /**
   * Subscribe to live factory status changes
   * @param {Function} callback - Callback function to handle updates
   * @returns {Function} Unsubscribe function
   */
  subscribeLiveFactoryStatus(callback) {
    // Subscribe to work_sessions changes
    const unsubscribe = onSnapshot(
      query(this.workSessionsCollection, where('endTime', '==', null)),
      async (snapshot) => {
        try {
          const liveStatus = await this.getLiveFactoryStatus();
          callback(liveStatus);
        } catch (error) {
          console.error('Error in live status subscription:', error);
        }
      }
    );

    return unsubscribe;
  }

  /**
   * T√≠nh to√°n th·ªùi gian l√†m vi·ªác (c√≥ x·ª≠ l√Ω gi·ªù ngh·ªâ tr∆∞a)
   * @param {Date} startTime - Th·ªùi gian b·∫Øt ƒë·∫ßu
   * @param {Date} endTime - Th·ªùi gian k·∫øt th√∫c
   * @returns {number} S·ªë gi·ªù l√†m vi·ªác
   */
  calculateWorkDuration(startTime, endTime) {
    const diffMs = endTime.getTime() - startTime.getTime();
    let hours = diffMs / (1000 * 60 * 60);

    // X·ª≠ l√Ω gi·ªù ngh·ªâ tr∆∞a (11:30-13:00)
    const startHour = startTime.getHours();
    const startMinute = startTime.getMinutes();
    const endHour = endTime.getHours();
    const endMinute = endTime.getMinutes();

    const startTotalMinutes = startHour * 60 + startMinute;
    const endTotalMinutes = endHour * 60 + endMinute;
    const lunchStartMinutes = 11 * 60 + 30; // 11:30
    const lunchEndMinutes = 13 * 60; // 13:00

    // N·∫øu th·ªùi gian l√†m vi·ªác b·∫Øt ƒë·∫ßu tr∆∞·ªõc 11:30 v√† k·∫øt th√∫c sau 13:00
    if (
      startTotalMinutes < lunchStartMinutes &&
      endTotalMinutes > lunchEndMinutes
    ) {
      hours -= 1.5; // Tr·ª´ 1.5 gi·ªù ngh·ªâ tr∆∞a
    }
    // N·∫øu b·∫Øt ƒë·∫ßu trong gi·ªù ngh·ªâ tr∆∞a
    else if (
      startTotalMinutes >= lunchStartMinutes &&
      startTotalMinutes < lunchEndMinutes
    ) {
      const minutesInLunch = Math.min(
        lunchEndMinutes - startTotalMinutes,
        endTotalMinutes - startTotalMinutes
      );
      if (minutesInLunch > 0) {
        hours -= minutesInLunch / 60;
      }
    }
    // N·∫øu k·∫øt th√∫c trong gi·ªù ngh·ªâ tr∆∞a
    else if (
      endTotalMinutes > lunchStartMinutes &&
      endTotalMinutes <= lunchEndMinutes
    ) {
      const minutesInLunch = Math.min(
        endTotalMinutes - lunchStartMinutes,
        endTotalMinutes - startTotalMinutes
      );
      if (minutesInLunch > 0) {
        hours -= minutesInLunch / 60;
      }
    }

    return Math.max(0, parseFloat(hours.toFixed(2)));
  }

  /**
   * T√≠nh to√°n th·ªùi gian hi·ªán t·∫°i t·ª´ khi b·∫Øt ƒë·∫ßu
   * @param {Date} startTime - Th·ªùi gian b·∫Øt ƒë·∫ßu
   * @returns {string} Formatted duration string
   */
  calculateCurrentDuration(startTime) {
    const now = new Date();
    const duration = this.calculateWorkDuration(startTime, now);

    const hours = Math.floor(duration);
    const minutes = Math.round((duration - hours) * 60);

    return `${hours.toString().padStart(2, '0')}:${minutes
      .toString()
      .padStart(2, '0')}:00`;
  }

  /**
   * Ki·ªÉm tra c√≥ ph·∫£i gi·ªù tƒÉng ca kh√¥ng
   * @param {Date} time - Th·ªùi gian c·∫ßn ki·ªÉm tra
   * @returns {boolean} True n·∫øu l√† gi·ªù tƒÉng ca
   */
  isOvertimeHour(time) {
    const hour = time.getHours();
    const minute = time.getMinutes();

    // TƒÉng ca n·∫øu sau 17:30 ho·∫∑c tr∆∞·ªõc 7:00
    return hour > 17 || (hour === 17 && minute >= 30) || hour < 7;
  }

  /**
   * L·∫•y work sessions theo ng√†y
   * @param {string} date - Ng√†y theo format YYYY-MM-DD
   * @returns {Promise<Array>} Danh s√°ch work sessions
   */
  async getWorkSessionsByDate(date) {
    try {
      const q = query(
        this.workSessionsCollection,
        where('date', '==', date),
        orderBy('startTime', 'asc')
      );

      const querySnapshot = await getDocs(q);
      const sessions = [];

      querySnapshot.forEach((doc) => {
        sessions.push({
          id: doc.id,
          ...doc.data(),
        });
      });

      return sessions;
    } catch (error) {
      console.error('Error getting work sessions by date:', error);
      throw error;
    }
  }
}

export default new ProductionService();


--- END: src\api\productionService.js ---


--- START: src\api\projectDiscussionService.js ---
import { db } from '../config/firebaseConfig';
import {
  collection,
  addDoc,
  query,
  where,
  orderBy,
  getDocs,
  doc,
  updateDoc,
  deleteDoc,
  serverTimestamp,
  onSnapshot,
} from 'firebase/firestore';
import storage from '@react-native-firebase/storage';
import { auth } from '../config/firebaseConfig';

// Get discussions for a specific project
export const getProjectDiscussions = async (projectId) => {
  try {
    const q = query(
      collection(db, 'projectDiscussions'),
      where('projectId', '==', projectId),
      orderBy('createdAt', 'desc')
    );

    const querySnapshot = await getDocs(q);
    const discussions = [];

    querySnapshot.forEach((doc) => {
      discussions.push({
        id: doc.id,
        ...doc.data(),
      });
    });

    return discussions;
  } catch (error) {
    console.error('Error getting project discussions:', error);
    throw error;
  }
};

// Add a new discussion message
export const addDiscussionMessage = async (
  projectId,
  message,
  userId,
  userName,
  userPhotoURL,
  messageType = 'text',
  attachments = []
) => {
  try {
    const discussionData = {
      projectId,
      message,
      userId,
      userName,
      userPhotoURL,
      messageType, // 'text', 'image', 'pdf', 'link'
      attachments,
      isRecalled: false,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
    };

    const docRef = await addDoc(
      collection(db, 'projectDiscussions'),
      discussionData
    );
    return {
      id: docRef.id,
      ...discussionData,
    };
  } catch (error) {
    console.error('Error adding discussion message:', error);
    throw error;
  }
};

// Update a discussion message
export const updateDiscussionMessage = async (messageId, message) => {
  try {
    const messageRef = doc(db, 'projectDiscussions', messageId);
    await updateDoc(messageRef, {
      message,
      updatedAt: serverTimestamp(),
    });
  } catch (error) {
    console.error('Error updating discussion message:', error);
    throw error;
  }
};

// Recall a discussion message (mark as recalled instead of deleting)
export const recallDiscussionMessage = async (messageId) => {
  try {
    const messageRef = doc(db, 'projectDiscussions', messageId);
    await updateDoc(messageRef, {
      isRecalled: true,
      updatedAt: serverTimestamp(),
    });
  } catch (error) {
    console.error('Error recalling discussion message:', error);
    throw error;
  }
};

// Upload file to Firebase Storage using react-native-firebase
export const uploadFileToStorage = async (file, projectId) => {
  try {
    // Validate file
    if (!file || !file.uri) {
      throw new Error('File kh√¥ng h·ª£p l·ªá');
    }

    // Get current user
    const currentUser = auth.currentUser;
    if (!currentUser) {
      throw new Error('Ng∆∞·ªùi d√πng ch∆∞a ƒëƒÉng nh·∫≠p');
    }

    // Create unique file path: discussion_files/{projectId}/{userId}/{timestamp}_{fileName}
    const timestamp = Date.now();
    const fileName = file.name || `file_${timestamp}`;
    const fileExtension = fileName.split('.').pop() || '';
    const uniqueFileName = `${timestamp}_${fileName}`;

    const destinationPath = `discussion_files/${projectId}/${currentUser.uid}/${uniqueFileName}`;

    console.log(
      `[Storage] B·∫Øt ƒë·∫ßu upload file: ${fileName} -> ${destinationPath}`
    );

    // Create storage reference
    const storageRef = storage().ref(destinationPath);

    // Upload file using putFile (handles streaming efficiently)
    const uploadTask = await storageRef.putFile(file.uri);

    if (uploadTask.state !== 'success') {
      throw new Error('Upload file th·∫•t b·∫°i');
    }

    console.log(`[Storage] Upload th√†nh c√¥ng: ${fileName}`);

    // Get download URL
    const downloadURL = await storageRef.getDownloadURL();

    // Get file metadata
    const metadata = await storageRef.getMetadata();

    // Return attachment object for Firestore
    const attachment = {
      name: fileName,
      url: downloadURL,
      type: file.type || mimeTypeFromExtension(fileExtension),
      size: metadata.size || 0,
      storagePath: destinationPath,
      uploadedAt: new Date().toISOString(),
    };

    console.log(`[Storage] File ready for Firestore:`, attachment);
    return attachment;
  } catch (error) {
    console.error('‚ùå [Storage] L·ªói upload file:', error);
    throw new Error(`Upload file th·∫•t b·∫°i: ${error.message}`);
  }
};

// Helper function to determine MIME type from file extension
const mimeTypeFromExtension = (extension) => {
  const mimeTypes = {
    jpg: 'image/jpeg',
    jpeg: 'image/jpeg',
    png: 'image/png',
    gif: 'image/gif',
    pdf: 'application/pdf',
    doc: 'application/msword',
    docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    xls: 'application/vnd.ms-excel',
    xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    txt: 'text/plain',
  };

  return mimeTypes[extension.toLowerCase()] || 'application/octet-stream';
};

// Get discussion count for a project
export const getDiscussionCount = async (projectId) => {
  try {
    const q = query(
      collection(db, 'projectDiscussions'),
      where('projectId', '==', projectId)
    );

    const querySnapshot = await getDocs(q);
    return querySnapshot.size;
  } catch (error) {
    console.error('Error getting discussion count:', error);
    return 0;
  }
};

// Real-time listener for project discussions
export const subscribeToProjectDiscussions = (projectId, callback) => {
  const q = query(
    collection(db, 'projectDiscussions'),
    where('projectId', '==', projectId),
    orderBy('createdAt', 'desc')
  );

  return onSnapshot(q, (querySnapshot) => {
    const discussions = [];
    querySnapshot.forEach((doc) => {
      discussions.push({
        id: doc.id,
        ...doc.data(),
      });
    });
    callback(discussions);
  });
};


--- END: src\api\projectDiscussionService.js ---


--- START: src\api\projectService.js ---
//src/api/projectService.js
import {
  collection,
  addDoc,
  updateDoc,
  deleteDoc,
  doc,
  query,
  orderBy,
  getDocs,
  getDoc,
  where,
  serverTimestamp,
  arrayUnion,
  runTransaction,
} from 'firebase/firestore';
import { db, functions } from '../config/firebaseConfig';
import { httpsCallable } from 'firebase/functions';
import { getCustomerById } from './customerService'; // Import getCustomerById

/**
 * L·∫•y t·∫•t c·∫£ d·ª± √°n
 * @returns {Promise<Array>} - M·∫£ng d·ª± √°n
 */
export const getProjects = async () => {
  try {
    const projectsRef = collection(db, 'projects');
    const q = query(projectsRef, orderBy('createdAt', 'desc'));
    const querySnapshot = await getDocs(q);

    // D·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c denormalize, kh√¥ng c·∫ßn query th√™m
    const projects = querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));

    return projects;
  } catch (error) {
    throw error;
  }
};

/**
 * L·∫•y d·ª± √°n theo ID k√®m th√¥ng tin kh√°ch h√†ng
 * @param {string} projectId - ID d·ª± √°n
 * @returns {Promise<Object|null>} - D·ªØ li·ªáu d·ª± √°n ho·∫∑c null n·∫øu kh√¥ng t√¨m th·∫•y
 */
export const getProjectById = async (projectId) => {
  try {
    const projectRef = doc(db, 'projects', projectId);
    const projectSnapshot = await getDoc(projectRef);

    if (projectSnapshot.exists()) {
      const projectData = {
        id: projectSnapshot.id,
        ...projectSnapshot.data(),
      };

      // N·∫øu d·ª± √°n c√≥ customerId, l·∫•y th√¥ng tin kh√°ch h√†ng
      if (projectData.customerId) {
        try {
          const customerRef = doc(db, 'customers', projectData.customerId);
          const customerSnapshot = await getDoc(customerRef);

          if (customerSnapshot.exists()) {
            const customerData = customerSnapshot.data();
            // Th√™m th√¥ng tin kh√°ch h√†ng v√†o d·ª± √°n
            return {
              ...projectData,
              customerName: customerData.name || 'Kh√¥ng x√°c ƒë·ªãnh',
              customerContactPerson: customerData.contactPerson || '',
              customerEmail: customerData.email || '',
              customerPhone: customerData.phone || '',
              customerAddress: customerData.address || '',
              customerTaxCode: customerData.taxCode || '',
              customer: {
                id: projectData.customerId,
                ...customerData,
              },
            };
          }
        } catch (error) {
          console.error(
            `L·ªói khi l·∫•y th√¥ng tin kh√°ch h√†ng cho d·ª± √°n ${projectId}:`,
            error
          );
        }
      }

      // Tr·∫£ v·ªÅ d·ª± √°n g·ªëc n·∫øu kh√¥ng c√≥ customerId ho·∫∑c c√≥ l·ªói
      return {
        ...projectData,
        customerName: 'Kh√¥ng x√°c ƒë·ªãnh',
        customerContactPerson: '',
        customerEmail: '',
        customerPhone: '',
        customerAddress: '',
        customerTaxCode: '',
      };
    } else {
      return null;
    }
  } catch (error) {
    throw error;
  }
};

/**
 * T·∫°o d·ª± √°n m·ªõi
 * @param {Object} projectData - D·ªØ li·ªáu d·ª± √°n
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng t·∫°o d·ª± √°n
 * @returns {Promise<string>} - ID c·ªßa d·ª± √°n ƒë√£ t·∫°o
 */
export const createProject = async (projectData, userId) => {
  try {
    const projectToSave = { ...projectData };

    // Denormalization: Fetch and add customerName if customerId exists
    if (projectToSave.customerId) {
      const customer = await getCustomerById(projectToSave.customerId);
      if (customer) {
        projectToSave.customerName = customer.name;
      }
    }

    // T·∫°o c·∫•u tr√∫c tasks m·∫∑c ƒë·ªãnh
    const defaultTasks = {
      quotation: { status: 'pending' },
      material_separation: { status: 'pending' },
      material_purchasing: {
        label: 'Mua v·∫≠t t∆∞ & ph·ª• ki·ªán',
        status: 'pending',
      },
      material_cutting: { status: 'pending' },
      assembly: { status: 'pending' },
      painting: { status: 'pending' },
      shipping: { status: 'pending' },
      other: { name: '', status: 'pending' },
    };

    const docRef = await addDoc(collection(db, 'projects'), {
      ...projectToSave,
      tasks: defaultTasks, // Th√™m c·∫•u tr√∫c tasks m·∫∑c ƒë·ªãnh
      createdAt: serverTimestamp(),
      createdBy: userId,
      updatedAt: serverTimestamp(),
    });

    // Tr·∫£ v·ªÅ ID c·ªßa d·ª± √°n v·ª´a t·∫°o
    return docRef.id;
  } catch (error) {
    throw error;
  }
};

/**
 * C·∫≠p nh·∫≠t th√¥ng tin d·ª± √°n
 * @param {string} projectId - ID d·ª± √°n
 * @param {Object} projectData - D·ªØ li·ªáu d·ª± √°n c·∫≠p nh·∫≠t
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng c·∫≠p nh·∫≠t d·ª± √°n
 * @returns {Promise<void>}
 */
export const updateProject = async (projectId, projectData, userId) => {
  try {
    const projectToUpdate = { ...projectData };

    // Denormalization: If customerId is being updated, also update customerName
    if (projectToUpdate.customerId) {
      const customer = await getCustomerById(projectToUpdate.customerId);
      if (customer) {
        projectToUpdate.customerName = customer.name;
      } else {
        projectToUpdate.customerName = 'Kh√¥ng x√°c ƒë·ªãnh'; // Handle case where customer might not be found
      }
    }

    // Lo·∫°i b·ªè c√°c field c√≥ gi√° tr·ªã undefined ƒë·ªÉ tr√°nh l·ªói Firestore
    const cleanData = Object.fromEntries(
      Object.entries(projectToUpdate).filter(
        ([_, value]) => value !== undefined
      )
    );

    const projectRef = doc(db, 'projects', projectId);
    await updateDoc(projectRef, {
      ...cleanData,
      updatedAt: serverTimestamp(),
      updatedBy: userId,
    });
  } catch (error) {
    console.error('L·ªói khi c·∫≠p nh·∫≠t d·ª± √°n:', error);
    throw error;
  }
};

/**
 * X√≥a d·ª± √°n
 * @param {string} projectId - ID d·ª± √°n
 * @returns {Promise<void>}
 */
export const deleteProject = async (projectId) => {
  try {
    const projectRef = doc(db, 'projects', projectId);
    await deleteDoc(projectRef);
  } catch (error) {
    console.error('Error deleting project:', error);
    throw new Error('Kh√¥ng th·ªÉ x√≥a d·ª± √°n. Vui l√≤ng th·ª≠ l·∫°i.');
  }
};

/**
 * L·∫•y d·ª± √°n theo kh√°ch h√†ng
 * @param {string} customerId - ID kh√°ch h√†ng
 * @returns {Promise<Array>} - M·∫£ng d·ª± √°n thu·ªôc kh√°ch h√†ng
 */
export const getProjectsByCustomer = async (customerId) => {
  try {
    const projectsRef = collection(db, 'projects');
    const q = query(
      projectsRef,
      where('customerId', '==', customerId),
      orderBy('createdAt', 'desc')
    );

    const querySnapshot = await getDocs(q);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    throw error;
  }
};

/**
 * L·∫•y d·ª± √°n theo tr·∫°ng th√°i
 * @param {string} status - Tr·∫°ng th√°i d·ª± √°n (pending, in-progress, completed, cancelled)
 * @returns {Promise<Array>} - M·∫£ng d·ª± √°n thu·ªôc tr·∫°ng th√°i ƒë√£ ch·ªâ ƒë·ªãnh
 */
export const getProjectsByStatus = async (status) => {
  try {
    const projectsRef = collection(db, 'projects');

    // Special case for 'all' - return all projects
    if (status === 'all') {
      const q = query(projectsRef, orderBy('createdAt', 'desc'));
      const querySnapshot = await getDocs(q);
      return querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));
    }

    // Map filter keys to actual status values in the database
    let statusValue = status;
    if (status === 'in_progress') {
      statusValue = 'in-progress';
    } else if (status === 'production_complete') {
      statusValue = 'production-complete';
    } else if (status === 'delivered') {
      statusValue = 'delivered';
    }

    const q = query(
      projectsRef,
      where('status', '==', statusValue),
      orderBy('createdAt', 'desc')
    );

    const querySnapshot = await getDocs(q);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    throw error;
  }
};

/**
 * T√¨m ki·∫øm d·ª± √°n theo t√™n
 * @param {string} searchTerm - T·ª´ kh√≥a t√¨m ki·∫øm
 * @returns {Promise<Array>} - M·∫£ng d·ª± √°n ph√π h·ª£p
 */
export const searchProjects = async (searchTerm) => {
  try {
    const projectsRef = collection(db, 'projects');
    const nameQuery = query(
      projectsRef,
      where('name', '>=', searchTerm),
      where('name', '<=', searchTerm + '\uf8ff')
    );

    const querySnapshot = await getDocs(nameQuery);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    throw error;
  }
};

/**
 * Updates the status of a specific task within a project.
 * This is a targeted update to ensure it passes security rules for non-admin users.
 * @param {string} projectId The ID of the project to update.
 * @param {string} taskKey The key of the task to update (e.g., 'material_separation').
 * @param {string} newStatus The new status for the task.
 */
export const updateTaskStatus = async (projectId, taskKey, newStatus) => {
  if (!projectId || !taskKey || !newStatus) {
    throw new Error('C·∫ßn c√≥ ID d·ª± √°n, kh√≥a c√¥ng vi·ªác v√† tr·∫°ng th√°i m·ªõi.');
  }
  try {
    const projectRef = doc(db, 'projects', projectId);
    // Construct the field path dynamically
    const fieldPath = `tasks.${taskKey}.status`;
    await updateDoc(projectRef, {
      [fieldPath]: newStatus,
    });
  } catch (error) {
    console.error('Error updating task status:', error);
    if (error.code === 'permission-denied') {
      throw new Error('B·∫°n kh√¥ng c√≥ quy·ªÅn c·∫≠p nh·∫≠t tr·∫°ng th√°i c√¥ng vi·ªác n√†y.');
    }
    throw new Error(
      'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i c√¥ng vi·ªác. Vui l√≤ng th·ª≠ l·∫°i.'
    );
  }
};

/**
 * C·∫≠p nh·∫≠t t√™n c√¥ng vi·ªác "other"
 * @param {string} projectId - ID d·ª± √°n
 * @param {string} taskName - T√™n c√¥ng vi·ªác kh√°c
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng c·∫≠p nh·∫≠t
 * @returns {Promise<void>}
 */
export const updateCustomTask = async (projectId, taskName, userId) => {
  try {
    const projectRef = doc(db, 'projects', projectId);
    const updatePath = `tasks.other.name`;

    await updateDoc(projectRef, {
      [updatePath]: taskName,
      updatedAt: serverTimestamp(),
      updatedBy: userId,
    });
  } catch (error) {
    throw error;
  }
};

/**
 * Updates the status of a specific workflow stage within a project.
 * This is a targeted update to ensure it passes security rules for non-admin users.
 * @param {string} projectId The ID of the project to update.
 * @param {string} stageId The ID of the stage to update.
 * @param {string} newStatus The new status for the stage.
 * @param {string} assignedToId The ID of the user assigned to the stage.
 */
export const updateWorkflowStageStatus = async (
  projectId,
  stageId,
  newStatus,
  assignedToId = null
) => {
  console.log('üîÑ updateWorkflowStageStatus called:', {
    projectId,
    stageId,
    newStatus,
    assignedToId,
  });

  // üîß ALWAYS use transaction for workflowStages updates to ensure consistency
  console.log(
    'üîÑ Using transaction for workflowStages update (recommended approach)'
  );

  await runTransaction(db, async (transaction) => {
    const ref = doc(db, 'projects', projectId);
    const snap = await transaction.get(ref);

    if (!snap.exists()) {
      console.error('‚ùå Project not found:', projectId);
      throw new Error('Project not found');
    }

    const stages = snap.data().workflowStages || [];
    console.log(
      'üìã Current stages:',
      stages.map((s) => ({
        stageId: s.stageId,
        processName: s.processName,
        status: s.status,
      }))
    );

    console.log('üîç Looking for stageId:', stageId);
    console.log(
      'üîç Available stageIds:',
      stages.map((s) => s.stageId)
    );
    console.log('üîç StageId type:', typeof stageId);
    console.log(
      'üîç Available stageId types:',
      stages.map((s) => typeof s.stageId)
    );

    const idx = stages.findIndex((s) => s.stageId === stageId);
    console.log('üéØ Found stage at index:', idx);

    if (idx === -1) {
      console.error('‚ùå Stage not found:', stageId);
      console.error(
        'Available stageIds:',
        stages.map((s) => s.stageId)
      );
      throw new Error('Stage not found');
    }

    console.log(`üéØ Found stage at index ${idx}:`, {
      stageId: stages[idx].stageId,
      processName: stages[idx].processName,
      currentStatus: stages[idx].status,
      newStatus,
    });

    stages[idx] = {
      ...stages[idx],
      status: newStatus,
      ...(assignedToId ? { assignedToId } : {}),
    };

    console.log('üíæ Updating stage to:', stages[idx]);
    transaction.update(ref, {
      workflowStages: stages,
      updatedAt: serverTimestamp(),
    });
    console.log('‚úÖ Transaction update completed');
  });
};

/**
 * C·∫≠p nh·∫≠t chi ti·∫øt (status, notes, files) cho m·ªôt c√¥ng ƒëo·∫°n c·ª• th·ªÉ
 * @param {string} projectId
 * @param {string} stageId
 * @param {Object} data - {status?, notes?, files?}
 */
export const updateStageDetails = async (projectId, stageId, data) => {
  try {
    const projectRef = doc(db, 'projects', projectId);

    await runTransaction(db, async (tx) => {
      const snap = await tx.get(projectRef);
      if (!snap.exists()) throw new Error('Project not found');
      const project = snap.data();
      const stages = project.workflowStages || [];
      const idx = stages.findIndex((s) => s.stageId === stageId);
      if (idx === -1) throw new Error('Stage not found');

      // Lo·∫°i b·ªè c√°c field undefined t·ª´ data
      const cleanData = Object.fromEntries(
        Object.entries(data).filter(([_, value]) => value !== undefined)
      );

      stages[idx] = {
        ...stages[idx],
        ...cleanData, // status, notes, files
      };

      tx.update(projectRef, {
        workflowStages: stages,
        updatedAt: serverTimestamp(),
      });
    });
  } catch (error) {
    console.error('Error updating stage details:', error);
    throw new Error('Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t chi ti·∫øt c√¥ng ƒëo·∫°n.');
  }
};

const ProjectService = {
  /**
   * Calls a cloud function to create folders for a project in Google Drive.
   * @param {string} projectId - The ID of the project.
   * @param {string} accessToken - The Google access token.
   * @returns {Promise<any>} The result from the cloud function.
   */
  async createProjectFolders(projectId, accessToken) {
    try {
      const createFolders = httpsCallable(functions, 'createProjectFolders');
      const result = await createFolders({ projectId, accessToken });
      return result.data;
    } catch (error) {
      console.error('Error creating project folders:', error);
      throw error;
    }
  },

  /**
   * Imports materials from a Google Sheet file in Drive.
   * @param {string} fileId - The ID of the Google Sheet file.
   * @param {string} projectId - The ID of the project to associate materials with.
   * @param {string} accessToken - The user's Google access token.
   * @returns {Promise<any>} The result from the cloud function.
   */
  async importMaterialsFromDrive(fileId, projectId, accessToken) {
    try {
      const importMaterials = httpsCallable(
        functions,
        'importMaterialsFromDrive'
      );
      const result = await importMaterials({ fileId, projectId, accessToken });
      return result.data;
    } catch (error) {
      console.error('Error importing materials from drive:', error);
      throw error;
    }
  },

  /**
   * Deletes a file from Google Drive using a cloud function.
   * @param {string} fileId - The ID of the file to delete.
   * @param {string} accessToken - The user's Google access token.
   * @returns {Promise<any>}
   */
  async deleteFileFromDrive(fileId, accessToken) {
    try {
      const deleteFile = httpsCallable(functions, 'deleteFileFromDrive');
      const result = await deleteFile({ fileId, accessToken });
      return result.data;
    } catch (error) {
      console.error('Error deleting file from drive:', error);
      throw error;
    }
  },

  /**
   * Triggers processing of a payable ledger from a Google Sheet.
   * @param {string} fileId - The ID of the Google Sheet.
   * @param {string} accessToken - The Google access token.
   * @returns {Promise<any>}
   */
  async processPayableLedgerFromDrive(fileId, accessToken) {
    try {
      const processLedger = httpsCallable(
        functions,
        'processPayableLedgerFromDrive'
      );
      const result = await processLedger({ fileId, accessToken });
      return result.data;
    } catch (error) {
      console.error('Error processing payable ledger:', error);
      throw error;
    }
  },
};

/**
 * Assign worker to a project stage
 * @param {string} projectId - Project ID
 * @param {string} stageId - Stage ID
 * @param {string} workerId - Worker ID
 * @param {string} workerName - Worker name
 * @returns {Promise<void>}
 */
export const assignWorkerToStage = async (
  projectId,
  stageId,
  workerId,
  workerName
) => {
  try {
    const projectRef = doc(db, 'projects', projectId);

    await runTransaction(db, async (transaction) => {
      const projectDoc = await transaction.get(projectRef);

      if (!projectDoc.exists()) {
        throw new Error('Project not found');
      }

      const projectData = projectDoc.data();
      const workflowStages = projectData.workflowStages || [];

      // Find and update the specific stage
      const updatedStages = workflowStages.map((stage) => {
        if (stage.stageId === stageId) {
          const assignedWorkers = stage.assignedWorkers || [];

          // Check if worker is already assigned
          if (!assignedWorkers.includes(workerId)) {
            return {
              ...stage,
              assignedWorkers: [...assignedWorkers, workerId],
              assignedWorkerNames: [
                ...(stage.assignedWorkerNames || []),
                workerName,
              ],
              status: 'assigned', // Update status to assigned
              assignedAt: new Date(),
            };
          }
        }
        return stage;
      });

      // Update the project with new stage assignments
      transaction.update(projectRef, {
        workflowStages: updatedStages,
        updatedAt: serverTimestamp(),
      });
    });

    console.log(
      `Successfully assigned ${workerName} to stage ${stageId} in project ${projectId}`
    );
  } catch (error) {
    console.error('Error assigning worker to stage:', error);
    throw error;
  }
};

export const saveProjectAccessoryPrice = async (projectId, accessoryPrice) => {
  try {
    const projectRef = doc(db, 'projects', projectId);
    await updateDoc(projectRef, {
      accessoryPrice: Number(accessoryPrice || 0),
      updatedAt: serverTimestamp(),
    });
  } catch (error) {
    console.error('L·ªói khi l∆∞u gi√° ph·ª• ki·ªán:', error);
    throw error;
  }
};

export const getProjectAccessoryPrice = async (projectId) => {
  try {
    const projectRef = doc(db, 'projects', projectId);
    const projectSnap = await getDoc(projectRef);
    if (projectSnap.exists()) {
      return projectSnap.data().accessoryPrice || 0;
    }
    return 0;
  } catch (error) {
    console.error('L·ªói khi l·∫•y gi√° ph·ª• ki·ªán:', error);
    return 0;
  }
};

export default ProjectService;


--- END: src\api\projectService.js ---


--- START: src\api\proposalService.js ---
// src/api/proposalService.js
import {
  collection,
  addDoc,
  getDocs,
  query,
  where,
  doc,
  updateDoc,
  serverTimestamp,
  orderBy,
  getDoc, // Add getDoc
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';

/**
 * Ki·ªÉm tra xem ng∆∞·ªùi d√πng c√≥ quy·ªÅn t·∫°o ƒë·ªÅ xu·∫•t kh√¥ng
 * @param {string} role - Role c·ªßa ng∆∞·ªùi d√πng
 * @returns {boolean}
 */
export const canCreateProposal = (role) => {
  const allowedRoles = ['ky_su', 'pho_giam_doc', 'thuong_mai'];
  return allowedRoles.includes(role);
};

/**
 * Ki·ªÉm tra xem ng∆∞·ªùi d√πng c√≥ quy·ªÅn duy·ªát ƒë·ªÅ xu·∫•t kh√¥ng
 * @param {string} role - Role c·ªßa ng∆∞·ªùi d√πng
 * @returns {boolean}
 */
export const canApproveProposal = (role) => {
  const allowedRoles = ['giam_doc', 'thuong_mai'];
  return allowedRoles.includes(role);
};

/**
 * T·∫°o phi·∫øu ƒë·ªÅ xu·∫•t v·∫≠t t∆∞ m·ªõi
 * @param {Object} proposalData - {projectId, projectName, items:[], createdBy, proposalCode, requiredDate, priority, purpose, createdByName}
 * @returns {Promise<string>} id c·ªßa phi·∫øu ƒë√£ t·∫°o
 */
export const createProposal = async (proposalData) => {
  const dataToSave = {
    ...proposalData,
    status: 'pending',
    createdAt: serverTimestamp(),
  };
  const docRef = await addDoc(collection(db, 'purchase_proposals'), dataToSave);
  return docRef.id;
};

/**
 * L·∫•y danh s√°ch ƒë·ªÅ xu·∫•t c·ªßa 1 d·ª± √°n
 * @param {string} projectId
 */
export const getProposalsByProject = async (projectId) => {
  const q = query(
    collection(db, 'purchase_proposals'),
    where('projectId', '==', projectId),
    orderBy('createdAt', 'desc')
  );
  const snap = await getDocs(q);
  return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
};

/**
 * L·∫•y danh s√°ch ƒë·ªÅ xu·∫•t theo tr·∫°ng th√°i
 * @param {string} status - 'pending', 'approved', 'rejected'
 */
export const getProposalsByStatus = async (status) => {
  try {
    // Th·ª≠ truy v·∫•n v·ªõi orderBy
    const q = query(
      collection(db, 'purchase_proposals'),
      where('status', '==', status),
      orderBy('createdAt', 'desc')
    );
    const snap = await getDocs(q);
    return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
  } catch (error) {
    // N·∫øu l·ªói do ch∆∞a c√≥ index, th·ª≠ truy v·∫•n kh√¥ng c√≥ orderBy
    if (
      error.code === 'failed-precondition' ||
      error.message.includes('index')
    ) {
      console.warn('Index error, trying without orderBy:', error.message);
      const q = query(
        collection(db, 'purchase_proposals'),
        where('status', '==', status)
      );
      const snap = await getDocs(q);
      return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
    } else {
      // N·∫øu l√† l·ªói kh√°c th√¨ throw
      throw error;
    }
  }
};

/**
 * C·∫≠p nh·∫≠t tr·∫°ng th√°i phi·∫øu (approved / rejected)
 * @param {string} proposalId
 * @param {'approved'|'rejected'} status
 * @param {string} approvedBy uid
 * @param {string} approvedByName t√™n ng∆∞·ªùi duy·ªát
 * @param {string} comment ghi ch√∫ khi duy·ªát/t·ª´ ch·ªëi
 */
export const updateProposalStatus = async (
  proposalId,
  status,
  approvedBy,
  approvedByName,
  comment = ''
) => {
  const proposalRef = doc(db, 'purchase_proposals', proposalId);

  // Lo·∫°i b·ªè c√°c field c√≥ gi√° tr·ªã undefined ƒë·ªÉ tr√°nh l·ªói Firestore
  const updateData = {
    status,
    approvedBy,
    approvedByName,
    approvedAt: serverTimestamp(),
    comment,
  };

  const cleanData = Object.fromEntries(
    Object.entries(updateData).filter(([_, value]) => value !== undefined)
  );

  await updateDoc(proposalRef, cleanData);

  // Create a notification for the creator
  if (status === 'approved' || status === 'rejected') {
    try {
      const proposalSnap = await getDoc(proposalRef);
      if (proposalSnap.exists()) {
        const proposalData = proposalSnap.data();
        if (proposalData.createdBy && proposalData.createdBy !== approvedBy) {
          const notificationMessage =
            status === 'approved'
              ? `ƒê·ªÅ xu·∫•t "${
                  proposalData.proposalCode || 'Kh√¥ng c√≥ m√£'
                }" ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát.`
              : `ƒê·ªÅ xu·∫•t "${
                  proposalData.proposalCode || 'Kh√¥ng c√≥ m√£'
                }" ƒë√£ b·ªã t·ª´ ch·ªëi.`;

          const notificationData = {
            userId: proposalData.createdBy,
            message: notificationMessage,
            proposalId: proposalId,
            read: false,
            createdAt: serverTimestamp(),
            type:
              status === 'approved' ? 'PROPOSAL_APPROVED' : 'PROPOSAL_REJECTED',
            navLink: {
              screen: 'ProposalList',
            },
          };
          await addDoc(collection(db, 'notifications'), notificationData);
        }
      }
    } catch (error) {
      console.error('Failed to create notification:', error);
    }
  }
};

/**
 * C·∫≠p nh·∫≠t gi√° v·∫≠t t∆∞ trong phi·∫øu ƒë·ªÅ xu·∫•t
 * @param {string} proposalId - ID c·ªßa phi·∫øu ƒë·ªÅ xu·∫•t
 * @param {Array} materials - M·∫£ng v·∫≠t t∆∞ v·ªõi th√¥ng tin gi√° ƒë√£ c·∫≠p nh·∫≠t
 * @returns {Promise<void>}
 */
export const updateProposalMaterialPrices = async (proposalId, materials) => {
  const ref = doc(db, 'purchase_proposals', proposalId);

  // T√≠nh t·ªïng gi√° tr·ªã ƒë∆°n h√†ng
  let totalOrderValue = 0;
  materials.forEach((item) => {
    if (item.price && item.quantity) {
      const price = parseFloat(item.price);
      const quantity = parseFloat(item.quantity);
      if (!isNaN(price) && !isNaN(quantity)) {
        totalOrderValue += price * quantity;
      }
    }
  });

  const updateData = {
    items: materials,
    hasPrices: true,
    totalValue: totalOrderValue,
    priceUpdatedAt: serverTimestamp(),
  };

  // Lo·∫°i b·ªè c√°c field c√≥ gi√° tr·ªã undefined ƒë·ªÉ tr√°nh l·ªói Firestore
  const cleanData = Object.fromEntries(
    Object.entries(updateData).filter(([_, value]) => value !== undefined)
  );

  await updateDoc(ref, cleanData);
};


--- END: src\api\proposalService.js ---


--- START: src\api\purchaseOrderService.js ---
// src/api/purchaseOrderService.js
import {
  collection,
  addDoc,
  getDocs,
  query,
  where,
  orderBy,
  serverTimestamp,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';
import { httpsCallable, getFunctions } from 'firebase/functions';

// Get Firebase Functions instance for asia-southeast1 region
const functionsInstance = getFunctions(undefined, 'asia-southeast1');

export const createPO = async (poData) => {
  const dataToSave = {
    ...poData,
    status: 'created',
    createdAt: serverTimestamp(),
  };
  const docRef = await addDoc(collection(db, 'purchase_orders'), dataToSave);
  return docRef.id;
};

export const getPOsByProject = async (projectId) => {
  const q = query(
    collection(db, 'purchase_orders'),
    where('projectId', '==', projectId),
    orderBy('createdAt', 'desc')
  );
  const snap = await getDocs(q);
  return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
};

export const getAllPOs = async () => {
  const snap = await getDocs(
    query(collection(db, 'purchase_orders'), orderBy('createdAt', 'desc'))
  );
  return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
};

/**
 * Saves PO receipt confirmation data to Firestore
 * This function assumes files have already been uploaded to Drive
 * @param {Object} params - Parameters
 * @param {string} params.poId - Purchase order ID
 * @param {string} params.projectId - Project ID
 * @param {Array} params.filesToSave - Array of file objects to save (with id, name, url)
 * @param {string} params.remarks - Optional remarks
 * @returns {Promise<Object>} - Result with success status
 */
export const savePOReceiptConfirmation = async ({
  poId,
  projectId,
  filesToSave,
  remarks = '',
}) => {
  const callable = httpsCallable(
    functionsInstance,
    'savePOReceiptConfirmation'
  );
  const res = await callable({ poId, projectId, filesToSave, remarks });
  return res.data;
};


--- END: src\api\purchaseOrderService.js ---


--- START: src\api\quotationService.js ---
//src/api/quotationService.js
import {
  collection,
  addDoc,
  updateDoc,
  doc,
  getDoc,
  getDocs,
  query,
  where,
  orderBy,
  serverTimestamp,
} from 'firebase/firestore';
// import { getStorage, ref, uploadString, getDownloadURL } from 'firebase/storage';
import { db } from '../config/firebaseConfig';
// import * as FileSystem from 'expo-file-system';

/**
 * Save quotation metadata to Firestore.
 * The PDF is assumed to be already created and stored by a cloud function.
 * @param {string} projectId - Project ID
 * @param {Object} quotationData - All quotation data, including pdfUrl and createdBy
 * @returns {Promise<Object>} - Saved quotation data with Firestore document ID
 */
export const saveQuotation = async (projectId, quotationData) => {
  try {
    console.log(
      'Saving quotation metadata to Firestore for project:',
      projectId
    );

    // Destructure and validate required fields from quotationData
    const { pdfUrl, createdBy } = quotationData;

    if (!projectId) {
      throw new Error('ProjectId kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng');
    }

    if (!pdfUrl) {
      throw new Error('PDF URL kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng');
    }

    if (!createdBy) {
      throw new Error('UserId (createdBy) kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng');
    }

    // 1. Save quotation data to Firestore
    const quotationRef = collection(db, `projects/${projectId}/quotations`);
    const docRef = await addDoc(quotationRef, {
      ...quotationData,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(), // Add updatedAt for consistency
    });

    console.log('Quotation metadata saved with ID:', docRef.id);

    // 2. Update project task status
    const projectRef = doc(db, 'projects', projectId);
    const updateData = {
      'tasks.quotation.status': 'completed',
      'tasks.quotation.completedAt': serverTimestamp(),
      'tasks.quotation.completedBy': createdBy,
      updatedAt: serverTimestamp(),
      updatedBy: createdBy,
    };

    // Lo·∫°i b·ªè c√°c field c√≥ gi√° tr·ªã undefined ƒë·ªÉ tr√°nh l·ªói Firestore
    const cleanData = Object.fromEntries(
      Object.entries(updateData).filter(([_, value]) => value !== undefined)
    );

    await updateDoc(projectRef, cleanData);

    console.log('Project status updated.');

    return {
      id: docRef.id,
      ...quotationData,
    };
  } catch (error) {
    console.error('Error saving quotation metadata:', error);
    throw error;
  }
};

/**
 * Get all quotations for a specific project
 * @param {string} projectId - Project ID
 * @returns {Promise<Array>} - Array of quotations
 */
export const getQuotationsByProject = async (projectId) => {
  try {
    const quotationsRef = collection(db, `projects/${projectId}/quotations`);
    const q = query(quotationsRef, orderBy('createdAt', 'desc'));
    const querySnapshot = await getDocs(q);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    console.error('Error getting quotations:', error);
    throw error;
  }
};

/**
 * Get a specific quotation by ID
 * @param {string} projectId - Project ID
 * @param {string} quotationId - Quotation ID
 * @returns {Promise<Object|null>} - Quotation data or null if not found
 */
export const getQuotationById = async (projectId, quotationId) => {
  try {
    const quotationRef = doc(
      db,
      `projects/${projectId}/quotations`,
      quotationId
    );
    const quotationSnapshot = await getDoc(quotationRef);

    if (quotationSnapshot.exists()) {
      return {
        id: quotationSnapshot.id,
        ...quotationSnapshot.data(),
      };
    } else {
      return null;
    }
  } catch (error) {
    console.error('Error getting quotation by ID:', error);
    throw error;
  }
};


--- END: src\api\quotationService.js ---


--- START: src\api\requestService.js ---
// src/api/requestService.js
import {
  collection,
  addDoc,
  serverTimestamp,
  query,
  where,
  getDocs,
  orderBy,
  updateDoc,
  doc,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';

// --- Leave Requests ---
export const submitLeaveRequest = async ({
  userId,
  userName,
  type,
  startDate,
  endDate,
  reason,
}) => {
  const colRef = collection(db, 'leave_requests');
  const payload = {
    userId,
    userName: userName || '',
    type,
    startDate,
    endDate,
    reason,
    status: 'pending',
    submittedAt: serverTimestamp(),
  };
  const docRef = await addDoc(colRef, payload);
  return { id: docRef.id, ...payload };
};

export const fetchPendingLeaveRequests = async () => {
  const colRef = collection(db, 'leave_requests');
  const q = query(
    colRef,
    where('status', '==', 'pending'),
    orderBy('submittedAt', 'desc')
  );
  const snap = await getDocs(q);
  return snap.docs.map((d) => ({
    id: d.id,
    ...d.data(),
    requestType: 'leave',
  }));
};

export const fetchLeaveRequestsByUser = async (userId) => {
  const colRef = collection(db, 'leave_requests');
  const q = query(colRef, where('userId', '==', userId));
  const snap = await getDocs(q);
  const items = snap.docs.map((d) => ({ id: d.id, ...d.data() }));
  // Sort by submittedAt desc on client to avoid composite index requirement
  items.sort((a, b) => {
    const ta = a.submittedAt?.toMillis ? a.submittedAt.toMillis() : 0;
    const tb = b.submittedAt?.toMillis ? b.submittedAt.toMillis() : 0;
    return tb - ta;
  });
  return items;
};

export const updateLeaveRequestStatus = async (
  id,
  status,
  managerNote = ''
) => {
  const ref = doc(db, 'leave_requests', id);
  await updateDoc(ref, { status, managerNote, decidedAt: serverTimestamp() });
};

// --- Advance Salary Requests ---
export const submitAdvanceSalaryRequest = async ({
  userId,
  userName,
  amount,
  reason,
  requestDate,
  expectedPaymentDate,
}) => {
  const colRef = collection(db, 'advance_requests');
  const payload = {
    userId,
    userName: userName || '',
    amount,
    reason,
    requestDate,
    expectedPaymentDate,
    status: 'pending',
    submittedAt: serverTimestamp(),
  };
  const docRef = await addDoc(colRef, payload);
  return { id: docRef.id, ...payload };
};

export const fetchPendingAdvanceRequests = async () => {
  const colRef = collection(db, 'advance_requests');
  const q = query(
    colRef,
    where('status', '==', 'pending'),
    orderBy('submittedAt', 'desc')
  );
  const snap = await getDocs(q);
  return snap.docs.map((d) => ({
    id: d.id,
    ...d.data(),
    requestType: 'advance',
  }));
};

export const updateAdvanceRequestStatus = async (
  id,
  status,
  managerNote = ''
) => {
  const ref = doc(db, 'advance_requests', id);
  await updateDoc(ref, { status, managerNote, decidedAt: serverTimestamp() });
};

export const fetchAdvanceRequestsByUser = async (userId) => {
  const colRef = collection(db, 'advance_requests');
  const q = query(colRef, where('userId', '==', userId));
  const snap = await getDocs(q);
  const items = snap.docs.map((d) => ({ id: d.id, ...d.data() }));
  items.sort((a, b) => {
    const ta = a.submittedAt?.toMillis ? a.submittedAt.toMillis() : 0;
    const tb = b.submittedAt?.toMillis ? b.submittedAt.toMillis() : 0;
    return tb - ta;
  });
  return items;
};




--- END: src\api\requestService.js ---


--- START: src\api\salaryService.js ---
import {
  collection,
  addDoc,
  updateDoc,
  doc,
  getDoc,
  getDocs,
  query,
  where,
  orderBy,
  serverTimestamp,
  deleteDoc,
  runTransaction,
  documentId,
  setDoc,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';
import { getUsers } from './userService';

class SalaryService {
  constructor() {
    this.db = db;
  }

  // ===== QU·∫¢N L√ù C·∫§U H√åNH H·ªÜ TH·ªêNG =====

  /**
   * L·∫•y c·∫•u h√¨nh h·ªá th·ªëng t·ª´ collection 'settings'.
   * @returns {Promise<Object>} - C·∫•u h√¨nh c√¥ng ty.
   */
  async getSystemSettings() {
    try {
      const settingsRef = doc(this.db, 'settings', 'companyConfig');
      const settingsDoc = await getDoc(settingsRef);

      if (settingsDoc.exists()) {
        return settingsDoc.data();
      } else {
        // Tr·∫£ v·ªÅ gi√° tr·ªã m·∫∑c ƒë·ªãnh n·∫øu ch∆∞a c√≥ c·∫•u h√¨nh
        console.warn(
          'Kh√¥ng t√¨m th·∫•y companyConfig trong Firestore, s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh.'
        );
        return {
          standardWorkingDays: 26,
          overtimeMultipliers: {
            normal: 1.5,
            sunday: 2.0,
            holiday: 3.0,
          },
        };
      }
    } catch (error) {
      console.error('L·ªói khi l·∫•y c·∫•u h√¨nh h·ªá th·ªëng:', error);
      throw error;
    }
  }

  // ===== QU·∫¢N L√ù D·ªÆ LI·ªÜU NH√ÇN VI√äN =====

  /**
   * L·∫•y th√¥ng tin chi ti·∫øt c·ªßa m·ªôt nh√¢n vi√™n.
   * @param {string} employeeId - ID c·ªßa nh√¢n vi√™n.
   * @returns {Promise<Object>} - D·ªØ li·ªáu chi ti·∫øt c·ªßa nh√¢n vi√™n.
   */
  async getEmployeeDetails(employeeId) {
    try {
      const userRef = doc(this.db, 'users', employeeId);
      const userDoc = await getDoc(userRef);

      if (!userDoc.exists()) {
        throw new Error(`Kh√¥ng t√¨m th·∫•y nh√¢n vi√™n v·ªõi ID: ${employeeId}`);
      }
      const userData = userDoc.data();
      return {
        id: userDoc.id,
        ...userData,
        // ƒê·∫£m b·∫£o c√°c tr∆∞·ªùng quan tr·ªçng c√≥ gi√° tr·ªã m·∫∑c ƒë·ªãnh
        salaryType:
          userData.salaryType || (userData.monthlySalary ? 'monthly' : 'daily'),
        dailySalary: userData.dailySalary || 0,
        monthlySalary: userData.monthlySalary || 0,
        insuranceContributionBase: userData.insuranceContributionBase || 0,
        annualLeaveBalance:
          userData.annualLeaveBalance !== undefined
            ? userData.annualLeaveBalance
            : 12,
      };
    } catch (error) {
      console.error('L·ªói khi l·∫•y th√¥ng tin nh√¢n vi√™n:', error);
      throw error;
    }
  }

  /**
   * L·∫•y danh s√°ch ·ª©ng l∆∞∆°ng ƒë√£ ƒë∆∞·ª£c duy·ªát c·ªßa nh√¢n vi√™n trong th√°ng.
   * @param {string} employeeId - ID nh√¢n vi√™n.
   * @param {number} month - Th√°ng (1-12).
   * @param {number} year - NƒÉm.
   * @returns {Promise<Array>} - Danh s√°ch c√°c kho·∫£n ·ª©ng l∆∞∆°ng.
   */
  async getAdvancePayments(employeeId, month, year) {
    try {
      const startDate = new Date(year, month - 1, 1);
      const endDate = new Date(year, month, 0, 23, 59, 59);

      console.log('DEBUG getAdvancePayments:', {
        employeeId,
        month,
        year,
        startDate: startDate.toISOString(),
        endDate: endDate.toISOString(),
      });

      const advanceRef = collection(this.db, 'advance_requests');
      const q = query(
        advanceRef,
        where('userId', '==', employeeId),
        where('status', '==', 'approved')
      );

      const querySnapshot = await getDocs(q);
      const allDocs = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));

      console.log('DEBUG all approved advances:', allDocs);

      // Filter by date range manually since Firestore date queries can be tricky
      const filteredDocs = allDocs.filter((doc) => {
        const requestDate = doc.requestDate?.toDate
          ? doc.requestDate.toDate()
          : new Date(doc.requestDate);
        return requestDate >= startDate && requestDate <= endDate;
      });

      console.log('DEBUG filtered advances for period:', filteredDocs);
      return filteredDocs;
    } catch (error) {
      console.error('L·ªói khi l·∫•y danh s√°ch ·ª©ng l∆∞∆°ng:', error);
      return [];
    }
  }

  /**
   * ƒê·ªçc cache b√°o c√°o t·ªïng l∆∞∆°ng trong Firestore n·∫øu c√≥
   */
  async getCachedSalaryReport(month, year) {
    try {
      const id = `${year}-${String(month).padStart(2, '0')}`;
      const ref = doc(this.db, 'salaryReportCache', id);
      const snap = await getDoc(ref);
      if (snap.exists()) {
        const data = snap.data();
        return data?.payload || null;
      }
      return null;
    } catch (e) {
      console.warn('Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c cache b√°o c√°o:', e);
      return null;
    }
  }

  /**
   * L∆∞u cache b√°o c√°o t·ªïng l∆∞∆°ng v√†o Firestore
   */
  async saveSalaryReportCache(month, year, reportPayload) {
    try {
      const id = `${year}-${String(month).padStart(2, '0')}`;
      const ref = doc(this.db, 'salaryReportCache', id);
      await setDoc(ref, {
        month,
        year,
        payload: reportPayload,
        updatedAt: serverTimestamp(),
      });
    } catch (e) {
      console.warn('Kh√¥ng l∆∞u ƒë∆∞·ª£c cache b√°o c√°o:', e);
    }
  }

  /**
   * L·∫•y b√°o c√°o t·ªïng l∆∞∆°ng cho t·∫•t c·∫£ nh√¢n vi√™n trong th√°ng (t√≠nh t·ª´ d·ªØ li·ªáu g·ªëc)
   * @param {number} month - Th√°ng (1-12)
   * @param {number} year - NƒÉm
   * @returns {Promise<Object>} - B√°o c√°o t·ªïng l∆∞∆°ng
   */
  async getTotalSalaryReport(month, year, options = {}) {
    try {
      const { forceRefresh = false } = options;
      console.log('DEBUG getTotalSalaryReport:', { month, year, forceRefresh });

      if (!forceRefresh) {
        const cached = await this.getCachedSalaryReport(month, year);
        if (cached) {
          return cached;
        }
      }

      // 1) Fetch all users
      const usersRef = collection(this.db, 'users');
      const usersSnapshot = await getDocs(usersRef);
      const allUsers = usersSnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));

      // 2) For each user, try to get the latest salary slip in that month/year
      const resolvedReports = [];
      for (const user of allUsers) {
        try {
          const slipsQ = query(
            collection(this.db, 'salarySlips'),
            where('employeeId', '==', user.id),
            where('month', '==', parseInt(month)),
            where('year', '==', parseInt(year)),
            orderBy('createdAt', 'desc')
          );
          const slipsSnap = await getDocs(slipsQ);
          if (!slipsSnap.empty) {
            // Use the latest slip as ground truth
            const latestSlip = {
              id: slipsSnap.docs[0].id,
              ...slipsSnap.docs[0].data(),
            };
            resolvedReports.push({
              employeeId: latestSlip.employeeId,
              employeeName: latestSlip.employeeName,
              position: user.position || 'Nh√¢n vi√™n',
              attendanceSummary: latestSlip.attendanceSummary,
              calculatedSalary: latestSlip.calculatedSalary,
              source: 'slip',
            });
            continue;
          }

          // 3) If no slip exists, compute from raw data (fallback)
          const attendance = await this.getEmployeeAttendance(
            user.id,
            month,
            year
          );
          const advancePayments = await this.getAdvancePayments(
            user.id,
            month,
            year
          );

          const monthlySalary = Number(user.monthlySalary) || 0;
          const dailySalaryRate = Number(user.dailySalary) || 0;
          const baseSalary =
            monthlySalary > 0 ? monthlySalary : dailySalaryRate * 26;
          const effectiveDays = Number(attendance.effectiveWorkingDays) || 0;
          const baseSalaryForMonth =
            monthlySalary > 0
              ? (monthlySalary / 26) * effectiveDays
              : dailySalaryRate * effectiveDays;

          const hourlyRate =
            baseSalaryForMonth > 0 ? baseSalaryForMonth / 8 : 0;
          const overtimePay = {
            normal:
              (Number(attendance.overtimeHours.normal) || 0) * hourlyRate * 1.5,
            sunday:
              (Number(attendance.overtimeHours.sunday) || 0) * hourlyRate * 1.5,
            holiday:
              (Number(attendance.overtimeHours.holiday) || 0) *
              hourlyRate *
              1.5,
          };
          const totalOvertimePay =
            overtimePay.normal + overtimePay.sunday + overtimePay.holiday;

          const insuranceBase =
            Number(user.insuranceContributionBase) || baseSalary;
          const autoDeductions = await this.getAutoDeductions(insuranceBase);
          const totalAutoDeductions = autoDeductions.reduce(
            (s, d) => s + (Number(d.amount) || 0),
            0
          );
          const totalAdvancePayments = advancePayments.reduce(
            (s, p) => s + (Number(p.amount) || 0),
            0
          );

          const grossSalary = baseSalaryForMonth + totalOvertimePay;
          const totalDeductions = totalAutoDeductions + totalAdvancePayments;
          const netSalary = Math.max(0, grossSalary - totalDeductions);

          resolvedReports.push({
            employeeId: user.id,
            employeeName: user.displayName || user.email || 'Nh√¢n vi√™n',
            position: user.position || 'Nh√¢n vi√™n',
            attendanceSummary: attendance,
            calculatedSalary: {
              baseSalary: baseSalaryForMonth,
              totalOvertimePay,
              grossSalary,
              totalDeductions,
              netSalary,
              autoDeductions,
              advancePayments,
            },
            source: 'computed',
          });
        } catch (e) {
          console.error('Report item error for user', user.id, e);
        }
      }

      // Normalize per-entry totals to avoid mismatch
      const normalizedReports = resolvedReports.map((r) => {
        const gross = Number(r.calculatedSalary?.grossSalary) || 0;
        const net = Number(r.calculatedSalary?.netSalary) || 0;
        let totalDeductions = Number(r.calculatedSalary?.totalDeductions);
        if (
          !Number.isFinite(totalDeductions) ||
          Math.abs(gross - totalDeductions - net) > 1
        ) {
          totalDeductions = Math.max(0, gross - net);
        }
        return {
          ...r,
          calculatedSalary: {
            ...r.calculatedSalary,
            grossSalary: gross,
            netSalary: net,
            totalDeductions,
          },
        };
      });

      // 4) Aggregate totals
      const totalGrossSalary = normalizedReports.reduce(
        (s, r) => s + (r.calculatedSalary?.grossSalary || 0),
        0
      );
      const totalNetSalary = normalizedReports.reduce(
        (s, r) => s + (r.calculatedSalary?.netSalary || 0),
        0
      );
      const totalDeductions = Math.max(0, totalGrossSalary - totalNetSalary);

      const finalReport = {
        month,
        year,
        totalSalarySlips: normalizedReports.length,
        totalGrossSalary,
        totalDeductions,
        totalNetSalary,
        salarySlips: normalizedReports,
        generatedAt: Date.now(),
      };

      // L∆∞u cache ƒë·ªÉ l·∫ßn sau m·ªü ra nhanh
      await this.saveSalaryReportCache(month, year, finalReport);

      return finalReport;
    } catch (error) {
      console.error('L·ªói khi l·∫•y b√°o c√°o t·ªïng l∆∞∆°ng:', error);
      throw error;
    }
  }

  // ===== NHI·ªÜM V·ª§ 2: T√ÅI C·∫§U TR√öC LOGIC BACKEND =====

  /**
   * (VI·∫æT L·∫†I) T·ªïng h·ª£p d·ªØ li·ªáu ch·∫•m c√¥ng v√† ngh·ªâ ph√©p c·ªßa nh√¢n vi√™n trong th√°ng.
   * @param {string} employeeId - ID nh√¢n vi√™n.
   * @param {number} month - Th√°ng (1-12).
   * @param {number} year - NƒÉm.
   * @returns {Promise<Object>} - ƒê·ªëi t∆∞·ª£ng t√≥m t·∫Øt ch·∫•m c√¥ng.
   */
  async getEmployeeAttendance(employeeId, month, year) {
    try {
      const startDate = new Date(year, month - 1, 1);
      const endDate = new Date(year, month, 0);

      // 1. L·∫•y d·ªØ li·ªáu ch·∫•m c√¥ng t·ª´ collection 'attendance'
      const attendanceRef = collection(this.db, 'attendance');
      const attendanceQuery = query(
        attendanceRef,
        where('userId', '==', employeeId),
        where('date', '>=', `${year}-${String(month).padStart(2, '0')}-01`),
        where(
          'date',
          '<=',
          `${year}-${String(month).padStart(2, '0')}-${String(
            endDate.getDate()
          ).padStart(2, '0')}`
        )
      );
      const attendanceSnapshot = await getDocs(attendanceQuery);
      const actualWorkDays = attendanceSnapshot.size;

      // Ph√¢n lo·∫°i gi·ªù tƒÉng ca
      const overtimeHours = { normal: 0, sunday: 0, holiday: 0 };
      // L·∫•y danh s√°ch ng√†y l·ªÖ trong kho·∫£ng th√°ng
      const startDateStr = `${year}-${String(month).padStart(2, '0')}-01`;
      const endDateStr = `${year}-${String(month).padStart(2, '0')}-${String(
        endDate.getDate()
      ).padStart(2, '0')}`;
      const holidaysRef = collection(this.db, 'holidays');
      const holidaysQuery = query(
        holidaysRef,
        where(documentId(), '>=', startDateStr),
        where(documentId(), '<=', endDateStr)
      );
      const holidaysSnap = await getDocs(holidaysQuery);
      const holidays = holidaysSnap.docs.map((d) => d.id);

      // DEBUG rows collector
      const debugRows = [];
      // OT details per day for frontend breakdown
      const overtimeDetails = [];

      const parseHours = (timeStr) => {
        if (!timeStr || typeof timeStr !== 'string') return null;
        const [h, m] = timeStr.split(':').map((x) => parseInt(x, 10));
        if (Number.isNaN(h) || Number.isNaN(m)) return null;
        return h + m / 60;
      };

      // M·ªëc gi·ªù chu·∫©n cho ng√†y th∆∞·ªùng
      const NORMAL_WORK_END = parseHours('17:30'); // 17h30
      const DEFAULT_OT_END = parseHours('20:30'); // 20h30 (m·∫∑c ƒë·ªãnh OT ƒë·∫øn 20:30 => 3 gi·ªù)

      attendanceSnapshot.forEach((docItem) => {
        const data = docItem.data();
        let workDateStr = data.date;
        if (
          !workDateStr &&
          typeof docItem.id === 'string' &&
          docItem.id.includes('_')
        ) {
          const parts = docItem.id.split('_');
          const datePart = parts[1];
          if (datePart && /^\d{4}-\d{2}-\d{2}$/.test(datePart)) {
            workDateStr = datePart;
          }
        }
        if (!workDateStr) return; // kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c ng√†y
        const workDate = new Date(workDateStr);
        const dayOfWeek = workDate.getDay();
        const isHoliday = holidays.includes(workDateStr);

        // T√≠nh s·ªë gi·ªù l√†m vi·ªác trong ng√†y n·∫øu c√≥ clockIn/clockOut, fallback 8 gi·ªù
        const inH = parseHours(data.clockIn);
        const outH = parseHours(data.clockOut);
        let workedHours = 0;
        if (inH !== null && outH !== null && outH > inH) {
          workedHours = outH - inH;
        }

        if (isHoliday) {
          // L√†m v√†o ng√†y l·ªÖ: to√†n b·ªô gi·ªù l√† OT ng√†y l·ªÖ
          overtimeHours.holiday += workedHours > 0 ? workedHours : 8;
          return;
        }

        if (dayOfWeek === 0) {
          // L√†m v√†o Ch·ªß nh·∫≠t: to√†n b·ªô gi·ªù l√† OT ch·ªß nh·∫≠t
          overtimeHours.sunday += workedHours > 0 ? workedHours : 8;
          return;
        }

        // Ng√†y th∆∞·ªùng: n·∫øu c√≥ c·ªù tƒÉng ca th√¨ t√≠nh OT theo m·ªëc 17:30 -> (overtimeEnd | otEndTime | overtimeTo | otTo | default 20:30)
        // L∆ØU √ù: KH√îNG d√πng clockOut ƒë·ªÉ suy ra OT n·∫øu kh√¥ng c√≥ tr∆∞·ªùng OT k·∫øt th√∫c ri√™ng.
        if (data.overtime) {
          // Tr∆∞·ªùng h·ª£p t∆∞∆°ng th√≠ch c≈©: n·∫øu overtime l√† s·ªë, hi·ªÉu l√† s·ªë gi·ªù OT nh·∫≠p tay
          const explicitOt =
            typeof data.overtime === 'number' ? data.overtime : null;

          if (explicitOt && explicitOt > 0) {
            overtimeHours.normal += explicitOt;
            overtimeDetails.push({
              date: workDateStr,
              type: 'weekday',
              hours: explicitOt,
              source: 'explicit',
            });
          } else {
            // ∆Øu ti√™n gi·ªù k·∫øt th√∫c OT theo c√°c tr∆∞·ªùng ri√™ng; n·∫øu kh√¥ng c√≥, m·∫∑c ƒë·ªãnh 20:30
            const otEndCandidates = [
              data.overtimeEnd,
              data.otEndTime,
              data.overtimeTo,
              data.otTo,
            ]
              .map((t) => parseHours(t))
              .filter((v) => v !== null);
            const endH =
              otEndCandidates.length > 0 ? otEndCandidates[0] : DEFAULT_OT_END;
            const startH = NORMAL_WORK_END; // OT b·∫Øt ƒë·∫ßu t·ª´ 17:30
            const computedOt = Math.max(0, endH - startH);
            const finalOt = computedOt > 0 ? computedOt : 3; // fallback: 3 gi·ªù n·∫øu kh√¥ng ƒë·ªß d·ªØ li·ªáu

            overtimeHours.normal += finalOt;
            overtimeDetails.push({
              date: workDateStr,
              type: 'weekday',
              hours: finalOt,
              start: '17:30',
              end:
                otEndCandidates.length > 0
                  ? data.overtimeEnd ||
                    data.otEndTime ||
                    data.overtimeTo ||
                    data.otTo
                  : '20:30',
              source: otEndCandidates.length > 0 ? 'endField' : 'default2030',
            });
          }
        }
      });

      // 2. L·∫•y d·ªØ li·ªáu ngh·ªâ ph√©p ƒë√£ ƒë∆∞·ª£c duy·ªát t·ª´ collection 'leaveRequests'
      const leaveRef = collection(this.db, 'leaveRequests');
      const leaveQuery = query(
        leaveRef,
        where('userId', '==', employeeId),
        where('status', '==', 'approved'),
        where('leaveType', '==', 'paid') // Ch·ªâ t√≠nh ngh·ªâ ph√©p c√≥ l∆∞∆°ng
      );
      const leaveSnapshot = await getDocs(leaveQuery);

      let paidLeaveDays = 0;
      leaveSnapshot.forEach((doc) => {
        const leave = doc.data();
        const leaveStart = leave.startDate.toDate();
        const leaveEnd = leave.endDate.toDate();

        // T√≠nh s·ªë ng√†y ngh·ªâ ph√©p trong th√°ng ƒëang x√©t
        for (
          let d = new Date(leaveStart);
          d <= leaveEnd;
          d.setDate(d.getDate() + 1)
        ) {
          if (d.getFullYear() === year && d.getMonth() === month - 1) {
            paidLeaveDays++;
          }
        }
      });

      // DEBUG: in ra c√°ch c·ªông d·ªìn OT theo t·ª´ng ng√†y
      try {
        console.log('DEBUG OT MONTH', {
          employeeId,
          month,
          year,
          actualWorkDays,
          paidLeaveDays,
          overtimeHours,
          rows: debugRows,
        });
      } catch (e) {
        // ignore logging errors
      }

      // T√≠nh s·ªë ng√†y c√¥ng hi·ªáu qu·∫£ (ng√†y c√¥ng th·ª±c t·∫ø + ngh·ªâ ph√©p)
      const effectiveWorkingDays = actualWorkDays + paidLeaveDays;

      return {
        actualWorkDays,
        paidLeaveDays,
        effectiveWorkingDays,
        overtimeHours,
        overtimeDetails,
      };
    } catch (error) {
      console.error('L·ªói khi t·ªïng h·ª£p d·ªØ li·ªáu ch·∫•m c√¥ng:', error);
      throw error;
    }
  }

  /**
   * (VI·∫æT L·∫†I) T√≠nh c√°c kho·∫£n kh·∫•u tr·ª´ t·ª± ƒë·ªông (BHXH, BHYT, BHTN).
   * @param {number} insuranceContributionBase - L∆∞∆°ng ƒë√≥ng BHXH c·ªë ƒë·ªãnh.
   * @returns {Promise<Array>} - Danh s√°ch c√°c kho·∫£n kh·∫•u tr·ª´ t·ª± ƒë·ªông.
   */
  async getAutoDeductions(insuranceContributionBase) {
    if (insuranceContributionBase <= 0) {
      return [];
    }
    // C√°c t·ª∑ l·ªá n√†y c√≥ th·ªÉ ƒë∆∞·ª£c chuy·ªÉn v√†o 'settings' collection ƒë·ªÉ linh ho·∫°t h∆°n
    const deductionsConfig = [
      { name: 'B·∫£o hi·ªÉm x√£ h·ªôi (8%)', rate: 0.08 },
      { name: 'B·∫£o hi·ªÉm y t·∫ø (1.5%)', rate: 0.015 },
      { name: 'B·∫£o hi·ªÉm th·∫•t nghi·ªáp (1%)', rate: 0.01 },
    ];

    return deductionsConfig.map((config) => ({
      name: config.name,
      amount: Math.round(insuranceContributionBase * config.rate),
      isAuto: true,
    }));
  }

  /**
   * (VI·∫æT L·∫†I) Th·ª±c hi·ªán to√†n b·ªô logic t√≠nh to√°n l∆∞∆°ng chi ti·∫øt.
   * @param {Object} employeeInfo - Th√¥ng tin nh√¢n vi√™n (l∆∞∆°ng th√°ng, etc.).
   * @param {Object} attendanceSummary - T√≥m t·∫Øt ch·∫•m c√¥ng t·ª´ getEmployeeAttendance.
   * @param {Object} systemSettings - C·∫•u h√¨nh h·ªá th·ªëng (ng√†y c√¥ng chu·∫©n, h·ªá s·ªë OT).
   * @param {Object} manualInputs - C√°c kho·∫£n nh·∫≠p tay (ph·ª• c·∫•p, th∆∞·ªüng, kh·∫•u tr·ª´ kh√°c).
   * @returns {Object} - K·∫øt qu·∫£ t√≠nh l∆∞∆°ng chi ti·∫øt.
   */
  calculateSalary(
    employeeInfo,
    attendanceSummary,
    systemSettings,
    manualInputs
  ) {
    const { monthlySalary, dailySalary, salaryType } = employeeInfo;
    const { actualWorkDays, paidLeaveDays, overtimeHours } = attendanceSummary;
    const { standardWorkingDays, overtimeMultipliers } = systemSettings;
    const {
      allowances = [],
      bonuses = [],
      deductions = [],
      advancePayments = [],
    } = manualInputs;

    // 1. T√≠nh ng√†y c√¥ng hi·ªáu l·ª±c
    const effectiveWorkingDays = actualWorkDays + paidLeaveDays;

    // 2. T√≠nh l∆∞∆°ng c∆° b·∫£n theo lo·∫°i l∆∞∆°ng
    let baseSalary = 0;
    let hourlyRate = 0;
    if (salaryType === 'daily') {
      baseSalary = (dailySalary || 0) * effectiveWorkingDays;
      hourlyRate = (dailySalary || 0) / 8;
    } else {
      baseSalary = (monthlySalary / standardWorkingDays) * effectiveWorkingDays;
      hourlyRate = monthlySalary / standardWorkingDays / 8;
    }

    // 3. T√≠nh l∆∞∆°ng tƒÉng ca
    const mNormal = overtimeMultipliers?.normal ?? 1.5;
    const mSunday = mNormal; // Ch·ªß nh·∫≠t c√πng ƒë∆°n gi√° OT nh∆∞ ng√†y th∆∞·ªùng
    const mHoliday = overtimeMultipliers?.holiday ?? 3.0;

    const overtimeHourlyRate = {
      normal: hourlyRate * mNormal,
      sunday: hourlyRate * mSunday,
      holiday: hourlyRate * mHoliday,
    };

    const overtimePay = {
      normal: overtimeHourlyRate.normal * (overtimeHours.normal || 0),
      sunday: overtimeHourlyRate.sunday * (overtimeHours.sunday || 0),
      holiday: overtimeHourlyRate.holiday * (overtimeHours.holiday || 0),
    };
    const totalOvertimePay =
      (overtimePay.normal || 0) +
      (overtimePay.sunday || 0) +
      (overtimePay.holiday || 0);

    // 4. T√≠nh t·ªïng thu nh·∫≠p (Gross)
    const totalAllowances = allowances.reduce(
      (sum, item) => sum + item.amount,
      0
    );
    const totalBonuses = bonuses.reduce((sum, item) => sum + item.amount, 0);
    const grossSalary =
      baseSalary + totalOvertimePay + totalAllowances + totalBonuses;

    // 5. T√≠nh t·ªïng kh·∫•u tr·ª´ v√† l∆∞∆°ng Net
    const totalManualDeductions = deductions.reduce(
      (sum, item) => sum + item.amount,
      0
    );
    const totalAdvancePayments = advancePayments.reduce(
      (sum, item) => sum + item.amount,
      0
    );
    // C√°c kho·∫£n kh·∫•u tr·ª´ t·ª± ƒë·ªông (BHXH...) s·∫Ω ƒë∆∞·ª£c th√™m v√†o sau
    const totalDeductionsBeforeInsurance =
      totalManualDeductions + totalAdvancePayments;
    const netSalaryBeforeInsurance =
      grossSalary - totalDeductionsBeforeInsurance;

    return {
      // Inputs & Base Info
      monthlySalary,
      standardWorkingDays,
      hourlyRate: Math.round(hourlyRate),

      // Attendance & Prorated Salary
      attendanceSummary,
      effectiveWorkingDays,
      baseSalary: Math.round(baseSalary),

      // Overtime
      overtimeMultipliers,
      overtimeHourlyRate: {
        normal: Math.round(overtimeHourlyRate.normal),
        sunday: Math.round(overtimeHourlyRate.sunday),
        holiday: Math.round(overtimeHourlyRate.holiday),
      },
      overtimePay: {
        normal: Math.round(overtimePay.normal),
        sunday: Math.round(overtimePay.sunday),
        holiday: Math.round(overtimePay.holiday),
      },
      totalOvertimePay: Math.round(totalOvertimePay),

      // Incomes
      allowances,
      totalAllowances: Math.round(totalAllowances),
      bonuses,
      totalBonuses: Math.round(totalBonuses),
      grossSalary: Math.round(grossSalary),

      // Deductions
      manualDeductions: deductions,
      totalManualDeductions: Math.round(totalManualDeductions),
      advancePayments,
      totalAdvancePayments: Math.round(totalAdvancePayments),

      // Summary (t·∫°m th·ªùi, s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t l·∫°i sau khi c√≥ BHXH)
      netSalaryBeforeInsurance: Math.round(netSalaryBeforeInsurance),
    };
  }

  /**
   * (VI·∫æT L·∫†I) H√†m ƒëi·ªÅu ph·ªëi ch√≠nh, t·∫°o phi·∫øu l∆∞∆°ng t·ª± ƒë·ªông.
   * @param {Object} data - D·ªØ li·ªáu ƒë·∫ßu v√†o t·ª´ client (employeeId, month, year, manual inputs).
   * @returns {Promise<Object>} - Phi·∫øu l∆∞∆°ng ƒë√£ t·∫°o.
   */
  async createSalarySlipAuto(data) {
    const {
      employeeId,
      month,
      year,
      allowances = [],
      bonuses = [],
      deductions = [],
      notes = '',
    } = data;

    if (!employeeId || !month || !year) {
      throw new Error('Th√¥ng tin nh√¢n vi√™n, th√°ng, nƒÉm l√† b·∫Øt bu·ªôc.');
    }

    // S·ª≠ d·ª•ng transaction ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh to√†n v·∫πn d·ªØ li·ªáu (c·∫≠p nh·∫≠t ph√©p nƒÉm)
    return await runTransaction(this.db, async (transaction) => {
      // 1. L·∫•y c·∫•u h√¨nh, th√¥ng tin nh√¢n vi√™n, ch·∫•m c√¥ng, v√† ·ª©ng l∆∞∆°ng
      const systemSettings = await this.getSystemSettings();
      const employeeInfo = await this.getEmployeeDetails(employeeId);
      const attendanceSummary = await this.getEmployeeAttendance(
        employeeId,
        month,
        year
      );
      const advancePayments = await this.getAdvancePayments(
        employeeId,
        month,
        year
      );

      // 2. T√≠nh c√°c kho·∫£n kh·∫•u tr·ª´ BHXH d·ª±a tr√™n insuranceContributionBase
      const autoDeductions = await this.getAutoDeductions(
        employeeInfo.insuranceContributionBase
      );

      // 3. G·ªçi h√†m t√≠nh l∆∞∆°ng v·ªõi t·∫•t c·∫£ d·ªØ li·ªáu ƒë√£ thu th·∫≠p
      const calculatedSalary = this.calculateSalary(
        employeeInfo,
        attendanceSummary,
        systemSettings,
        { allowances, bonuses, deductions, advancePayments }
      );

      // 4. Ho√†n thi·ªán t√≠nh to√°n t·ªïng kh·∫•u tr·ª´ v√† l∆∞∆°ng th·ª±c nh·∫≠n
      const totalAutoDeductions = autoDeductions.reduce(
        (sum, item) => sum + item.amount,
        0
      );
      const totalDeductions =
        calculatedSalary.totalManualDeductions +
        calculatedSalary.totalAdvancePayments +
        totalAutoDeductions;
      const netSalary = calculatedSalary.grossSalary - totalDeductions;

      // Lo·∫°i b·ªè tr∆∞·ªùng t·∫°m th·ªùi kh·ªèi calculatedSalary tr∆∞·ªõc khi l∆∞u
      const { netSalaryBeforeInsurance, ...finalCalculatedFields } =
        calculatedSalary;

      // 5. Chu·∫©n b·ªã d·ªØ li·ªáu ƒë·ªÉ l∆∞u v√†o Firestore
      const finalSalarySlip = {
        // Metadata
        employeeId,
        employeeName: employeeInfo.displayName || employeeInfo.name,
        month: parseInt(month),
        year: parseInt(year),
        createdAt: serverTimestamp(),
        status: 'pending', // 'pending', 'approved', 'paid'
        notes,

        // Input Data
        employeeInfo: {
          salaryType:
            employeeInfo.salaryType ||
            (employeeInfo.monthlySalary ? 'monthly' : 'daily'),
          dailySalary: employeeInfo.dailySalary || 0,
          monthlySalary: employeeInfo.monthlySalary || 0,
          insuranceContributionBase:
            employeeInfo.insuranceContributionBase || 0,
        },
        manualInputs: {
          allowances,
          bonuses,
          manualDeductions: deductions,
          advancePayments,
        },

        // Calculated Data
        attendanceSummary,
        calculatedSalary: {
          ...finalCalculatedFields,
          autoDeductions,
          totalAutoDeductions: Math.round(totalAutoDeductions),
          totalDeductions: Math.round(totalDeductions),
          netSalary: Math.round(netSalary),
        },
      };

      // 6. L∆∞u phi·∫øu l∆∞∆°ng v√†o collection 'salarySlips'
      const newSlipRef = doc(collection(this.db, 'salarySlips'));
      transaction.set(newSlipRef, finalSalarySlip);

      // 7. C·∫≠p nh·∫≠t l·∫°i s·ªë ph√©p nƒÉm c·ªßa nh√¢n vi√™n
      const paidLeaveDaysInMonth = attendanceSummary.paidLeaveDays;
      if (paidLeaveDaysInMonth > 0) {
        const userRef = doc(this.db, 'users', employeeId);
        const newBalance =
          (employeeInfo.annualLeaveBalance || 0) - paidLeaveDaysInMonth;
        transaction.update(userRef, { annualLeaveBalance: newBalance });
      }

      return { id: newSlipRef.id, ...finalSalarySlip };
    });
  }

  /**
   * L·∫•y danh s√°ch phi·∫øu l∆∞∆°ng (c√≥ th·ªÉ l·ªçc).
   * @param {Object} filters - B·ªô l·ªçc (month, year, employeeId, status).
   * @returns {Promise<Array>} - Danh s√°ch phi·∫øu l∆∞∆°ng.
   */
  async getSalarySlips(filters = {}) {
    try {
      const { month, year, employeeId, status } = filters;
      let q = query(
        collection(this.db, 'salarySlips'),
        orderBy('createdAt', 'desc')
      );

      if (month) q = query(q, where('month', '==', parseInt(month)));
      if (year) q = query(q, where('year', '==', parseInt(year)));
      if (employeeId) q = query(q, where('employeeId', '==', employeeId));
      if (status) q = query(q, where('status', '==', status));

      const querySnapshot = await getDocs(q);
      return querySnapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
    } catch (error) {
      console.error('L·ªói khi l·∫•y danh s√°ch phi·∫øu l∆∞∆°ng:', error);
      throw error;
    }
  }
}

export default new SalaryService();


--- END: src\api\salaryService.js ---


--- START: src\api\supplierService.js ---
// src/api/supplierService.js
import { db } from '../config/firebaseConfig';
import {
  collection,
  doc,
  getDoc,
  getDocs,
  addDoc,
  updateDoc,
  deleteDoc,
  query,
  orderBy,
  where,
  serverTimestamp,
} from 'firebase/firestore';

// L·∫•y danh s√°ch t·∫•t c·∫£ nh√† cung c·∫•p
export const getAllSuppliers = async () => {
  try {
    const suppliersRef = collection(db, 'suppliers');
    const q = query(suppliersRef, orderBy('name', 'asc'));
    const querySnapshot = await getDocs(q);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    console.error('L·ªói khi l·∫•y danh s√°ch nh√† cung c·∫•p:', error);
    throw error;
  }
};

// L·∫•y th√¥ng tin chi ti·∫øt c·ªßa m·ªôt nh√† cung c·∫•p
export const getSupplierById = async (supplierId) => {
  try {
    const supplierRef = doc(db, 'suppliers', supplierId);
    const supplierDoc = await getDoc(supplierRef);

    if (supplierDoc.exists()) {
      return {
        id: supplierDoc.id,
        ...supplierDoc.data(),
      };
    } else {
      throw new Error('Kh√¥ng t√¨m th·∫•y nh√† cung c·∫•p');
    }
  } catch (error) {
    console.error('L·ªói khi l·∫•y th√¥ng tin nh√† cung c·∫•p:', error);
    throw error;
  }
};

// Th√™m nh√† cung c·∫•p m·ªõi
export const addSupplier = async (supplierData) => {
  try {
    const suppliersRef = collection(db, 'suppliers');

    // Th√™m timestamp
    const supplierWithTimestamp = {
      ...supplierData,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
    };

    const docRef = await addDoc(suppliersRef, supplierWithTimestamp);
    return {
      id: docRef.id,
      ...supplierWithTimestamp,
    };
  } catch (error) {
    console.error('L·ªói khi th√™m nh√† cung c·∫•p:', error);
    throw error;
  }
};

// C·∫≠p nh·∫≠t th√¥ng tin nh√† cung c·∫•p
export const updateSupplier = async (supplierId, supplierData) => {
  try {
    const supplierRef = doc(db, 'suppliers', supplierId);

    // Lo·∫°i b·ªè c√°c field c√≥ gi√° tr·ªã undefined ƒë·ªÉ tr√°nh l·ªói Firestore
    const cleanData = Object.fromEntries(
      Object.entries(supplierData).filter(([_, value]) => value !== undefined)
    );

    // Th√™m timestamp c·∫≠p nh·∫≠t
    const updatedData = {
      ...cleanData,
      updatedAt: serverTimestamp(),
    };

    await updateDoc(supplierRef, updatedData);
    return {
      id: supplierId,
      ...updatedData,
    };
  } catch (error) {
    console.error('L·ªói khi c·∫≠p nh·∫≠t nh√† cung c·∫•p:', error);
    throw error;
  }
};

// X√≥a nh√† cung c·∫•p
export const deleteSupplier = async (supplierId) => {
  try {
    const supplierRef = doc(db, 'suppliers', supplierId);
    await deleteDoc(supplierRef);
    return true;
  } catch (error) {
    console.error('L·ªói khi x√≥a nh√† cung c·∫•p:', error);
    throw error;
  }
};

// T√¨m ki·∫øm nh√† cung c·∫•p theo t√™n
export const searchSuppliers = async (searchTerm) => {
  try {
    // L∆∞u √Ω: Firestore kh√¥ng h·ªó tr·ª£ t√¨m ki·∫øm full-text
    // ƒê√¢y l√† c√°ch ƒë∆°n gi·∫£n ƒë·ªÉ t√¨m ki·∫øm, c√≥ th·ªÉ c·∫ßn c·∫£i ti·∫øn sau
    const suppliersRef = collection(db, 'suppliers');
    const q = query(suppliersRef, orderBy('name'));
    const querySnapshot = await getDocs(q);

    const searchTermLower = searchTerm.toLowerCase();
    return querySnapshot.docs
      .map((doc) => ({ id: doc.id, ...doc.data() }))
      .filter(
        (supplier) =>
          supplier.name.toLowerCase().includes(searchTermLower) ||
          (supplier.contactName &&
            supplier.contactName.toLowerCase().includes(searchTermLower)) ||
          (supplier.phone && supplier.phone.includes(searchTerm))
      );
  } catch (error) {
    console.error('L·ªói khi t√¨m ki·∫øm nh√† cung c·∫•p:', error);
    throw error;
  }
};

// L·∫•y danh s√°ch nh√† cung c·∫•p theo danh m·ª•c v·∫≠t t∆∞
export const getSuppliersByCategory = async (category) => {
  try {
    const suppliersRef = collection(db, 'suppliers');
    const q = query(
      suppliersRef,
      where('categories', 'array-contains', category)
    );
    const querySnapshot = await getDocs(q);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    console.error('L·ªói khi l·∫•y nh√† cung c·∫•p theo danh m·ª•c:', error);
    throw error;
  }
};

// Th√™m ƒë√°nh gi√° cho nh√† cung c·∫•p
export const addSupplierRating = async (supplierId, ratingData) => {
  try {
    const supplierRef = doc(db, 'suppliers', supplierId);
    const supplierDoc = await getDoc(supplierRef);

    if (!supplierDoc.exists()) {
      throw new Error('Kh√¥ng t√¨m th·∫•y nh√† cung c·∫•p');
    }

    const supplierData = supplierDoc.data();
    const ratings = supplierData.ratings || [];

    // Th√™m ƒë√°nh gi√° m·ªõi v·ªõi timestamp
    const newRating = {
      ...ratingData,
      createdAt: serverTimestamp(),
    };

    ratings.push(newRating);

    // T√≠nh l·∫°i ƒëi·ªÉm ƒë√°nh gi√° trung b√¨nh
    const totalRating = ratings.reduce((sum, r) => sum + r.rating, 0);
    const averageRating = totalRating / ratings.length;

    await updateDoc(supplierRef, {
      ratings,
      averageRating,
      updatedAt: serverTimestamp(),
    });

    return {
      ratings,
      averageRating,
    };
  } catch (error) {
    console.error('L·ªói khi th√™m ƒë√°nh gi√° nh√† cung c·∫•p:', error);
    throw error;
  }
};


--- END: src\api\supplierService.js ---


--- START: src\api\userService.js ---
// src/api/userService.js
import {
  collection,
  addDoc,
  updateDoc,
  deleteDoc,
  doc,
  query,
  orderBy,
  getDocs,
  getDoc,
  where,
  serverTimestamp,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';

/**
 * L·∫•y t·∫•t c·∫£ ng∆∞·ªùi d√πng
 * @returns {Promise<Array>} - M·∫£ng ng∆∞·ªùi d√πng
 */
export const getUsers = async () => {
  try {
    const usersRef = collection(db, 'users');
    const q = query(usersRef, orderBy('createdAt', 'desc'));
    const querySnapshot = await getDocs(q);

    const users = querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));

    return users;
  } catch (error) {
    console.error('Error getting users:', error);
    throw error;
  }
};

/**
 * L·∫•y ng∆∞·ªùi d√πng theo ID
 * @param {string} userId - ID ng∆∞·ªùi d√πng
 * @returns {Promise<Object|null>} - D·ªØ li·ªáu ng∆∞·ªùi d√πng ho·∫∑c null n·∫øu kh√¥ng t√¨m th·∫•y
 */
export const getUserById = async (userId) => {
  try {
    const userRef = doc(db, 'users', userId);
    const userSnapshot = await getDoc(userRef);

    if (userSnapshot.exists()) {
      return {
        id: userSnapshot.id,
        ...userSnapshot.data(),
      };
    } else {
      return null;
    }
  } catch (error) {
    console.error('Error getting user by ID:', error);
    throw error;
  }
};

/**
 * L·∫•y ng∆∞·ªùi d√πng theo role
 * @param {string} role - Role c·ªßa ng∆∞·ªùi d√πng (worker, manager, admin, etc.)
 * @returns {Promise<Array>} - M·∫£ng ng∆∞·ªùi d√πng thu·ªôc role ƒë√£ ch·ªâ ƒë·ªãnh
 */
export const getUsersByRole = async (role) => {
  try {
    const usersRef = collection(db, 'users');
    const q = query(
      usersRef,
      where('role', '==', role),
      orderBy('createdAt', 'desc')
    );

    const querySnapshot = await getDocs(q);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    console.error('Error getting users by role:', error);
    throw error;
  }
};

/**
 * T·∫°o ng∆∞·ªùi d√πng m·ªõi
 * @param {Object} userData - D·ªØ li·ªáu ng∆∞·ªùi d√πng
 * @returns {Promise<string>} - ID c·ªßa ng∆∞·ªùi d√πng ƒë√£ t·∫°o
 */
export const createUser = async (userData) => {
  try {
    const docRef = await addDoc(collection(db, 'users'), {
      ...userData,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
    });

    return docRef.id;
  } catch (error) {
    console.error('Error creating user:', error);
    throw error;
  }
};

/**
 * C·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng
 * @param {string} userId - ID ng∆∞·ªùi d√πng
 * @param {Object} userData - D·ªØ li·ªáu ng∆∞·ªùi d√πng c·∫≠p nh·∫≠t
 * @returns {Promise<void>}
 */
export const updateUser = async (userId, userData) => {
  try {
    // Lo·∫°i b·ªè c√°c field c√≥ gi√° tr·ªã undefined ƒë·ªÉ tr√°nh l·ªói Firestore
    const cleanData = Object.fromEntries(
      Object.entries(userData).filter(([_, value]) => value !== undefined)
    );

    const userRef = doc(db, 'users', userId);
    await updateDoc(userRef, {
      ...cleanData,
      updatedAt: serverTimestamp(),
    });
  } catch (error) {
    console.error('Error updating user:', error);
    throw error;
  }
};

/**
 * X√≥a ng∆∞·ªùi d√πng
 * @param {string} userId - ID ng∆∞·ªùi d√πng
 * @returns {Promise<void>}
 */
export const deleteUser = async (userId) => {
  try {
    const userRef = doc(db, 'users', userId);
    await deleteDoc(userRef);
  } catch (error) {
    console.error('Error deleting user:', error);
    throw error;
  }
};

/**
 * L·∫•y danh s√°ch workers (ng∆∞·ªùi l√†m vi·ªác)
 * @returns {Promise<Array>} - M·∫£ng workers
 */
export const getWorkers = async () => {
  try {
    return await getUsersByRole('worker');
  } catch (error) {
    console.error('Error getting workers:', error);
    throw error;
  }
};

/**
 * T√¨m ki·∫øm ng∆∞·ªùi d√πng theo t√™n
 * @param {string} searchTerm - T·ª´ kh√≥a t√¨m ki·∫øm
 * @returns {Promise<Array>} - M·∫£ng ng∆∞·ªùi d√πng ph√π h·ª£p
 */
export const searchUsers = async (searchTerm) => {
  try {
    const usersRef = collection(db, 'users');
    const nameQuery = query(
      usersRef,
      where('name', '>=', searchTerm),
      where('name', '<=', searchTerm + '\uf8ff')
    );

    const querySnapshot = await getDocs(nameQuery);

    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
  } catch (error) {
    console.error('Error searching users:', error);
    throw error;
  }
};

export default {
  getUsers,
  getUserById,
  getUsersByRole,
  createUser,
  updateUser,
  deleteUser,
  getWorkers,
  searchUsers,
};


--- END: src\api\userService.js ---


--- START: src\components\AIChatComponent.js ---
import React, { useState, useRef, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  FlatList,
  StyleSheet,
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Image,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import * as DocumentPicker from 'expo-document-picker';
import * as ImagePicker from 'expo-image-picker';
import { useAIChat } from '../contexts/AIChatContext';
import { askAboutProject, askGeneralQuestion } from '../api/aiChatService';

const AIChatComponent = ({
  project = null,
  style = {},
  initialQuestion = null,
  navigation = null,
}) => {
  const [inputText, setInputText] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const [typingText, setTypingText] = useState('');
  const [typingSpeed, setTypingSpeed] = useState(30); // T·ªëc ƒë·ªô typing (ms)
  const typingIntervalRef = useRef(null);
  const [attachments, setAttachments] = useState([]);
  const [showAttachmentOptions, setShowAttachmentOptions] = useState(false);
  const flatListRef = useRef(null);

  const {
    messages,
    addMessage,
    updateMessageStatus,
    setCurrentProject,
    clearChat,
    isLoading,
    error,
    chatMode,
    markMessageAsRead,
  } = useAIChat();

  // Set current project when component mounts or project changes
  useEffect(() => {
    if (project) {
      setCurrentProject(project);
    }
  }, [project]);

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    if (messages.length > 0 && flatListRef.current) {
      setTimeout(() => {
        flatListRef.current?.scrollToEnd({ animated: true });
      }, 100);
    }
  }, [messages]);

  // Mark messages as read when user views them
  useEffect(() => {
    if (messages.length > 0) {
      markMessageAsRead();
    }
  }, [messages]);

  // Handle initial question if provided
  useEffect(() => {
    if (initialQuestion && messages.length === 0) {
      // Auto-send initial question after a short delay
      setTimeout(() => {
        handleSendInitialQuestion(initialQuestion);
      }, 500);
    }
  }, [initialQuestion, messages.length]);

  // Cleanup typing interval on unmount
  useEffect(() => {
    return () => {
      if (typingIntervalRef.current) {
        clearInterval(typingIntervalRef.current);
        typingIntervalRef.current = null;
      }
    };
  }, []);

  // Request permissions for image picker
  useEffect(() => {
    (async () => {
      const { status } =
        await ImagePicker.requestMediaLibraryPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert(
          'Quy·ªÅn truy c·∫≠p',
          'C·∫ßn quy·ªÅn truy c·∫≠p th∆∞ vi·ªán ·∫£nh ƒë·ªÉ ch·ªçn ·∫£nh'
        );
      }
    })();
  }, []);

  const handleSendInitialQuestion = async (question) => {
    if (!question.trim() || isTyping) return;

    const userMessage = {
      role: 'user',
      content: question.trim(),
      type: 'user',
    };

    // Add user message to chat
    const addedMessage = addMessage(userMessage, project?.id);

    try {
      let response;

      if (project) {
        // Ask about specific project
        response = await askAboutProject(question.trim(), project, messages);
      } else {
        // Ask general question
        response = await askGeneralQuestion(question.trim(), messages);
      }

      if (response.success) {
        // Start typing effect - message will be added automatically when typing completes
        startTypingEffect(response.message);
        updateMessageStatus(addedMessage.id, 'delivered');
      } else {
        // Handle error
        updateMessageStatus(addedMessage.id, 'error');
        Alert.alert(
          'L·ªói',
          response.message || 'C√≥ l·ªói x·∫£y ra khi g·ª≠i tin nh·∫Øn'
        );
      }
    } catch (error) {
      console.error('Error sending initial question:', error);
      updateMessageStatus(addedMessage.id, 'error');
      Alert.alert('L·ªói', 'C√≥ l·ªói x·∫£y ra khi g·ª≠i tin nh·∫Øn');
    }
  };

  // Handle image selection
  const handleImagePicker = async () => {
    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        aspect: [4, 3],
        quality: 0.8,
      });

      if (!result.canceled && result.assets[0]) {
        const newAttachment = {
          id: Date.now().toString(),
          type: 'image',
          uri: result.assets[0].uri,
          name: `image_${Date.now()}.jpg`,
          size: result.assets[0].fileSize || 0,
        };
        setAttachments([...attachments, newAttachment]);
        setShowAttachmentOptions(false);
      }
    } catch (error) {
      console.error('Error picking image:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ch·ªçn ·∫£nh');
    }
  };

  // Handle document selection
  const handleDocumentPicker = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: '*/*',
        copyToCacheDirectory: true,
      });

      if (!result.canceled && result.assets[0]) {
        const newAttachment = {
          id: Date.now().toString(),
          type: 'document',
          uri: result.assets[0].uri,
          name: result.assets[0].name,
          size: result.assets[0].size || 0,
        };
        setAttachments([...attachments, newAttachment]);
        setShowAttachmentOptions(false);
      }
    } catch (error) {
      console.error('Error picking document:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ch·ªçn t√†i li·ªáu');
    }
  };

  // Remove attachment
  const removeAttachment = (attachmentId) => {
    setAttachments(attachments.filter((att) => att.id !== attachmentId));
  };

  // Clear all attachments
  const clearAttachments = () => {
    setAttachments([]);
  };

  const handleSendMessage = async () => {
    if ((!inputText.trim() && attachments.length === 0) || isTyping) return;

    const userMessage = {
      role: 'user',
      content: inputText.trim() || 'ƒê√£ g·ª≠i file ƒë√≠nh k√®m',
      type: 'user',
      attachments: attachments.length > 0 ? [...attachments] : undefined,
    };

    // Add user message to chat
    const addedMessage = addMessage(userMessage, project?.id);
    setInputText('');
    clearAttachments(); // Clear attachments after sending

    try {
      let response;

      if (project) {
        // Ask about specific project
        response = await askAboutProject(
          inputText.trim(),
          project,
          messages,
          attachments
        );
      } else {
        // Ask general question
        response = await askGeneralQuestion(
          inputText.trim(),
          messages,
          attachments
        );
      }

      if (response.success) {
        // Start typing effect - message will be added automatically when typing completes
        startTypingEffect(response.message);
        updateMessageStatus(addedMessage.id, 'delivered');
      } else {
        // Handle error
        const errorMessage = {
          role: 'assistant',
          content: `‚ùå ${response.message}`,
          type: 'error',
        };

        addMessage(errorMessage, project?.id);
        updateMessageStatus(addedMessage.id, 'error');
      }
    } catch (error) {
      console.error('Error sending message:', error);

      const errorMessage = {
        role: 'assistant',
        content: '‚ùå C√≥ l·ªói x·∫£y ra khi g·ª≠i tin nh·∫Øn. Vui l√≤ng th·ª≠ l·∫°i.',
        type: 'error',
      };

      addMessage(errorMessage, project?.id);
      updateMessageStatus(addedMessage.id, 'error');
    }
  };

  const renderSuggestedQuestions = () => {
    // B·ªè c√¢u h·ªèi g·ª£i √Ω t·ª± ƒë·ªông
    return null;
  };

  // H√†m x·ª≠ l√Ω text markdown
  const renderMarkdownText = (text) => {
    if (!text) return null;

    // X·ª≠ l√Ω bold text v·ªõi **
    const parts = text.split(/(\*\*.*?\*\*)/g);

    return parts.map((part, index) => {
      if (part.startsWith('**') && part.endsWith('**')) {
        // Text bold
        const boldText = part.slice(2, -2);
        return (
          <Text key={index} style={[styles.messageText, styles.boldText]}>
            {boldText}
          </Text>
        );
      } else if (part.trim()) {
        // Text th∆∞·ªùng
        return (
          <Text key={index} style={styles.messageText}>
            {part}
          </Text>
        );
      }
      return null;
    });
  };

  // H√†m t·∫°o typing effect
  const startTypingEffect = (fullText) => {
    setTypingText('');
    setIsTyping(true);

    let currentIndex = 0;
    if (typingIntervalRef.current) {
      clearInterval(typingIntervalRef.current);
    }
    const interval = setInterval(() => {
      if (currentIndex < fullText.length) {
        setTypingText(fullText.substring(0, currentIndex + 1));
        currentIndex++;

        // Auto-scroll to bottom when typing
        if (flatListRef.current) {
          setTimeout(() => {
            flatListRef.current?.scrollToEnd({ animated: true });
          }, 50);
        }
      } else {
        clearInterval(interval);
        typingIntervalRef.current = null;

        // Add AI message to chat after typing is complete
        const aiMessage = {
          role: 'assistant',
          content: fullText,
          type: 'ai',
        };
        addMessage(aiMessage, project?.id);

        // Reset typing state
        setIsTyping(false);
        setTypingText('');
      }
    }, typingSpeed);
    typingIntervalRef.current = interval;
  };

  const renderMessage = ({ item }) => {
    const isUser = item.role === 'user';
    const isError = item.type === 'error';

    return (
      <View
        style={[
          styles.messageContainer,
          isUser ? styles.userMessage : styles.aiMessage,
          isError && styles.errorMessage,
        ]}
      >
        <View
          style={[
            styles.messageBubble,
            isUser ? styles.userBubble : styles.aiBubble,
            isError && styles.errorBubble,
          ]}
        >
          {isUser ? (
            <Text
              style={[
                styles.messageText,
                styles.userText,
                isError && styles.errorText,
              ]}
            >
              {item.content}
            </Text>
          ) : (
            <View style={styles.aiMessageContent}>
              {renderMarkdownText(item.content)}
            </View>
          )}

          {/* Render attachments if any */}
          {item.attachments && item.attachments.length > 0 && (
            <View style={styles.attachmentsInMessage}>
              {item.attachments.map((attachment) => (
                <View key={attachment.id} style={styles.attachmentInMessage}>
                  {attachment.type === 'image' ? (
                    <Image
                      source={{ uri: attachment.uri }}
                      style={styles.attachmentInMessageImage}
                    />
                  ) : (
                    <View style={styles.documentAttachment}>
                      <Ionicons
                        name="document-outline"
                        size={24}
                        color="#4F46E5"
                      />
                      <Text
                        style={styles.documentAttachmentName}
                        numberOfLines={1}
                      >
                        {attachment.name}
                      </Text>
                    </View>
                  )}
                </View>
              ))}
            </View>
          )}

          <View style={styles.messageFooter}>
            <Text style={styles.timestamp}>
              {new Date(item.timestamp).toLocaleTimeString('vi-VN', {
                hour: '2-digit',
                minute: '2-digit',
              })}
            </Text>
            {item.status && (
              <View style={styles.statusContainer}>
                {item.status === 'sent' && (
                  <Ionicons name="checkmark" size={12} color="#6B7280" />
                )}
                {item.status === 'delivered' && (
                  <Ionicons name="checkmark-done" size={12} color="#4F46E5" />
                )}
                {item.status === 'error' && (
                  <Ionicons name="alert-circle" size={12} color="#DC2626" />
                )}
              </View>
            )}
          </View>
        </View>
      </View>
    );
  };

  const handleClearChat = () => {
    Alert.alert(
      'X√≥a l·ªãch s·ª≠ chat',
      'B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a to√†n b·ªô l·ªãch s·ª≠ chat n√†y?',
      [
        { text: 'H·ªßy', style: 'cancel' },
        {
          text: 'X√≥a',
          style: 'destructive',
          onPress: () => {
            clearChat();
          },
        },
      ]
    );
  };

  const renderTypingIndicator = () => {
    if (!isTyping) return null;

    return (
      <View style={[styles.messageContainer, styles.aiMessage]}>
        <View style={[styles.messageBubble, styles.aiBubble]}>
          {typingText ? (
            <ScrollView style={styles.typingScroll} nestedScrollEnabled>
              <View style={styles.aiMessageContent}>
                {renderMarkdownText(typingText)}
              </View>
            </ScrollView>
          ) : (
            <View style={styles.typingIndicator}>
              <Text style={styles.typingText}>AI ƒëang tr·∫£ l·ªùi</Text>
              <View style={styles.dots}>
                <View style={[styles.dot, styles.dot1]} />
                <View style={[styles.dot, styles.dot2]} />
                <View style={[styles.dot, styles.dot3]} />
              </View>
            </View>
          )}
        </View>
      </View>
    );
  };

  return (
    <View style={[styles.container, style]}>
      {renderSuggestedQuestions()}

      <FlatList
        ref={flatListRef}
        data={messages}
        renderItem={renderMessage}
        keyExtractor={(item) => item.id}
        style={styles.messagesList}
        showsVerticalScrollIndicator={false}
        ListFooterComponent={isTyping ? renderTypingIndicator() : null}
        ListEmptyComponent={
          <View style={styles.emptyState}>
            <Ionicons name="sparkles-outline" size={48} color="#CBD5E1" />
            <Text style={styles.emptyStateTitle}>Ch√†o b·∫°n! üëã</Text>
            <Text style={styles.emptyStateText}>
              T√¥i c√≥ th·ªÉ gi√∫p b·∫°n v·ªõi c√°c c√¢u h·ªèi v·ªÅ qu·∫£n l√Ω d·ª± √°n s·∫£n xu·∫•t, quy
              tr√¨nh l√†m vi·ªác, v√† c√°c v·∫•n ƒë·ªÅ li√™n quan ƒë·∫øn s·∫£n xu·∫•t c√¥ng nghi·ªáp.
            </Text>
          </View>
        }
      />

      {error && (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>‚ùå {error}</Text>
        </View>
      )}

      {/* Attachment Preview */}
      {attachments.length > 0 && (
        <View style={styles.attachmentsContainer}>
          <Text style={styles.attachmentsTitle}>File ƒë√≠nh k√®m:</Text>
          {attachments.map((attachment) => (
            <View key={attachment.id} style={styles.attachmentItem}>
              {attachment.type === 'image' ? (
                <Image
                  source={{ uri: attachment.uri }}
                  style={styles.attachmentImage}
                />
              ) : (
                <Ionicons name="document-outline" size={24} color="#4F46E5" />
              )}
              <View style={styles.attachmentInfo}>
                <Text style={styles.attachmentName} numberOfLines={1}>
                  {attachment.name}
                </Text>
                <Text style={styles.attachmentSize}>
                  {(attachment.size / 1024).toFixed(1)} KB
                </Text>
              </View>
              <TouchableOpacity
                onPress={() => removeAttachment(attachment.id)}
                style={styles.removeAttachmentButton}
              >
                <Ionicons name="close-circle" size={20} color="#DC2626" />
              </TouchableOpacity>
            </View>
          ))}
          <TouchableOpacity
            onPress={clearAttachments}
            style={styles.clearAttachmentsButton}
          >
            <Text style={styles.clearAttachmentsText}>X√≥a t·∫•t c·∫£</Text>
          </TouchableOpacity>
        </View>
      )}

      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.inputContainer}
      >
        {/* Attachment Options */}
        <TouchableOpacity
          style={styles.attachmentButton}
          onPress={() => setShowAttachmentOptions(!showAttachmentOptions)}
        >
          <Ionicons name="attach" size={22} color="#4F46E5" />
        </TouchableOpacity>

        {showAttachmentOptions && (
          <View style={styles.attachmentOptions}>
            <TouchableOpacity
              style={styles.attachmentOption}
              onPress={handleImagePicker}
            >
              <Ionicons name="image" size={20} color="#4F46E5" />
              <Text style={styles.attachmentOptionText}>Ch·ªçn ·∫£nh</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.attachmentOption}
              onPress={handleDocumentPicker}
            >
              <Ionicons name="document" size={20} color="#4F46E5" />
              <Text style={styles.attachmentOptionText}>Ch·ªçn t√†i li·ªáu</Text>
            </TouchableOpacity>
          </View>
        )}

        <TextInput
          style={styles.textInput}
          value={inputText}
          onChangeText={setInputText}
          placeholder="H·ªèi g√¨ ƒë√≥ v·ªÅ qu·∫£n l√Ω d·ª± √°n..."
          placeholderTextColor="#6B7280"
          multiline
          maxLength={1000}
          editable={!isTyping}
        />
        <TouchableOpacity
          style={[
            styles.sendButton,
            ((!inputText.trim() && attachments.length === 0) || isTyping) &&
              styles.sendButtonDisabled,
          ]}
          onPress={handleSendMessage}
          disabled={(!inputText.trim() && attachments.length === 0) || isTyping}
        >
          <Ionicons
            name="send"
            size={20}
            color={
              (!inputText.trim() && attachments.length === 0) || isTyping
                ? '#D1D5DB'
                : '#FFFFFF'
            }
          />
        </TouchableOpacity>
      </KeyboardAvoidingView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F8FAFC',
  },

  suggestionsContainer: {
    backgroundColor: '#FFFFFF',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#E5E5EA',
  },

  suggestionsTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#000000',
    marginBottom: 12,
  },

  suggestionButton: {
    backgroundColor: '#F2F2F7',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    marginRight: 12,
    borderWidth: 1,
    borderColor: '#E5E5EA',
  },

  suggestionText: {
    fontSize: 14,
    color: '#007AFF',
    textAlign: 'center',
  },

  messagesList: {
    flex: 1,
    paddingHorizontal: 20,
  },

  messageContainer: {
    marginVertical: 8,
    flexDirection: 'row',
  },

  userMessage: {
    justifyContent: 'flex-end',
  },

  aiMessage: {
    justifyContent: 'flex-start',
  },

  messageBubble: {
    maxWidth: '80%',
    padding: 16,
    borderRadius: 20,
  },

  userBubble: {
    backgroundColor: '#4F46E5',
    borderBottomRightRadius: 6,
    shadowColor: '#4F46E5',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
  },

  aiBubble: {
    backgroundColor: '#FFFFFF',
    borderBottomLeftRadius: 6,
    borderWidth: 1,
    borderColor: '#E2E8F0',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.08,
    shadowRadius: 4,
    elevation: 2,
  },

  errorBubble: {
    backgroundColor: '#FEF2F2',
    borderColor: '#EF4444',
    borderWidth: 1,
  },

  messageText: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '400',
  },

  userText: {
    color: '#FFFFFF',
    fontWeight: '500',
  },

  aiText: {
    color: '#1F2937',
    fontWeight: '400',
  },

  boldText: {
    fontWeight: '700',
    color: '#1F2937',
  },

  aiMessageContent: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    width: '100%',
  },

  errorText: {
    color: '#DC2626',
    fontWeight: '500',
  },

  messageFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 8,
    paddingTop: 8,
    borderTopWidth: 0.5,
    borderTopColor: 'rgba(0,0,0,0.1)',
  },

  timestamp: {
    fontSize: 11,
    color: '#6B7280',
    fontWeight: '400',
  },

  statusContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },

  typingIndicator: {
    flexDirection: 'row',
    alignItems: 'center',
    width: '100%',
  },

  typingText: {
    fontSize: 16,
    color: '#6B7280',
    marginRight: 8,
    fontWeight: '500',
  },

  dots: {
    flexDirection: 'row',
  },

  dot: {
    width: 6,
    height: 6,
    borderRadius: 3,
    backgroundColor: '#6B7280',
    marginHorizontal: 2,
  },

  dot1: {
    opacity: 0.4,
  },

  dot2: {
    opacity: 0.6,
  },

  dot3: {
    opacity: 0.8,
  },

  emptyState: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 60,
  },

  emptyStateTitle: {
    fontSize: 22,
    fontWeight: '700',
    color: '#1F2937',
    marginTop: 16,
    marginBottom: 8,
  },

  emptyStateText: {
    fontSize: 16,
    color: '#6B7280',
    textAlign: 'center',
    paddingHorizontal: 32,
    lineHeight: 24,
  },

  errorContainer: {
    backgroundColor: '#FEF2F2',
    padding: 16,
    margin: 16,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#EF4444',
  },

  inputContainer: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    padding: 20,
    backgroundColor: '#FFFFFF',
    borderTopWidth: 1,
    borderTopColor: '#E5E7EB',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: -2,
    },
    shadowOpacity: 0.08,
    shadowRadius: 4,
    elevation: 8,
  },

  textInput: {
    flex: 1,
    backgroundColor: '#F9FAFB',
    borderRadius: 24,
    paddingHorizontal: 18,
    paddingVertical: 14,
    fontSize: 16,
    maxHeight: 100,
    marginRight: 12,
    borderWidth: 1,
    borderColor: '#E5E7EB',
    color: '#1F2937',
  },

  sendButton: {
    backgroundColor: '#4F46E5',
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#4F46E5',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 4,
  },

  sendButtonDisabled: {
    backgroundColor: '#D1D5DB',
  },

  // Styles cho file ƒë√≠nh k√®m
  attachmentsContainer: {
    backgroundColor: '#F9FAFB',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: '#E5E7EB',
  },

  attachmentsTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#1F2937',
    marginBottom: 8,
  },

  attachmentItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#FFFFFF',
    padding: 12,
    borderRadius: 12,
    marginBottom: 8,
    borderWidth: 1,
    borderColor: '#E5E7EB',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.05,
    shadowRadius: 2,
    elevation: 1,
  },

  attachmentImage: {
    width: 40,
    height: 40,
    borderRadius: 8,
    marginRight: 12,
  },

  attachmentInfo: {
    flex: 1,
    marginRight: 8,
  },

  attachmentName: {
    fontSize: 14,
    fontWeight: '500',
    color: '#1F2937',
    marginBottom: 2,
  },

  attachmentSize: {
    fontSize: 12,
    color: '#6B7280',
  },

  removeAttachmentButton: {
    padding: 4,
  },

  clearAttachmentsButton: {
    alignSelf: 'flex-end',
    padding: 8,
  },

  clearAttachmentsText: {
    fontSize: 14,
    color: '#EF4444',
    fontWeight: '500',
  },

  attachmentButton: {
    padding: 10,
    marginRight: 12,
  },

  attachmentOptions: {
    position: 'absolute',
    bottom: 60,
    left: 16,
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 8,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 4,
    },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 8,
    zIndex: 1000,
    borderWidth: 1,
    borderColor: '#E5E7EB',
  },

  attachmentOption: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    borderRadius: 8,
  },

  attachmentOptionText: {
    fontSize: 14,
    color: '#1F2937',
    marginLeft: 8,
    fontWeight: '500',
  },

  // Styles cho file ƒë√≠nh k√®m trong tin nh·∫Øn
  attachmentsInMessage: {
    marginTop: 12,
  },

  attachmentInMessage: {
    marginBottom: 6,
  },

  attachmentInMessageImage: {
    width: 120,
    height: 120,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#E5E7EB',
  },

  documentAttachment: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#F3F4F6',
    padding: 12,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#E5E7EB',
  },

  documentAttachmentName: {
    fontSize: 12,
    color: '#4F46E5',
    marginLeft: 8,
    flex: 1,
    fontWeight: '500',
  },
});

export default AIChatComponent;


--- END: src\components\AIChatComponent.js ---


--- START: src\components\AIChatTestComponent.js ---
import React, { useState } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  Alert,
  ScrollView,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import AIChatComponent from './AIChatComponent';

const AIChatTestComponent = () => {
  const [testMode, setTestMode] = useState('basic');

  const testProject = {
    id: 'test-project-001',
    name: 'D·ª± √°n Test S·∫£n Xu·∫•t',
    description: 'D·ª± √°n test ƒë·ªÉ ki·ªÉm tra ch·ª©c nƒÉng AI Chat v·ªõi file ƒë√≠nh k√®m',
    status: 'ƒêang th·ª±c hi·ªán',
    customerName: 'Kh√°ch h√†ng Test',
    startDate: '2024-01-01',
    endDate: '2024-12-31',
    budget: '100,000,000 VND',
    workflowStages: [
      { name: 'Thi·∫øt k·∫ø', status: 'Ho√†n th√†nh' },
      { name: 'S·∫£n xu·∫•t', status: 'ƒêang th·ª±c hi·ªán' },
      { name: 'Ki·ªÉm tra ch·∫•t l∆∞·ª£ng', status: 'Ch∆∞a b·∫Øt ƒë·∫ßu' },
    ],
    workers: [
      { name: 'Nguy·ªÖn VƒÉn A', role: 'K·ªπ s∆∞ tr∆∞·ªüng' },
      { name: 'Tr·∫ßn Th·ªã B', role: 'C√¥ng nh√¢n s·∫£n xu·∫•t' },
    ],
  };

  const runBasicTest = () => {
    Alert.alert(
      'Test C∆° B·∫£n',
      'Ki·ªÉm tra ch·ª©c nƒÉng chat AI c∆° b·∫£n:\n\n' +
        '1. G·ª≠i tin nh·∫Øn vƒÉn b·∫£n\n' +
        '2. Nh·∫≠n ph·∫£n h·ªìi t·ª´ AI\n' +
        '3. Hi·ªÉn th·ªã l·ªãch s·ª≠ chat\n' +
        '4. X·ª≠ l√Ω l·ªói k·∫øt n·ªëi',
      [{ text: 'OK' }]
    );
  };

  const runAttachmentTest = () => {
    Alert.alert(
      'Test File ƒê√≠nh K√®m',
      'Ki·ªÉm tra ch·ª©c nƒÉng file ƒë√≠nh k√®m:\n\n' +
        '1. Ch·ªçn ·∫£nh t·ª´ th∆∞ vi·ªán\n' +
        '2. Ch·ªçn t√†i li·ªáu t·ª´ thi·∫øt b·ªã\n' +
        '3. Hi·ªÉn th·ªã preview file\n' +
        '4. G·ª≠i tin nh·∫Øn v·ªõi file ƒë√≠nh k√®m\n' +
        '5. AI x·ª≠ l√Ω v√† tr·∫£ l·ªùi v·ªÅ file',
      [{ text: 'OK' }]
    );
  };

  const runProjectContextTest = () => {
    Alert.alert(
      'Test Context D·ª± √Ån',
      'Ki·ªÉm tra AI hi·ªÉu context d·ª± √°n:\n\n' +
        '1. H·ªèi v·ªÅ ti·∫øn ƒë·ªô d·ª± √°n\n' +
        '2. H·ªèi v·ªÅ c√°c c√¥ng ƒëo·∫°n\n' +
        '3. H·ªèi v·ªÅ nh√¢n vi√™n\n' +
        '4. H·ªèi v·ªÅ ng√¢n s√°ch',
      [{ text: 'OK' }]
    );
  };

  const runErrorHandlingTest = () => {
    Alert.alert(
      'Test X·ª≠ L√Ω L·ªói',
      'Ki·ªÉm tra x·ª≠ l√Ω l·ªói:\n\n' +
        '1. L·ªói k·∫øt n·ªëi m·∫°ng\n' +
        '2. L·ªói API\n' +
        '3. File kh√¥ng h·ª£p l·ªá\n' +
        '4. Quy·ªÅn truy c·∫≠p',
      [{ text: 'OK' }]
    );
  };

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>üß™ AI Chat Test Component</Text>
        <Text style={styles.subtitle}>
          Ki·ªÉm tra ch·ª©c nƒÉng AI Chat v·ªõi file ƒë√≠nh k√®m
        </Text>
      </View>

      <ScrollView style={styles.testButtonsContainer}>
        <TouchableOpacity
          style={[
            styles.testButton,
            testMode === 'basic' && styles.activeButton,
          ]}
          onPress={() => setTestMode('basic')}
        >
          <Ionicons name="chatbubble-outline" size={24} color="#007AFF" />
          <Text style={styles.testButtonText}>Test C∆° B·∫£n</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[
            styles.testButton,
            testMode === 'attachments' && styles.activeButton,
          ]}
          onPress={() => setTestMode('attachments')}
        >
          <Ionicons name="attach-outline" size={24} color="#007AFF" />
          <Text style={styles.testButtonText}>Test File ƒê√≠nh K√®m</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[
            styles.testButton,
            testMode === 'project' && styles.activeButton,
          ]}
          onPress={() => setTestMode('project')}
        >
          <Ionicons name="business-outline" size={24} color="#007AFF" />
          <Text style={styles.testButtonText}>Test Context D·ª± √Ån</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[
            styles.testButton,
            testMode === 'error' && styles.activeButton,
          ]}
          onPress={() => setTestMode('error')}
        >
          <Ionicons name="warning-outline" size={24} color="#007AFF" />
          <Text style={styles.testButtonText}>Test X·ª≠ L√Ω L·ªói</Text>
        </TouchableOpacity>
      </ScrollView>

      <View style={styles.testInfo}>
        <Text style={styles.testInfoTitle}>H∆∞·ªõng D·∫´n Test:</Text>

        {testMode === 'basic' && (
          <View style={styles.testInfoContent}>
            <Text style={styles.testInfoText}>
              ‚Ä¢ G·ª≠i tin nh·∫Øn vƒÉn b·∫£n ƒë∆°n gi·∫£n{'\n'}‚Ä¢ Ki·ªÉm tra ph·∫£n h·ªìi t·ª´ AI
              {'\n'}‚Ä¢ Xem l·ªãch s·ª≠ chat{'\n'}‚Ä¢ Test giao di·ªán c∆° b·∫£n
            </Text>
            <TouchableOpacity
              style={styles.runTestButton}
              onPress={runBasicTest}
            >
              <Text style={styles.runTestButtonText}>Ch·∫°y Test</Text>
            </TouchableOpacity>
          </View>
        )}

        {testMode === 'attachments' && (
          <View style={styles.testInfoContent}>
            <Text style={styles.testInfoText}>
              ‚Ä¢ Ch·ªçn ·∫£nh t·ª´ th∆∞ vi·ªán{'\n'}‚Ä¢ Ch·ªçn t√†i li·ªáu t·ª´ thi·∫øt b·ªã{'\n'}‚Ä¢ Xem
              preview file ƒë√≠nh k√®m{'\n'}‚Ä¢ G·ª≠i tin nh·∫Øn v·ªõi file{'\n'}‚Ä¢ Ki·ªÉm tra
              AI x·ª≠ l√Ω file
            </Text>
            <TouchableOpacity
              style={styles.runTestButton}
              onPress={runAttachmentTest}
            >
              <Text style={styles.runTestButtonText}>Ch·∫°y Test</Text>
            </TouchableOpacity>
          </View>
        )}

        {testMode === 'project' && (
          <View style={styles.testInfoContent}>
            <Text style={styles.testInfoText}>
              ‚Ä¢ H·ªèi v·ªÅ ti·∫øn ƒë·ªô d·ª± √°n{'\n'}‚Ä¢ H·ªèi v·ªÅ c√°c c√¥ng ƒëo·∫°n{'\n'}‚Ä¢ H·ªèi v·ªÅ
              nh√¢n vi√™n{'\n'}‚Ä¢ H·ªèi v·ªÅ ng√¢n s√°ch{'\n'}‚Ä¢ Ki·ªÉm tra AI hi·ªÉu context
            </Text>
            <TouchableOpacity
              style={styles.runTestButton}
              onPress={runProjectContextTest}
            >
              <Text style={styles.runTestButtonText}>Ch·∫°y Test</Text>
            </TouchableOpacity>
          </View>
        )}

        {testMode === 'error' && (
          <View style={styles.testInfoContent}>
            <Text style={styles.testInfoText}>
              ‚Ä¢ Test l·ªói k·∫øt n·ªëi m·∫°ng{'\n'}‚Ä¢ Test l·ªói API{'\n'}‚Ä¢ Test file kh√¥ng
              h·ª£p l·ªá{'\n'}‚Ä¢ Test quy·ªÅn truy c·∫≠p{'\n'}‚Ä¢ Ki·ªÉm tra x·ª≠ l√Ω l·ªói
            </Text>
            <TouchableOpacity
              style={styles.runTestButton}
              onPress={runErrorHandlingTest}
            >
              <Text style={styles.runTestButtonText}>Ch·∫°y Test</Text>
            </TouchableOpacity>
          </View>
        )}
      </View>

      <View style={styles.chatContainer}>
        <Text style={styles.chatTitle}>
          {testMode === 'basic' && 'üí¨ Chat AI C∆° B·∫£n'}
          {testMode === 'attachments' && 'üìé Chat AI v·ªõi File ƒê√≠nh K√®m'}
          {testMode === 'project' && 'üèóÔ∏è Chat AI v·ªÅ D·ª± √Ån'}
          {testMode === 'error' && '‚ö†Ô∏è Test X·ª≠ L√Ω L·ªói'}
        </Text>

        <AIChatComponent
          project={testMode === 'project' ? testProject : null}
          style={styles.chatComponent}
        />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F2F2F7',
  },
  header: {
    backgroundColor: '#FFFFFF',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#E5E5EA',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#000000',
    textAlign: 'center',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#8E8E93',
    textAlign: 'center',
  },
  testButtonsContainer: {
    padding: 16,
  },
  testButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#FFFFFF',
    padding: 16,
    borderRadius: 12,
    marginBottom: 12,
    borderWidth: 2,
    borderColor: '#E5E5EA',
  },
  activeButton: {
    borderColor: '#007AFF',
    backgroundColor: '#F0F8FF',
  },
  testButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#000000',
    marginLeft: 12,
  },
  testInfo: {
    backgroundColor: '#FFFFFF',
    margin: 16,
    padding: 16,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#E5E5EA',
  },
  testInfoTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#000000',
    marginBottom: 12,
  },
  testInfoContent: {
    alignItems: 'center',
  },
  testInfoText: {
    fontSize: 14,
    color: '#666666',
    lineHeight: 20,
    textAlign: 'center',
    marginBottom: 16,
  },
  runTestButton: {
    backgroundColor: '#007AFF',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
  },
  runTestButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
  chatContainer: {
    flex: 1,
    margin: 16,
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    overflow: 'hidden',
  },
  chatTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#000000',
    textAlign: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#E5E5EA',
  },
  chatComponent: {
    flex: 1,
  },
});

export default AIChatTestComponent;


--- END: src\components\AIChatTestComponent.js ---


--- START: src\components\CustomerAddModal.js ---
import React from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Modal,
  SafeAreaView,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';

const CustomerAddModal = ({ visible, onClose, onManualAdd, onImportExcel }) => {
  const { theme } = useTheme();

  return (
    <Modal
      visible={visible}
      transparent={true}
      animationType="fade"
      onRequestClose={onClose}
    >
      <View style={styles.overlay}>
        <View
          style={[
            styles.modalContainer,
            { backgroundColor: theme.card, borderColor: theme.border },
          ]}
        >
          <View style={styles.header}>
            <Text style={[styles.title, { color: theme.text }]}>
              Th√™m Kh√°ch H√†ng
            </Text>
            <TouchableOpacity onPress={onClose} style={styles.closeButton}>
              <Ionicons name="close" size={24} color={theme.textSecondary} />
            </TouchableOpacity>
          </View>

          <View style={styles.optionsContainer}>
            {/* Option 1: Th√™m th·ªß c√¥ng */}
            <TouchableOpacity
              style={[
                styles.optionCard,
                {
                  backgroundColor: theme.background,
                  borderColor: theme.border,
                },
              ]}
              onPress={() => {
                onClose();
                onManualAdd();
              }}
            >
              <View style={styles.optionIcon}>
                <Ionicons
                  name="person-add-outline"
                  size={32}
                  color={theme.primary}
                />
              </View>
              <View style={styles.optionContent}>
                <Text style={[styles.optionTitle, { color: theme.text }]}>
                  Th√™m th·ªß c√¥ng
                </Text>
                <Text
                  style={[
                    styles.optionDescription,
                    { color: theme.textSecondary },
                  ]}
                >
                  Nh·∫≠p th√¥ng tin kh√°ch h√†ng t·ª´ng ng∆∞·ªùi m·ªôt
                </Text>
              </View>
              <Ionicons
                name="chevron-forward"
                size={20}
                color={theme.textSecondary}
              />
            </TouchableOpacity>

            {/* Option 2: Import t·ª´ Excel */}
            <TouchableOpacity
              style={[
                styles.optionCard,
                {
                  backgroundColor: theme.background,
                  borderColor: theme.border,
                },
              ]}
              onPress={() => {
                onClose();
                onImportExcel();
              }}
            >
              <View style={styles.optionIcon}>
                <Ionicons
                  name="cloud-upload-outline"
                  size={32}
                  color={theme.primary}
                />
              </View>
              <View style={styles.optionContent}>
                <Text style={[styles.optionTitle, { color: theme.text }]}>
                  Import t·ª´ Excel
                </Text>
                <Text
                  style={[
                    styles.optionDescription,
                    { color: theme.textSecondary },
                  ]}
                >
                  Import h√†ng lo·∫°t t·ª´ file Excel
                </Text>
              </View>
              <Ionicons
                name="chevron-forward"
                size={20}
                color={theme.textSecondary}
              />
            </TouchableOpacity>
          </View>

          <View style={styles.footer}>
            <TouchableOpacity
              style={[styles.cancelButton, { borderColor: theme.border }]}
              onPress={onClose}
            >
              <Text
                style={[
                  styles.cancelButtonText,
                  { color: theme.textSecondary },
                ]}
              >
                H·ªßy
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContainer: {
    width: '100%',
    maxWidth: 400,
    borderRadius: 16,
    borderWidth: 1,
    overflow: 'hidden',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  closeButton: {
    padding: 4,
  },
  optionsContainer: {
    padding: 20,
    gap: 16,
  },
  optionCard: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderRadius: 12,
    borderWidth: 1,
  },
  optionIcon: {
    marginRight: 16,
  },
  optionContent: {
    flex: 1,
  },
  optionTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 4,
  },
  optionDescription: {
    fontSize: 14,
    lineHeight: 20,
  },
  footer: {
    padding: 20,
    borderTopWidth: 1,
    borderTopColor: '#e0e0e0',
  },
  cancelButton: {
    padding: 12,
    borderRadius: 8,
    borderWidth: 1,
    alignItems: 'center',
  },
  cancelButtonText: {
    fontSize: 16,
    fontWeight: '500',
  },
});

export default CustomerAddModal;

















--- END: src\components\CustomerAddModal.js ---


--- START: src\components\CustomIconDebug.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Image,
  TouchableOpacity,
  Alert,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import AsyncStorage from '@react-native-async-storage/async-storage';
import * as FileSystem from 'expo-file-system';

/**
 * Component debug ƒë·ªÉ ki·ªÉm tra custom icons
 */
const CustomIconDebug = () => {
  const [customIcons, setCustomIcons] = useState([]);
  const [debugInfo, setDebugInfo] = useState('');

  useEffect(() => {
    loadAndDebugIcons();
  }, []);

  const loadAndDebugIcons = async () => {
    try {
      // Load custom icons
      const saved = await AsyncStorage.getItem('customIconFiles');
      if (saved) {
        const icons = JSON.parse(saved);
        setCustomIcons(icons);

        // Debug each icon
        let debugText = `Found ${icons.length} custom icons:\n\n`;

        for (const icon of icons) {
          debugText += `Icon: ${icon.name}\n`;
          debugText += `ID: ${icon.id}\n`;
          debugText += `URI: ${icon.uri}\n`;

          // Check if file exists
          const fileInfo = await FileSystem.getInfoAsync(icon.uri);
          debugText += `File exists: ${fileInfo.exists}\n`;
          debugText += `File size: ${fileInfo.size || 'N/A'} bytes\n`;
          debugText += `File type: ${
            fileInfo.isDirectory ? 'Directory' : 'File'
          }\n`;
          debugText += `---\n`;
        }

        setDebugInfo(debugText);
      } else {
        setDebugInfo('No custom icons found in AsyncStorage');
      }
    } catch (error) {
      setDebugInfo(`Error loading icons: ${error.message}`);
    }
  };

  const clearAllCustomIcons = async () => {
    Alert.alert('X√°c nh·∫≠n', 'B·∫°n c√≥ mu·ªën x√≥a t·∫•t c·∫£ custom icons ƒë·ªÉ debug?', [
      { text: 'H·ªßy', style: 'cancel' },
      {
        text: 'X√≥a t·∫•t c·∫£',
        style: 'destructive',
        onPress: async () => {
          try {
            // Delete all files
            for (const icon of customIcons) {
              await FileSystem.deleteAsync(icon.uri, { idempotent: true });
            }

            // Clear AsyncStorage
            await AsyncStorage.removeItem('customIconFiles');
            await AsyncStorage.removeItem('customStageIcons');

            setCustomIcons([]);
            setDebugInfo('All custom icons cleared');

            Alert.alert('Th√†nh c√¥ng', 'ƒê√£ x√≥a t·∫•t c·∫£ custom icons');
          } catch (error) {
            Alert.alert('L·ªói', `Kh√¥ng th·ªÉ x√≥a: ${error.message}`);
          }
        },
      },
    ]);
  };

  const renderIcon = (icon) => (
    <View key={icon.id} style={styles.iconContainer}>
      <Text style={styles.iconTitle}>{icon.name}</Text>
      <View style={styles.iconPreview}>
        <Image
          source={{ uri: icon.uri }}
          style={styles.iconImage}
          onError={(error) => {
            console.error('Image load error:', error);
          }}
          onLoad={() => {
            console.log('Image loaded successfully:', icon.uri);
          }}
        />
      </View>
      <Text style={styles.iconUri} numberOfLines={2}>
        {icon.uri}
      </Text>
    </View>
  );

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>Custom Icon Debug</Text>
        <TouchableOpacity
          onPress={loadAndDebugIcons}
          style={styles.refreshButton}
        >
          <Ionicons name="refresh" size={20} color="#007AFF" />
        </TouchableOpacity>
      </View>

      <View style={styles.debugSection}>
        <Text style={styles.debugTitle}>Debug Info:</Text>
        <Text style={styles.debugText}>{debugInfo}</Text>
      </View>

      <View style={styles.iconsSection}>
        <Text style={styles.sectionTitle}>Custom Icons Preview:</Text>
        {customIcons.map(renderIcon)}
      </View>

      <TouchableOpacity
        onPress={clearAllCustomIcons}
        style={styles.clearButton}
      >
        <Text style={styles.clearButtonText}>Clear All Custom Icons</Text>
      </TouchableOpacity>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: '#fff',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  refreshButton: {
    padding: 8,
  },
  debugSection: {
    backgroundColor: '#f8f8f8',
    padding: 12,
    borderRadius: 8,
    marginBottom: 16,
  },
  debugTitle: {
    fontSize: 14,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  debugText: {
    fontSize: 12,
    fontFamily: 'monospace',
    color: '#333',
  },
  iconsSection: {
    marginBottom: 16,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  iconContainer: {
    backgroundColor: '#f0f0f0',
    padding: 12,
    borderRadius: 8,
    marginBottom: 8,
  },
  iconTitle: {
    fontSize: 14,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  iconPreview: {
    alignItems: 'center',
    marginBottom: 8,
  },
  iconImage: {
    width: 48,
    height: 48,
    backgroundColor: '#ddd',
    borderRadius: 4,
  },
  iconUri: {
    fontSize: 10,
    color: '#666',
    fontFamily: 'monospace',
  },
  clearButton: {
    backgroundColor: '#FF6B6B',
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
  },
  clearButtonText: {
    color: '#fff',
    fontWeight: 'bold',
  },
});

export default CustomIconDebug;





























































































































--- END: src\components\CustomIconDebug.js ---


--- START: src\components\InventoryItemCard.js ---
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { Card } from 'react-native-paper';
import StatusIndicator from './StatusIndicator';

/**
 * Component hi·ªÉn th·ªã th√¥ng tin v·∫≠t t∆∞ trong kho d∆∞·ªõi d·∫°ng card
 */
const InventoryItemCard = ({ item, onPress }) => {
  // X√°c ƒë·ªãnh tr·∫°ng th√°i t·ªìn kho
  const getStockStatus = () => {
    if (!item.minQuantity) return 'normal'; // N·∫øu kh√¥ng thi·∫øt l·∫≠p m·ª©c t·ªëi thi·ªÉu

    if (item.stockQuantity <= 0) {
      return 'critical'; // H·∫øt h√†ng
    } else if (item.stockQuantity <= item.minQuantity) {
      return 'warning'; // D∆∞·ªõi m·ª©c t·ªëi thi·ªÉu
    } else {
      return 'normal'; // B√¨nh th∆∞·ªùng
    }
  };

  // Hi·ªÉn th·ªã tr·∫°ng th√°i
  const renderStockStatus = () => {
    const status = getStockStatus();
    let statusText = 'B√¨nh th∆∞·ªùng';

    if (status === 'critical') {
      statusText = 'H·∫øt h√†ng';
    } else if (status === 'warning') {
      statusText = 'D∆∞·ªõi m·ª©c t·ªëi thi·ªÉu';
    }

    return <StatusIndicator status={status} text={statusText} />;
  };

  return (
    <TouchableOpacity onPress={() => onPress(item)}>
      <Card style={styles.card}>
        <Card.Content>
          <View style={styles.header}>
            <View style={styles.titleContainer}>
              <Text style={styles.title} numberOfLines={1}>
                {item.name}
              </Text>
              <Text style={styles.code}>M√£: {item.code}</Text>
            </View>
            {renderStockStatus()}
          </View>

          <View style={styles.detailsContainer}>
            <View style={styles.detailRow}>
              <Text style={styles.detailLabel}>T·ªìn kho:</Text>
              <Text style={styles.detailValue}>
                {item.stockQuantity} {item.unit}
              </Text>
            </View>

            {item.material && (
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>V·∫≠t li·ªáu:</Text>
                <Text style={styles.detailValue}>{item.material}</Text>
              </View>
            )}

            {item.weight > 0 && (
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Kh·ªëi l∆∞·ª£ng:</Text>
                <Text style={styles.detailValue}>{item.weight} kg</Text>
              </View>
            )}

            {item.price > 0 && (
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>ƒê∆°n gi√°:</Text>
                <Text style={styles.detailValue}>
                  {item.price.toLocaleString('vi-VN')} ƒë
                </Text>
              </View>
            )}
          </View>
        </Card.Content>
      </Card>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  card: {
    marginVertical: 8,
    marginHorizontal: 16,
    elevation: 2,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  titleContainer: {
    flex: 1,
  },
  title: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  code: {
    fontSize: 12,
    color: '#666',
  },
  detailsContainer: {
    marginTop: 5,
  },
  detailRow: {
    flexDirection: 'row',
    marginVertical: 2,
  },
  detailLabel: {
    width: 80,
    color: '#666',
  },
  detailValue: {
    flex: 1,
    fontWeight: '500',
  },
});

export default InventoryItemCard;


--- END: src\components\InventoryItemCard.js ---


--- START: src\components\MaterialsContextDemo.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  Alert,
  ActivityIndicator,
} from 'react-native';
import { useMaterialsContext } from '../hooks/useMaterialsContext';
import { GoogleSignin } from '@react-native-google-signin/google-signin';

/**
 * Component demo ƒë·ªÉ test function getAutoMaterialsContext
 * Hi·ªÉn th·ªã th√¥ng tin v·∫≠t t∆∞ t·ª´ b√°o gi√° ho·∫∑c file Excel
 */
const MaterialsContextDemo = ({ project }) => {
  const {
    materialsContext,
    isLoading,
    error,
    hasMaterialsContext,
    materialsSource,
    materialsCount,
    materialsList,
    isFromQuotation,
    isFromExcel,
    hasNoData,
    fetchMaterialsContext,
    refreshContext,
    clearCache,
  } = useMaterialsContext(project);

  const [accessToken, setAccessToken] = useState(null);

  // L·∫•y access token khi component mount
  useEffect(() => {
    const getToken = async () => {
      try {
        const isSignedIn = await GoogleSignin.isSignedIn();
        if (isSignedIn) {
          const tokens = await GoogleSignin.getTokens();
          setAccessToken(tokens.accessToken);
        }
      } catch (error) {
        console.error('L·ªói khi l·∫•y access token:', error);
      }
    };

    getToken();
  }, []);

  // T·ª± ƒë·ªông fetch context khi c√≥ project
  useEffect(() => {
    if (project && accessToken) {
      fetchMaterialsContext(accessToken);
    }
  }, [project, accessToken, fetchMaterialsContext]);

  const handleFetchContext = async () => {
    try {
      await fetchMaterialsContext(accessToken);
    } catch (error) {
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ l·∫•y context v·∫≠t t∆∞: ' + error.message);
    }
  };

  const handleRefreshContext = async () => {
    try {
      await refreshContext(accessToken);
      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ refresh context v·∫≠t t∆∞');
    } catch (error) {
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ refresh context: ' + error.message);
    }
  };

  const handleClearCache = () => {
    clearCache();
    Alert.alert('Th√†nh c√¥ng', 'ƒê√£ x√≥a cache');
  };

  const renderMaterialsList = () => {
    if (!materialsList || materialsList.length === 0) {
      return <Text style={styles.noData}>Kh√¥ng c√≥ danh s√°ch v·∫≠t t∆∞</Text>;
    }

    return (
      <View style={styles.materialsList}>
        <Text style={styles.sectionTitle}>
          Danh s√°ch v·∫≠t t∆∞ ({materialsList.length}):
        </Text>
        {materialsList.slice(0, 10).map((item, index) => (
          <View key={index} style={styles.materialItem}>
            <Text style={styles.materialName}>
              {index + 1}. {item.name || item.materialName || 'Kh√¥ng c√≥ t√™n'}
            </Text>
            {item.code && (
              <Text style={styles.materialCode}>M√£: {item.code}</Text>
            )}
            {item.quantity && (
              <Text style={styles.materialQuantity}>
                SL: {item.quantity} {item.unit || ''}
              </Text>
            )}
            {item.price && (
              <Text style={styles.materialPrice}>Gi√°: {item.price}</Text>
            )}
          </View>
        ))}
        {materialsList.length > 10 && (
          <Text style={styles.moreItems}>
            ... v√† {materialsList.length - 10} v·∫≠t t∆∞ kh√°c
          </Text>
        )}
      </View>
    );
  };

  const renderContextInfo = () => {
    if (!materialsContext) {
      return <Text style={styles.noData}>Ch∆∞a c√≥ context v·∫≠t t∆∞</Text>;
    }

    return (
      <View style={styles.contextInfo}>
        <Text style={styles.sectionTitle}>Th√¥ng tin Context:</Text>

        <View style={styles.infoRow}>
          <Text style={styles.infoLabel}>Ngu·ªìn d·ªØ li·ªáu:</Text>
          <Text style={styles.infoValue}>
            {materialsSource === 'quotation'
              ? 'B√°o gi√° m·ªõi nh·∫•t'
              : materialsSource === 'excel'
              ? 'File Excel Google Drive'
              : 'Kh√¥ng c√≥ d·ªØ li·ªáu'}
          </Text>
        </View>

        {materialsCount > 0 && (
          <View style={styles.infoRow}>
            <Text style={styles.infoLabel}>S·ªë l∆∞·ª£ng v·∫≠t t∆∞:</Text>
            <Text style={styles.infoValue}>{materialsCount}</Text>
          </View>
        )}

        {isFromQuotation && materialsContext.materialsData && (
          <>
            <View style={styles.infoRow}>
              <Text style={styles.infoLabel}>M√£ b√°o gi√°:</Text>
              <Text style={styles.infoValue}>
                {materialsContext.materialsData.quotationNumber ||
                  materialsContext.materialsData.quotationId}
              </Text>
            </View>
            {materialsContext.materialsData.totalAmount && (
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>T·ªïng gi√° tr·ªã:</Text>
                <Text style={styles.infoValue}>
                  {materialsContext.materialsData.totalAmount.toLocaleString(
                    'vi-VN'
                  )}{' '}
                  VNƒê
                </Text>
              </View>
            )}
          </>
        )}

        {isFromExcel && materialsContext.materialsData && (
          <>
            <View style={styles.infoRow}>
              <Text style={styles.infoLabel}>T√™n file:</Text>
              <Text style={styles.infoValue}>
                {materialsContext.materialsData.fileName}
              </Text>
            </View>
            {materialsContext.materialsData.lastModified && (
              <View style={styles.infoRow}>
                <Text style={styles.infoLabel}>C·∫≠p nh·∫≠t l√∫c:</Text>
                <Text style={styles.infoValue}>
                  {new Date(
                    materialsContext.materialsData.lastModified
                  ).toLocaleString('vi-VN')}
                </Text>
              </View>
            )}
          </>
        )}
      </View>
    );
  };

  if (!project) {
    return (
      <View style={styles.container}>
        <Text style={styles.error}>
          Vui l√≤ng ch·ªçn d·ª± √°n ƒë·ªÉ xem context v·∫≠t t∆∞
        </Text>
      </View>
    );
  }

  return (
    <ScrollView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>Demo Context V·∫≠t T∆∞</Text>
        <Text style={styles.subtitle}>D·ª± √°n: {project.name}</Text>
      </View>

      <View style={styles.controls}>
        <TouchableOpacity
          style={[styles.button, styles.primaryButton]}
          onPress={handleFetchContext}
          disabled={isLoading}
        >
          {isLoading ? (
            <ActivityIndicator color="#fff" />
          ) : (
            <Text style={styles.buttonText}>L·∫•y Context</Text>
          )}
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.button, styles.secondaryButton]}
          onPress={handleRefreshContext}
          disabled={isLoading}
        >
          <Text style={styles.buttonText}>Refresh</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.button, styles.dangerButton]}
          onPress={handleClearCache}
        >
          <Text style={styles.buttonText}>X√≥a Cache</Text>
        </TouchableOpacity>
      </View>

      {error && (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>L·ªói: {error}</Text>
        </View>
      )}

      {renderContextInfo()}
      {renderMaterialsList()}

      <View style={styles.status}>
        <Text style={styles.statusText}>
          Tr·∫°ng th√°i: {hasMaterialsContext ? 'C√≥ d·ªØ li·ªáu' : 'Kh√¥ng c√≥ d·ªØ li·ªáu'}
        </Text>
        <Text style={styles.statusText}>Ngu·ªìn: {materialsSource}</Text>
        <Text style={styles.statusText}>S·ªë l∆∞·ª£ng: {materialsCount}</Text>
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
    padding: 16,
  },
  header: {
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
  controls: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginBottom: 20,
  },
  button: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 8,
    minWidth: 100,
    alignItems: 'center',
  },
  primaryButton: {
    backgroundColor: '#007AFF',
  },
  secondaryButton: {
    backgroundColor: '#34C759',
  },
  dangerButton: {
    backgroundColor: '#FF3B30',
  },
  buttonText: {
    color: '#fff',
    fontWeight: '600',
  },
  errorContainer: {
    backgroundColor: '#FFE5E5',
    padding: 12,
    borderRadius: 8,
    marginBottom: 16,
  },
  errorText: {
    color: '#D70015',
    textAlign: 'center',
  },
  contextInfo: {
    backgroundColor: '#fff',
    padding: 16,
    borderRadius: 8,
    marginBottom: 16,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginBottom: 12,
  },
  infoRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  infoLabel: {
    fontSize: 14,
    color: '#666',
    flex: 1,
  },
  infoValue: {
    fontSize: 14,
    color: '#333',
    fontWeight: '500',
    flex: 2,
    textAlign: 'right',
  },
  materialsList: {
    backgroundColor: '#fff',
    padding: 16,
    borderRadius: 8,
    marginBottom: 16,
  },
  materialItem: {
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
    paddingVertical: 8,
  },
  materialName: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    marginBottom: 4,
  },
  materialCode: {
    fontSize: 14,
    color: '#666',
    marginBottom: 2,
  },
  materialQuantity: {
    fontSize: 14,
    color: '#666',
    marginBottom: 2,
  },
  materialPrice: {
    fontSize: 14,
    color: '#007AFF',
    fontWeight: '500',
  },
  moreItems: {
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
    textAlign: 'center',
    marginTop: 8,
  },
  status: {
    backgroundColor: '#fff',
    padding: 16,
    borderRadius: 8,
    marginBottom: 16,
  },
  statusText: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
  },
  noData: {
    fontSize: 16,
    color: '#999',
    textAlign: 'center',
    fontStyle: 'italic',
    padding: 20,
  },
  error: {
    fontSize: 16,
    color: '#FF3B30',
    textAlign: 'center',
    padding: 20,
  },
});

export default MaterialsContextDemo;
















































--- END: src\components\MaterialsContextDemo.js ---


--- START: src\components\MediaInstructionsViewer.js ---
import React, { useState } from 'react';
import {
  View,
  Text,
  Image,
  TouchableOpacity,
  StyleSheet,
  ScrollView,
  Modal,
  Dimensions,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { Audio } from 'expo-av';

const { width } = Dimensions.get('window');

const MediaInstructionsViewer = ({
  instructionImages = [],
  instructionNotes = '',
  instructionAudio = null,
  visible = true,
}) => {
  const [selectedImage, setSelectedImage] = useState(null);
  const [sound, setSound] = useState(null);
  const [isPlaying, setIsPlaying] = useState(false);

  const playAudio = async () => {
    try {
      if (instructionAudio && instructionAudio.url) {
        const { sound } = await Audio.Sound.createAsync(
          { uri: instructionAudio.url },
          { shouldPlay: true }
        );
        setSound(sound);
        setIsPlaying(true);

        sound.setOnPlaybackStatusUpdate((status) => {
          if (status.didJustFinish) {
            setIsPlaying(false);
            sound.unloadAsync();
          }
        });
      }
    } catch (error) {
      console.error('Error playing audio:', error);
    }
  };

  const stopAudio = async () => {
    try {
      if (sound) {
        await sound.stopAsync();
        await sound.unloadAsync();
        setSound(null);
        setIsPlaying(false);
      }
    } catch (error) {
      console.error('Error stopping audio:', error);
    }
  };

  const openImageModal = (image) => {
    setSelectedImage(image);
  };

  const closeImageModal = () => {
    setSelectedImage(null);
  };

  if (!visible) return null;

  const hasInstructions =
    instructionNotes ||
    (instructionImages && instructionImages.length > 0) ||
    instructionAudio;

  if (!hasInstructions) {
    return (
      <View style={styles.container}>
        <View style={styles.header}>
          <Ionicons name="information-circle-outline" size={24} color="#666" />
          <Text style={styles.headerTitle}>H∆∞·ªõng d·∫´n th·ª±c hi·ªán</Text>
        </View>
        <Text style={styles.noInstructionsText}>
          Ch∆∞a c√≥ h∆∞·ªõng d·∫´n cho c√¥ng ƒëo·∫°n n√†y
        </Text>
        <Text
          style={[styles.noInstructionsText, { fontSize: 12, marginTop: 8 }]}
        >
          Vui l√≤ng li√™n h·ªá qu·∫£n l√Ω ƒë·ªÉ ƒë∆∞·ª£c h∆∞·ªõng d·∫´n chi ti·∫øt.
        </Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Ionicons name="information-circle" size={24} color="#0066cc" />
        <Text style={styles.headerTitle}>H∆∞·ªõng d·∫´n th·ª±c hi·ªán</Text>
      </View>

      <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>
        {/* Text Instructions */}
        {instructionNotes ? (
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>üìù H∆∞·ªõng d·∫´n chi ti·∫øt</Text>
            <View style={styles.notesContainer}>
              <Text style={styles.notesText}>{instructionNotes}</Text>
            </View>
          </View>
        ) : null}

        {/* Image Instructions */}
        {instructionImages && instructionImages.length > 0 ? (
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>üì∏ H√¨nh ·∫£nh h∆∞·ªõng d·∫´n</Text>
            <ScrollView
              horizontal
              showsHorizontalScrollIndicator={false}
              style={styles.imagesScroll}
            >
              {instructionImages.map((image, index) => (
                <TouchableOpacity
                  key={index}
                  style={styles.imageContainer}
                  onPress={() => openImageModal(image)}
                >
                  <Image
                    source={{ uri: image.url || image.uri }}
                    style={styles.instructionImage}
                    resizeMode="cover"
                  />
                  <View style={styles.imageOverlay}>
                    <Ionicons name="expand-outline" size={20} color="#fff" />
                  </View>
                </TouchableOpacity>
              ))}
            </ScrollView>
          </View>
        ) : null}

        {/* Audio Instructions */}
        {instructionAudio ? (
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>üé§ H∆∞·ªõng d·∫´n b·∫±ng gi·ªçng n√≥i</Text>
            <View style={styles.audioContainer}>
              <TouchableOpacity
                style={styles.audioButton}
                onPress={isPlaying ? stopAudio : playAudio}
              >
                <Ionicons
                  name={isPlaying ? 'pause-circle' : 'play-circle'}
                  size={48}
                  color="#0066cc"
                />
              </TouchableOpacity>
              <Text style={styles.audioText}>
                {isPlaying ? 'ƒêang ph√°t...' : 'Nh·∫•n ƒë·ªÉ nghe h∆∞·ªõng d·∫´n'}
              </Text>
            </View>
          </View>
        ) : null}
      </ScrollView>

      {/* Image Modal */}
      <Modal
        visible={!!selectedImage}
        transparent={true}
        animationType="fade"
        onRequestClose={closeImageModal}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContainer}>
            <TouchableOpacity
              style={styles.closeButton}
              onPress={closeImageModal}
            >
              <Ionicons name="close" size={30} color="#fff" />
            </TouchableOpacity>
            {selectedImage && (
              <Image
                source={{ uri: selectedImage.url || selectedImage.uri }}
                style={styles.fullImage}
                resizeMode="contain"
              />
            )}
          </View>
        </View>
      </Modal>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#fff',
    borderRadius: 12,
    margin: 16,
    padding: 16,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
    elevation: 5,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
    paddingBottom: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginLeft: 8,
  },
  content: {
    maxHeight: 400,
  },
  section: {
    marginBottom: 20,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 12,
  },
  notesContainer: {
    backgroundColor: '#f8f9fa',
    padding: 12,
    borderRadius: 8,
    borderLeftWidth: 4,
    borderLeftColor: '#0066cc',
  },
  notesText: {
    fontSize: 14,
    lineHeight: 20,
    color: '#333',
  },
  imagesScroll: {
    marginBottom: 8,
  },
  imageContainer: {
    position: 'relative',
    marginRight: 12,
  },
  instructionImage: {
    width: 120,
    height: 120,
    borderRadius: 8,
    backgroundColor: '#f0f0f0',
  },
  imageOverlay: {
    position: 'absolute',
    top: 8,
    right: 8,
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
    borderRadius: 12,
    padding: 4,
  },
  audioContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f8f9fa',
    padding: 16,
    borderRadius: 8,
  },
  audioButton: {
    marginRight: 16,
  },
  audioText: {
    flex: 1,
    fontSize: 14,
    color: '#333',
    fontWeight: '500',
  },
  noInstructionsText: {
    textAlign: 'center',
    color: '#666',
    fontStyle: 'italic',
    fontSize: 14,
    paddingVertical: 20,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.9)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    width: width * 0.95,
    height: '80%',
    justifyContent: 'center',
    alignItems: 'center',
  },
  closeButton: {
    position: 'absolute',
    top: 40,
    right: 20,
    zIndex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    borderRadius: 20,
    padding: 8,
  },
  fullImage: {
    width: '100%',
    height: '100%',
  },
});

export default MediaInstructionsViewer;


--- END: src\components\MediaInstructionsViewer.js ---


--- START: src\components\ProcessPickerModal.js ---
import React, { useState, useEffect, useCallback } from 'react';
import {
  Modal,
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  SectionList,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { collection, getDocs, addDoc } from 'firebase/firestore';
import { db } from '../config/firebaseConfig';

/**
 * ProcessPickerModal component
 * Props:
 *  - visible: boolean
 *  - onClose(): void  // close without saving
 *  - onConfirm(templates: ProcessTemplate[]): void // return chosen templates
 *  - existingStageKeys: string[] // list of process keys already in workflow
 */
const ProcessPickerModal = ({
  visible,
  onClose,
  onConfirm,
  existingStageKeys = [],
}) => {
  const [loading, setLoading] = useState(false);
  const [sections, setSections] = useState([]); // [{title, data: ProcessTemplate[]}]
  const [selectedIds, setSelectedIds] = useState(new Set());

  // Predefined templates to seed if collection is empty
  const DEFAULT_TEMPLATES = [
    // T·∫°o ph√¥i & C·∫Øt g·ªçt
    {
      processKey: 'laser_plasma_cut',
      processName: 'C·∫Øt Laser/Plasma',
      category: 'T·∫°o ph√¥i & C·∫Øt g·ªçt',
    },
    {
      processKey: 'oxy_gas_cut',
      processName: 'C·∫Øt Oxy-Gas',
      category: 'T·∫°o ph√¥i & C·∫Øt g·ªçt',
    },
    {
      processKey: 'saw_cut',
      processName: 'C·∫Øt b·∫±ng M√°y c∆∞a',
      category: 'T·∫°o ph√¥i & C·∫Øt g·ªçt',
    },
    {
      processKey: 'punch',
      processName: 'ƒê·ªôt / D·∫≠p l·ªó',
      category: 'T·∫°o ph√¥i & C·∫Øt g·ªçt',
    },
    {
      processKey: 'turning',
      processName: 'Ti·ªán',
      category: 'T·∫°o ph√¥i & C·∫Øt g·ªçt',
    },
    {
      processKey: 'milling',
      processName: 'Phay',
      category: 'T·∫°o ph√¥i & C·∫Øt g·ªçt',
    },
    {
      processKey: 'drill_tap',
      processName: 'Khoan / Ta-r√¥',
      category: 'T·∫°o ph√¥i & C·∫Øt g·ªçt',
    },
    // Bi·∫øn d·∫°ng
    {
      processKey: 'bending',
      processName: 'Ch·∫•n / G·∫•p',
      category: 'Bi·∫øn d·∫°ng',
    },
    {
      processKey: 'rolling',
      processName: 'L·ªëc / U·ªën T√¥n',
      category: 'Bi·∫øn d·∫°ng',
    },
    {
      processKey: 'pressing',
      processName: 'D·∫≠p / √âp',
      category: 'Bi·∫øn d·∫°ng',
    },
    // L·∫Øp r√°p & Ho√†n thi·ªán
    {
      processKey: 'fit_up',
      processName: 'T·ªï h·ª£p / G√° ƒë·∫∑t',
      category: 'L·∫Øp r√°p & Ho√†n thi·ªán',
    },
    {
      processKey: 'welding',
      processName: 'H√†n',
      category: 'L·∫Øp r√°p & Ho√†n thi·ªán',
    },
    {
      processKey: 'grinding',
      processName: 'M√†i / X·ª≠ l√Ω b·ªÅ m·∫∑t',
      category: 'L·∫Øp r√°p & Ho√†n thi·ªán',
    },
    {
      processKey: 'sand_blasting',
      processName: 'Phun c√°t / Phun bi',
      category: 'L·∫Øp r√°p & Ho√†n thi·ªán',
    },
    {
      processKey: 'painting',
      processName: 'S∆°n',
      category: 'L·∫Øp r√°p & Ho√†n thi·ªán',
    },
    {
      processKey: 'inox_polish',
      processName: 'ƒê√°nh b√≥ng Inox',
      category: 'L·∫Øp r√°p & Ho√†n thi·ªán',
    },
    {
      processKey: 'qc_ndt',
      processName: 'Ki·ªÉm tra KCS / NDT',
      category: 'L·∫Øp r√°p & Ho√†n thi·ªán',
    },
    {
      processKey: 'pack_ship',
      processName: 'ƒê√≥ng g√≥i & V·∫≠n chuy·ªÉn',
      category: 'L·∫Øp r√°p & Ho√†n thi·ªán',
    },
  ];

  const fetchTemplates = useCallback(async () => {
    try {
      setLoading(true);
      const snap = await getDocs(collection(db, 'process_templates'));
      const list = snap.docs.map((d) => ({ id: d.id, ...d.data() }));

      // Auto-seed if empty
      if (list.length === 0) {
        await Promise.all(
          DEFAULT_TEMPLATES.map((tpl) =>
            addDoc(collection(db, 'process_templates'), tpl)
          )
        );
        // Re-fetch after seeding
        return fetchTemplates();
      }

      // Group by category
      const grouped = list.reduce((acc, tpl) => {
        const key = tpl.category || 'Kh√°c';
        if (!acc[key]) acc[key] = [];
        acc[key].push(tpl);
        return acc;
      }, {});
      const groupedSections = Object.keys(grouped).map((cat) => ({
        title: cat,
        data: grouped[cat],
      }));
      setSections(groupedSections);
    } catch (err) {
      console.error('Error loading process templates', err);
    } finally {
      setLoading(false);
    }
  }, []);

  // Fetch when opened
  useEffect(() => {
    if (visible) {
      fetchTemplates();
    } else {
      // reset selection when closing
      setSelectedIds(new Set());
    }
  }, [visible, fetchTemplates]);

  const toggleSelect = (template) => {
    const id = template.id;
    const disabled = existingStageKeys.includes(template.processKey);
    if (disabled) return; // ignore taps on already-added stages

    setSelectedIds((prev) => {
      const next = new Set(prev);
      if (next.has(id)) next.delete(id);
      else next.add(id);
      return next;
    });
  };

  const handleConfirm = () => {
    // flatten all sections to find selected templates
    const allTemplates = sections.flatMap((s) => s.data);
    const selected = allTemplates.filter((tpl) => selectedIds.has(tpl.id));
    onConfirm(selected);
    onClose();
  };

  const renderItem = ({ item }) => {
    const disabled = existingStageKeys.includes(item.processKey);
    const selected = disabled || selectedIds.has(item.id);
    const iconColor = disabled ? '#bbb' : selected ? '#4CAF50' : '#999';

    return (
      <TouchableOpacity
        style={[styles.itemRow, disabled && styles.disabledRow]}
        activeOpacity={disabled ? 1 : 0.6}
        onPress={() => toggleSelect(item)}
      >
        <Text style={[styles.itemText, disabled && styles.disabledText]}>
          {item.processName}
        </Text>
        {selected ? (
          <Ionicons name="checkbox" size={22} color={iconColor} />
        ) : (
          <Ionicons name="square-outline" size={22} color={iconColor} />
        )}
      </TouchableOpacity>
    );
  };

  const renderSectionHeader = ({ section: { title } }) => (
    <View style={styles.sectionHeader}>
      <Text style={styles.sectionHeaderText}>{title}</Text>
    </View>
  );

  return (
    <Modal
      visible={visible}
      animationType="slide"
      transparent
      onRequestClose={onClose}
    >
      <View style={styles.overlay}>
        <View style={styles.container}>
          <Text style={styles.title}>Ch·ªçn C√¥ng ƒëo·∫°n</Text>

          {loading ? (
            <View style={styles.loaderWrapper}>
              <ActivityIndicator size="large" color="#0066cc" />
            </View>
          ) : sections.length === 0 ||
            sections.every((s) => s.data.length === 0) ? (
            <View style={styles.emptyWrapper}>
              <Ionicons name="alert-circle-outline" size={40} color="#999" />
              <Text style={styles.emptyText}>Ch∆∞a c√≥ c√¥ng ƒëo·∫°n n√†o.</Text>
            </View>
          ) : (
            <SectionList
              sections={sections}
              keyExtractor={(item) => item.id}
              renderItem={renderItem}
              renderSectionHeader={renderSectionHeader}
              stickySectionHeadersEnabled={false}
              contentContainerStyle={styles.listContent}
            />
          )}

          {/* Actions */}
          <View style={styles.actions}>
            <TouchableOpacity style={styles.cancelBtn} onPress={onClose}>
              <Text style={styles.btnText}>H·ªßy</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[
                styles.confirmBtn,
                { opacity: selectedIds.size ? 1 : 0.5 },
              ]}
              disabled={!selectedIds.size}
              onPress={handleConfirm}
            >
              <Text style={[styles.btnText, { color: '#fff' }]}>Th√™m</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.4)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  container: {
    width: '90%',
    maxHeight: '80%',
    backgroundColor: '#fff',
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingBottom: 8,
    paddingTop: 12,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 12,
  },
  sectionHeader: {
    backgroundColor: '#f1f1f1',
    paddingVertical: 6,
    paddingHorizontal: 8,
    borderRadius: 6,
    marginTop: 8,
  },
  sectionHeaderText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
  },
  itemRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  itemText: {
    fontSize: 16,
    color: '#333',
    flex: 1,
  },
  listContent: {
    paddingBottom: 8,
  },
  loaderWrapper: {
    paddingVertical: 20,
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    marginTop: 12,
  },
  cancelBtn: {
    paddingVertical: 10,
    paddingHorizontal: 16,
    marginRight: 8,
  },
  confirmBtn: {
    backgroundColor: '#0066cc',
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 6,
  },
  btnText: {
    fontSize: 16,
  },
  emptyWrapper: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 20,
  },
  emptyText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
  },
  disabledRow: {
    backgroundColor: '#f4f4f4',
  },
  disabledText: {
    color: '#999',
  },
});

export default ProcessPickerModal;


--- END: src\components\ProcessPickerModal.js ---


--- START: src\components\SearchInventoryModal.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  FlatList,
  StyleSheet,
  Modal,
  ActivityIndicator,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import {
  getFirestore,
  collection,
  query,
  where,
  orderBy,
  getDocs,
  limit,
} from 'firebase/firestore';
import { useTheme } from '../contexts/ThemeContext';

export const SearchInventoryModal = ({ visible, onClose, onSelect }) => {
  const { theme } = useTheme();
  const [searchQuery, setSearchQuery] = useState('');
  const [items, setItems] = useState([]);
  const [filteredItems, setFilteredItems] = useState([]);
  const [loading, setLoading] = useState(false);
  const db = getFirestore();

  // Load inventory items when modal becomes visible
  useEffect(() => {
    if (visible) {
      loadInventoryItems();
    }
  }, [visible]);

  // Filter items when search query changes
  useEffect(() => {
    if (searchQuery.trim() === '') {
      setFilteredItems(items);
    } else {
      const query = searchQuery.toLowerCase();
      const filtered = items.filter(
        (item) =>
          item.name.toLowerCase().includes(query) ||
          (item.code && item.code.toLowerCase().includes(query)) ||
          (item.material && item.material.toLowerCase().includes(query))
      );
      setFilteredItems(filtered);
    }
  }, [searchQuery, items]);

  // Load inventory items from Firestore
  const loadInventoryItems = async () => {
    setLoading(true);
    try {
      console.log('=== SEARCHINVENTORYMODAL: B·∫ÆT ƒê·∫¶U LOAD ===');
      const inventoryRef = collection(db, 'inventory');

      let q;
      let snapshot;

      try {
        // Th·ª≠ query v·ªõi orderBy name tr∆∞·ªõc
        console.log('=== SEARCHINVENTORYMODAL: TH·ª¨ QUERY V·ªöI ORDERBY NAME ===');
        q = query(inventoryRef, orderBy('name'), limit(100));
        snapshot = await getDocs(q);
        console.log('=== SEARCHINVENTORYMODAL: QUERY ORDERBY TH√ÄNH C√îNG ===');
      } catch (orderByError) {
        console.log(
          '=== SEARCHINVENTORYMODAL: QUERY ORDERBY TH·∫§T B·∫†I, TH·ª¨ QUERY KH√îNG C√ì ORDERBY ==='
        );
        console.log('L·ªói orderBy:', orderByError.message);

        // Fallback: query kh√¥ng c√≥ orderBy
        q = query(inventoryRef, limit(100));
        snapshot = await getDocs(q);
        console.log(
          '=== SEARCHINVENTORYMODAL: QUERY KH√îNG C√ì ORDERBY TH√ÄNH C√îNG ==='
        );
      }

      const inventoryItems = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));

      console.log('=== SEARCHINVENTORYMODAL: D·ªÆ LI·ªÜU ƒê√É LOAD ===');
      console.log('S·ªë l∆∞·ª£ng items:', inventoryItems.length);

      // S·∫Øp x·∫øp th·ªß c√¥ng theo t√™n n·∫øu c·∫ßn
      const sortedItems = inventoryItems.sort((a, b) => {
        const aName = (a.name || '').toLowerCase();
        const bName = (b.name || '').toLowerCase();
        return aName.localeCompare(bName);
      });

      setItems(sortedItems);
      setFilteredItems(sortedItems);

      console.log('=== SEARCHINVENTORYMODAL: HO√ÄN TH√ÄNH LOAD ===');
    } catch (error) {
      console.error('=== SEARCHINVENTORYMODAL: L·ªñI LOAD ===');
      console.error('Error loading inventory items:', error);
      console.error('Error details:', error.message, error.code);
    } finally {
      setLoading(false);
    }
  };

  // Format currency
  const formatCurrency = (amount) => {
    if (!amount) return '0 ƒë';
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
      minimumFractionDigits: 0,
    }).format(amount);
  };

  // Render inventory item
  const renderItem = ({ item }) => (
    <TouchableOpacity
      style={[styles.itemContainer, { backgroundColor: theme.cardBackground }]}
      onPress={() => onSelect(item)}
    >
      <View style={styles.itemInfo}>
        <Text style={[styles.itemName, { color: theme.text }]}>
          {item.name}
        </Text>
        <Text style={[styles.itemCode, { color: theme.textSecondary }]}>
          M√£: {item.code}
        </Text>
        {item.material && (
          <Text style={[styles.itemDetail, { color: theme.textSecondary }]}>
            {item.material} {item.weight ? `- ${item.weight} kg` : ''}
          </Text>
        )}
      </View>
      <View style={styles.itemStats}>
        <Text style={[styles.itemPrice, { color: theme.text }]}>
          {formatCurrency(item.price)}
        </Text>
        <Text style={[styles.itemStock, { color: theme.textSecondary }]}>
          T·ªìn: {item.stockQuantity} {item.unit}
        </Text>
      </View>
      <View style={styles.iconContainer}>
        <Ionicons name="add-circle" size={24} color={theme.primary} />
      </View>
    </TouchableOpacity>
  );

  return (
    <Modal
      visible={visible}
      animationType="slide"
      transparent={true}
      onRequestClose={onClose}
    >
      <View
        style={[styles.modalOverlay, { backgroundColor: 'rgba(0,0,0,0.5)' }]}
      >
        <View
          style={[styles.modalContainer, { backgroundColor: theme.background }]}
        >
          <View style={styles.header}>
            <TouchableOpacity onPress={onClose}>
              <Ionicons name="close" size={24} color={theme.text} />
            </TouchableOpacity>
            <Text style={[styles.title, { color: theme.text }]}>
              Ch·ªçn v·∫≠t t∆∞
            </Text>
            <View style={{ width: 24 }} />
          </View>

          <View
            style={[
              styles.searchContainer,
              { backgroundColor: theme.inputBackground },
            ]}
          >
            <Ionicons name="search" size={20} color={theme.textSecondary} />
            <TextInput
              style={[styles.searchInput, { color: theme.text }]}
              placeholder="T√¨m t√™n, m√£ ho·∫∑c v·∫≠t li·ªáu"
              placeholderTextColor={theme.textSecondary}
              value={searchQuery}
              onChangeText={setSearchQuery}
            />
            {searchQuery ? (
              <TouchableOpacity onPress={() => setSearchQuery('')}>
                <Ionicons
                  name="close-circle"
                  size={20}
                  color={theme.textSecondary}
                />
              </TouchableOpacity>
            ) : null}
          </View>

          {loading ? (
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color={theme.primary} />
              <Text
                style={[styles.loadingText, { color: theme.textSecondary }]}
              >
                ƒêang t·∫£i v·∫≠t t∆∞...
              </Text>
            </View>
          ) : (
            <>
              <Text
                style={[styles.resultCount, { color: theme.textSecondary }]}
              >
                {filteredItems.length} v·∫≠t t∆∞
              </Text>

              <FlatList
                data={filteredItems}
                keyExtractor={(item) => item.id}
                renderItem={renderItem}
                contentContainerStyle={styles.listContent}
                ItemSeparatorComponent={() => (
                  <View
                    style={[
                      styles.separator,
                      { backgroundColor: theme.border },
                    ]}
                  />
                )}
                ListEmptyComponent={() => (
                  <View style={styles.emptyContainer}>
                    <Ionicons
                      name="alert-circle-outline"
                      size={48}
                      color={theme.textSecondary}
                    />
                    <Text
                      style={[styles.emptyText, { color: theme.textSecondary }]}
                    >
                      {searchQuery
                        ? 'Kh√¥ng t√¨m th·∫•y v·∫≠t t∆∞ ph√π h·ª£p'
                        : 'Ch∆∞a c√≥ v·∫≠t t∆∞ n√†o trong kho'}
                    </Text>
                  </View>
                )}
              />
            </>
          )}
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    width: '90%',
    height: '80%',
    borderRadius: 12,
    overflow: 'hidden',
    paddingHorizontal: 16,
    paddingBottom: 16,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 16,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 8,
    marginBottom: 16,
  },
  searchInput: {
    flex: 1,
    marginLeft: 8,
    marginRight: 8,
    fontSize: 16,
  },
  resultCount: {
    marginBottom: 8,
    fontSize: 14,
  },
  listContent: {
    paddingBottom: 16,
  },
  itemContainer: {
    flexDirection: 'row',
    padding: 12,
    borderRadius: 8,
    marginVertical: 4,
  },
  itemInfo: {
    flex: 2,
    justifyContent: 'center',
  },
  itemName: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  itemCode: {
    fontSize: 14,
    marginBottom: 2,
  },
  itemDetail: {
    fontSize: 14,
  },
  itemStats: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'flex-end',
  },
  itemPrice: {
    fontWeight: 'bold',
    fontSize: 14,
    marginBottom: 4,
  },
  itemStock: {
    fontSize: 12,
  },
  iconContainer: {
    width: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  separator: {
    height: 1,
    marginVertical: 4,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 60,
  },
  emptyText: {
    marginTop: 12,
    fontSize: 16,
    textAlign: 'center',
  },
});

export default SearchInventoryModal;


--- END: src\components\SearchInventoryModal.js ---


--- START: src\components\StageAssignmentModal.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  Modal,
  StyleSheet,
  TouchableOpacity,
  FlatList,
  ActivityIndicator,
  TextInput,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import {
  collection,
  query,
  where,
  getDocs,
  getFirestore,
} from 'firebase/firestore';
import { useTheme } from '../contexts/ThemeContext';

const StageAssignmentModal = ({
  visible,
  onClose,
  onAssign,
  projectId,
  selectedStage,
  projectStages,
  navigation,
}) => {
  const { theme } = useTheme();
  const [loading, setLoading] = useState(false);
  const [workers, setWorkers] = useState([]);
  const [filteredWorkers, setFilteredWorkers] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedStageId, setSelectedStageId] = useState(null);
  const [selectedWorkerId, setSelectedWorkerId] = useState(null);

  // Update selectedStageId when selectedStage prop changes
  useEffect(() => {
    if (selectedStage) {
      setSelectedStageId(selectedStage.stageId);
    } else {
      setSelectedStageId(null);
    }
  }, [selectedStage]);

  useEffect(() => {
    if (visible) {
      console.log('Modal opened, loading workers...');
      console.log('Project stages:', projectStages);
      loadWorkers();
    }
  }, [visible, projectStages]);

  useEffect(() => {
    if (searchQuery.trim() === '') {
      setFilteredWorkers(workers);
    } else {
      const query = searchQuery.toLowerCase();
      const filtered = workers.filter(
        (worker) =>
          (worker.displayName &&
            worker.displayName.toLowerCase().includes(query)) ||
          (worker.email && worker.email.toLowerCase().includes(query))
      );
      setFilteredWorkers(filtered);
    }
  }, [searchQuery, workers]);

  const loadWorkers = async () => {
    try {
      setLoading(true);
      const db = getFirestore();
      const usersRef = collection(db, 'users');
      const q = query(usersRef, where('role', 'in', ['ky_su', 'cong_nhan']));

      const querySnapshot = await getDocs(q);
      const workersList = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));

      console.log('Loaded workers:', workersList.length);
      setWorkers(workersList);
      setFilteredWorkers(workersList);
    } catch (error) {
      console.error('Error loading workers:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleSelectStage = (stageId) => {
    setSelectedStageId(stageId);
  };

  const handleSelectWorker = (workerId) => {
    setSelectedWorkerId(workerId);
  };

  const handleAssign = () => {
    if (selectedStageId && selectedWorkerId) {
      const selectedWorker = workers.find((w) => w.id === selectedWorkerId);
      const selectedStage = projectStages.find(
        (s) => s.stageId === selectedStageId
      );

      if (selectedWorker && selectedStage) {
        onAssign(
          selectedStageId,
          selectedWorkerId,
          selectedWorker.displayName || selectedWorker.email
        );
      }
    }
  };

  const handleViewStageDetails = () => {
    if (selectedStageId) {
      const selectedStage = projectStages.find(
        (s) => s.stageId === selectedStageId
      );
      if (selectedStage) {
        onClose();
        navigation.navigate('StageDetail', { projectId, stage: selectedStage });
      }
    }
  };

  const renderStageItem = ({ item }) => {
    console.log('Rendering stage item:', item);
    const isSelected = selectedStageId === item.stageId;
    const statusColor =
      item.status === 'completed'
        ? '#4CAF50'
        : item.status === 'in_progress'
        ? '#FFD54F'
        : '#9E9E9E';

    return (
      <TouchableOpacity
        style={[styles.stageItem, isSelected && styles.selectedStageItem]}
        onPress={() => handleSelectStage(item.stageId)}
      >
        <View style={styles.stageInfo}>
          <Text style={styles.stageName}>{item.processName}</Text>
          <View style={[styles.statusBadge, { backgroundColor: statusColor }]}>
            <Text style={styles.statusText}>
              {item.status === 'completed'
                ? 'Ho√†n th√†nh'
                : item.status === 'in_progress'
                ? 'ƒêang l√†m'
                : 'Ch·ªù x·ª≠ l√Ω'}
            </Text>
          </View>
        </View>
        {isSelected && (
          <Ionicons name="checkmark-circle" size={24} color="#4CAF50" />
        )}
      </TouchableOpacity>
    );
  };

  const renderWorkerItem = ({ item }) => {
    console.log('Rendering worker item:', item);
    const isSelected = selectedWorkerId === item.id;
    const displayName =
      item.displayName || item.email || 'Ng∆∞·ªùi d√πng kh√¥ng x√°c ƒë·ªãnh';
    const role = item.role === 'ky_su' ? 'K·ªπ s∆∞' : 'C√¥ng nh√¢n';

    return (
      <TouchableOpacity
        style={[styles.workerItem, isSelected && styles.selectedWorkerItem]}
        onPress={() => handleSelectWorker(item.id)}
      >
        <View style={styles.workerAvatar}>
          <Text style={styles.workerInitial}>
            {displayName.charAt(0).toUpperCase()}
          </Text>
        </View>
        <View style={styles.workerInfo}>
          <Text style={styles.workerName}>{displayName}</Text>
          <Text style={styles.workerRole}>{role}</Text>
        </View>
        {isSelected && (
          <Ionicons name="checkmark-circle" size={24} color="#4CAF50" />
        )}
      </TouchableOpacity>
    );
  };

  console.log('Rendering modal with:', {
    visible,
    projectStages: projectStages?.length || 0,
    workers: workers?.length || 0,
    filteredWorkers: filteredWorkers?.length || 0,
  });

  return (
    <Modal
      visible={visible}
      transparent
      animationType="slide"
      onRequestClose={onClose}
    >
      <View style={styles.modalOverlay}>
        <View style={styles.modalContainer}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>Ph√¢n c√¥ng c√¥ng vi·ªác</Text>
            <TouchableOpacity onPress={onClose} style={styles.closeButton}>
              <Ionicons name="close" size={24} color="#000" />
            </TouchableOpacity>
          </View>

          <View style={styles.sectionsContainer}>
            {/* Stages Section */}
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Ch·ªçn C√¥ng ƒëo·∫°n:</Text>
              <FlatList
                data={projectStages || []}
                keyExtractor={(item) => item.stageId || item.id}
                renderItem={renderStageItem}
                style={{ flex: 1 }}
                contentContainerStyle={{ paddingBottom: 8 }}
                showsVerticalScrollIndicator={true}
                ListEmptyComponent={
                  <View style={styles.emptyContainer}>
                    <Text style={styles.emptyMessage}>
                      Kh√¥ng c√≥ c√¥ng ƒëo·∫°n n√†o
                    </Text>
                  </View>
                }
              />

              {selectedStageId && (
                <TouchableOpacity
                  style={styles.viewDetailsButton}
                  onPress={handleViewStageDetails}
                >
                  <Ionicons name="eye-outline" size={18} color="#fff" />
                  <Text style={styles.viewDetailsText}>
                    Xem chi ti·∫øt c√¥ng ƒëo·∫°n
                  </Text>
                </TouchableOpacity>
              )}
            </View>

            {/* Workers Section */}
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Ch·ªçn Ng∆∞·ªùi th·ª±c hi·ªán:</Text>
              <View style={styles.searchContainer}>
                <Ionicons
                  name="search"
                  size={20}
                  color="#666"
                  style={styles.searchIcon}
                />
                <TextInput
                  style={styles.searchInput}
                  placeholder="T√¨m ki·∫øm ng∆∞·ªùi th·ª±c hi·ªán..."
                  value={searchQuery}
                  onChangeText={setSearchQuery}
                  autoCapitalize="none"
                />
              </View>

              {loading ? (
                <ActivityIndicator
                  size="large"
                  color="#0066cc"
                  style={styles.loader}
                />
              ) : (
                <FlatList
                  data={filteredWorkers || []}
                  keyExtractor={(item) => item.id}
                  renderItem={renderWorkerItem}
                  style={{ flex: 1 }}
                  contentContainerStyle={{ paddingBottom: 8 }}
                  showsVerticalScrollIndicator={true}
                  ListEmptyComponent={
                    <View style={styles.emptyContainer}>
                      <Text style={styles.emptyMessage}>
                        {searchQuery
                          ? 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi ph√π h·ª£p'
                          : 'Kh√¥ng c√≥ ng∆∞·ªùi th·ª±c hi·ªán n√†o'}
                      </Text>
                    </View>
                  }
                />
              )}
            </View>
          </View>

          <View style={styles.actionButtons}>
            <TouchableOpacity
              style={[styles.button, styles.cancelButton]}
              onPress={onClose}
            >
              <Text style={styles.cancelButtonText}>H·ªßy</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[
                styles.button,
                styles.assignButton,
                (!selectedStageId || !selectedWorkerId) &&
                  styles.disabledButton,
              ]}
              onPress={handleAssign}
              disabled={!selectedStageId || !selectedWorkerId}
            >
              <Text style={styles.assignButtonText}>Ph√¢n c√¥ng</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContainer: {
    width: '95%',
    height: '80%',
    backgroundColor: '#fff',
    borderRadius: 12,
    overflow: 'hidden',
    flexDirection: 'column',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    backgroundColor: '#fff',
    flexShrink: 0,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  closeButton: {
    padding: 4,
  },
  sectionsContainer: {
    flex: 1,
    flexDirection: 'column',
  },
  section: {
    flex: 1,
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 12,
  },

  stageItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  selectedStageItem: {
    backgroundColor: 'rgba(0, 102, 204, 0.05)',
  },
  stageInfo: {
    flex: 1,
  },
  stageName: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 4,
  },
  statusBadge: {
    alignSelf: 'flex-start',
    paddingVertical: 4,
    paddingHorizontal: 8,
    borderRadius: 12,
    marginTop: 4,
  },
  statusText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
    marginBottom: 16,
    borderRadius: 8,
    paddingHorizontal: 12,
    height: 44,
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    height: 44,
    fontSize: 16,
  },

  workerItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  selectedWorkerItem: {
    backgroundColor: 'rgba(0, 102, 204, 0.05)',
  },
  workerAvatar: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#0066cc',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  workerInitial: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
  },
  workerInfo: {
    flex: 1,
  },
  workerName: {
    fontSize: 16,
    fontWeight: '500',
  },
  workerRole: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  viewDetailsButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#0066cc',
    padding: 10,
    borderRadius: 8,
    marginTop: 8,
    flexShrink: 0,
  },
  viewDetailsText: {
    color: '#fff',
    marginLeft: 8,
    fontWeight: '500',
  },
  actionButtons: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
    backgroundColor: '#fff',
    flexShrink: 0,
  },
  button: {
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 8,
    marginLeft: 8,
  },
  cancelButton: {
    backgroundColor: '#f1f1f1',
  },
  cancelButtonText: {
    color: '#333',
    fontWeight: '500',
  },
  assignButton: {
    backgroundColor: '#0066cc',
  },
  assignButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
  disabledButton: {
    opacity: 0.5,
  },
  loader: {
    marginVertical: 32,
  },
  emptyMessage: {
    padding: 16,
    textAlign: 'center',
    color: '#666',
    fontSize: 14,
    fontStyle: 'italic',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    minHeight: 80,
  },
});

export default StageAssignmentModal;


--- END: src\components\StageAssignmentModal.js ---


--- START: src\components\StageIconManager.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  FlatList,
  Modal,
  Alert,
  Image,
} from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import * as FileSystem from 'expo-file-system';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Ionicons } from '@expo/vector-icons';
import {
  STAGE_ICONS,
  AVAILABLE_ICONS,
  getStageIcon,
} from '../utils/stageIcons';

/**
 * Component ƒë·ªÉ qu·∫£n l√Ω v√† thay ƒë·ªïi icon cho c√°c stage
 */
const StageIconManager = ({
  visible,
  onClose,
  onIconSelect,
  currentProcessKey,
}) => {
  const [selectedCategory, setSelectedCategory] = useState('tools');
  const [selectedIcon, setSelectedIcon] = useState(
    getStageIcon(currentProcessKey)
  );
  const [customIcons, setCustomIcons] = useState([]);
  const [isCustomIcon, setIsCustomIcon] = useState(false);
  const [imageErrors, setImageErrors] = useState({});

  const categories = [...Object.keys(AVAILABLE_ICONS), 'custom'];

  // Load custom icons khi component mount
  useEffect(() => {
    loadCustomIcons();
  }, []);

  const loadCustomIcons = async () => {
    try {
      const saved = await AsyncStorage.getItem('customIconFiles');
      if (saved) {
        setCustomIcons(JSON.parse(saved));
        // Reset image errors khi load l·∫°i
        setImageErrors({});
      }
    } catch (error) {
      console.error('Error loading custom icons:', error);
    }
  };

  const saveCustomIcons = async (icons) => {
    try {
      await AsyncStorage.setItem('customIconFiles', JSON.stringify(icons));
      setCustomIcons(icons);
    } catch (error) {
      console.error('Error saving custom icons:', error);
    }
  };

  const handleIconSelect = (iconName, isCustom = false) => {
    setSelectedIcon(iconName);
    setIsCustomIcon(isCustom);
  };

  const uploadCustomIcon = async () => {
    try {
      // Request permission
      const { status } =
        await ImagePicker.requestMediaLibraryPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert('L·ªói', 'C·∫ßn quy·ªÅn truy c·∫≠p th∆∞ vi·ªán ·∫£nh ƒë·ªÉ upload icon');
        return;
      }

      // Pick image
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        aspect: [1, 1], // Square aspect ratio
        quality: 0.8,
        base64: false, // Kh√¥ng c·∫ßn base64, d√πng URI tr·ª±c ti·∫øp
      });

      if (!result.canceled && result.assets[0]) {
        const asset = result.assets[0];

        // Create unique filename
        const timestamp = Date.now();
        const filename = `custom_icon_${timestamp}.png`;
        const fileUri = `${FileSystem.documentDirectory}${filename}`;

        // Copy image to app's document directory
        await FileSystem.copyAsync({
          from: asset.uri,
          to: fileUri,
        });

        // Verify file exists
        const fileInfo = await FileSystem.getInfoAsync(fileUri);
        console.log('File info:', fileInfo);

        // Add to custom icons list
        const newIcon = {
          id: timestamp.toString(),
          name: `Custom ${customIcons.length + 1}`,
          uri: fileUri,
          filename: filename,
          originalUri: asset.uri, // Keep original for debugging
        };

        console.log('New custom icon:', newIcon);

        const updatedIcons = [...customIcons, newIcon];
        await saveCustomIcons(updatedIcons);

        Alert.alert(
          'Th√†nh c√¥ng',
          `ƒê√£ upload icon t√πy ch·ªânh!\nFile: ${filename}`
        );

        // Switch to custom category to show the new icon
        setSelectedCategory('custom');
      }
    } catch (error) {
      console.error('Error uploading custom icon:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ upload icon. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  };

  const deleteCustomIcon = async (iconId) => {
    Alert.alert('X√°c nh·∫≠n x√≥a', 'B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a icon n√†y?', [
      { text: 'H·ªßy', style: 'cancel' },
      {
        text: 'X√≥a',
        style: 'destructive',
        onPress: async () => {
          try {
            const iconToDelete = customIcons.find((icon) => icon.id === iconId);
            if (iconToDelete) {
              // Delete file from storage
              await FileSystem.deleteAsync(iconToDelete.uri, {
                idempotent: true,
              });

              // Remove from list
              const updatedIcons = customIcons.filter(
                (icon) => icon.id !== iconId
              );
              await saveCustomIcons(updatedIcons);

              Alert.alert('Th√†nh c√¥ng', 'ƒê√£ x√≥a icon t√πy ch·ªânh!');
            }
          } catch (error) {
            console.error('Error deleting custom icon:', error);
            Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ x√≥a icon.');
          }
        },
      },
    ]);
  };

  const handleConfirm = () => {
    if (isCustomIcon) {
      // For custom icons, pass the full icon object
      const customIcon = customIcons.find((icon) => icon.id === selectedIcon);
      onIconSelect(currentProcessKey, customIcon, true);
    } else {
      // For regular icons, pass the icon name
      onIconSelect(currentProcessKey, selectedIcon, false);
    }
    onClose();
  };

  const renderIconItem = ({ item }) => (
    <TouchableOpacity
      style={[
        styles.iconItem,
        selectedIcon === item && styles.selectedIconItem,
      ]}
      onPress={() => handleIconSelect(item, false)}
    >
      <Ionicons
        name={item}
        size={24}
        color={selectedIcon === item ? '#007AFF' : '#666'}
      />
      <Text style={styles.iconName}>{item}</Text>
    </TouchableOpacity>
  );

  const renderCustomIconItem = ({ item }) => {
    const hasError = imageErrors[item.id];

    return (
      <TouchableOpacity
        style={[
          styles.iconItem,
          selectedIcon === item.id && styles.selectedIconItem,
        ]}
        onPress={() => handleIconSelect(item.id, true)}
      >
        {!hasError ? (
          <Image
            source={{ uri: item.uri }}
            style={styles.customIconImage}
            onError={(error) => {
              console.error('Error loading custom icon:', error);
              setImageErrors((prev) => ({ ...prev, [item.id]: true }));
            }}
            onLoad={() => {
              console.log('Custom icon loaded successfully:', item.uri);
              setImageErrors((prev) => ({ ...prev, [item.id]: false }));
            }}
          />
        ) : (
          <View style={styles.fallbackIconContainer}>
            <Ionicons name="image-outline" size={20} color="#999" />
          </View>
        )}
        <Text style={styles.iconName}>{item.name}</Text>
        <TouchableOpacity
          style={styles.deleteIconButton}
          onPress={() => deleteCustomIcon(item.id)}
        >
          <Ionicons name="close-circle" size={16} color="#FF6B6B" />
        </TouchableOpacity>
      </TouchableOpacity>
    );
  };

  const renderCategoryButton = (category) => {
    const categoryLabel = category === 'custom' ? 'T√πy ch·ªânh' : category;

    return (
      <TouchableOpacity
        key={category}
        style={[
          styles.categoryButton,
          selectedCategory === category && styles.selectedCategoryButton,
        ]}
        onPress={() => setSelectedCategory(category)}
      >
        <Text
          style={[
            styles.categoryText,
            selectedCategory === category && styles.selectedCategoryText,
          ]}
        >
          {categoryLabel}
        </Text>
      </TouchableOpacity>
    );
  };

  return (
    <Modal
      visible={visible}
      animationType="slide"
      presentationStyle="pageSheet"
    >
      <View style={styles.container}>
        <View style={styles.header}>
          <TouchableOpacity onPress={onClose}>
            <Text style={styles.cancelButton}>H·ªßy</Text>
          </TouchableOpacity>
          <Text style={styles.title}>Ch·ªçn Icon cho {currentProcessKey}</Text>
          <TouchableOpacity onPress={handleConfirm}>
            <Text style={styles.confirmButton}>X√°c nh·∫≠n</Text>
          </TouchableOpacity>
        </View>

        <View style={styles.previewContainer}>
          <Text style={styles.previewLabel}>Xem tr∆∞·ªõc:</Text>
          <View style={styles.previewIcon}>
            <Ionicons name={selectedIcon} size={40} color="#007AFF" />
          </View>
          <Text style={styles.previewText}>{selectedIcon}</Text>
        </View>

        <View style={styles.categoriesContainer}>
          <Text style={styles.sectionTitle}>Danh m·ª•c:</Text>
          <View style={styles.categoriesRow}>
            {categories.map(renderCategoryButton)}
          </View>
        </View>

        <View style={styles.iconsContainer}>
          <View style={styles.sectionHeaderContainer}>
            <Text style={styles.sectionTitle}>
              {selectedCategory === 'custom'
                ? 'Icons t√πy ch·ªânh:'
                : `Icons trong danh m·ª•c "${selectedCategory}":`}
            </Text>
            {selectedCategory === 'custom' && (
              <TouchableOpacity
                style={styles.uploadButton}
                onPress={uploadCustomIcon}
              >
                <Ionicons name="add-circle" size={24} color="#007AFF" />
                <Text style={styles.uploadButtonText}>Upload</Text>
              </TouchableOpacity>
            )}
          </View>

          {selectedCategory === 'custom' ? (
            customIcons.length > 0 ? (
              <FlatList
                data={customIcons}
                renderItem={renderCustomIconItem}
                keyExtractor={(item) => item.id}
                numColumns={3}
                contentContainerStyle={styles.iconsList}
              />
            ) : (
              <View style={styles.emptyContainer}>
                <Ionicons name="images-outline" size={48} color="#ccc" />
                <Text style={styles.emptyText}>Ch∆∞a c√≥ icon t√πy ch·ªânh</Text>
                <Text style={styles.emptySubText}>
                  B·∫•m n√∫t "Upload" ƒë·ªÉ th√™m icon c·ªßa b·∫°n
                </Text>
              </View>
            )
          ) : (
            <FlatList
              data={AVAILABLE_ICONS[selectedCategory]}
              renderItem={renderIconItem}
              keyExtractor={(item) => item}
              numColumns={3}
              contentContainerStyle={styles.iconsList}
            />
          )}
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  cancelButton: {
    color: '#666',
    fontSize: 16,
  },
  confirmButton: {
    color: '#007AFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  previewContainer: {
    alignItems: 'center',
    padding: 20,
    backgroundColor: '#f8f8f8',
  },
  previewLabel: {
    fontSize: 16,
    marginBottom: 10,
  },
  previewIcon: {
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: '#fff',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  previewText: {
    fontSize: 12,
    color: '#666',
  },
  categoriesContainer: {
    padding: 16,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  categoriesRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  categoryButton: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    marginRight: 8,
    marginBottom: 8,
    backgroundColor: '#f0f0f0',
    borderRadius: 16,
  },
  selectedCategoryButton: {
    backgroundColor: '#007AFF',
  },
  categoryText: {
    fontSize: 14,
    color: '#666',
  },
  selectedCategoryText: {
    color: '#fff',
  },
  iconsContainer: {
    flex: 1,
    padding: 16,
  },
  iconsList: {
    paddingBottom: 20,
  },
  iconItem: {
    flex: 1,
    alignItems: 'center',
    padding: 16,
    margin: 4,
    backgroundColor: '#f8f8f8',
    borderRadius: 8,
    borderWidth: 2,
    borderColor: 'transparent',
  },
  selectedIconItem: {
    borderColor: '#007AFF',
    backgroundColor: '#e3f2fd',
  },
  iconName: {
    fontSize: 10,
    marginTop: 4,
    textAlign: 'center',
    color: '#666',
  },
  sectionHeaderContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  uploadButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 6,
    backgroundColor: '#e3f2fd',
    borderRadius: 16,
  },
  uploadButtonText: {
    marginLeft: 4,
    fontSize: 14,
    color: '#007AFF',
    fontWeight: '500',
  },
  customIconImage: {
    width: 24,
    height: 24,
    resizeMode: 'contain',
    borderRadius: 4,
  },
  fallbackIconContainer: {
    width: 24,
    height: 24,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
    borderRadius: 4,
  },
  deleteIconButton: {
    position: 'absolute',
    top: -4,
    right: -4,
    backgroundColor: '#fff',
    borderRadius: 8,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 40,
  },
  emptyText: {
    fontSize: 16,
    color: '#666',
    marginTop: 12,
    fontWeight: '500',
  },
  emptySubText: {
    fontSize: 14,
    color: '#999',
    marginTop: 4,
    textAlign: 'center',
  },
});

export default StageIconManager;


--- END: src\components\StageIconManager.js ---


--- START: src\components\StatusIndicator.js ---
//src/components/StatusIndicator.js
import React from 'react';
import { View, StyleSheet, Platform } from 'react-native';

/**
 * Component hi·ªÉn th·ªã tr·∫°ng th√°i c√¥ng vi·ªác d∆∞·ªõi d·∫°ng h√¨nh tr√≤n c√≥ m√†u s·∫Øc
 * @param {Object} props - Props c·ªßa component
 * @param {string} props.status - Tr·∫°ng th√°i c√¥ng vi·ªác (pending, in_progress, completed)
 * @param {number} props.size - K√≠ch th∆∞·ªõc c·ªßa h√¨nh tr√≤n (m·∫∑c ƒë·ªãnh: 16)
 * @returns {React.Component} StatusIndicator component
 */
const StatusIndicator = ({ status, size = 16 }) => {
  // X√°c ƒë·ªãnh m√†u s·∫Øc d·ª±a tr√™n tr·∫°ng th√°i
  const getStatusColor = () => {
    switch (status) {
      case 'completed':
        return '#4CAF50'; // Xanh l√°
      case 'in_progress':
        return '#FFC107'; // V√†ng
      case 'pending':
        return '#FF9800'; // Cam
      default:
        return '#9E9E9E'; // X√°m
    }
  };

  return (
    <View
      style={[
        styles.indicator,
        {
          backgroundColor: getStatusColor(),
          width: size,
          height: size,
          borderRadius: size / 2,
        },
      ]}
    />
  );
};

const styles = StyleSheet.create({
  indicator: {
    // ƒê·ªï b√≥ng cho iOS
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.3,
    shadowRadius: 2,
    // ƒê·ªï b√≥ng cho Android
    elevation: 4,
    // C√°c style kh√°c
    marginRight: 10,
    borderWidth: 1,
    borderColor: 'rgba(0,0,0,0.05)',
  },
});

export default StatusIndicator;


--- END: src\components\StatusIndicator.js ---


--- START: src\components\StyledTextInput.js ---
import React, { forwardRef } from 'react';
import { TextInput, StyleSheet, View, Text } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

/**
 * Component TextInput t√πy ch·ªânh v√† nh·∫•t qu√°n cho to√†n b·ªô ·ª©ng d·ª•ng
 * @param {Object} props - Props c·ªßa component
 * @param {string} props.label - Nh√£n cho tr∆∞·ªùng nh·∫≠p li·ªáu
 * @param {string} props.iconName - T√™n bi·ªÉu t∆∞·ª£ng Ionicons (t√πy ch·ªçn)
 * @param {string} props.error - Th√¥ng b√°o l·ªói (t√πy ch·ªçn)
 * @param {Object} props.containerStyle - Style cho container (t√πy ch·ªçn)
 * @param {Object} props.inputStyle - Style cho input (t√πy ch·ªçn)
 * @param {boolean} props.required - ƒê√°nh d·∫•u tr∆∞·ªùng b·∫Øt bu·ªôc (t√πy ch·ªçn)
 * @returns {React.Component} StyledTextInput component
 */
const StyledTextInput = forwardRef(
  (
    {
      label,
      iconName,
      error,
      containerStyle,
      inputStyle,
      required = false,
      ...props
    },
    ref
  ) => {
    return (
      <View style={[styles.container, containerStyle]}>
        {label && (
          <Text style={styles.label}>
            {label}
            {required && <Text style={styles.requiredMark}>*</Text>}
          </Text>
        )}

        <View
          style={[
            styles.inputContainer,
            error ? styles.inputContainerError : null,
          ]}
        >
          {iconName && (
            <Ionicons
              name={iconName}
              size={20}
              color="#666"
              style={styles.icon}
            />
          )}

          <TextInput
            ref={ref}
            style={[styles.input, inputStyle]}
            placeholderTextColor="#999"
            {...props}
          />

          {props.secureTextEntry !== undefined && (
            <View style={styles.rightIconContainer}>{props.rightIcon}</View>
          )}
        </View>

        {error && <Text style={styles.errorText}>{error}</Text>}
      </View>
    );
  }
);

const styles = StyleSheet.create({
  container: {
    marginBottom: 16,
  },
  label: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    marginBottom: 6,
  },
  requiredMark: {
    color: '#e74c3c',
    marginLeft: 4,
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    backgroundColor: '#f9f9f9',
    height: 50,
    paddingHorizontal: 12,
  },
  inputContainerError: {
    borderColor: '#e74c3c',
  },
  icon: {
    marginRight: 10,
  },
  input: {
    flex: 1,
    height: 50,
    fontSize: 16,
    color: '#333',
  },
  rightIconContainer: {
    paddingLeft: 8,
  },
  errorText: {
    color: '#e74c3c',
    fontSize: 12,
    marginTop: 4,
    marginLeft: 4,
  },
});

export default StyledTextInput;


--- END: src\components\StyledTextInput.js ---


--- START: src\components\SupplierPickerModal.js ---
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Modal,
  TouchableOpacity,
  FlatList,
  ActivityIndicator,
  TextInput,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { getAllSuppliers } from '../api/supplierService';

const SupplierPickerModal = ({ visible, onClose, onSelect }) => {
  const [loading, setLoading] = useState(true);
  const [suppliers, setSuppliers] = useState([]);
  const [search, setSearch] = useState('');

  useEffect(() => {
    if (visible) {
      fetchSuppliers();
    }
  }, [visible]);

  const fetchSuppliers = async () => {
    setLoading(true);
    try {
      const data = await getAllSuppliers();
      setSuppliers(data);
    } catch (err) {
      console.error('Load suppliers error:', err);
    } finally {
      setLoading(false);
    }
  };

  const filtered = suppliers.filter((s) =>
    s.name.toLowerCase().includes(search.toLowerCase())
  );

  const renderItem = ({ item }) => (
    <TouchableOpacity
      style={styles.item}
      onPress={() => {
        onSelect(item);
        onClose();
      }}
    >
      <Text style={styles.name}>{item.name}</Text>
      {item.address ? <Text style={styles.sub}>{item.address}</Text> : null}
    </TouchableOpacity>
  );

  return (
    <Modal visible={visible} transparent animationType="slide">
      <View style={styles.overlay}>
        <View style={styles.container}>
          <View style={styles.header}>
            <Text style={styles.title}>Ch·ªçn nh√† cung c·∫•p</Text>
            <TouchableOpacity onPress={onClose}>
              <Ionicons name="close" size={24} color="#333" />
            </TouchableOpacity>
          </View>

          <View style={styles.searchBar}>
            <Ionicons name="search" size={18} color="#666" />
            <TextInput
              style={styles.searchInput}
              placeholder="T√¨m ki·∫øm..."
              value={search}
              onChangeText={setSearch}
            />
          </View>

          {loading ? (
            <ActivityIndicator size="large" color="#0066cc" />
          ) : (
            <FlatList
              data={filtered}
              keyExtractor={(item) => item.id}
              renderItem={renderItem}
              ItemSeparatorComponent={() => <View style={styles.separator} />}
            />
          )}
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.4)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  container: {
    width: '90%',
    maxHeight: '80%',
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  title: { fontSize: 18, fontWeight: 'bold', color: '#333' },
  searchBar: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 6,
    paddingHorizontal: 8,
    marginBottom: 12,
  },
  searchInput: { flex: 1, paddingVertical: 6, marginLeft: 6 },
  item: { paddingVertical: 10 },
  name: { fontSize: 16, fontWeight: '500', color: '#333' },
  sub: { fontSize: 12, color: '#666', marginTop: 2 },
  separator: { height: 1, backgroundColor: '#eee' },
});

export default SupplierPickerModal;


--- END: src\components\SupplierPickerModal.js ---


--- START: src\components\TaskAssignmentModal.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  Modal,
  StyleSheet,
  TouchableOpacity,
  FlatList,
  ActivityIndicator,
  TextInput,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { getAssignableUsers } from '../api/projectService';

const TaskAssignmentModal = ({
  visible,
  onClose,
  onAssign,
  taskName,
  currentAssignee,
}) => {
  const [loading, setLoading] = useState(true);
  const [users, setUsers] = useState([]);
  const [filteredUsers, setFilteredUsers] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedUserId, setSelectedUserId] = useState(currentAssignee || null);

  useEffect(() => {
    if (visible) {
      loadUsers();
    }
  }, [visible]);

  useEffect(() => {
    if (searchQuery.trim() === '') {
      setFilteredUsers(users);
    } else {
      const query = searchQuery.toLowerCase();
      const filtered = users.filter(
        (user) =>
          (user.displayName &&
            user.displayName.toLowerCase().includes(query)) ||
          (user.email && user.email.toLowerCase().includes(query))
      );
      setFilteredUsers(filtered);
    }
  }, [searchQuery, users]);

  const loadUsers = async () => {
    try {
      setLoading(true);
      const assignableUsers = await getAssignableUsers();
      setUsers(assignableUsers);
      setFilteredUsers(assignableUsers);
    } catch (error) {
      console.error('Error loading assignable users:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleAssign = () => {
    const selectedUser = users.find((user) => user.id === selectedUserId);
    if (selectedUser) {
      onAssign(selectedUser.id, selectedUser.displayName || selectedUser.email);
    }
  };

  const renderUserItem = ({ item }) => {
    const isSelected = selectedUserId === item.id;
    const displayName =
      item.displayName || item.email || 'Ng∆∞·ªùi d√πng kh√¥ng x√°c ƒë·ªãnh';
    const role = item.role === 'ky_su' ? 'K·ªπ s∆∞' : 'C√¥ng nh√¢n';

    return (
      <TouchableOpacity
        style={[styles.userItem, isSelected && styles.selectedUserItem]}
        onPress={() => setSelectedUserId(item.id)}
      >
        <View style={styles.userAvatar}>
          <Text style={styles.userInitial}>
            {displayName.charAt(0).toUpperCase()}
          </Text>
        </View>
        <View style={styles.userInfo}>
          <Text style={styles.userName}>{displayName}</Text>
          <Text style={styles.userRole}>{role}</Text>
        </View>
        {isSelected && (
          <Ionicons name="checkmark-circle" size={24} color="#4CAF50" />
        )}
      </TouchableOpacity>
    );
  };

  return (
    <Modal
      visible={visible}
      transparent
      animationType="slide"
      onRequestClose={onClose}
    >
      <View style={styles.modalOverlay}>
        <View style={styles.modalContainer}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>Ph√¢n c√¥ng c√¥ng vi·ªác</Text>
            <TouchableOpacity onPress={onClose} style={styles.closeButton}>
              <Ionicons name="close" size={24} color="#000" />
            </TouchableOpacity>
          </View>

          <Text style={styles.taskName}>{taskName}</Text>

          <View style={styles.searchContainer}>
            <Ionicons
              name="search"
              size={20}
              color="#666"
              style={styles.searchIcon}
            />
            <TextInput
              style={styles.searchInput}
              placeholder="T√¨m ki·∫øm ng∆∞·ªùi d√πng..."
              value={searchQuery}
              onChangeText={setSearchQuery}
              autoCapitalize="none"
            />
          </View>

          {loading ? (
            <ActivityIndicator
              size="large"
              color="#0066cc"
              style={styles.loader}
            />
          ) : (
            <FlatList
              data={filteredUsers}
              keyExtractor={(item) => item.id}
              renderItem={renderUserItem}
              contentContainerStyle={styles.userList}
              ListEmptyComponent={
                <Text style={styles.emptyMessage}>
                  {searchQuery
                    ? 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng ph√π h·ª£p'
                    : 'Kh√¥ng c√≥ ng∆∞·ªùi d√πng n√†o'}
                </Text>
              }
            />
          )}

          <View style={styles.actionButtons}>
            <TouchableOpacity
              style={[styles.button, styles.cancelButton]}
              onPress={onClose}
            >
              <Text style={styles.cancelButtonText}>H·ªßy</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[
                styles.button,
                styles.assignButton,
                !selectedUserId && styles.disabledButton,
              ]}
              onPress={handleAssign}
              disabled={!selectedUserId}
            >
              <Text style={styles.assignButtonText}>Ph√¢n c√¥ng</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    width: '90%',
    maxHeight: '80%',
    backgroundColor: '#fff',
    borderRadius: 12,
    overflow: 'hidden',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  closeButton: {
    padding: 4,
  },
  taskName: {
    fontSize: 16,
    fontWeight: '600',
    padding: 16,
    backgroundColor: '#f9f9f9',
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
    margin: 16,
    borderRadius: 8,
    paddingHorizontal: 12,
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    height: 44,
    fontSize: 16,
  },
  userList: {
    paddingHorizontal: 16,
  },
  userItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  selectedUserItem: {
    backgroundColor: 'rgba(0, 102, 204, 0.05)',
  },
  userAvatar: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#0066cc',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  userInitial: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
  },
  userInfo: {
    flex: 1,
  },
  userName: {
    fontSize: 16,
    fontWeight: '500',
  },
  userRole: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  emptyMessage: {
    padding: 16,
    textAlign: 'center',
    color: '#666',
  },
  actionButtons: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  button: {
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 8,
    marginLeft: 8,
  },
  cancelButton: {
    backgroundColor: '#f1f1f1',
  },
  cancelButtonText: {
    color: '#333',
    fontWeight: '500',
  },
  assignButton: {
    backgroundColor: '#0066cc',
  },
  assignButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
  disabledButton: {
    opacity: 0.5,
  },
  loader: {
    marginVertical: 32,
  },
});

export default TaskAssignmentModal;


--- END: src\components\TaskAssignmentModal.js ---


--- START: src\components\TaskCard.js ---
import React, { useContext } from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import { ThemeContext } from '../contexts/ThemeContext';

const TaskCard = ({ task, onPress }) => {
  const { theme } = useContext(ThemeContext);
  const styles = getStyles(theme);

  const getStatusColor = (status) => {
    switch (status) {
      case 'completed':
        return { bg: 'rgba(46, 204, 113, 0.2)', text: '#27AE60' };
      case 'in_progress':
        return { bg: 'rgba(52, 152, 219, 0.2)', text: '#2980B9' };
      case 'pending':
        return { bg: 'rgba(241, 196, 15, 0.2)', text: '#F39C12' };
      default:
        return { bg: theme.border, text: theme.textSecondary };
    }
  };

  const getStatusLabel = (status) => {
    switch (status) {
      case 'completed':
        return 'Ho√†n th√†nh';
      case 'in_progress':
        return 'ƒêang th·ª±c hi·ªán';
      case 'pending':
        return 'Ch·ªù x·ª≠ l√Ω';
      default:
        return 'Kh√¥ng x√°c ƒë·ªãnh';
    }
  };

  const statusStyle = getStatusColor(task.status);

  return (
    <TouchableOpacity style={styles.card} onPress={onPress}>
      <View style={styles.cardHeader}>
        <Text style={styles.taskLabel}>{task.taskLabel}</Text>
        <View style={[styles.statusBadge, { backgroundColor: statusStyle.bg }]}>
          <Text style={[styles.statusText, { color: statusStyle.text }]}>
            {getStatusLabel(task.status)}
          </Text>
        </View>
      </View>
      <View style={styles.cardBody}>
        <Text style={styles.projectName}>D·ª± √°n: {task.projectName}</Text>
        <Text style={styles.assignedTo}>Ph·ª• tr√°ch: {task.assignedToName}</Text>
      </View>
    </TouchableOpacity>
  );
};

const getStyles = (theme) =>
  StyleSheet.create({
    card: {
      backgroundColor: theme.card,
      padding: 16,
      borderRadius: 12,
      marginVertical: 8,
      borderWidth: 1,
      borderColor: theme.border,
      elevation: 2,
      shadowColor: '#000',
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.05,
      shadowRadius: 2,
    },
    cardHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 4,
    },
    taskLabel: {
      fontSize: 17,
      fontWeight: 'bold',
      color: theme.text,
      flex: 1, // Allow text to wrap if long
    },
    statusBadge: {
      paddingHorizontal: 10,
      paddingVertical: 4,
      borderRadius: 12,
      marginLeft: 8,
    },
    statusText: {
      fontSize: 12,
      fontWeight: '600',
    },
    cardBody: {
      marginTop: 8,
    },
    projectName: {
      fontSize: 14,
      color: theme.textSecondary,
      marginBottom: 4,
    },
    assignedTo: {
      fontSize: 14,
      color: theme.textSecondary,
    },
  });

export default TaskCard;


--- END: src\components\TaskCard.js ---


--- START: src\components\TestComponent.js ---
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

/**
 * Component test ƒë∆°n gi·∫£n ƒë·ªÉ ki·ªÉm tra app kh√¥ng crash
 */
const TestComponent = () => {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>‚úÖ App ƒëang ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng</Text>
      <Text style={styles.subText}>Kh√¥ng c√≥ l·ªói hooks</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
  },
  text: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#4CAF50',
    marginBottom: 8,
  },
  subText: {
    fontSize: 14,
    color: '#666',
  },
});

export default TestComponent;





























































































































--- END: src\components\TestComponent.js ---


--- START: src\components\WorkDetailModal.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Modal,
  TouchableOpacity,
  ScrollView,
  Alert,
  Image,
  Dimensions,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import ProductionService from '../api/productionService';
import MediaInstructionsViewer from './MediaInstructionsViewer';

const { width, height } = Dimensions.get('window');

const WorkDetailModal = ({
  visible,
  worker,
  onClose,
  onStartWork,
  onStopWork,
  onTaskCompleted,
  theme,
}) => {
  const [tasks, setTasks] = useState([]);
  const [runningSession, setRunningSession] = useState(null);
  const [loading, setLoading] = useState(false);
  const [currentTime, setCurrentTime] = useState('');
  const [selectedTaskForInstructions, setSelectedTaskForInstructions] =
    useState(null);
  const [showInstructionsModal, setShowInstructionsModal] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [pausedTime, setPausedTime] = useState(0); // Th·ªùi gian ƒë√£ t·∫°m ng∆∞ng (milliseconds)
  const [pauseStartTime, setPauseStartTime] = useState(null); // Th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu pause

  // Load worker tasks when modal opens
  useEffect(() => {
    if (visible && worker) {
      // üöÄ Reset states when modal opens fresh
      console.log('Modal opened for worker:', worker.workerName);
      loadWorkerTasks();
      loadRunningSession();
    } else if (!visible) {
      // üßπ Clean up when modal closes
      console.log('Modal closed, cleaning up states');
      setTasks([]);
      setRunningSession(null);
      setCurrentTime('');
    }
  }, [visible, worker]);

  // Update timer for running session
  useEffect(() => {
    let interval = null;

    if (runningSession && runningSession.startTime && !isPaused) {
      interval = setInterval(() => {
        const startTime = new Date(runningSession.startTime.seconds * 1000);
        const now = new Date();
        const diffMs = now.getTime() - startTime.getTime() - pausedTime;

        const hours = Math.floor(diffMs / (1000 * 60 * 60));
        const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);

        setCurrentTime(
          `${hours.toString().padStart(2, '0')}:${minutes
            .toString()
            .padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`
        );
      }, 1000);
    }

    return () => {
      if (interval) {
        clearInterval(interval);
      }
    };
  }, [runningSession, isPaused, pausedTime, pauseStartTime]);

  // Load worker tasks
  const loadWorkerTasks = async () => {
    if (!worker) return;

    try {
      setLoading(true);
      const workerTasks = await ProductionService.getTasksForWorker(
        worker.workerId
      );
      setTasks(workerTasks);
    } catch (error) {
      console.error('Error loading worker tasks:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch c√¥ng vi·ªác');
    } finally {
      setLoading(false);
    }
  };

  // Load running session
  const loadRunningSession = async () => {
    if (!worker) return;

    try {
      const session = await ProductionService.getRunningSessionForWorker(
        worker.workerId
      );
      setRunningSession(session);
    } catch (error) {
      console.error('Error loading running session:', error);
    }
  };

  // Handle viewing instructions
  const handleViewInstructions = (task) => {
    setSelectedTaskForInstructions(task);
    setShowInstructionsModal(true);
  };

  const handleCloseInstructions = () => {
    setShowInstructionsModal(false);
    setSelectedTaskForInstructions(null);
  };

  // Handle start work
  const handleStartWork = async (task) => {
    if (!worker) return;

    Alert.alert('X√°c nh·∫≠n', `B·∫Øt ƒë·∫ßu c√¥ng vi·ªác: ${task.stageName}?`, [
      { text: 'H·ªßy', style: 'cancel' },
      {
        text: 'B·∫Øt ƒë·∫ßu',
        onPress: async () => {
          await onStartWork(worker.workerId, worker.workerName, task);
          // Reload data after starting
          await loadRunningSession();
          await loadWorkerTasks();
        },
      },
    ]);
  };

  // Handle stop work
  const handleStopWork = async () => {
    if (!worker || !runningSession) return;

    console.log('=== HANDLE STOP WORK DEBUG ===');
    console.log('Worker:', worker.workerId);
    console.log('Running session:', {
      id: runningSession.id,
      stageName: runningSession.stageName,
      projectId: runningSession.projectId,
      stageId: runningSession.stageId,
    });

    Alert.alert(
      'X√°c nh·∫≠n',
      `K·∫øt th√∫c c√¥ng vi·ªác: ${runningSession.stageName}?`,
      [
        { text: 'H·ªßy', style: 'cancel' },
        {
          text: 'K·∫øt th√∫c',
          style: 'destructive',
          onPress: async () => {
            console.log('User confirmed stop work');

            // üöÄ OPTIMISTIC UI UPDATE - C·∫≠p nh·∫≠t giao di·ªán ngay l·∫≠p t·ª©c
            console.log('Applying optimistic updates...');

            // 1. D·ª´ng timer ngay l·∫≠p t·ª©c b·∫±ng c√°ch clear running session
            setRunningSession(null);

            // 2. Lo·∫°i b·ªè task v·ª´a ho√†n th√†nh kh·ªèi danh s√°ch ngay l·∫≠p t·ª©c
            const completedTaskId = runningSession.stageId;
            console.log('üéØ Completing task with stageId:', completedTaskId);
            console.log(
              'üìã Current tasks before filter:',
              tasks.map((t) => ({
                stageId: t.stageId,
                stageName: t.stageName,
                stageStatus: t.stageStatus,
              }))
            );

            setTasks((prevTasks) => {
              const filteredTasks = prevTasks.filter(
                (task) => task.stageId !== completedTaskId
              );
              console.log(
                'üìã Tasks after filter:',
                filteredTasks.map((t) => ({
                  stageId: t.stageId,
                  stageName: t.stageName,
                  stageStatus: t.stageStatus,
                }))
              );
              return filteredTasks;
            });

            // 3. üì° Th√¥ng b√°o cho parent component v·ªÅ task ƒë√£ ho√†n th√†nh
            if (onTaskCompleted) {
              onTaskCompleted(completedTaskId, worker.workerId);
            }

            console.log('Optimistic updates applied - UI updated immediately');

            // 4. G·ª≠i y√™u c·∫ßu l√™n server ƒë·ªÉ ƒë·ªìng b·ªô d·ªØ li·ªáu (ch·∫°y background)
            try {
              console.log('üîÑ Starting server sync...', {
                workerId: worker.workerId,
                workerName: worker.workerName,
                runningSession: {
                  id: runningSession.id,
                  projectId: runningSession.projectId,
                  stageId: runningSession.stageId,
                  stageName: runningSession.stageName,
                },
              });

              await onStopWork(
                worker.workerId,
                worker.workerName,
                runningSession
              );
              console.log('‚úÖ Server sync completed successfully');
            } catch (error) {
              console.error('‚ùå Server sync failed:', error);

              // üîÑ ROLLBACK - N·∫øu server fail, kh√¥i ph·ª•c l·∫°i UI
              console.log(
                'üîÑ Rolling back optimistic updates due to server error'
              );
              await loadRunningSession();
              await loadWorkerTasks();

              Alert.alert(
                'L·ªói',
                'Kh√¥ng th·ªÉ ho√†n th√†nh c√¥ng vi·ªác. Vui l√≤ng th·ª≠ l·∫°i.'
              );
            }
          },
        },
      ]
    );
  };

  // Handle pause work
  const handlePauseWork = () => {
    if (!runningSession) return;

    Alert.alert(
      'X√°c nh·∫≠n',
      `T·∫°m ng∆∞ng c√¥ng vi·ªác: ${runningSession.stageName}?`,
      [
        { text: 'H·ªßy', style: 'cancel' },
        {
          text: 'T·∫°m ng∆∞ng',
          onPress: () => {
            const now = new Date().getTime();
            setPauseStartTime(now);
            setIsPaused(true);
          },
        },
      ]
    );
  };

  // Handle resume work
  const handleResumeWork = () => {
    if (!runningSession) return;

    Alert.alert(
      'X√°c nh·∫≠n',
      `Ti·∫øp t·ª•c c√¥ng vi·ªác: ${runningSession.stageName}?`,
      [
        { text: 'H·ªßy', style: 'cancel' },
        {
          text: 'Ti·∫øp t·ª•c',
          onPress: () => {
            if (pauseStartTime) {
              const now = new Date().getTime();
              const pauseDuration = now - pauseStartTime;
              setPausedTime((prev) => prev + pauseDuration);
            }
            setPauseStartTime(null);
            setIsPaused(false);
          },
        },
      ]
    );
  };

  // Format role
  const formatRole = (role) => {
    const roleMap = {
      tho_han: 'Th·ª£ H√†n',
      tho_co_khi: 'Th·ª£ C∆° Kh√≠',
      tho_lap_rap: 'Th·ª£ L·∫Øp R√°p',
    };
    return roleMap[role] || role;
  };

  // Get task status color
  const getTaskStatusColor = (status) => {
    switch (status) {
      case 'assigned':
        return '#2196F3'; // Blue
      case 'in_progress':
        return '#FF9800'; // Orange
      case 'completed':
        return '#4CAF50'; // Green
      default:
        return '#9E9E9E'; // Gray
    }
  };

  // Get task status text
  const getTaskStatusText = (status) => {
    switch (status) {
      case 'assigned':
        return 'ƒê∆∞·ª£c giao';
      case 'in_progress':
        return 'ƒêang th·ª±c hi·ªán';
      case 'completed':
        return 'Ho√†n th√†nh';
      default:
        return 'Kh√¥ng x√°c ƒë·ªãnh';
    }
  };

  if (!worker) return null;

  return (
    <Modal
      visible={visible}
      animationType="slide"
      presentationStyle="pageSheet"
      onRequestClose={onClose}
    >
      <View style={[styles.container, { backgroundColor: theme.background }]}>
        {/* Header */}
        <View
          style={[
            styles.header,
            {
              backgroundColor: theme.cardBackground,
              borderBottomColor: theme.border,
            },
          ]}
        >
          <View style={styles.headerLeft}>
            <TouchableOpacity style={styles.closeButton} onPress={onClose}>
              <Ionicons name="close" size={24} color={theme.text} />
            </TouchableOpacity>
            <Text style={[styles.headerTitle, { color: theme.text }]}>
              Chi ti·∫øt c√¥ng vi·ªác
            </Text>
          </View>
        </View>

        <ScrollView style={styles.content} showsVerticalScrollIndicator={false}>
          {/* Worker Info */}
          <View
            style={[
              styles.workerInfo,
              { backgroundColor: theme.cardBackground },
            ]}
          >
            <View style={styles.workerHeader}>
              {worker.avatar ? (
                <Image
                  source={{ uri: worker.avatar }}
                  style={styles.workerAvatar}
                />
              ) : (
                <View
                  style={[
                    styles.avatarPlaceholder,
                    { backgroundColor: theme.primaryLight },
                  ]}
                >
                  <Ionicons name="person" size={32} color={theme.primary} />
                </View>
              )}

              <View style={styles.workerDetails}>
                <Text style={[styles.workerName, { color: theme.text }]}>
                  {worker.workerName}
                </Text>
                <Text
                  style={[styles.workerRole, { color: theme.textSecondary }]}
                >
                  {formatRole(worker.workerRole)}
                </Text>

                <View style={styles.statusContainer}>
                  <View
                    style={[
                      styles.statusDot,
                      {
                        backgroundColor:
                          worker.status === 'working' ? '#4CAF50' : '#9E9E9E',
                      },
                    ]}
                  />
                  <Text
                    style={[styles.statusText, { color: theme.textSecondary }]}
                  >
                    {worker.status === 'working'
                      ? 'ƒêang l√†m vi·ªác'
                      : 'ƒêang r·∫£nh'}
                  </Text>
                </View>
              </View>
            </View>
          </View>

          {/* Running Session */}
          {runningSession && (
            <View
              style={[
                styles.section,
                { backgroundColor: theme.cardBackground },
              ]}
            >
              <View style={styles.sectionHeader}>
                <Ionicons name="play-circle" size={20} color="#4CAF50" />
                <Text style={[styles.sectionTitle, { color: theme.text }]}>
                  C√¥ng vi·ªác ƒëang th·ª±c hi·ªán
                </Text>
              </View>

              <View
                style={[
                  styles.runningTask,
                  { backgroundColor: 'rgba(76, 175, 80, 0.1)' },
                ]}
              >
                <View style={styles.taskHeader}>
                  <Text style={[styles.taskName, { color: theme.text }]}>
                    {runningSession.stageName}
                  </Text>
                  <Text
                    style={[styles.projectName, { color: theme.textSecondary }]}
                  >
                    {runningSession.projectName}
                  </Text>
                </View>

                <View style={styles.timerContainer}>
                  <Ionicons name="time" size={16} color="#4CAF50" />
                  <Text style={[styles.timerText, { color: '#4CAF50' }]}>
                    {currentTime}
                  </Text>
                </View>

                <View style={styles.actionButtonsContainer}>
                  {/* Pause/Resume Button */}
                  <TouchableOpacity
                    style={[
                      styles.pauseButton,
                      { backgroundColor: isPaused ? '#4CAF50' : '#FF9800' },
                    ]}
                    onPress={isPaused ? handleResumeWork : handlePauseWork}
                  >
                    <Ionicons
                      name={isPaused ? 'play' : 'pause'}
                      size={16}
                      color="#fff"
                    />
                    <Text style={styles.pauseButtonText}>
                      {isPaused ? 'TI·∫æP T·ª§C' : 'T·∫†M NG∆ØNG'}
                    </Text>
                  </TouchableOpacity>

                  {/* Complete Button */}
                  <TouchableOpacity
                    style={[styles.stopButton, { backgroundColor: '#F44336' }]}
                    onPress={handleStopWork}
                  >
                    <Ionicons name="checkmark" size={20} color="#fff" />
                    <Text style={styles.stopButtonText}>HO√ÄN TH√ÄNH</Text>
                  </TouchableOpacity>
                </View>
              </View>
            </View>
          )}

          {/* Available Tasks */}
          <View
            style={[styles.section, { backgroundColor: theme.cardBackground }]}
          >
            {(() => {
              const availableTasks = tasks.filter(
                (task) => task.stageStatus !== 'completed'
              );

              // Debug logs
              console.log('=== TASK FILTERING DEBUG ===');
              console.log('Total tasks:', tasks.length);
              console.log(
                'Available tasks (not completed):',
                availableTasks.length
              );
              console.log(
                'Running session:',
                runningSession ? runningSession.stageName : 'None'
              );
              tasks.forEach((task, index) => {
                console.log(`Task ${index + 1}:`, {
                  stageName: task.stageName,
                  stageStatus: task.stageStatus,
                  projectId: task.projectId,
                  stageId: task.stageId,
                });
              });
              console.log('=== END DEBUG ===');

              return (
                <>
                  <View style={styles.sectionHeader}>
                    <Ionicons name="list" size={20} color={theme.primary} />
                    <Text style={[styles.sectionTitle, { color: theme.text }]}>
                      C√¥ng vi·ªác ƒë∆∞·ª£c giao ({availableTasks.length})
                    </Text>
                  </View>

                  {loading ? (
                    <View style={styles.loadingContainer}>
                      <Text
                        style={[
                          styles.loadingText,
                          { color: theme.textSecondary },
                        ]}
                      >
                        ƒêang t·∫£i...
                      </Text>
                    </View>
                  ) : availableTasks.length === 0 ? (
                    <View style={styles.emptyContainer}>
                      <Ionicons
                        name="checkmark-circle"
                        size={48}
                        color="#4CAF50"
                      />
                      <Text
                        style={[
                          styles.emptyText,
                          { color: theme.textSecondary },
                        ]}
                      >
                        {tasks.length === 0
                          ? 'Kh√¥ng c√≥ c√¥ng vi·ªác m·ªõi'
                          : 'T·∫•t c·∫£ c√¥ng vi·ªác ƒë√£ ho√†n th√†nh'}
                      </Text>
                    </View>
                  ) : (
                    availableTasks.map((task, index) => (
                      <View
                        key={`${task.projectId}-${task.stageId}`}
                        style={styles.taskItem}
                      >
                        <View style={styles.taskInfo}>
                          <Text
                            style={[styles.taskName, { color: theme.text }]}
                          >
                            {task.stageName}
                          </Text>
                          <Text
                            style={[
                              styles.projectName,
                              { color: theme.textSecondary },
                            ]}
                          >
                            {task.projectName}
                          </Text>

                          <View style={styles.taskStatus}>
                            <View
                              style={[
                                styles.statusDot,
                                {
                                  backgroundColor: getTaskStatusColor(
                                    task.stageStatus
                                  ),
                                },
                              ]}
                            />
                            <Text
                              style={[
                                styles.statusText,
                                { color: theme.textSecondary },
                              ]}
                            >
                              {getTaskStatusText(task.stageStatus)}
                            </Text>
                          </View>

                          {/* Media Instructions Indicators */}
                          {(task.hasInstructions ||
                            task.hasImages ||
                            task.hasAudio) && (
                            <View style={styles.mediaIndicators}>
                              <Text
                                style={[
                                  styles.mediaLabel,
                                  { color: theme.textSecondary },
                                ]}
                              >
                                H∆∞·ªõng d·∫´n:
                              </Text>
                              {task.hasInstructions && (
                                <Ionicons
                                  name="document-text"
                                  size={14}
                                  color="#0066cc"
                                  style={styles.mediaIcon}
                                />
                              )}
                              {task.hasImages && (
                                <Ionicons
                                  name="image"
                                  size={14}
                                  color="#0066cc"
                                  style={styles.mediaIcon}
                                />
                              )}
                              {task.hasAudio && (
                                <Ionicons
                                  name="volume-high"
                                  size={14}
                                  color="#0066cc"
                                  style={styles.mediaIcon}
                                />
                              )}
                            </View>
                          )}
                        </View>

                        <View style={styles.taskActions}>
                          {/* View Instructions Button - Always show for debugging */}
                          <TouchableOpacity
                            style={[
                              styles.instructionsButton,
                              { backgroundColor: '#0066cc' },
                            ]}
                            onPress={() => handleViewInstructions(task)}
                          >
                            <Ionicons
                              name="information-circle"
                              size={14}
                              color="#fff"
                            />
                            <Text style={styles.instructionsButtonText}>
                              H∆Ø·ªöNG D·∫™N
                            </Text>
                          </TouchableOpacity>

                          {/* Start Work Button */}
                          {task.stageStatus === 'assigned' &&
                            !runningSession && (
                              <TouchableOpacity
                                style={[
                                  styles.startButton,
                                  { backgroundColor: '#4CAF50' },
                                ]}
                                onPress={() => handleStartWork(task)}
                              >
                                <Ionicons name="play" size={16} color="#fff" />
                                <Text style={styles.startButtonText}>
                                  B·∫ÆT ƒê·∫¶U
                                </Text>
                              </TouchableOpacity>
                            )}
                        </View>
                      </View>
                    ))
                  )}
                </>
              );
            })()}
          </View>
        </ScrollView>
      </View>

      {/* Instructions Modal */}
      <Modal
        visible={showInstructionsModal}
        animationType="slide"
        presentationStyle="pageSheet"
        onRequestClose={handleCloseInstructions}
      >
        <View
          style={[
            styles.instructionsModalContainer,
            { backgroundColor: theme.background },
          ]}
        >
          <View
            style={[
              styles.instructionsHeader,
              { borderBottomColor: theme.border },
            ]}
          >
            <Text style={[styles.instructionsTitle, { color: theme.text }]}>
              H∆∞·ªõng d·∫´n: {selectedTaskForInstructions?.stageName}
            </Text>
            <TouchableOpacity
              style={styles.closeInstructionsButton}
              onPress={handleCloseInstructions}
            >
              <Ionicons name="close" size={24} color={theme.text} />
            </TouchableOpacity>
          </View>

          {selectedTaskForInstructions && (
            <ScrollView style={{ flex: 1 }}>
              <MediaInstructionsViewer
                instructionImages={
                  selectedTaskForInstructions.instructionImages || []
                }
                instructionNotes={
                  selectedTaskForInstructions.instructionNotes || ''
                }
                instructionAudio={
                  selectedTaskForInstructions.instructionAudio || null
                }
                visible={true}
              />

              {/* Debug info */}
              <View
                style={{
                  padding: 16,
                  backgroundColor: '#f0f0f0',
                  margin: 16,
                  borderRadius: 8,
                }}
              >
                <Text style={{ fontWeight: 'bold', marginBottom: 8 }}>
                  Debug Info:
                </Text>
                <Text>Task: {selectedTaskForInstructions.stageName}</Text>
                <Text>Project: {selectedTaskForInstructions.projectName}</Text>
                <Text>
                  Has Instructions:{' '}
                  {selectedTaskForInstructions.hasInstructions ? 'Yes' : 'No'}
                </Text>
                <Text>
                  Has Images:{' '}
                  {selectedTaskForInstructions.hasImages ? 'Yes' : 'No'}
                </Text>
                <Text>
                  Has Audio:{' '}
                  {selectedTaskForInstructions.hasAudio ? 'Yes' : 'No'}
                </Text>
                <Text>
                  Images Count:{' '}
                  {selectedTaskForInstructions.instructionImages?.length || 0}
                </Text>
                <Text>
                  Notes Length:{' '}
                  {selectedTaskForInstructions.instructionNotes?.length || 0}
                </Text>
                <Text>
                  Audio:{' '}
                  {selectedTaskForInstructions.instructionAudio
                    ? 'Available'
                    : 'None'}
                </Text>
              </View>
            </ScrollView>
          )}
        </View>
      </Modal>
    </Modal>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
  },
  headerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  closeButton: {
    marginRight: 16,
    padding: 8,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  content: {
    flex: 1,
    padding: 16,
  },
  workerInfo: {
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
  },
  workerHeader: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  workerAvatar: {
    width: 64,
    height: 64,
    borderRadius: 32,
    marginRight: 16,
  },
  avatarPlaceholder: {
    width: 64,
    height: 64,
    borderRadius: 32,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 16,
  },
  workerDetails: {
    flex: 1,
  },
  workerName: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  workerRole: {
    fontSize: 14,
    marginBottom: 8,
  },
  statusContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  statusDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
    marginRight: 6,
  },
  statusText: {
    fontSize: 14,
    fontWeight: '500',
  },
  section: {
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
  },
  sectionHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  runningTask: {
    borderRadius: 8,
    padding: 16,
  },
  taskHeader: {
    marginBottom: 8,
  },
  taskName: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 2,
  },
  projectName: {
    fontSize: 14,
  },
  timerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  timerText: {
    fontSize: 18,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  actionButtonsContainer: {
    flexDirection: 'row',
    gap: 12,
    marginTop: 12,
  },
  pauseButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 8,
    flex: 1,
  },
  pauseButtonText: {
    color: '#fff',
    fontSize: 14,
    fontWeight: 'bold',
    marginLeft: 6,
  },
  stopButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 8,
    flex: 1,
  },
  stopButtonText: {
    color: '#fff',
    fontSize: 14,
    fontWeight: 'bold',
    marginLeft: 6,
  },
  loadingContainer: {
    alignItems: 'center',
    paddingVertical: 32,
  },
  loadingText: {
    fontSize: 16,
  },
  emptyContainer: {
    alignItems: 'center',
    paddingVertical: 32,
  },
  emptyText: {
    fontSize: 16,
    marginTop: 8,
    textAlign: 'center',
  },
  taskItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(0,0,0,0.1)',
  },
  taskInfo: {
    flex: 1,
  },
  taskStatus: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 4,
  },
  taskActions: {
    flexDirection: 'row',
    gap: 8,
  },
  startButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 6,
  },
  startButtonText: {
    color: '#fff',
    fontSize: 14,
    fontWeight: 'bold',
    marginLeft: 4,
  },
  instructionsButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 6,
  },
  instructionsButtonText: {
    color: '#fff',
    fontSize: 11,
    fontWeight: 'bold',
    marginLeft: 4,
  },
  mediaIndicators: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 4,
  },
  mediaLabel: {
    fontSize: 11,
    marginRight: 6,
    fontWeight: '500',
  },
  mediaIcon: {
    marginRight: 4,
  },
  instructionsModalContainer: {
    flex: 1,
  },
  instructionsHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
  },
  instructionsTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    flex: 1,
  },
  closeInstructionsButton: {
    padding: 8,
  },
});

export default WorkDetailModal;


--- END: src\components\WorkDetailModal.js ---


--- START: src\components\WorkerCard.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Image,
  Dimensions,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';

const { width } = Dimensions.get('window');

const WorkerCard = ({ worker, onPress, theme }) => {
  const [currentTime, setCurrentTime] = useState('');

  // Update timer every second for working workers
  useEffect(() => {
    let interval = null;

    if (worker.status === 'working' && worker.currentTask) {
      interval = setInterval(() => {
        const startTime = new Date(worker.currentTask.startTime.seconds * 1000);
        const now = new Date();
        const diffMs = now.getTime() - startTime.getTime();

        // Calculate hours and minutes
        const hours = Math.floor(diffMs / (1000 * 60 * 60));
        const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);

        setCurrentTime(
          `${hours.toString().padStart(2, '0')}:${minutes
            .toString()
            .padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`
        );
      }, 1000);
    }

    return () => {
      if (interval) {
        clearInterval(interval);
      }
    };
  }, [worker.status, worker.currentTask]);

  // Get card width based on screen size - optimized for tablet landscape
  const getCardWidth = () => {
    const screenWidth = width;
    const padding = 32; // Total horizontal padding
    const spacing = 16; // Space between cards

    if (screenWidth > 1200) {
      // 5 columns for large tablets
      return (screenWidth - padding - spacing * 4) / 5;
    } else if (screenWidth > 900) {
      // 4 columns for medium tablets
      return (screenWidth - padding - spacing * 3) / 4;
    } else if (screenWidth > 600) {
      // 3 columns for small tablets
      return (screenWidth - padding - spacing * 2) / 3;
    } else {
      // 2 columns for phones
      return (screenWidth - padding - spacing) / 2;
    }
  };

  // Get status color
  const getStatusColor = () => {
    switch (worker.status) {
      case 'working':
        return '#4CAF50'; // Green
      case 'idle':
        return '#9E9E9E'; // Gray
      default:
        return '#9E9E9E';
    }
  };

  // Get status text
  const getStatusText = () => {
    switch (worker.status) {
      case 'working':
        return 'ƒêang l√†m vi·ªác';
      case 'idle':
        return 'ƒêang r·∫£nh';
      default:
        return 'Kh√¥ng x√°c ƒë·ªãnh';
    }
  };

  // Format worker role - simplified for kiosk
  const formatRole = (role) => {
    const roleMap = {
      tho_han: 'Th·ª£ H√†n',
      tho_co_khi: 'Th·ª£ C∆° Kh√≠',
      tho_lap_rap: 'Th·ª£ L·∫Øp R√°p',
    };
    return roleMap[role] || role;
  };

  const cardWidth = getCardWidth();
  const statusColor = getStatusColor();

  return (
    <TouchableOpacity
      style={[
        styles.card,
        {
          backgroundColor: theme.cardBackground,
          borderColor: theme.border,
          width: cardWidth,
        },
      ]}
      onPress={() => onPress(worker)}
      activeOpacity={0.7}
    >
      {/* Avatar with Status Ring */}
      <View style={styles.avatarContainer}>
        <View
          style={[
            styles.avatarRing,
            {
              borderColor: statusColor,
              borderWidth: worker.status === 'working' ? 4 : 2,
            },
          ]}
        >
          {worker.avatar ? (
            <Image source={{ uri: worker.avatar }} style={styles.avatar} />
          ) : (
            <View
              style={[
                styles.avatarPlaceholder,
                { backgroundColor: theme.primaryLight },
              ]}
            >
              <Ionicons name="person" size={36} color={theme.primary} />
            </View>
          )}
        </View>

        {/* Notification Badge */}
        {worker.newTasksCount > 0 && (
          <View style={styles.notificationBadge}>
            <Text style={styles.badgeText}>
              {worker.newTasksCount > 9 ? '9+' : worker.newTasksCount}
            </Text>
          </View>
        )}
      </View>

      {/* Worker Info */}
      <View style={styles.infoContainer}>
        <Text
          style={[styles.workerName, { color: theme.text }]}
          numberOfLines={1}
          ellipsizeMode="tail"
        >
          {worker.workerName}
        </Text>

        {/* Current Task */}
        {worker.status === 'working' && worker.currentTask && (
          <View style={styles.taskContainer}>
            <Text
              style={[styles.taskName, { color: theme.text }]}
              numberOfLines={1}
              ellipsizeMode="tail"
            >
              {worker.currentTask.stageName}
            </Text>
            <Text
              style={[styles.projectName, { color: theme.textSecondary }]}
              numberOfLines={1}
              ellipsizeMode="tail"
            >
              {worker.currentTask.projectName}
            </Text>

            {/* Timer */}
            <View style={styles.timerContainer}>
              <Ionicons name="time" size={12} color={theme.primary} />
              <Text style={[styles.timerText, { color: theme.primary }]}>
                {currentTime || worker.currentTask.duration}
              </Text>
            </View>
          </View>
        )}
      </View>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  card: {
    borderRadius: 12,
    padding: 16,
    margin: 8,
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    borderWidth: 1,
    minHeight: 200,
  },
  avatarContainer: {
    alignItems: 'center',
    marginBottom: 12,
    position: 'relative',
  },
  avatarRing: {
    borderRadius: 39,
    padding: 3,
  },
  avatar: {
    width: 72,
    height: 72,
    borderRadius: 36,
  },
  avatarPlaceholder: {
    width: 72,
    height: 72,
    borderRadius: 36,
    justifyContent: 'center',
    alignItems: 'center',
  },
  notificationBadge: {
    position: 'absolute',
    top: -2,
    right: -2,
    backgroundColor: '#FF3B30',
    borderRadius: 10,
    minWidth: 20,
    height: 20,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#fff',
  },
  badgeText: {
    color: '#fff',
    fontSize: 10,
    fontWeight: 'bold',
  },
  infoContainer: {
    alignItems: 'center',
    flex: 1,
  },
  workerName: {
    fontSize: 18,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 8,
  },

  taskContainer: {
    alignItems: 'center',
    marginTop: 4,
  },
  taskName: {
    fontSize: 14,
    fontWeight: '600',
    textAlign: 'center',
    marginBottom: 2,
  },
  projectName: {
    fontSize: 11,
    textAlign: 'center',
    marginBottom: 4,
  },
  timerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(76, 175, 80, 0.1)',
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 8,
  },
  timerText: {
    fontSize: 11,
    fontWeight: 'bold',
    marginLeft: 2,
  },
});

export default WorkerCard;


--- END: src\components\WorkerCard.js ---


--- START: src\components\WorkerFeaturesMenu.js ---
import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';

/**
 * Component hi·ªÉn th·ªã menu ch·ª©c nƒÉng cho c√¥ng nh√¢n, k·ªπ s∆∞, k·∫ø to√°n
 * Bao g·ªìm: Xem ch·∫•m c√¥ng, Xin ngh·ªâ ph√©p, Xin ·ª©ng l∆∞∆°ng
 */
const WorkerFeaturesMenu = ({ userRole, onNavigate, style = {} }) => {
  const { theme } = useTheme();

  // X√°c ƒë·ªãnh role v√† ti√™u ƒë·ªÅ
  const isWorker = userRole?.toLowerCase() === 'cong_nhan';
  const isEngineer = userRole?.toLowerCase() === 'ky_su';
  const isAccountant = userRole?.toLowerCase() === 'ke_toan';

  const getRoleTitle = () => {
    if (isWorker) return 'Ch·ª©c nƒÉng c√¥ng nh√¢n';
    if (isEngineer) return 'Ch·ª©c nƒÉng k·ªπ s∆∞';
    if (isAccountant) return 'Ch·ª©c nƒÉng k·∫ø to√°n';
    return 'Ch·ª©c nƒÉng nh√¢n vi√™n';
  };

  const getRoleIcon = () => {
    if (isWorker) return 'construct-outline';
    if (isEngineer) return 'school-outline';
    if (isAccountant) return 'calculator-outline';
    return 'person-outline';
  };

  const getRoleColor = () => {
    if (isWorker) return '#4CAF50'; // Green
    if (isEngineer) return '#2196F3'; // Blue
    if (isAccountant) return '#FF9800'; // Orange
    return '#9C27B0'; // Purple
  };

  const menuItems = [
    {
      id: 'attendance',
      title: 'Xem ch·∫•m c√¥ng',
      description: 'Xem l·ªãch s·ª≠ v√† th·ªëng k√™',
      icon: 'time-outline',
      iconColor: '#4CAF50',
      screen: 'WorkerAttendance',
    },
    {
      id: 'leave',
      title: 'Xin ngh·ªâ ph√©p',
      description: 'ƒêƒÉng k√Ω v√† theo d√µi',
      icon: 'calendar-outline',
      iconColor: '#FF9800',
      screen: 'LeaveRequest',
    },
    {
      id: 'advance',
      title: 'Xin ·ª©ng l∆∞∆°ng',
      description: 'Y√™u c·∫ßu v√† theo d√µi',
      icon: 'cash-outline',
      iconColor: '#2196F3',
      screen: 'AdvanceSalary',
    },
  ];

  const handleMenuPress = (screen) => {
    if (onNavigate && typeof onNavigate === 'function') {
      onNavigate(screen);
    }
  };

  return (
    <View style={[styles.container, style]}>
      {/* Header v·ªõi icon v√† ti√™u ƒë·ªÅ */}
      <View style={styles.header}>
        <View style={[styles.roleIcon, { backgroundColor: getRoleColor() }]}>
          <Ionicons name={getRoleIcon()} size={24} color="#fff" />
        </View>
        <Text style={[styles.roleTitle, { color: theme.text }]}>
          {getRoleTitle()}
        </Text>
      </View>

      {/* Grid menu items */}
      <View style={styles.menuGrid}>
        {menuItems.map((item) => (
          <TouchableOpacity
            key={item.id}
            style={[
              styles.menuCard,
              { backgroundColor: theme.card, borderColor: theme.border },
            ]}
            onPress={() => handleMenuPress(item.screen)}
            activeOpacity={0.7}
          >
            <View
              style={[styles.menuIcon, { backgroundColor: item.iconColor }]}
            >
              <Ionicons name={item.icon} size={24} color="#fff" />
            </View>
            <Text style={[styles.menuText, { color: theme.text }]}>
              {item.title}
            </Text>
            <Text style={[styles.menuDesc, { color: theme.textSecondary }]}>
              {item.description}
            </Text>
          </TouchableOpacity>
        ))}
      </View>

      {/* Th√¥ng tin b·ªï sung cho t·ª´ng role */}
      <View
        style={[
          styles.infoCard,
          { backgroundColor: theme.card, borderColor: theme.border },
        ]}
      >
        <Ionicons
          name="information-circle-outline"
          size={20}
          color={theme.primary}
        />
        <Text style={[styles.infoText, { color: theme.textSecondary }]}>
          {isWorker && 'B·∫°n c√≥ th·ªÉ xem ch·∫•m c√¥ng, xin ngh·ªâ ph√©p v√† ·ª©ng l∆∞∆°ng'}
          {isEngineer && 'B·∫°n c√≥ th·ªÉ xem ch·∫•m c√¥ng, xin ngh·ªâ ph√©p v√† ·ª©ng l∆∞∆°ng'}
          {isAccountant &&
            'B·∫°n c√≥ th·ªÉ xem ch·∫•m c√¥ng, xin ngh·ªâ ph√©p v√† ·ª©ng l∆∞∆°ng'}
        </Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    paddingHorizontal: 16,
    marginBottom: 20,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  roleIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  roleTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  menuGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  menuCard: {
    width: '31%',
    padding: 16,
    borderRadius: 12,
    borderWidth: 1,
    alignItems: 'center',
    marginBottom: 12,
    minHeight: 120,
  },
  menuIcon: {
    width: 48,
    height: 48,
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 12,
  },
  menuText: {
    fontSize: 14,
    fontWeight: '600',
    textAlign: 'center',
    marginBottom: 4,
  },
  menuDesc: {
    fontSize: 12,
    textAlign: 'center',
    lineHeight: 16,
  },
  infoCard: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    borderRadius: 8,
    borderWidth: 1,
  },
  infoText: {
    fontSize: 12,
    marginLeft: 8,
    flex: 1,
    lineHeight: 16,
  },
});

export default WorkerFeaturesMenu;
















































--- END: src\components\WorkerFeaturesMenu.js ---


--- START: src\config\authConfig.js ---
//src/config/authConfig.js
// C·∫•u h√¨nh x√°c th·ª±c cho c√°c d·ªãch v·ª• b√™n ngo√†i
export const googleAuthConfig = {
  // Thay th·∫ø c√°c gi√° tr·ªã n√†y b·∫±ng Client ID th·ª±c t·∫ø c·ªßa b·∫°n
  iosClientId:
    '370615243912-o6d5f9a9l5vbui1o1gcnd5t0lbkru9is.apps.googleusercontent.com',
  androidClientId:
    '370615243912-v7btvdq1e1b4min5snq7av9jpoe7lr10.apps.googleusercontent.com',
  webClientId:
    '370615243912-fesvpqtf06r7ugj31ma1urmrii85m7at.apps.googleusercontent.com',
  offlineAccess: true,

  // C√°c scopes m·∫∑c ƒë·ªãnh cho Google Drive
  driveScopes: [
    'https://www.googleapis.com/auth/drive.file', // Cho ph√©p app t·∫°o v√† qu·∫£n l√Ω c√°c file do app t·∫°o
    // N·∫øu c·∫ßn r·ªông h∆°n: 'https://www.googleapis.com/auth/drive'
  ],

  // C√°c scopes m·∫∑c ƒë·ªãnh cho Google Sheets
  sheetsScopes: [
    'https://www.googleapis.com/auth/drive.readonly',
    'https://www.googleapis.com/auth/spreadsheets.readonly',
  ],
};

// H√†m helper ƒë·ªÉ log chi ti·∫øt l·ªói Google API
export const logGoogleApiError = (error, context = '') => {
  console.error(`Google API Error ${context ? `(${context})` : ''}:`, error);

  // Log th√¥ng tin chi ti·∫øt h∆°n n·∫øu c√≥
  if (error.response) {
    console.error('Error response:', {
      status: error.response.status,
      statusText: error.response.statusText,
      data: error.response.data,
    });
  }

  // Log th√¥ng tin request n·∫øu c√≥
  if (error.config) {
    console.error('Request config:', {
      url: error.config.url,
      method: error.config.method,
      headers: error.config.headers,
      params: error.config.params,
    });
  }

  return error;
};


--- END: src\config\authConfig.js ---


--- START: src\config\colors.js ---
//src/config/colors.js
export const lightTheme = {
  // M√†u n·ªÅn
  background: '#FFFFFF',
  backgroundSecondary: '#F8F8F8',
  card: '#FFFFFF',

  // M√†u ch·ªØ
  text: '#333333',
  textSecondary: '#666666',
  textMuted: '#999999',

  // M√†u th∆∞∆°ng hi·ªáu v√† h√†nh ƒë·ªông
  primary: '#0066CC',
  primaryLight: '#E6F0FA',
  secondary: '#4CAF50',
  danger: '#E74C3C',
  warning: '#FF9800',
  info: '#2196F3',

  // M√†u vi·ªÅn
  border: '#DDDDDD',
  borderLight: '#EEEEEE',

  // M√†u tr·∫°ng th√°i
  statusCompleted: '#4CAF50',
  statusInProgress: '#2196F3',
  statusPending: '#FF9800',
  statusCancelled: '#F44336',

  // M√†u input
  inputBackground: '#F9F9F9',
  inputBorder: '#DDDDDD',
  inputPlaceholder: '#999999',

  // M√†u kh√°c
  divider: '#EEEEEE',
  shadow: '#000000',
  overlay: 'rgba(0, 0, 0, 0.5)',

  // ƒê·ªô trong su·ªët
  opacity: {
    disabled: 0.5,
    hover: 0.8,
  },
};

export const darkTheme = {
  // M√†u n·ªÅn
  background: '#121212',
  backgroundSecondary: '#1E1E1E',
  card: '#242424',

  // M√†u ch·ªØ
  text: '#FFFFFF',
  textSecondary: '#CCCCCC',
  textMuted: '#999999',

  // M√†u th∆∞∆°ng hi·ªáu v√† h√†nh ƒë·ªông
  primary: '#0B84FF',
  primaryLight: '#1C2A3A',
  secondary: '#4CAF50',
  danger: '#E74C3C',
  warning: '#FF9800',
  info: '#2196F3',

  // M√†u vi·ªÅn
  border: '#444444',
  borderLight: '#333333',

  // M√†u tr·∫°ng th√°i
  statusCompleted: '#4CAF50',
  statusInProgress: '#2196F3',
  statusPending: '#FF9800',
  statusCancelled: '#F44336',

  // M√†u input
  inputBackground: '#333333',
  inputBorder: '#444444',
  inputPlaceholder: '#777777',

  // M√†u kh√°c
  divider: '#333333',
  shadow: '#000000',
  overlay: 'rgba(0, 0, 0, 0.7)',

  // ƒê·ªô trong su·ªët
  opacity: {
    disabled: 0.5,
    hover: 0.8,
  },
};


--- END: src\config\colors.js ---


--- START: src\config\firebaseConfig.js ---
//src/config/firebaseConfig.js
// Import the required Firebase modules
import { initializeApp, getApps, getApp } from 'firebase/app';
import {
  initializeAuth,
  getReactNativePersistence,
  getAuth,
} from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';
import { getStorage } from 'firebase/storage';
import { getFunctions, connectFunctionsEmulator } from 'firebase/functions';
import AsyncStorage from '@react-native-async-storage/async-storage';
// Import Firebase compat to support legacy code that still uses the namespaced API (e.g., firebase.firestore())
import firebaseCompat from 'firebase/compat/app';
import 'firebase/compat/firestore';
import 'firebase/compat/auth';
import 'firebase/compat/storage';
import 'firebase/compat/functions';

// Firebase configuration object
const firebaseConfig = {
  apiKey: 'AIzaSyBYQoTM8YwjL4cq1TdF7dFz5U6Ss-wxb3A',
  authDomain: 'tanyb-fe4bf.firebaseapp.com',
  projectId: 'tanyb-fe4bf',
  storageBucket: 'tanyb-fe4bf.appspot.com',
  messagingSenderId: '370615243912',
  appId: '1:370615243912:web:f070ed1f8a20f4baaf7b3d',
  measurementId: 'G-DY64DPJJVQ',
};

let app;
let auth;

// Singleton pattern to avoid re-initialization
if (getApps().length < 1) {
  app = initializeApp(firebaseConfig);
  auth = initializeAuth(app, {
    persistence: getReactNativePersistence(AsyncStorage),
  });
} else {
  app = getApp();
  auth = getAuth(app);
}

const db = getFirestore(app);
const storage = getStorage(app);
const functions = getFunctions(app, 'asia-southeast1');

// (T√πy ch·ªçn) N·∫øu b·∫°n d√πng emulator ƒë·ªÉ test local, h√£y b·ªè comment d√≤ng d∆∞·ªõi
// if (__DEV__) {
//   try {
//     connectFunctionsEmulator(functions, 'localhost', 5001);
//   } catch (e) {
//     console.warn('Functions emulator already connected?');
//   }
// }

console.log('Firebase services handled.');

// Initialize firebase compat (namespaced) app if not already initialized
if (!firebaseCompat.apps.length) {
  firebaseCompat.initializeApp(firebaseConfig);
}

// Firestore and other services are now accessible via firebaseCompat.firestore(), etc.

// Export the initialized services
export { auth, db, storage, functions, firebaseCompat as firebase };
export default app;


--- END: src\config\firebaseConfig.js ---


--- START: src\contexts\AIChatContext.js ---
import React, { createContext, useContext, useReducer, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Action types
const ACTIONS = {
  SET_LOADING: 'SET_LOADING',
  ADD_MESSAGE: 'ADD_MESSAGE',
  SET_ERROR: 'SET_ERROR',
  CLEAR_CHAT: 'CLEAR_CHAT',
  LOAD_CHAT_HISTORY: 'LOAD_CHAT_HISTORY',
  SET_CURRENT_PROJECT: 'SET_CURRENT_PROJECT',
  UPDATE_MESSAGE_STATUS: 'UPDATE_MESSAGE_STATUS',
  SET_CHAT_MODE: 'SET_CHAT_MODE',
  ADD_SUGGESTED_QUESTION: 'ADD_SUGGESTED_QUESTION',
  MARK_MESSAGE_AS_READ: 'MARK_MESSAGE_AS_READ',
};

// Chat modes
export const CHAT_MODES = {
  GENERAL: 'general',
  PROJECT: 'project',
  EXPERT: 'expert',
};

// Initial state
const initialState = {
  messages: [],
  isLoading: false,
  error: null,
  currentProject: null,
  chatHistory: {}, // L∆∞u tr·ªØ theo projectId
  chatMode: CHAT_MODES.GENERAL,
  suggestedQuestions: [],
  unreadCount: 0,
};

// Reducer
const aiChatReducer = (state, action) => {
  switch (action.type) {
    case ACTIONS.SET_LOADING:
      return {
        ...state,
        isLoading: action.payload,
        error: null,
      };

    case ACTIONS.ADD_MESSAGE:
      const { message, projectId } = action.payload;
      const projectKey = projectId || 'general';

      return {
        ...state,
        messages: [...state.messages, message],
        chatHistory: {
          ...state.chatHistory,
          [projectKey]: [...(state.chatHistory[projectKey] || []), message],
        },
        unreadCount:
          message.role === 'assistant'
            ? state.unreadCount + 1
            : state.unreadCount,
      };

    case ACTIONS.SET_ERROR:
      return {
        ...state,
        error: action.payload,
        isLoading: false,
      };

    case ACTIONS.CLEAR_CHAT:
      return {
        ...state,
        messages: [],
        error: null,
        unreadCount: 0,
      };

    case ACTIONS.LOAD_CHAT_HISTORY:
      return {
        ...state,
        chatHistory: action.payload,
      };

    case ACTIONS.SET_CURRENT_PROJECT:
      const project = action.payload;
      const projectKeyForProject = project?.id || 'general';

      return {
        ...state,
        currentProject: project,
        messages: project
          ? state.chatHistory[projectKeyForProject] || []
          : state.chatHistory['general'] || [],
        chatMode: project ? CHAT_MODES.PROJECT : CHAT_MODES.GENERAL,
        unreadCount: 0, // Reset unread count when switching projects
      };

    case ACTIONS.UPDATE_MESSAGE_STATUS:
      const { messageId, status, response } = action.payload;
      return {
        ...state,
        messages: state.messages.map((msg) =>
          msg.id === messageId
            ? { ...msg, status, response, timestamp: new Date().toISOString() }
            : msg
        ),
        chatHistory: Object.keys(state.chatHistory).reduce((acc, key) => {
          acc[key] = state.chatHistory[key].map((msg) =>
            msg.id === messageId
              ? {
                  ...msg,
                  status,
                  response,
                  timestamp: new Date().toISOString(),
                }
              : msg
          );
          return acc;
        }, {}),
      };

    case ACTIONS.SET_CHAT_MODE:
      return {
        ...state,
        chatMode: action.payload,
      };

    case ACTIONS.ADD_SUGGESTED_QUESTION:
      return {
        ...state,
        suggestedQuestions: [...state.suggestedQuestions, action.payload],
      };

    case ACTIONS.MARK_MESSAGE_AS_READ:
      return {
        ...state,
        unreadCount: Math.max(0, state.unreadCount - 1),
      };

    default:
      return state;
  }
};

// Context
const AIChatContext = createContext();

// Provider component
export const AIChatProvider = ({ children }) => {
  const [state, dispatch] = useReducer(aiChatReducer, initialState);

  // Load chat history from storage on mount
  useEffect(() => {
    loadChatHistoryFromStorage();
  }, []);

  // Save chat history to storage whenever it changes
  useEffect(() => {
    saveChatHistoryToStorage();
  }, [state.chatHistory]);

  // Load chat history from AsyncStorage
  const loadChatHistoryFromStorage = async () => {
    try {
      const storedHistory = await AsyncStorage.getItem('ai_chat_history');
      if (storedHistory) {
        const parsedHistory = JSON.parse(storedHistory);
        dispatch({ type: ACTIONS.LOAD_CHAT_HISTORY, payload: parsedHistory });
      }
    } catch (error) {
      console.error('Error loading chat history:', error);
    }
  };

  // Save chat history to AsyncStorage
  const saveChatHistoryToStorage = async () => {
    try {
      await AsyncStorage.setItem(
        'ai_chat_history',
        JSON.stringify(state.chatHistory)
      );
    } catch (error) {
      console.error('Error saving chat history:', error);
    }
  };

  // Add a new message
  const addMessage = (message, projectId = null) => {
    const messageWithId = {
      ...message,
      id: Date.now().toString(),
      timestamp: new Date().toISOString(),
      status: 'sent',
      isRead: false,
    };

    dispatch({
      type: ACTIONS.ADD_MESSAGE,
      payload: { message: messageWithId, projectId },
    });

    return messageWithId;
  };

  // Update message status (e.g., when AI responds)
  const updateMessageStatus = (messageId, status, response = null) => {
    dispatch({
      type: ACTIONS.UPDATE_MESSAGE_STATUS,
      payload: { messageId, status, response },
    });
  };

  // Set current project for context
  const setCurrentProject = (project) => {
    dispatch({ type: ACTIONS.SET_CURRENT_PROJECT, payload: project });
  };

  // Clear current chat
  const clearChat = () => {
    dispatch({ type: ACTIONS.CLEAR_CHAT });
  };

  // Set chat mode
  const setChatMode = (mode) => {
    dispatch({ type: ACTIONS.SET_CHAT_MODE, payload: mode });
  };

  // Mark message as read
  const markMessageAsRead = () => {
    dispatch({ type: ACTIONS.MARK_MESSAGE_AS_READ });
  };

  // Get chat history for a specific project
  const getChatHistory = (projectId = null) => {
    const key = projectId || 'general';
    return state.chatHistory[key] || [];
  };

  // Get current project context
  const getCurrentProject = () => state.currentProject;

  // Check if currently loading
  const isLoading = () => state.isLoading;

  // Get current error
  const getError = () => state.error;

  // Get chat mode
  const getChatMode = () => state.chatMode;

  // Get unread count
  const getUnreadCount = () => state.unreadCount;

  // Get suggested questions
  const getSuggestedQuestions = () => state.suggestedQuestions;

  // Export chat history
  const exportChatHistory = async (projectId = null) => {
    try {
      const history = getChatHistory(projectId);
      const exportData = {
        project: projectId ? getCurrentProject() : null,
        timestamp: new Date().toISOString(),
        messages: history,
      };

      // Save to file or share
      return exportData;
    } catch (error) {
      console.error('Error exporting chat history:', error);
      return null;
    }
  };

  // Search in chat history
  const searchInChatHistory = (query, projectId = null) => {
    const history = getChatHistory(projectId);
    if (!query.trim()) return history;

    const searchTerm = query.toLowerCase();
    return history.filter((message) =>
      message.content.toLowerCase().includes(searchTerm)
    );
  };

  const value = {
    // State
    messages: state.messages,
    isLoading: state.isLoading,
    error: state.error,
    currentProject: state.currentProject,
    chatMode: state.chatMode,
    unreadCount: state.unreadCount,
    suggestedQuestions: state.suggestedQuestions,

    // Actions
    addMessage,
    updateMessageStatus,
    setCurrentProject,
    clearChat,
    setChatMode,
    markMessageAsRead,
    getChatHistory,
    getCurrentProject,
    isLoading,
    getError,
    getChatMode,
    getUnreadCount,
    getSuggestedQuestions,
    exportChatHistory,
    searchInChatHistory,

    // Constants
    CHAT_MODES,

    // Dispatch for custom actions
    dispatch,
  };

  return (
    <AIChatContext.Provider value={value}>{children}</AIChatContext.Provider>
  );
};

// Custom hook to use the context
export const useAIChat = () => {
  const context = useContext(AIChatContext);
  if (!context) {
    throw new Error('useAIChat must be used within an AIChatProvider');
  }
  return context;
};


--- END: src\contexts\AIChatContext.js ---


--- START: src\contexts\AuthContext.js ---
//src/contexts/AuthContext.js
import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
} from 'react';
import {
  onAuthStateChanged,
  signOut,
  signInWithEmailAndPassword,
  createUserWithEmailAndPassword,
  updateProfile,
  sendPasswordResetEmail,
} from 'firebase/auth';
import { doc, getDoc, setDoc, serverTimestamp } from 'firebase/firestore';
import { auth, db } from '../config/firebaseConfig';
import { Alert } from 'react-native';
import NetInfo from '@react-native-community/netinfo';
import { GoogleSignin } from '@react-native-google-signin/google-signin';
import messaging from '@react-native-firebase/messaging';
import { updateUser } from '../api/userService';

// T·∫°o context cho x√°c th·ª±c
const AuthContext = createContext();

// Provider component ƒë·ªÉ cung c·∫•p tr·∫°ng th√°i x√°c th·ª±c cho to√†n b·ªô ·ª©ng d·ª•ng
export const AuthProvider = ({ children }) => {
  // C√°c state c·∫ßn thi·∫øt
  const [currentUser, setCurrentUser] = useState(null);
  const [userRole, setUserRole] = useState(null);
  const [loadingAuth, setLoadingAuth] = useState(true);
  const [error, setError] = useState(null);
  const [connectionStatus, setConnectionStatus] = useState('connected');
  const [isOffline, setIsOffline] = useState(false);

  // Theo d√µi tr·∫°ng th√°i k·∫øt n·ªëi m·∫°ng
  useEffect(() => {
    console.log('Setting up network listener...');
    const unsubscribeNetInfo = NetInfo.addEventListener((state) => {
      console.log(
        'Network status:',
        state.isConnected ? 'Connected' : 'Disconnected'
      );
      setIsOffline(!state.isConnected);
      setConnectionStatus(state.isConnected ? 'connected' : 'disconnected');
    });

    return () => {
      unsubscribeNetInfo();
    };
  }, []);

  // H√†m y√™u c·∫ßu quy·ªÅn v√† l·∫•y FCM token
  const requestUserPermissionAndGetToken = async (userId) => {
    const authStatus = await messaging().requestPermission();
    const enabled =
      authStatus === messaging.AuthorizationStatus.AUTHORIZED ||
      authStatus === messaging.AuthorizationStatus.PROVISIONAL;

    if (enabled) {
      console.log('Authorization status:', authStatus);
      try {
        const fcmToken = await messaging().getToken();
        if (fcmToken) {
          console.log('A new FCM token has been generated:', fcmToken);
          // L∆∞u token v√†o Firestore
          await updateUser(userId, { fcmToken: fcmToken });
        }
      } catch (error) {
        console.error('Failed to get FCM token', error);
      }
    }
  };

  // H√†m l·∫•y th√¥ng tin ng∆∞·ªùi d√πng t·ª´ Firestore
  const fetchUserData = useCallback(async (userAuth) => {
    if (!userAuth) return null;

    const userRef = doc(db, 'users', userAuth.uid);
    try {
      console.log('Fetching user data for:', userAuth.uid);
      const docSnap = await getDoc(userRef);

      if (docSnap.exists()) {
        console.log('User data found:', docSnap.data());
        return { uid: userAuth.uid, email: userAuth.email, ...docSnap.data() };
      } else {
        console.log('User document not found! Creating new one.');
        const newUser = {
          uid: userAuth.uid,
          email: userAuth.email,
          role: 'user',
          createdAt: serverTimestamp(),
          displayName: userAuth.displayName || userAuth.email.split('@')[0],
          photoURL: userAuth.photoURL || '',
        };
        await setDoc(userRef, newUser);
        console.log('New user document created.');
        return newUser;
      }
    } catch (err) {
      console.error('Error fetching/creating user document:', err);
      // Fallback offline data
      return {
        uid: userAuth.uid,
        email: userAuth.email,
        displayName: userAuth.displayName || userAuth.email.split('@')[0],
        role: 'user',
        isOfflineData: true,
      };
    }
  }, []);

  // L·∫Øng nghe s·ª± thay ƒë·ªïi tr·∫°ng th√°i x√°c th·ª±c
  useEffect(() => {
    console.log('Setting up auth state listener...');

    // Ki·ªÉm tra xem auth ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o ch∆∞a
    if (!auth) {
      console.error('Auth instance is not initialized!');
      setLoadingAuth(false);
      setError('Authentication service is not available');
      return () => {};
    }

    const unsubscribe = onAuthStateChanged(auth, async (userAuth) => {
      console.log(
        'Auth state changed:',
        userAuth ? 'User logged in' : 'User logged out'
      );
      setLoadingAuth(true);

      try {
        if (userAuth) {
          const userData = await fetchUserData(userAuth);
          if (userData) {
            setCurrentUser(userData);
            setUserRole(userData.role || 'user');
            // G·ªåI H√ÄM L·∫§Y TOKEN ·ªû ƒê√ÇY
            requestUserPermissionAndGetToken(userAuth.uid);
          }
        } else {
          setCurrentUser(null);
          setUserRole(null);
        }
      } catch (err) {
        console.error('Error in auth state change:', err);
        setError('Authentication error occurred.');
      } finally {
        setLoadingAuth(false);
      }
    });

    return () => unsubscribe();
  }, [fetchUserData]);

  // H√†m ƒëƒÉng nh·∫≠p
  const login = async (email, password) => {
    try {
      setLoadingAuth(true);
      setError(null);

      // Ki·ªÉm tra k·∫øt n·ªëi m·∫°ng
      const netInfo = await NetInfo.fetch();
      if (!netInfo.isConnected) {
        throw new Error('No internet connection');
      }

      await signInWithEmailAndPassword(auth, email, password);
      console.log('Login successful:', email);
      return true;
    } catch (error) {
      console.error('Login error:', error);
      let errorMessage = 'Login failed. Please check your credentials.';

      switch (error.code) {
        case 'auth/invalid-email':
          errorMessage = 'Invalid email address.';
          break;
        case 'auth/user-disabled':
          errorMessage = 'This account has been disabled.';
          break;
        case 'auth/user-not-found':
          errorMessage = 'No account found with this email.';
          break;
        case 'auth/wrong-password':
          errorMessage = 'Incorrect password.';
          break;
        case 'auth/too-many-requests':
          errorMessage = 'Too many failed attempts. Please try again later.';
          break;
        case 'auth/network-request-failed':
          errorMessage = 'Network error. Please check your connection.';
          break;
        default:
          if (
            error.message.includes('internet') ||
            error.message.includes('connection')
          ) {
            errorMessage = 'No internet connection. Please check your network.';
          }
          break;
      }

      setError(errorMessage);
      Alert.alert('Login Error', errorMessage);
      return false;
    } finally {
      setLoadingAuth(false);
    }
  };

  // H√†m ƒëƒÉng k√Ω
  const register = async (email, password, displayName) => {
    try {
      setLoadingAuth(true);
      setError(null);

      const userCredential = await createUserWithEmailAndPassword(
        auth,
        email,
        password
      );

      if (displayName) {
        await updateProfile(userCredential.user, { displayName });
      }

      await setDoc(doc(db, 'users', userCredential.user.uid), {
        email,
        displayName: displayName || email.split('@')[0],
        role: 'user',
        createdAt: serverTimestamp(),
        photoURL: '',
      });

      console.log('Registration successful:', email);
      return true;
    } catch (error) {
      console.error('Registration error:', error);
      let errorMessage = 'Registration failed. Please try again.';

      switch (error.code) {
        case 'auth/email-already-in-use':
          errorMessage = 'This email is already registered.';
          break;
        case 'auth/invalid-email':
          errorMessage = 'Invalid email address.';
          break;
        case 'auth/weak-password':
          errorMessage =
            'Password is too weak. Please choose a stronger password.';
          break;
        case 'auth/network-request-failed':
          errorMessage = 'Network error. Please check your connection.';
          break;
      }

      setError(errorMessage);
      Alert.alert('Registration Error', errorMessage);
      return false;
    } finally {
      setLoadingAuth(false);
    }
  };

  // H√†m ƒëƒÉng xu·∫•t
  const logout = async () => {
    try {
      // ƒêƒÉng xu·∫•t kh·ªèi Google Sign-In tr∆∞·ªõc
      if (await GoogleSignin.isSignedIn()) {
        await GoogleSignin.signOut();
        console.log('Google user signed out');
      }

      // Sau ƒë√≥ ƒëƒÉng xu·∫•t kh·ªèi Firebase
      await signOut(auth);

      // C·∫≠p nh·∫≠t state
      setCurrentUser(null);
      setUserRole(null);

      console.log('User logged out successfully from all services');
      return true;
    } catch (error) {
      console.error('Logout failed:', error);
      setError('Logout failed. Please try again.');
      Alert.alert('Error', 'Logout failed. Please try again.');
      return false;
    }
  };

  // H√†m qu√™n m·∫≠t kh·∫©u
  const resetPassword = async (email) => {
    try {
      setLoadingAuth(true);
      setError(null);
      await sendPasswordResetEmail(auth, email);
      Alert.alert(
        'Password Reset Email Sent',
        'Please check your inbox and follow the instructions to reset your password.'
      );
      return true;
    } catch (error) {
      console.error('Password reset error:', error);
      let errorMessage =
        'Could not send password reset email. Please try again.';

      switch (error.code) {
        case 'auth/invalid-email':
          errorMessage = 'Invalid email address.';
          break;
        case 'auth/user-not-found':
          errorMessage = 'No account found with this email.';
          break;
      }

      setError(errorMessage);
      Alert.alert('Password Reset Error', errorMessage);
      return false;
    } finally {
      setLoadingAuth(false);
    }
  };

  // Gi√° tr·ªã context ƒë·ªÉ cung c·∫•p cho to√†n b·ªô ·ª©ng d·ª•ng
  const value = {
    currentUser,
    userRole,
    user: currentUser,
    loadingAuth,
    error,
    isSignedIn: !!currentUser,
    login,
    logout,
    register,
    resetPassword,
    connectionStatus,
    isOffline,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

// Custom hook ƒë·ªÉ s·ª≠ d·ª•ng AuthContext
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export default AuthContext;


--- END: src\contexts\AuthContext.js ---


--- START: src\contexts\ThemeContext.js ---
import React, { createContext, useState, useContext, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useColorScheme } from 'react-native';
import { lightTheme, darkTheme } from '../config/colors';

// T·∫°o context cho theme
const ThemeContext = createContext();

// Hook ƒë·ªÉ s·ª≠ d·ª•ng theme
export const useTheme = () => useContext(ThemeContext);

// Provider component
export const ThemeProvider = ({ children }) => {
  // L·∫•y theme h·ªá th·ªëng
  const systemColorScheme = useColorScheme();

  // State ƒë·ªÉ l∆∞u tr·∫°ng th√°i dark mode
  const [isDarkMode, setIsDarkMode] = useState(false);

  // State ƒë·ªÉ l∆∞u tr·∫°ng th√°i theo d√µi h·ªá th·ªëng
  const [followSystem, setFollowSystem] = useState(true);

  // L·∫•y theme t·ª´ storage khi component mount
  useEffect(() => {
    const loadThemePreference = async () => {
      try {
        const storedIsDarkMode = await AsyncStorage.getItem('isDarkMode');
        const storedFollowSystem = await AsyncStorage.getItem('followSystem');

        if (storedFollowSystem !== null) {
          setFollowSystem(storedFollowSystem === 'true');
        }

        if (storedIsDarkMode !== null && !followSystem) {
          setIsDarkMode(storedIsDarkMode === 'true');
        } else if (followSystem) {
          setIsDarkMode(systemColorScheme === 'dark');
        }
      } catch (error) {
        console.log('Error loading theme preference:', error);
      }
    };

    loadThemePreference();
  }, [systemColorScheme]);

  // C·∫≠p nh·∫≠t theme khi systemColorScheme thay ƒë·ªïi v√† followSystem = true
  useEffect(() => {
    if (followSystem) {
      setIsDarkMode(systemColorScheme === 'dark');
    }
  }, [systemColorScheme, followSystem]);

  // H√†m toggle dark mode
  const toggleTheme = async () => {
    try {
      const newValue = !isDarkMode;
      setIsDarkMode(newValue);
      await AsyncStorage.setItem('isDarkMode', String(newValue));

      // Khi ng∆∞·ªùi d√πng ch·ªß ƒë·ªông thay ƒë·ªïi theme, t·∫Øt ch·∫ø ƒë·ªô theo d√µi h·ªá th·ªëng
      if (followSystem) {
        setFollowSystem(false);
        await AsyncStorage.setItem('followSystem', 'false');
      }
    } catch (error) {
      console.log('Error saving theme preference:', error);
    }
  };

  // H√†m toggle ch·∫ø ƒë·ªô theo d√µi h·ªá th·ªëng
  const toggleFollowSystem = async () => {
    try {
      const newValue = !followSystem;
      setFollowSystem(newValue);
      await AsyncStorage.setItem('followSystem', String(newValue));

      // N·∫øu b·∫≠t ch·∫ø ƒë·ªô theo d√µi h·ªá th·ªëng, c·∫≠p nh·∫≠t theme theo h·ªá th·ªëng
      if (newValue) {
        const systemIsDark = systemColorScheme === 'dark';
        setIsDarkMode(systemIsDark);
        await AsyncStorage.setItem('isDarkMode', String(systemIsDark));
      }
    } catch (error) {
      console.log('Error saving system preference:', error);
    }
  };

  // L·∫•y theme hi·ªán t·∫°i
  const theme = isDarkMode ? darkTheme : lightTheme;

  // Gi√° tr·ªã ƒë∆∞·ª£c cung c·∫•p b·ªüi context
  const value = {
    isDarkMode,
    theme,
    toggleTheme,
    followSystem,
    toggleFollowSystem,
  };

  return (
    <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>
  );
};

export default ThemeContext;


--- END: src\contexts\ThemeContext.js ---


--- START: src\hooks\useAIChatIntegration.js ---
import { useCallback } from 'react';
import { useNavigation } from '@react-navigation/native';
import { useAIChat } from '../contexts/AIChatContext';
import { askAboutProject, askGeneralQuestion } from '../api/aiChatService';

/**
 * Hook ƒë·ªÉ t√≠ch h·ª£p AI Chat v·ªõi c√°c m√†n h√¨nh kh√°c
 * Cung c·∫•p c√°c h√†m ti·ªán √≠ch ƒë·ªÉ t∆∞∆°ng t√°c v·ªõi AI t·ª´ b·∫•t k·ª≥ ƒë√¢u trong app
 * Phi√™n b·∫£n ƒë∆°n gi·∫£n kh√¥ng ph·ª• thu·ªôc v√†o AIChatContext
 */
export const useAIChatIntegration = () => {
  const navigation = useNavigation();
  const {
    addMessage,
    updateMessageStatus,
    setCurrentProject,
    getChatHistory,
    clearChat,
    chatMode,
    CHAT_MODES,
  } = useAIChat();

  /**
   * M·ªü m√†n h√¨nh AI Chat v·ªõi context d·ª± √°n c·ª• th·ªÉ
   * @param {Object} project - Th√¥ng tin d·ª± √°n
   * @param {string} initialQuestion - C√¢u h·ªèi ban ƒë·∫ßu (t√πy ch·ªçn)
   */
  const openAIChatWithProject = useCallback(
    (project, initialQuestion = null) => {
      if (!project) {
        console.warn('Project is required for openAIChatWithProject');
        return;
      }

      // Set current project in context
      setCurrentProject(project);

      // Navigate to AI Chat screen with project data
      navigation.navigate('AIChat', {
        project,
        initialQuestion,
      });

      // If there's an initial question, add it to chat after navigation
      if (initialQuestion) {
        setTimeout(() => {
          addMessage(
            {
              role: 'user',
              content: initialQuestion,
              type: 'user',
            },
            project.id
          );
        }, 500);
      }
    },
    [navigation, setCurrentProject, addMessage]
  );

  /**
   * M·ªü m√†n h√¨nh AI Chat chung (kh√¥ng c√≥ d·ª± √°n c·ª• th·ªÉ)
   * @param {string} initialQuestion - C√¢u h·ªèi ban ƒë·∫ßu (t√πy ch·ªçn)
   */
  const openGeneralAIChat = useCallback(
    (initialQuestion = null) => {
      // Clear current project
      setCurrentProject(null);

      // Navigate to AI Chat screen
      navigation.navigate('AIChat', {
        initialQuestion,
      });

      // If there's an initial question, add it to chat after navigation
      if (initialQuestion) {
        setTimeout(() => {
          addMessage({
            role: 'user',
            content: initialQuestion,
            type: 'user',
          });
        }, 500);
      }
    },
    [navigation, setCurrentProject, addMessage]
  );

  /**
   * G·ª≠i c√¢u h·ªèi nhanh ƒë·∫øn AI (kh√¥ng m·ªü m√†n h√¨nh chat)
   * @param {string} question - C√¢u h·ªèi
   * @param {Object} project - D·ª± √°n (t√πy ch·ªçn)
   * @returns {Promise<Object>} Ph·∫£n h·ªìi t·ª´ AI
   */
  const askQuickQuestion = useCallback(
    async (question, project = null) => {
      try {
        let response;

        if (project) {
          const chatHistory = getChatHistory(project.id);
          response = await askAboutProject(question, project, chatHistory);
        } else {
          const chatHistory = getChatHistory();
          response = await askGeneralQuestion(question, chatHistory);
        }

        return response;
      } catch (error) {
        console.error('Error asking quick question:', error);
        return {
          success: false,
          error: error.message,
          message: 'C√≥ l·ªói x·∫£y ra khi g·ª≠i c√¢u h·ªèi',
        };
      }
    },
    [getChatHistory]
  );

  /**
   * T·∫°o c√¢u h·ªèi g·ª£i √Ω d·ª±a tr√™n context hi·ªán t·∫°i
   * @param {Object} project - D·ª± √°n (t√πy ch·ªçn)
   * @param {string} context - Context c·ª• th·ªÉ (t√πy ch·ªçn)
   * @returns {Array} Danh s√°ch c√¢u h·ªèi g·ª£i √Ω
   */
  const getContextualSuggestions = useCallback(
    (project = null, context = null) => {
      const baseSuggestions = [];

      if (project) {
        baseSuggestions.push(
          `D·ª± √°n "${project.name}" ƒëang ·ªü giai ƒëo·∫°n n√†o?`,
          'C·∫ßn l√†m g√¨ ƒë·ªÉ ƒë·∫©y nhanh ti·∫øn ƒë·ªô d·ª± √°n?',
          'C√≥ v·∫•n ƒë·ªÅ g√¨ c·∫ßn l∆∞u √Ω trong d·ª± √°n n√†y?'
        );

        if (context === 'production') {
          baseSuggestions.push(
            'L√†m th·∫ø n√†o ƒë·ªÉ t·ªëi ∆∞u h√≥a quy tr√¨nh s·∫£n xu·∫•t?',
            'C·∫ßn chu·∫©n b·ªã g√¨ cho giai ƒëo·∫°n ti·∫øp theo?',
            'C√≥ th·ªÉ c·∫£i thi·ªán hi·ªáu su·∫•t s·∫£n xu·∫•t nh∆∞ th·∫ø n√†o?'
          );
        } else if (context === 'financial') {
          baseSuggestions.push(
            'L√†m th·∫ø n√†o ƒë·ªÉ ki·ªÉm so√°t chi ph√≠ d·ª± √°n?',
            'C√≥ th·ªÉ t·ªëi ∆∞u h√≥a ng√¢n s√°ch kh√¥ng?',
            'C·∫ßn l∆∞u √Ω g√¨ v·ªÅ t√†i ch√≠nh d·ª± √°n?'
          );
        }
      } else {
        baseSuggestions.push(
          'L√†m th·∫ø n√†o ƒë·ªÉ qu·∫£n l√Ω d·ª± √°n hi·ªáu qu·∫£?',
          'C√°c b∆∞·ªõc l·∫≠p k·∫ø ho·∫°ch d·ª± √°n s·∫£n xu·∫•t?',
          'L√†m sao ƒë·ªÉ theo d√µi ti·∫øn ƒë·ªô d·ª± √°n?'
        );
      }

      return baseSuggestions;
    },
    []
  );

  /**
   * Ki·ªÉm tra xem c√≥ tin nh·∫Øn ch∆∞a ƒë·ªçc kh√¥ng
   * @returns {boolean} C√≥ tin nh·∫Øn ch∆∞a ƒë·ªçc hay kh√¥ng
   */
  const hasUnreadMessages = useCallback(() => {
    const currentHistory = getChatHistory();
    return currentHistory.some(
      (msg) => msg.role === 'assistant' && !msg.isRead
    );
  }, [getChatHistory]);

  /**
   * L·∫•y s·ªë tin nh·∫Øn ch∆∞a ƒë·ªçc
   * @returns {number} S·ªë tin nh·∫Øn ch∆∞a ƒë·ªçc
   */
  const getUnreadCount = useCallback(() => {
    const currentHistory = getChatHistory();
    return currentHistory.filter(
      (msg) => msg.role === 'assistant' && !msg.isRead
    ).length;
  }, [getChatHistory]);

  /**
   * T·∫°o b√°o c√°o t√≥m t·∫Øt t·ª´ l·ªãch s·ª≠ chat
   * @param {string} projectId - ID d·ª± √°n (t√πy ch·ªçn)
   * @returns {Object} B√°o c√°o t√≥m t·∫Øt
   */
  const generateChatSummary = useCallback(
    (projectId = null) => {
      const history = getChatHistory(projectId);

      if (history.length === 0) {
        return {
          totalMessages: 0,
          userMessages: 0,
          aiMessages: 0,
          lastActivity: null,
          summary: 'Ch∆∞a c√≥ tin nh·∫Øn n√†o',
        };
      }

      const userMessages = history.filter((msg) => msg.role === 'user');
      const aiMessages = history.filter((msg) => msg.role === 'assistant');
      const lastMessage = history[history.length - 1];

      return {
        totalMessages: history.length,
        userMessages: userMessages.length,
        aiMessages: aiMessages.length,
        lastActivity: lastMessage?.timestamp,
        summary: `T·ªïng c·ªông ${history.length} tin nh·∫Øn, ${userMessages.length} t·ª´ ng∆∞·ªùi d√πng, ${aiMessages.length} t·ª´ AI`,
      };
    },
    [getChatHistory]
  );

  return {
    // Navigation functions
    openAIChatWithProject,
    openGeneralAIChat,

    // Quick question functions
    askQuickQuestion,

    // Utility functions
    getContextualSuggestions,
    hasUnreadMessages,
    getUnreadCount,
    generateChatSummary,

    // Context information
    chatMode,
    CHAT_MODES,

    // Direct context access
    setCurrentProject,
    clearChat,
    getChatHistory,
  };
};


--- END: src\hooks\useAIChatIntegration.js ---


--- START: src\hooks\useContractGenerator.js ---
import { useState } from 'react';
import { Share, Alert, Linking } from 'react-native';
import { httpsCallable, getFunctions } from 'firebase/functions';
import app from '../config/firebaseConfig';
import { GoogleSignin } from '@react-native-google-signin/google-signin';

/**
 * Custom hook for generating contract documents.
 * This hook now handles generating a Google Doc and sharing its URL.
 * @param {Object} options - Configuration options
 * @returns {Object} - Functions and state for contract generation
 */
const useContractGenerator = ({
  projectId,
  customerData,
  materials,
  quotationData,
}) => {
  const [isLoading, setIsLoading] = useState(false);
  const [contractDocUrl, setContractDocUrl] = useState(null);

  /**
   * Format contract data for the template.
   */
  const formatContractData = () => {
    // Get today's date components for the contract
    const today = new Date();
    const day = today.getDate().toString();
    const month = (today.getMonth() + 1).toString();

    // Prepare contract data
    const contractData = {
      // Basic info
      companyName: customerData?.companyName || customerData?.name || '',
      customerAddress: customerData?.address || '',
      companyPhone: customerData?.phoneNumber || customerData?.phone || '',
      taxCode: customerData?.taxCode || '',
      day,
      month,
      deliveryTime: quotationData?.deliveryTime || '',

      // Pass the original materials array
      materials: materials || [],
    };

    return contractData;
  };

  /**
   * Generate contract document
   */
  const generateContract = async () => {
    setIsLoading(true);
    setContractDocUrl(null); // Reset on new generation

    try {
      // Ensure Google signed in and get access token
      const signedIn = await GoogleSignin.isSignedIn();
      if (!signedIn) {
        await GoogleSignin.signIn();
      }
      const tokens = await GoogleSignin.getTokens();
      const accessToken = tokens?.accessToken;
      if (!accessToken) {
        throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c access token Google.');
      }

      // Format contract data
      const contractData = formatContractData();

      // Call cloud function to generate contract
      const functions = getFunctions(app, 'us-central1');
      const generateContractFunc = httpsCallable(functions, 'generateContract');

      const result = await generateContractFunc({
        contractData,
        fileName: `Hop_dong_${
          customerData?.companyName || customerData?.name || 'khach_hang'
        }_${new Date().getTime()}`,
        projectId,
        accessToken,
      });

      // The cloud function now returns docUrl and docId
      const { docUrl } = result.data;

      // Update state with the new Google Doc URL
      setContractDocUrl(docUrl);

      Alert.alert(
        'Th√†nh c√¥ng',
        'ƒê√£ t·∫°o h·ª£p ƒë·ªìng Google Docs th√†nh c√¥ng. B·∫°n c√≥ mu·ªën chia s·∫ª li√™n k·∫øt kh√¥ng?',
        [
          { text: 'ƒê·ªÉ sau', style: 'cancel' },
          { text: 'Chia s·∫ª', onPress: () => shareContractDoc(docUrl) },
        ]
      );

      return { docUrl };
    } catch (error) {
      console.error('Error generating contract:', error);
      Alert.alert(
        'L·ªói',
        `Kh√¥ng th·ªÉ t·∫°o h·ª£p ƒë·ªìng: ${error.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh'}`
      );
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  /**
   * Share the Google Doc contract URL.
   * @param {string} docUrl - The URL of the Google Doc to share.
   */
  const shareContractDoc = async (docUrl) => {
    const urlToShare = docUrl || contractDocUrl;
    if (!urlToShare) {
      Alert.alert('L·ªói', 'Ch∆∞a c√≥ li√™n k·∫øt h·ª£p ƒë·ªìng ƒë·ªÉ chia s·∫ª.');
      return;
    }

    try {
      // Tr∆∞·ªõc ti√™n, th·ª≠ m·ªü Google Docs tr·ª±c ti·∫øp ƒë·ªÉ t·∫≠n d·ª•ng giao di·ªán chia s·∫ª c√≥ s·∫µn c·ªßa Google
      const canOpenDoc = await Linking.canOpenURL(urlToShare);

      if (canOpenDoc) {
        // M·ªü tr·ª±c ti·∫øp Google Doc ƒë·ªÉ ng∆∞·ªùi d√πng chia s·∫ª t·ª´ giao di·ªán Google
        await Linking.openURL(urlToShare);
        return;
      }

      // N·∫øu kh√¥ng th·ªÉ m·ªü tr·ª±c ti·∫øp, th√¨ th·ª±c hi·ªán chia s·∫ª URL nh∆∞ ph∆∞∆°ng √°n d·ª± ph√≤ng
      await Share.share({
        message: `Vui l√≤ng xem h·ª£p ƒë·ªìng t·∫°i ƒë√¢y: ${urlToShare}`,
        url: urlToShare,
        title: 'Chia s·∫ª H·ª£p ƒë·ªìng',
      });
    } catch (error) {
      console.error('Error sharing contract doc:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ chia s·∫ª h·ª£p ƒë·ªìng: ' + error.message);
    }
  };

  return {
    isLoading,
    contractDocUrl,
    generateContract,
    shareContractDoc,
  };
};

export default useContractGenerator;


--- END: src\hooks\useContractGenerator.js ---


--- START: src\hooks\useCustomerImport.js ---
import { useState, useCallback } from 'react';
import { Alert } from 'react-native';
import {
  GoogleSignin,
  statusCodes,
} from '@react-native-google-signin/google-signin';
import { functions } from '../config/firebaseConfig';
import { httpsCallable } from 'firebase/functions';

export const useCustomerImport = () => {
  // State for Google Drive integration
  const [driveFiles, setDriveFiles] = useState([]);
  const [isPickerVisible, setIsPickerVisible] = useState(false);
  const [isLoadingFiles, setIsLoadingFiles] = useState(false);
  const [isProcessingFile, setIsProcessingFile] = useState(false);

  // L·∫•y danh s√°ch file customer t·ª´ Google Drive
  const fetchCustomerFiles = useCallback(async () => {
    setIsLoadingFiles(true);

    try {
      // 1. Ki·ªÉm tra ƒëƒÉng nh·∫≠p Google
      const isSignedIn = await GoogleSignin.isSignedIn();
      if (!isSignedIn) {
        Alert.alert(
          'Y√™u c·∫ßu ƒëƒÉng nh·∫≠p',
          'Vui l√≤ng ƒëƒÉng nh·∫≠p Google ƒë·ªÉ truy c·∫≠p file Excel.',
          [
            {
              text: 'H·ªßy',
              style: 'cancel',
            },
            {
              text: 'ƒêƒÉng nh·∫≠p',
              onPress: async () => {
                try {
                  await GoogleSignin.signIn();
                  // Th·ª≠ l·∫°i sau khi ƒëƒÉng nh·∫≠p
                  fetchCustomerFiles();
                } catch (error) {
                  console.error('L·ªói ƒëƒÉng nh·∫≠p Google:', error);
                  Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ƒëƒÉng nh·∫≠p Google.');
                }
              },
            },
          ]
        );
        return;
      }

      // 2. L·∫•y accessToken
      const tokens = await GoogleSignin.getTokens();
      const { accessToken } = tokens;

      if (!accessToken) {
        throw new Error(
          'Kh√¥ng th·ªÉ l·∫•y ƒë∆∞·ª£c access token c·ªßa Google. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.'
        );
      }

      // 3. G·ªçi Cloud Function ƒë·ªÉ l·∫•y danh s√°ch file
      const getCustomerFilesFunction = httpsCallable(
        functions,
        'getCustomerFiles'
      );
      const result = await getCustomerFilesFunction({ accessToken });

      if (result.data.success) {
        setDriveFiles(result.data.files || []);
      } else {
        throw new Error('Kh√¥ng th·ªÉ l·∫•y danh s√°ch file');
      }
    } catch (error) {
      console.error('‚ùå L·ªói khi t·∫£i file customer:', error);

      // X·ª≠ l√Ω l·ªói ƒëƒÉng nh·∫≠p
      if (error.code === statusCodes.SIGN_IN_REQUIRED) {
        Alert.alert(
          'Y√™u c·∫ßu ƒëƒÉng nh·∫≠p',
          'Vui l√≤ng ƒëƒÉng nh·∫≠p Google ƒë·ªÉ truy c·∫≠p file Excel.',
          [
            {
              text: 'H·ªßy',
              style: 'cancel',
            },
            {
              text: 'ƒêƒÉng nh·∫≠p',
              onPress: async () => {
                try {
                  await GoogleSignin.signIn();
                  // Th·ª≠ l·∫°i sau khi ƒëƒÉng nh·∫≠p
                  fetchCustomerFiles();
                } catch (signInError) {
                  console.error('L·ªói ƒëƒÉng nh·∫≠p Google:', signInError);
                  Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ƒëƒÉng nh·∫≠p Google.');
                }
              },
            },
          ]
        );
      } else {
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch file customer.');
      }
    } finally {
      setIsLoadingFiles(false);
    }
  }, []);

  // Import kh√°ch h√†ng t·ª´ file Excel
  const importCustomersFromFile = useCallback(async (fileId, fileName) => {
    setIsProcessingFile(true);

    try {
      // 1. Ki·ªÉm tra ƒëƒÉng nh·∫≠p Google
      const isSignedIn = await GoogleSignin.isSignedIn();
      if (!isSignedIn) {
        Alert.alert(
          'Y√™u c·∫ßu ƒëƒÉng nh·∫≠p',
          'Vui l√≤ng ƒëƒÉng nh·∫≠p Google ƒë·ªÉ import file Excel.',
          [
            {
              text: 'H·ªßy',
              style: 'cancel',
            },
            {
              text: 'ƒêƒÉng nh·∫≠p',
              onPress: async () => {
                try {
                  await GoogleSignin.signIn();
                  // Th·ª≠ l·∫°i sau khi ƒëƒÉng nh·∫≠p
                  importCustomersFromFile(fileId, fileName);
                } catch (error) {
                  console.error('L·ªói ƒëƒÉng nh·∫≠p Google:', error);
                  Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ƒëƒÉng nh·∫≠p Google.');
                }
              },
            },
          ]
        );
        return;
      }

      // 2. L·∫•y accessToken
      const tokens = await GoogleSignin.getTokens();
      const { accessToken } = tokens;

      if (!accessToken) {
        throw new Error(
          'Kh√¥ng th·ªÉ l·∫•y ƒë∆∞·ª£c access token c·ªßa Google. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.'
        );
      }

      // 3. Hi·ªÉn th·ªã th√¥ng b√°o ƒëang x·ª≠ l√Ω
      Alert.alert(
        'ƒêang x·ª≠ l√Ω...',
        `H·ªá th·ªëng ƒëang import kh√°ch h√†ng t·ª´ file "${fileName}". Vui l√≤ng ch·ªù.`
      );

      // 4. G·ªçi Cloud Function ƒë·ªÉ import
      const importCustomersFunction = httpsCallable(
        functions,
        'importCustomersFromExcel'
      );
      const result = await importCustomersFunction({
        driveFileId: fileId,
        accessToken,
      });

      // 5. X·ª≠ l√Ω k·∫øt qu·∫£
      if (result.data.success) {
        Alert.alert(
          'Th√†nh c√¥ng',
          `ƒê√£ import th√†nh c√¥ng ${result.data.successCount}/${
            result.data.totalProcessed
          } kh√°ch h√†ng.\n\n${
            result.data.errorCount > 0
              ? `C√≥ ${result.data.errorCount} l·ªói.`
              : ''
          }`
        );
        return result.data;
      } else {
        throw new Error('Import kh√¥ng th√†nh c√¥ng');
      }
    } catch (error) {
      console.error('‚ùå L·ªói khi import kh√°ch h√†ng:', error);

      // X·ª≠ l√Ω l·ªói ƒëƒÉng nh·∫≠p
      if (error.code === statusCodes.SIGN_IN_REQUIRED) {
        Alert.alert(
          'Y√™u c·∫ßu ƒëƒÉng nh·∫≠p',
          'Vui l√≤ng ƒëƒÉng nh·∫≠p Google ƒë·ªÉ import file Excel.',
          [
            {
              text: 'H·ªßy',
              style: 'cancel',
            },
            {
              text: 'ƒêƒÉng nh·∫≠p',
              onPress: async () => {
                try {
                  await GoogleSignin.signIn();
                  // Th·ª≠ l·∫°i sau khi ƒëƒÉng nh·∫≠p
                  importCustomersFromFile(fileId, fileName);
                } catch (signInError) {
                  console.error('L·ªói ƒëƒÉng nh·∫≠p Google:', signInError);
                  Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ƒëƒÉng nh·∫≠p Google.');
                }
              },
            },
          ]
        );
      } else {
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ import kh√°ch h√†ng t·ª´ file Excel.');
      }
    } finally {
      setIsProcessingFile(false);
    }
  }, []);

  return {
    driveFiles,
    isPickerVisible,
    isLoadingFiles,
    isProcessingFile,
    setIsPickerVisible,
    fetchCustomerFiles,
    importCustomersFromFile,
  };
};

















--- END: src\hooks\useCustomerImport.js ---


--- START: src\hooks\useDeliveryNoteGenerator.js ---
import { useState, useEffect, useCallback } from 'react';
import * as FileSystem from 'expo-file-system';
import * as Sharing from 'expo-sharing';
import { Alert } from 'react-native';
import { httpsCallable } from 'firebase/functions';
import { functions as firebaseFunctions } from '../config/firebaseConfig';
import { GoogleSignin } from '@react-native-google-signin/google-signin';
import {
  collection,
  query,
  orderBy,
  getDocs,
  limit,
  addDoc,
  serverTimestamp,
  doc,
  getDoc,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';

const useDeliveryNoteGenerator = ({ projectId }) => {
  const [isLoading, setIsLoading] = useState(false);
  const [excelUrl, setExcelUrl] = useState(null);
  const [driveFileId, setDriveFileId] = useState(null);
  const [latestQuotation, setLatestQuotation] = useState(null);
  const [isLoadingQuotation, setIsLoadingQuotation] = useState(false);

  // Fetch the latest quotation for this project
  useEffect(() => {
    const fetchLatestQuotation = async () => {
      if (!projectId) return;

      try {
        setIsLoadingQuotation(true);
        const quotationsRef = collection(
          db,
          `projects/${projectId}/quotations`
        );
        const q = query(quotationsRef, orderBy('createdAt', 'desc'), limit(1));
        const querySnapshot = await getDocs(q);

        if (!querySnapshot.empty) {
          const latestQuotationData = {
            id: querySnapshot.docs[0].id,
            ...querySnapshot.docs[0].data(),
          };
          setLatestQuotation(latestQuotationData);
          console.log(
            'Latest quotation found:',
            latestQuotationData.quotationNumber
          );
        } else {
          console.log('No quotations found for this project');
        }
      } catch (error) {
        console.error('Error fetching latest quotation:', error);
      } finally {
        setIsLoadingQuotation(false);
      }
    };

    fetchLatestQuotation();
  }, [projectId]);

  const formatDeliveryNoteDataForExcel = (deliveryNoteData) => {
    const {
      deliveryNoteNumber,
      deliveryDate,
      customerName,
      customerTaxCode,
      customerAddress,
      customerRepresentative,
      customerRepresentativePosition,
      items = [],
    } = deliveryNoteData;

    return {
      metadata: {
        deliveryNoteNumber,
        deliveryDate: new Date(deliveryDate).toLocaleDateString('vi-VN'),
        customerName: customerName || '',
        customerTaxCode: customerTaxCode || '',
        customerAddress: customerAddress || '',
        customerRepresentative: customerRepresentative || '',
        customerRepresentativePosition: customerRepresentativePosition || '',
      },
      items: items.map((item, index) => ({
        no: index + 1,
        name: item.name || '',
        material: item.material || '',
        unit: item.unit || '',
        quantity: item.quantity || 0,
      })),
    };
  };

  // Save delivery note metadata to Firestore
  const saveDeliveryNote = async (deliveryNoteData, excelUrl, driveFileId) => {
    try {
      const deliveryNotesRef = collection(
        db,
        `projects/${projectId}/deliveryNotes`
      );

      await addDoc(deliveryNotesRef, {
        ...deliveryNoteData,
        excelUrl,
        driveFileId,
        createdAt: serverTimestamp(),
      });

      console.log('Delivery note saved to Firestore');
    } catch (error) {
      console.error('Error saving delivery note to Firestore:', error);
      // Continue even if saving to Firestore fails
    }
  };

  const generateDeliveryNote = async (deliveryNoteData) => {
    try {
      setIsLoading(true);
      const formattedData = formatDeliveryNoteDataForExcel(deliveryNoteData);

      // Ensure we have a Google access token
      const signedIn = await GoogleSignin.isSignedIn();
      if (!signedIn) {
        await GoogleSignin.signIn();
      }
      const { accessToken } = await GoogleSignin.getTokens();
      if (!accessToken) {
        throw new Error('Kh√¥ng th·ªÉ l·∫•y Google access token');
      }

      console.log(
        'Calling generateDeliveryNoteExcel with accessToken:',
        accessToken ? 'Valid token' : 'No token'
      );

      const generateExcelFunc = httpsCallable(
        firebaseFunctions,
        'generateDeliveryNoteExcel'
      );

      console.log('Sending data to cloud function:', {
        projectId,
        deliveryNoteId: deliveryNoteData.deliveryNoteNumber.replace(/\//g, '-'),
      });

      const result = await generateExcelFunc({
        formattedData,
        projectId,
        deliveryNoteId: deliveryNoteData.deliveryNoteNumber.replace(/\//g, '-'),
        accessToken,
      });

      console.log('Cloud function result:', result.data);
      const { excelUrl: url, driveFileId: fileId } = result.data;

      setExcelUrl(url);
      setDriveFileId(fileId);

      // Save to Firestore
      await saveDeliveryNote(deliveryNoteData, url, fileId);

      return url;
    } catch (error) {
      console.error('Error generating delivery note excel:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫°o bi√™n b·∫£n giao h√†ng: ' + error.message);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  const shareDeliveryNote = async () => {
    try {
      if (!excelUrl) {
        Alert.alert('L·ªói', 'Ch∆∞a c√≥ file bi√™n b·∫£n ƒë·ªÉ chia s·∫ª.');
        return;
      }

      const fileUri = `${FileSystem.documentDirectory}delivery_note.xlsx`;
      const { uri } = await FileSystem.downloadAsync(excelUrl, fileUri);

      await Sharing.shareAsync(uri, {
        mimeType:
          'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        dialogTitle: 'Chia s·∫ª bi√™n b·∫£n giao h√†ng',
      });
    } catch (error) {
      console.error('Error sharing delivery note:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ chia s·∫ª file: ' + error.message);
    }
  };

  return {
    generateDeliveryNote,
    shareDeliveryNote,
    isLoading,
    isLoadingQuotation,
    excelUrl,
    driveFileId,
    latestQuotation,
  };
};

export default useDeliveryNoteGenerator;


--- END: src\hooks\useDeliveryNoteGenerator.js ---


--- START: src\hooks\useInventory.js ---
import { useState, useEffect, useCallback } from 'react';
import InventoryService from '../api/inventoryService';
import { firebase } from '../config/firebaseConfig';

/**
 * Hook qu·∫£n l√Ω c√°c ch·ª©c nƒÉng li√™n quan ƒë·∫øn kho
 * @returns {Object} C√°c ch·ª©c nƒÉng v√† d·ªØ li·ªáu kho
 */
const useInventory = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [inventoryItems, setInventoryItems] = useState([]);
  const [categories, setCategories] = useState([]);
  const [locations, setLocations] = useState([]);

  /**
   * L·∫•y danh s√°ch v·∫≠t t∆∞ t·ª´ Firestore
   */
  const fetchInventoryItems = useCallback(async (filters = {}) => {
    setLoading(true);
    setError(null);
    try {
      console.log('=== USEINVENTORY: B·∫ÆT ƒê·∫¶U FETCH INVENTORY ITEMS ===');

      // Kh·ªüi t·∫°o truy v·∫•n
      let query = firebase.firestore().collection('inventory');

      // √Åp d·ª•ng b·ªô l·ªçc n·∫øu c√≥
      if (filters.categoryId) {
        query = query.where('categoryId', '==', filters.categoryId);
      }

      if (filters.locationId) {
        query = query.where('locationId', '==', filters.locationId);
      }

      // Th·ª±c hi·ªán truy v·∫•n
      console.log('=== USEINVENTORY: TH·ª∞C HI·ªÜN QUERY ===');
      const snapshot = await query.get();

      console.log('=== USEINVENTORY: K·∫æT QU·∫¢ QUERY ===');
      console.log('S·ªë l∆∞·ª£ng documents:', snapshot.docs.length);

      // L·∫•y d·ªØ li·ªáu t·ª´ k·∫øt qu·∫£
      const items = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));

      console.log('=== USEINVENTORY: D·ªÆ LI·ªÜU ƒê√É PARSE ===');
      console.log('S·ªë l∆∞·ª£ng items:', items.length);
      if (items.length > 0) {
        console.log('Item ƒë·∫ßu ti√™n:', JSON.stringify(items[0], null, 2));
      }

      // S·∫Øp x·∫øp theo th·ªùi gian (m·ªõi nh·∫•t tr∆∞·ªõc)
      const sortedItems = items.sort((a, b) => {
        // ∆Øu ti√™n lastUpdated, sau ƒë√≥ updatedAt, cu·ªëi c√πng createdAt
        const aTime = a.lastUpdated || a.updatedAt || a.createdAt;
        const bTime = b.lastUpdated || b.updatedAt || b.createdAt;

        if (aTime && bTime) {
          return bTime.toDate().getTime() - aTime.toDate().getTime();
        }
        return 0;
      });

      console.log('=== USEINVENTORY: D·ªÆ LI·ªÜU ƒê√É S·∫ÆP X·∫æP ===');
      console.log('S·ªë l∆∞·ª£ng items sau khi s·∫Øp x·∫øp:', sortedItems.length);

      // √Åp d·ª•ng b·ªô l·ªçc t·ªìn kho n·∫øu c√≥
      const filteredItems = filters.lowStock
        ? sortedItems.filter(
            (item) =>
              item.stockQuantity <= (item.minQuantity || 0) &&
              item.minQuantity > 0
          )
        : sortedItems;

      console.log('=== USEINVENTORY: D·ªÆ LI·ªÜU SAU KHI L·ªåC ===');
      console.log('S·ªë l∆∞·ª£ng items sau khi l·ªçc:', filteredItems.length);

      setInventoryItems(filteredItems);
    } catch (err) {
      console.error('=== USEINVENTORY: L·ªñI FETCH ===');
      console.error('L·ªói khi l·∫•y danh s√°ch v·∫≠t t∆∞:', err);
      console.error('Error details:', err.message, err.code);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, []);

  /**
   * L·∫•y danh s√°ch danh m·ª•c v·∫≠t t∆∞
   */
  const fetchCategories = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const snapshot = await firebase
        .firestore()
        .collection('inventory_categories')
        .get();
      const fetchedCategories = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));
      setCategories(fetchedCategories);
    } catch (err) {
      console.error('L·ªói khi l·∫•y danh m·ª•c v·∫≠t t∆∞:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, []);

  /**
   * L·∫•y danh s√°ch c√°c v·ªã tr√≠ kho
   */
  const fetchLocations = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const locations = await InventoryService.getAllLocations();
      setLocations(locations);
    } catch (err) {
      console.error('L·ªói khi l·∫•y v·ªã tr√≠ kho:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, []);

  /**
   * Th√™m v·∫≠t t∆∞ m·ªõi v√†o kho
   * @param {Object} itemData - Th√¥ng tin v·∫≠t t∆∞
   * @returns {Promise<Object>} - K·∫øt qu·∫£ thao t√°c
   */
  const addInventoryItem = async (itemData) => {
    setLoading(true);
    setError(null);
    try {
      console.log('=== USEINVENTORY: B·∫ÆT ƒê·∫¶U TH√äM V·∫¨T T∆Ø ===');
      console.log('itemData nh·∫≠n ƒë∆∞·ª£c:', JSON.stringify(itemData, null, 2));

      const result = await InventoryService.addInventoryItem(itemData);
      console.log('=== USEINVENTORY: K·∫æT QU·∫¢ T·ª™ INVENTORYSERVICE ===');
      console.log('result:', result);

      // Refresh danh s√°ch n·∫øu th√†nh c√¥ng
      console.log('=== USEINVENTORY: B·∫ÆT ƒê·∫¶U REFRESH DANH S√ÅCH ===');
      await fetchInventoryItems();
      console.log('=== USEINVENTORY: HO√ÄN TH√ÄNH REFRESH DANH S√ÅCH ===');

      return result;
    } catch (err) {
      console.error('=== USEINVENTORY: L·ªñI KHI TH√äM V·∫¨T T∆Ø ===');
      console.error('Error object:', err);
      console.error('Error message:', err.message);
      console.error('Error code:', err.code);
      console.error('Error details:', err.details);
      console.error('=== END L·ªñI USEINVENTORY ===');

      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  /**
   * C·∫≠p nh·∫≠t th√¥ng tin v·∫≠t t∆∞
   * @param {string} itemId - ID v·∫≠t t∆∞
   * @param {Object} itemData - Th√¥ng tin c·∫≠p nh·∫≠t
   * @returns {Promise<Object>} - K·∫øt qu·∫£ thao t√°c
   */
  const updateInventoryItem = async (itemId, itemData) => {
    setLoading(true);
    setError(null);
    try {
      const result = await InventoryService.updateInventoryItem(
        itemId,
        itemData
      );
      // Refresh danh s√°ch n·∫øu th√†nh c√¥ng
      await fetchInventoryItems();
      return result;
    } catch (err) {
      console.error('L·ªói khi c·∫≠p nh·∫≠t v·∫≠t t∆∞:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  /**
   * T·∫°o giao d·ªãch nh·∫≠p/xu·∫•t kho
   * @param {Object} transactionData - Th√¥ng tin giao d·ªãch
   * @returns {Promise<Object>} - K·∫øt qu·∫£ thao t√°c
   */
  const createTransaction = async (transactionData) => {
    setLoading(true);
    setError(null);
    try {
      const result = await InventoryService.createTransaction(transactionData);
      // Refresh danh s√°ch n·∫øu th√†nh c√¥ng
      await fetchInventoryItems();
      return result;
    } catch (err) {
      console.error('L·ªói khi t·∫°o giao d·ªãch kho:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  /**
   * L·∫•y th·ªëng k√™ s·ª≠ d·ª•ng v·∫≠t t∆∞ theo d·ª± √°n
   * @param {string} projectId - ID d·ª± √°n
   * @param {Object} dateRange - Kho·∫£ng th·ªùi gian
   * @returns {Promise<Object>} - K·∫øt qu·∫£ thao t√°c
   */
  const getProjectMaterialUsage = async (projectId, dateRange = {}) => {
    setLoading(true);
    setError(null);
    try {
      return await InventoryService.getProjectMaterialUsage(
        projectId,
        dateRange.startDate,
        dateRange.endDate
      );
    } catch (err) {
      console.error('L·ªói khi l·∫•y th·ªëng k√™ s·ª≠ d·ª•ng v·∫≠t t∆∞:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  /**
   * Qu·∫£n l√Ω danh m·ª•c v·∫≠t t∆∞ (th√™m, s·ª≠a, x√≥a)
   * @param {string} action - H√†nh ƒë·ªông: 'add', 'update', 'delete'
   * @param {Object} categoryData - Th√¥ng tin danh m·ª•c
   * @param {string} categoryId - ID danh m·ª•c (cho update/delete)
   * @returns {Promise<Object>} - K·∫øt qu·∫£ thao t√°c
   */
  const manageCategory = async (action, categoryData, categoryId) => {
    setLoading(true);
    setError(null);
    try {
      const result = await InventoryService.manageCategory(
        action,
        categoryData,
        categoryId
      );
      // Refresh danh m·ª•c n·∫øu th√†nh c√¥ng
      await fetchCategories();
      return result;
    } catch (err) {
      console.error('L·ªói khi qu·∫£n l√Ω danh m·ª•c:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  /**
   * L·∫•y chi ti·∫øt v·∫≠t t∆∞
   * @param {string} itemId - ID v·∫≠t t∆∞
   * @returns {Promise<Object>} - Th√¥ng tin chi ti·∫øt v·∫≠t t∆∞
   */
  const getInventoryItemDetail = async (itemId) => {
    setLoading(true);
    setError(null);
    try {
      const itemDetail = await InventoryService.getItemById(itemId);
      const transactions = await InventoryService.getItemTransactions(itemId);

      // N·∫øu item c√≥ categoryId, l·∫•y th√¥ng tin danh m·ª•c
      let category = null;
      if (itemDetail.categoryId) {
        const categoryDoc = await firebase
          .firestore()
          .collection('inventory_categories')
          .doc(itemDetail.categoryId)
          .get();

        if (categoryDoc.exists) {
          category = {
            id: categoryDoc.id,
            ...categoryDoc.data(),
          };
        }
      }

      return {
        ...itemDetail,
        category,
        transactions,
      };
    } catch (err) {
      console.error('L·ªói khi l·∫•y chi ti·∫øt v·∫≠t t∆∞:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  /**
   * Nh·∫≠p v·∫≠t t∆∞ t·ª´ file Excel m·ªõi nh·∫•t trong Google Drive
   * @param {string} accessToken - Google access token
   * @param {string} folderId - ID c·ªßa folder ch·ª©a file Excel
   * @returns {Promise<Object>} - K·∫øt qu·∫£ nh·∫≠p v·∫≠t t∆∞
   */
  const importInventoryFromDrive = async (accessToken, folderId) => {
    setLoading(true);
    setError(null);
    try {
      const result = await InventoryService.importInventoryFromDrive(
        accessToken,
        folderId
      );
      // Refresh danh s√°ch n·∫øu th√†nh c√¥ng
      await fetchInventoryItems();
      return result;
    } catch (err) {
      console.error('L·ªói khi nh·∫≠p v·∫≠t t∆∞ t·ª´ Google Drive:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  /**
   * T√¨m v·∫≠t t∆∞ t∆∞∆°ng t·ª± trong kho
   * @param {Object} criteria - Ti√™u ch√≠ t√¨m ki·∫øm (t√™n, m√£, ƒë∆°n v·ªã...)
   * @returns {Promise<Array>} - Danh s√°ch v·∫≠t t∆∞ t∆∞∆°ng t·ª±
   */
  const findSimilarItems = useCallback(
    async (criteria) => {
      setLoading(true);
      setError(null);
      try {
        // N·∫øu ch∆∞a c√≥ d·ªØ li·ªáu, t·∫£i danh s√°ch v·∫≠t t∆∞
        if (inventoryItems.length === 0) {
          await fetchInventoryItems();
        }

        // T√¨m ki·∫øm theo t√™n
        if (criteria.name) {
          const nameWords = criteria.name
            .toLowerCase()
            .split(' ')
            .filter((word) => word.length > 2);

          const matchedItems = inventoryItems.filter((item) => {
            const itemNameLower = item.name.toLowerCase();

            // Ki·ªÉm tra t√™n v·∫≠t t∆∞ c√≥ ch·ª©a t·ª´ kh√≥a t√¨m ki·∫øm kh√¥ng
            const nameMatch = nameWords.some((word) =>
              itemNameLower.includes(word)
            );

            // Ki·ªÉm tra ƒë∆°n v·ªã t√≠nh n·∫øu c√≥
            const unitMatch =
              !criteria.unit ||
              (item.unit &&
                item.unit.toLowerCase() === criteria.unit.toLowerCase());

            // Ki·ªÉm tra ch·∫•t li·ªáu n·∫øu c√≥
            const materialMatch =
              !criteria.material ||
              (item.material &&
                item.material
                  .toLowerCase()
                  .includes(criteria.material.toLowerCase()));

            // Ki·ªÉm tra danh m·ª•c n·∫øu c√≥
            const categoryMatch =
              !criteria.categoryId || item.categoryId === criteria.categoryId;

            return nameMatch && unitMatch && materialMatch && categoryMatch;
          });

          return matchedItems;
        }

        // N·∫øu t√¨m theo m√£ v·∫≠t t∆∞
        if (criteria.code) {
          const codeLower = criteria.code.toLowerCase();

          return inventoryItems.filter(
            (item) => item.code && item.code.toLowerCase().includes(codeLower)
          );
        }

        // N·∫øu kh√¥ng c√≥ ti√™u ch√≠ c·ª• th·ªÉ, tr·∫£ v·ªÅ danh s√°ch tr·ªëng
        return [];
      } catch (err) {
        console.error('L·ªói khi t√¨m v·∫≠t t∆∞ t∆∞∆°ng t·ª±:', err);
        setError(err.message);
        return [];
      } finally {
        setLoading(false);
      }
    },
    [inventoryItems, fetchInventoryItems]
  );

  /**
   * G√°n v·∫≠t t∆∞ t·ª´ kho cho d·ª± √°n
   * @param {string} inventoryItemId - ID v·∫≠t t∆∞ trong kho
   * @param {string} projectId - ID d·ª± √°n
   * @param {number} quantity - S·ªë l∆∞·ª£ng c·∫ßn g√°n
   * @param {Object} metadata - Th√¥ng tin b·ªï sung
   * @returns {Promise<Object>} - K·∫øt qu·∫£ thao t√°c
   */
  const assignInventoryItemToProject = async (
    inventoryItemId,
    projectId,
    quantity,
    metadata = {}
  ) => {
    setLoading(true);
    setError(null);
    try {
      // T·∫°o giao d·ªãch xu·∫•t kho
      const transaction = {
        itemId: inventoryItemId,
        type: 'out',
        quantity,
        projectId,
        projectName: metadata.projectName || 'D·ª± √°n',
        reason: metadata.reason || 'G√°n cho d·ª± √°n',
        date: new Date(),
        createdBy: metadata.userId || 'unknown',
        createdByName: metadata.userName || 'Ng∆∞·ªùi d√πng',
      };

      const result = await createTransaction(transaction);

      // C·∫≠p nh·∫≠t l·∫°i danh s√°ch v·∫≠t t∆∞
      await fetchInventoryItems();

      return result;
    } catch (err) {
      console.error('L·ªói khi g√°n v·∫≠t t∆∞ cho d·ª± √°n:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  // S·ª≠ d·ª•ng useEffect ƒë·ªÉ kh·ªüi t·∫°o d·ªØ li·ªáu khi c·∫ßn
  useEffect(() => {
    fetchCategories();
    fetchLocations();
    // Kh√¥ng t·ª± ƒë·ªông l·∫•y danh s√°ch v·∫≠t t∆∞ ·ªü ƒë√¢y ƒë·ªÉ tr√°nh truy v·∫•n kh√¥ng c·∫ßn thi·∫øt
  }, [fetchCategories, fetchLocations]);

  return {
    loading,
    error,
    inventoryItems,
    categories,
    locations,
    fetchInventoryItems,
    fetchCategories,
    fetchLocations,
    addInventoryItem,
    updateInventoryItem,
    createTransaction,
    getProjectMaterialUsage,
    manageCategory,
    getInventoryItemDetail,
    importInventoryFromDrive,
    findSimilarItems,
    assignInventoryItemToProject,
  };
};

export default useInventory;


--- END: src\hooks\useInventory.js ---


--- START: src\hooks\useMaterialsContext.js ---
import { useState, useCallback } from 'react';
import {
  getAutoMaterialsContext,
  getMaterialsContextForProject,
  refreshMaterialsContext,
} from '../api/aiChatService';

/**
 * Hook ƒë·ªÉ qu·∫£n l√Ω context v·∫≠t t∆∞ cho d·ª± √°n
 * T·ª± ƒë·ªông l·∫•y v·∫≠t t∆∞ t·ª´ b√°o gi√° m·ªõi nh·∫•t ho·∫∑c file Google Drive
 */
export const useMaterialsContext = (project) => {
  const [materialsContext, setMaterialsContext] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [lastUpdated, setLastUpdated] = useState(null);

  /**
   * L·∫•y context v·∫≠t t∆∞ cho d·ª± √°n
   * @param {string} accessToken - Google access token (t√πy ch·ªçn)
   * @param {boolean} forceRefresh - B·∫Øt bu·ªôc refresh d·ªØ li·ªáu
   */
  const fetchMaterialsContext = useCallback(
    async (accessToken = null, forceRefresh = false) => {
      if (!project) {
        setError('D·ª± √°n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng');
        return;
      }

      // Ki·ªÉm tra cache n·∫øu kh√¥ng b·∫Øt bu·ªôc refresh
      if (!forceRefresh && materialsContext && lastUpdated) {
        const now = Date.now();
        const cacheAge = now - lastUpdated;
        // Cache trong 5 ph√∫t
        if (cacheAge < 5 * 60 * 1000) {
          console.log(
            'S·ª≠ d·ª•ng cache context v·∫≠t t∆∞ (tu·ªïi:',
            Math.round(cacheAge / 1000),
            'gi√¢y)'
          );
          return materialsContext;
        }
      }

      setIsLoading(true);
      setError(null);

      try {
        const result = await getAutoMaterialsContext(project, accessToken);

        if (result.materialsContext) {
          setMaterialsContext(result);
          setLastUpdated(Date.now());
          console.log('ƒê√£ c·∫≠p nh·∫≠t context v·∫≠t t∆∞:', result.materialsSource);
        } else {
          setError('Kh√¥ng c√≥ d·ªØ li·ªáu v·∫≠t t∆∞');
        }

        return result;
      } catch (err) {
        const errorMessage =
          err.message || 'C√≥ l·ªói x·∫£y ra khi l·∫•y context v·∫≠t t∆∞';
        setError(errorMessage);
        console.error('L·ªói khi l·∫•y context v·∫≠t t∆∞:', err);
        throw err;
      } finally {
        setIsLoading(false);
      }
    },
    [project, materialsContext, lastUpdated]
  );

  /**
   * Refresh context v·∫≠t t∆∞ (b·∫Øt bu·ªôc c·∫≠p nh·∫≠t)
   * @param {string} accessToken - Google access token (t√πy ch·ªçn)
   */
  const refreshContext = useCallback(
    async (accessToken = null) => {
      return await fetchMaterialsContext(accessToken, true);
    },
    [fetchMaterialsContext]
  );

  /**
   * L·∫•y context v·∫≠t t∆∞ v·ªõi th√¥ng tin chi ti·∫øt
   * @param {string} accessToken - Google access token (t√πy ch·ªçn)
   */
  const getDetailedContext = useCallback(
    async (accessToken = null) => {
      if (!project) {
        throw new Error('D·ª± √°n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng');
      }

      try {
        const result = await getMaterialsContextForProject(
          project,
          accessToken
        );
        return result;
      } catch (err) {
        console.error('L·ªói khi l·∫•y context chi ti·∫øt:', err);
        throw err;
      }
    },
    [project]
  );

  /**
   * X√≥a cache context v·∫≠t t∆∞
   */
  const clearCache = useCallback(() => {
    setMaterialsContext(null);
    setLastUpdated(null);
    setError(null);
    console.log('ƒê√£ x√≥a cache context v·∫≠t t∆∞');
  }, []);

  /**
   * Ki·ªÉm tra xem c√≥ context v·∫≠t t∆∞ hay kh√¥ng
   */
  const hasMaterialsContext = useCallback(() => {
    return materialsContext && materialsContext.materialsSource !== 'none';
  }, [materialsContext]);

  /**
   * L·∫•y th√¥ng tin ngu·ªìn d·ªØ li·ªáu v·∫≠t t∆∞
   */
  const getMaterialsSource = useCallback(() => {
    return materialsContext?.materialsSource || 'none';
  }, [materialsContext]);

  /**
   * L·∫•y s·ªë l∆∞·ª£ng v·∫≠t t∆∞
   */
  const getMaterialsCount = useCallback(() => {
    if (!materialsContext) return 0;

    switch (materialsContext.materialsSource) {
      case 'quotation':
        return materialsContext.materialsData?.materialsCount || 0;
      case 'excel':
        return materialsContext.materialsData?.materialsCount || 0;
      default:
        return 0;
    }
  }, [materialsContext]);

  /**
   * L·∫•y danh s√°ch v·∫≠t t∆∞
   */
  const getMaterialsList = useCallback(() => {
    if (!materialsContext) return [];

    switch (materialsContext.materialsSource) {
      case 'quotation':
        return materialsContext.materialsData?.materials || [];
      case 'excel':
        return materialsContext.materialsData?.materials || [];
      default:
        return [];
    }
  }, [materialsContext]);

  return {
    // State
    materialsContext,
    isLoading,
    error,
    lastUpdated,

    // Actions
    fetchMaterialsContext,
    refreshContext,
    getDetailedContext,
    clearCache,

    // Computed values
    hasMaterialsContext: hasMaterialsContext(),
    materialsSource: getMaterialsSource(),
    materialsCount: getMaterialsCount(),
    materialsList: getMaterialsList(),

    // Helpers
    isFromQuotation: getMaterialsSource() === 'quotation',
    isFromExcel: getMaterialsSource() === 'excel',
    hasNoData: getMaterialsSource() === 'none',
  };
};

export default useMaterialsContext;
















































--- END: src\hooks\useMaterialsContext.js ---


--- START: src\hooks\useMaterialsProcessor.js ---
//src/hooks/useMaterialsProcessor.js
import { useState, useCallback } from 'react';
import { Alert } from 'react-native';
import {
  GoogleSignin,
  statusCodes,
} from '@react-native-google-signin/google-signin';
import { functions } from '../config/firebaseConfig'; // Import functions instance
import { httpsCallable } from 'firebase/functions'; // Import httpsCallable
import { getAuth } from 'firebase/auth'; // Th√™m import getAuth

export const useMaterialsProcessor = (project) => {
  // State for materials data and table visibility
  const [materials, setMaterials] = useState([]);
  const [showMaterialsTable, setShowMaterialsTable] = useState(false);

  // State for Google Drive integration
  const [driveFiles, setDriveFiles] = useState([]);
  const [isPickerVisible, setIsPickerVisible] = useState(false);
  const [isLoadingFiles, setIsLoadingFiles] = useState(false);
  const [isGoogleDriveLoading, setIsGoogleDriveLoading] = useState(false);
  const [isProcessingFile, setIsProcessingFile] = useState(false); // State for processing

  const fetchGoogleDriveFiles = useCallback(async (token, folderId = null) => {
    setIsLoadingFiles(true);
    const baseUrl = 'https://www.googleapis.com/drive/v3/files';
    const params = new URLSearchParams();

    // Build query: when folderId provided, restrict to it; otherwise no results (we always want a folder)
    let query = 'trashed=false';
    if (folderId) {
      query = `'${folderId}' in parents and mimeType='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' and trashed=false`;
    } else {
      // No folder provided ‚Üí return empty list
      return [];
    }

    params.append('q', query);
    params.append('orderBy', 'modifiedTime desc');
    params.append('fields', 'files(id, name, modifiedTime, iconLink)');
    const url = `${baseUrl}?${params.toString()}`;

    try {
      const response = await fetch(url, {
        headers: { Authorization: `Bearer ${token}` },
      });
      if (!response.ok) {
        throw new Error(`Google Drive API error: ${response.status}`);
      }
      const json = await response.json();
      return json.files || [];
    } catch (error) {
      console.error('Error in fetchGoogleDriveFiles:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ l·∫•y danh s√°ch file t·ª´ Google Drive.');
      throw error;
    } finally {
      setIsLoadingFiles(false);
    }
  }, []);

  const handleFileSelect = useCallback(async (driveFile, fileName) => {
    setIsPickerVisible(false);
    setIsProcessingFile(true);
    Alert.alert(
      'ƒêang x·ª≠ l√Ω...',
      `H·ªá th·ªëng ƒëang x·ª≠ l√Ω file "${fileName}". Vui l√≤ng ch·ªù.`
    );

    try {
      // 1. L·∫•y accessToken t·ª´ GoogleSignin
      const tokens = await GoogleSignin.getTokens();
      const { accessToken } = tokens;

      if (!accessToken) {
        throw new Error(
          'Kh√¥ng th·ªÉ l·∫•y ƒë∆∞·ª£c access token c·ªßa Google. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.'
        );
      }

      // 2. G·ªçi Cloud Function `importMaterialsFromDrive`
      const importMaterials = httpsCallable(
        functions,
        'importMaterialsFromDrive'
      );
      const result = await importMaterials({
        driveFileId: driveFile.id,
        accessToken,
      });

      // 3. X·ª≠ l√Ω k·∫øt qu·∫£ tr·∫£ v·ªÅ
      const { materials: importedMaterials } = result.data || {};

      if (importedMaterials && importedMaterials.length > 0) {
        // DEBUG: log nguy√™n li·ªáu g·ªëc
        try {
          console.log(
            'D·ªØ li·ªáu g·ªëc t·ª´ backend:',
            JSON.stringify(importedMaterials, null, 2)
          );
        } catch (_) {}

        // Lu√¥n gi·ªØ l·∫°i d√≤ng t·ªïng h·ª£p (isSummary)
        const filteredMaterials = importedMaterials.filter(
          (item) =>
            item?.isSummary ||
            !(item?.name && item.name.toUpperCase().includes('L√ä S·ª∏ B√åNH'))
        );

        // DEBUG: log sau khi l·ªçc
        try {
          console.log(
            'D·ªØ li·ªáu sau khi l·ªçc:',
            JSON.stringify(filteredMaterials, null, 2)
          );
        } catch (_) {}

        // Process materials: filter out unwanted rows and mark special rows
        const processedMaterials = filteredMaterials.map((item) => {
          // 1) ∆Øu ti√™n ki·ªÉm tra d√≤ng t·ªïng h·ª£p tr∆∞·ªõc ti√™n
          if (item.isSummary) {
            return {
              ...item,
              // G√°n gi√° tr·ªã KL t·ªïng (totalWeight) v√†o thu·ªôc t√≠nh KL (weight)
              // ƒë·ªÉ giao di·ªán hi·ªÉn th·ªã m·ªôt c√°ch nh·∫•t qu√°n
              weight: item.totalWeight || item.weight || 0,
              selected: false,
              isNote: false,
              isAccessory: false,
            };
          }

          const name = (item.name || '').trim().toUpperCase();

          // 2) Ki·ªÉm tra ph·ª• ki·ªán
          const isAccessory = /^(PH·ª§ KI·ªÜN ƒêI K√àM)/.test(name);
          if (isAccessory) {
            return {
              ...item,
              isNote: false,
              isAccessory: true,
              no: '',
              stt: '',
              quantity: '',
              weight: 0,
              unitPrice: 0,
              totalPrice: 0,
              selected: false,
            };
          }

          // 3) Ki·ªÉm tra ghi ch√∫
          const isNote =
            /^(GHI CH√ö|\+|-|\*)/.test(name) ||
            (item.name &&
              !item.quantity &&
              !item.unit &&
              !item.material &&
              !item.quyCach);
          if (isNote) {
            return {
              ...item,
              isNote: true,
              no: '',
              stt: '',
              quantity: 0,
              weight: 0,
              unitPrice: 0,
              totalPrice: 0,
              selected: false,
            };
          }

          // 4) V·∫≠t t∆∞ th√¥ng th∆∞·ªùng: t√≠nh th√†nh ti·ªÅn
          const quantity = parseFloat(item.quantity || 0);
          const weight = parseFloat(item.weight || 0);
          const unitPrice = parseFloat(item.unitPrice || 0);
          const totalPrice =
            weight > 0 ? quantity * weight * unitPrice : quantity * unitPrice;

          return {
            ...item,
            isNote: false,
            isAccessory: false,
            selected: true,
            stt: item.stt || item.no || '',
            no: item.stt || item.no || '',
            totalPrice,
          };
        });

        console.log(`ƒê√£ x·ª≠ l√Ω ${processedMaterials.length} m·ª•c sau khi l·ªçc.`);

        // ƒê·∫∑t d·ªØ li·ªáu v√†o state v√† hi·ªÉn th·ªã
        setMaterials(processedMaterials);
        setShowMaterialsTable(true);
        Alert.alert(
          'Nh·∫≠p d·ªØ li·ªáu th√†nh c√¥ng',
          `ƒê√£ nh·∫≠p v√† x·ª≠ l√Ω ${processedMaterials.length} d√≤ng d·ªØ li·ªáu.`
        );
      } else {
        Alert.alert(
          'Kh√¥ng c√≥ d·ªØ li·ªáu',
          `Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu v·∫≠t t∆∞ h·ª£p l·ªá trong file "${fileName}".`
        );
      }
    } catch (error) {
      console.error('L·ªói khi g·ªçi importMaterialsFromDrive:', error);
      let errorMessage = error.message;
      if (error.code === 'functions/unauthenticated') {
        errorMessage =
          'X√°c th·ª±c th·∫•t b·∫°i. Vui l√≤ng ƒëƒÉng xu·∫•t v√† ƒëƒÉng nh·∫≠p l·∫°i.';
      } else if (error.code === 'functions/permission-denied') {
        errorMessage =
          'Token truy c·∫≠p Google Drive ƒë√£ h·∫øt h·∫°n. Vui l√≤ng th·ª≠ l·∫°i.';
      }
      Alert.alert('L·ªói x·ª≠ l√Ω file', `Chi ti·∫øt: ${errorMessage}`);
    } finally {
      setIsProcessingFile(false);
    }
  }, []);

  const handleImportFromGoogleDrive = useCallback(async () => {
    setIsGoogleDriveLoading(true);
    try {
      const isSignedIn = await GoogleSignin.isSignedIn();
      if (!isSignedIn) {
        await GoogleSignin.signIn();
      }
      const tokens = await GoogleSignin.getTokens();
      const accessToken = tokens.accessToken;
      if (!accessToken) {
        throw new Error('Kh√¥ng th·ªÉ l·∫•y ƒë∆∞·ª£c access token.');
      }

      // Check if we have project info with a Drive folder ID
      if (project && project.driveFolderId) {
        // 1) Find or create the subfolder "Th·ªëng k√™ v·∫≠t t∆∞" inside the project root
        const listChildrenUrl = `https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(
          `'${project.driveFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`
        )}&fields=files(id,name)&orderBy=name`;

        const listRes = await fetch(listChildrenUrl, {
          headers: { Authorization: `Bearer ${accessToken}` },
        });
        if (!listRes.ok) {
          throw new Error(`Google Drive API error: ${listRes.status}`);
        }
        const childJson = await listRes.json();
        let statsFolder = (childJson.files || []).find(
          (f) => f.name === 'Th·ªëng k√™ v·∫≠t t∆∞'
        );

        // Create folder if missing
        if (!statsFolder) {
          const createRes = await fetch(
            'https://www.googleapis.com/drive/v3/files',
            {
              method: 'POST',
              headers: {
                Authorization: `Bearer ${accessToken}`,
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                name: 'Th·ªëng k√™ v·∫≠t t∆∞',
                mimeType: 'application/vnd.google-apps.folder',
                parents: [project.driveFolderId],
              }),
            }
          );
          if (!createRes.ok) {
            throw new Error(
              `Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c 'Th·ªëng k√™ v·∫≠t t∆∞' (HTTP ${createRes.status})`
            );
          }
          const created = await createRes.json();
          statsFolder = { id: created.id, name: created.name };
        }

        // 2) List latest Excel files from that folder
        const files = await fetchGoogleDriveFiles(accessToken, statsFolder.id);
        if (files && files.length > 0) {
          setDriveFiles(files);
          setIsPickerVisible(true);
        } else {
          Alert.alert(
            'Kh√¥ng t√¨m th·∫•y file',
            'Kh√¥ng t√¨m th·∫•y file Excel n√†o trong th∆∞ m·ª•c d·ª± √°n n√†y. H√£y t·∫£i file Excel v√†o th∆∞ m·ª•c d·ª± √°n tr√™n Google Drive tr∆∞·ªõc.'
          );
        }
      } else {
        // Fallback to scanning all of Drive if no project folder ID
        Alert.alert(
          'Th√¥ng b√°o',
          'Th∆∞ m·ª•c Google Drive cho d·ª± √°n n√†y ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p. H·ªá th·ªëng s·∫Ω t√¨m trong to√†n b·ªô Google Drive c·ªßa b·∫°n.'
        );
        const files = await fetchGoogleDriveFiles(accessToken);
        if (files && files.length > 0) {
          setDriveFiles(files);
          setIsPickerVisible(true);
        } else {
          Alert.alert(
            'Kh√¥ng t√¨m th·∫•y file',
            'Kh√¥ng t√¨m th·∫•y file Excel n√†o trong Google Drive c·ªßa b·∫°n.'
          );
        }
      }
    } catch (error) {
      console.error('L·ªói khi thao t√°c v·ªõi Google Drive:', error);
      if (error.code !== statusCodes.SIGN_IN_CANCELLED) {
        Alert.alert('L·ªói', 'ƒê√£ x·∫£y ra l·ªói khi k·∫øt n·ªëi v·ªõi Google Drive.');
      }
    } finally {
      setIsGoogleDriveLoading(false);
    }
  }, [fetchGoogleDriveFiles, project]);

  const handlePriceChange = useCallback((text, index) => {
    // S·ª≠ d·ª•ng callback form c·ªßa setState ƒë·ªÉ ƒë·∫£m b·∫£o truy c·∫≠p v√†o state m·ªõi nh·∫•t
    setMaterials((currentMaterials) => {
      const newMaterials = JSON.parse(JSON.stringify(currentMaterials));
      const item = newMaterials[index];
      const price = parseFloat(text) || 0;
      item.unitPrice = price;

      // D√≤ng t·ªïng h·ª£p: th√†nh ti·ªÅn = ƒë∆°n gi√°
      if (item.isSummary) {
        item.totalPrice = price;
        return newMaterials;
      }

      // Calculate total price based on whether weight exists
      const quantity = parseFloat(item.quantity || 0);
      const weight = parseFloat(item.weight || 0);

      if (weight > 0) {
        // If weight exists: totalPrice = quantity * weight * unitPrice
        item.totalPrice = quantity * weight * price;
      } else {
        // If no weight: totalPrice = quantity * unitPrice (for items with unit "b·ªô")
        item.totalPrice = quantity * price;
      }

      return newMaterials;
    });
  }, []); // Dependency r·ªóng v√¨ ch√∫ng ta d√πng callback form c·ªßa setState

  const handleRequote = useCallback(
    (quotation, navigation, projectId, projectName, project) => {
      // Ki·ªÉm tra xem c√≥ ph·∫£i l√† manual quotation kh√¥ng
      // Ch·ªâ d·ª±a v√†o c√°c c·ªù r√µ r√†ng, kh√¥ng suy lu·∫≠n t·ª´ d·ªØ li·ªáu
      console.log('Debug quotation data:', {
        id: quotation.id,
        isManualQuotation: quotation.isManualQuotation,
        source: quotation.source,
        materialsCount: quotation.materials?.length,
      });

      const isManualQuotation =
        quotation.isManualQuotation === true || quotation.source === 'manual';

      console.log('Is manual quotation:', isManualQuotation);

      if (isManualQuotation) {
        // N·∫øu l√† manual quotation, navigate ƒë·∫øn ManualQuotationScreen
        navigation.navigate('ManualQuotation', {
          projectId,
          projectName,
          project,
          existingMaterials: quotation.materials || [],
          isRequote: true,
          originalQuotationId: quotation.id,
        });
      } else {
        // N·∫øu kh√¥ng ph·∫£i manual, l·∫•y STT t·ª´ b√°o gi√° m·ªõi nh·∫•t v√† t√≠nh to√°n l·∫°i th√†nh ti·ªÅn
        if (quotation.materials && Array.isArray(quotation.materials)) {
          // L·∫•y STT t·ª´ b√°o gi√° m·ªõi nh·∫•t (c√≥ th·ªÉ l√† "no", s·ªë, ch·ªØ c√°i, etc.)
          // v√† t√≠nh to√°n l·∫°i th√†nh ti·ªÅn d·ª±a tr√™n ƒë∆°n gi√° v√† s·ªë l∆∞·ª£ng/kh·ªëi l∆∞·ª£ng
          const materialsWithLatestSTT = quotation.materials.map((item) => {
            const quantity = parseFloat(item.quantity || 0);
            const weight = parseFloat(item.weight || 0);
            const unitPrice = parseFloat(item.unitPrice || 0);

            // T√≠nh to√°n l·∫°i th√†nh ti·ªÅn theo logic c·ªßa QuotationScreen
            const totalPrice = item.isSummary
              ? unitPrice
              : weight > 0
              ? quantity * weight * unitPrice
              : quantity * unitPrice;

            return {
              ...item,
              stt: item.no || item.stt || '', // L·∫•y STT t·ª´ tr∆∞·ªùng 'no' (ƒë∆∞·ª£c l∆∞u trong Firestore) ho·∫∑c 'stt'
              totalPrice: totalPrice, // C·∫≠p nh·∫≠t th√†nh ti·ªÅn ƒë√£ t√≠nh to√°n
            };
          });

          setMaterials(materialsWithLatestSTT);
          setShowMaterialsTable(true);
          Alert.alert(
            'T·∫£i th√†nh c√¥ng',
            `ƒê√£ t·∫£i l·∫°i d·ªØ li·ªáu t·ª´ b√°o gi√° ${quotation.quotationNumber} v·ªõi STT t·ª´ b√°o gi√° m·ªõi nh·∫•t v√† ƒë√£ t√≠nh to√°n l·∫°i th√†nh ti·ªÅn.`
          );
        } else {
          Alert.alert(
            'L·ªói',
            'B√°o gi√° n√†y kh√¥ng ch·ª©a d·ªØ li·ªáu v·∫≠t t∆∞ ƒë·ªÉ t·∫£i l·∫°i.'
          );
        }
      }
    },
    []
  );

  // H√†m ch·ªâ l·∫•y STT t·ª´ file Excel m·ªõi nh·∫•t
  const handleGetSTTFromLatestFile = useCallback(
    async (existingMaterials) => {
      try {
        // S·ª≠ d·ª•ng l·∫°i logic import t·ª´ Google Drive nh∆∞ng ch·ªâ l·∫•y STT
        const tokens = await GoogleSignin.getTokens();
        const { accessToken } = tokens;

        if (!accessToken) {
          throw new Error('Kh√¥ng th·ªÉ l·∫•y ƒë∆∞·ª£c access token c·ªßa Google.');
        }

        // L·∫•y danh s√°ch file Excel t·ª´ Google Drive
        const files = await fetchGoogleDriveFiles(accessToken);

        if (files.length === 0) {
          throw new Error('Kh√¥ng t√¨m th·∫•y file Excel n√†o.');
        }

        // L·∫•y file m·ªõi nh·∫•t
        const latestFile = files[0];

        // G·ªçi Cloud Function ƒë·ªÉ import file m·ªõi nh·∫•t
        const importMaterials = httpsCallable(
          functions,
          'importMaterialsFromDrive'
        );
        const result = await importMaterials({
          driveFileId: latestFile.id,
          accessToken,
        });

        if (result.data && result.data.materials) {
          const latestMaterials = result.data.materials;

          // B·∫Øt ch∆∞·ªõc y h·ªát c√°ch processMaterialData l·∫•y STT v√† t√≠nh to√°n l·∫°i th√†nh ti·ªÅn
          const updatedMaterials = existingMaterials.map(
            (existingItem, index) => {
              const latestItem = latestMaterials[index];

              // T√≠nh to√°n l·∫°i th√†nh ti·ªÅn d·ª±a tr√™n ƒë∆°n gi√° v√† s·ªë l∆∞·ª£ng/kh·ªëi l∆∞·ª£ng hi·ªán t·∫°i
              const quantity = parseFloat(existingItem.quantity || 0);
              const weight = parseFloat(existingItem.weight || 0);
              const unitPrice = parseFloat(existingItem.unitPrice || 0);

              const totalPrice = existingItem.isSummary
                ? unitPrice
                : weight > 0
                ? quantity * weight * unitPrice
                : quantity * unitPrice;

              return {
                ...existingItem, // Gi·ªØ nguy√™n t·∫•t c·∫£ d·ªØ li·ªáu c≈©
                stt: latestItem?.stt || latestItem?.no || '', // L·∫•y STT t·ª´ tr∆∞·ªùng 'stt' ho·∫∑c 'no'
                totalPrice: totalPrice, // C·∫≠p nh·∫≠t th√†nh ti·ªÅn ƒë√£ t√≠nh to√°n
              };
            }
          );

          setMaterials(updatedMaterials);
          setShowMaterialsTable(true);
          Alert.alert(
            'Th√†nh c√¥ng',
            'ƒê√£ c·∫≠p nh·∫≠t STT t·ª´ file Excel m·ªõi nh·∫•t v√† t√≠nh to√°n l·∫°i th√†nh ti·ªÅn.'
          );
        } else {
          throw new Error('Kh√¥ng th·ªÉ x·ª≠ l√Ω d·ªØ li·ªáu t·ª´ file Excel.');
        }
      } catch (error) {
        console.error('Error getting STT from latest file:', error);
        // N·∫øu c√≥ l·ªói, gi·ªØ nguy√™n d·ªØ li·ªáu c≈©
        setMaterials(existingMaterials);
        setShowMaterialsTable(true);
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t STT. Gi·ªØ nguy√™n d·ªØ li·ªáu c≈©.');
      }
    },
    [fetchGoogleDriveFiles]
  );

  // Process material data from Excel
  const processMaterialData = useCallback((rawData) => {
    if (!rawData || !Array.isArray(rawData)) {
      console.log('No materials data');
      return;
    }

    const processed = rawData.map((item) => {
      // D√≤ng t·ªïng h·ª£p: KL hi·ªÉn th·ªã = totalWeight (n·∫øu c√≥), th√†nh ti·ªÅn = ƒë∆°n gi√°
      if (item.isSummary) {
        return {
          ...item,
          weight: item.totalWeight || item.weight || 0,
          totalPrice: parseFloat(item.unitPrice || 0),
          selected: false,
          isNote: false,
        };
      }

      // Check if the item is a note
      if (item.isNote) {
        return {
          ...item,
          selected: false, // Add selected property for consistent handling
        };
      }

      // Extract essential data
      const quantity = parseFloat(item.quantity) || 0;
      const weight = parseFloat(item.weight || 0);
      const unitPrice = parseFloat(item.unitPrice || 0);

      // Calculate total price based on quantity, weight and unit price
      let totalPrice = 0;
      if (weight > 0) {
        totalPrice = quantity * weight * unitPrice;
      } else {
        totalPrice = quantity * unitPrice;
      }

      return {
        stt: item.no || item.stt || '', // L·∫•y STT t·ª´ tr∆∞·ªùng 'no' (ƒë∆∞·ª£c l∆∞u trong Firestore) ho·∫∑c 'stt'
        name: item.name || '',
        material: item.material || '',
        quyCach: item.quyCach || '',
        unit: item.unit || '',
        quantity,
        weight,
        unitPrice,
        totalPrice,
        selected: false, // Add selected property
        isNote: false, // Explicitly mark as not a note
      };
    });

    setMaterials(processed);
    setShowMaterialsTable(true);
  }, []);

  return {
    materials,
    setMaterials, // Export setMaterials
    showMaterialsTable,
    driveFiles,
    isPickerVisible,
    isLoadingFiles,
    isGoogleDriveLoading,
    isProcessingFile,
    handleImportFromGoogleDrive,
    handleFileSelect,
    handlePriceChange,
    handleRequote,
    handleGetSTTFromLatestFile,
    setIsPickerVisible,
  };
};


--- END: src\hooks\useMaterialsProcessor.js ---


--- START: src\hooks\usePOReceipt.js ---
import { useState } from 'react';
import { Alert } from 'react-native';
import { savePOReceiptConfirmation } from '../api/purchaseOrderService';
import { httpsCallable } from 'firebase/functions';
import { functions } from '../config/firebaseConfig';
import { GoogleSignin } from '@react-native-google-signin/google-signin';
import uuid from 'react-native-uuid';

const usePOReceipt = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [uploadProgress, setUploadProgress] = useState(0);

  // Upload a single file to Drive
  const uploadFile = async (projectId, file) => {
    try {
      console.log(
        `[POReceipt] Starting upload for file: ${file.fileName || 'unnamed'}`
      );

      // L·∫•y accessToken Google c·ªßa ng∆∞·ªùi d√πng
      console.log('[POReceipt] Getting Google access token');
      const tokens = await GoogleSignin.getTokens();
      const accessToken = tokens.accessToken;

      if (!accessToken) {
        console.error('[POReceipt] No access token available');
        throw new Error(
          'Phi√™n ƒëƒÉng nh·∫≠p Google ƒë√£ h·∫øt. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.'
        );
      }
      console.log('[POReceipt] Got access token successfully');

      // Generate a unique filename
      const ext = (file.fileName || 'jpg').split('.').pop();
      const uniqueFileName = `PO_${uuid.v4()}.${ext}`;
      console.log(`[POReceipt] Generated filename: ${uniqueFileName}`);

      // Call the uploadFileToDrive Cloud Function
      console.log('[POReceipt] Calling uploadFileToDriveUser cloud function');
      const uploadFn = httpsCallable(functions, 'uploadFileToDriveUser');
      const result = await uploadFn({
        accessToken,
        projectId,
        fileName: uniqueFileName,
        mimeType: file.mimeType,
        base64Data: file.base64Data,
      });

      console.log(
        '[POReceipt] Cloud function response:',
        JSON.stringify(result.data)
      );

      if (!result.data.success) {
        console.error('[POReceipt] Upload failed:', result.data.message);
        throw new Error(result.data.message || 'L·ªói t·∫£i file l√™n server');
      }

      console.log(
        `[POReceipt] File uploaded successfully. FileID: ${result.data.fileId}, Link: ${result.data.webViewLink}`
      );
      return result.data;
    } catch (err) {
      console.error('[POReceipt] File upload error:', err);
      // Log detailed error information
      if (err.details) {
        console.error(
          '[POReceipt] Error details:',
          JSON.stringify(err.details)
        );
      }
      if (err.code) {
        console.error('[POReceipt] Error code:', err.code);
      }
      console.error('File upload error in hook:', err);
      // N√©m l·ªói ra ngo√†i ƒë·ªÉ h√†m confirmReceipt c√≥ th·ªÉ b·∫Øt ƒë∆∞·ª£c
      throw err;
    }
  };

  // Main function to handle the entire PO receipt confirmation process
  const confirmReceipt = async ({ poId, projectId, files, remarks }) => {
    setLoading(true);
    setError(null);
    setUploadProgress(0);

    try {
      console.log(
        `[POReceipt] Starting confirmation process for PO: ${poId}, Project: ${projectId}`
      );
      console.log(`[POReceipt] Files to upload: ${files.length}`);

      // Step 1: Upload each file one by one
      const totalFiles = files.length;
      const uploadedFilesInfo = [];

      for (let i = 0; i < totalFiles; i++) {
        const fileToUpload = files[i];
        console.log(
          `Uploading file ${i + 1}/${totalFiles}:`,
          fileToUpload.fileName
        );
        const uploadResult = await uploadFile(projectId, fileToUpload);

        uploadedFilesInfo.push({
          id: uploadResult.fileId,
          name: uploadResult.fileName || fileToUpload.fileName,
          url: uploadResult.webViewLink,
          mimeType: uploadResult.mimeType,
          preview: uploadResult.thumbnailLink,
        });

        // Update progress
        setUploadProgress(((i + 1) / totalFiles) * 100);
      }

      // Step 2: Save the PO receipt confirmation data to Firestore
      console.log('All files uploaded. Saving confirmation to Firestore...');
      console.log(`[POReceipt] Files uploaded: ${uploadedFilesInfo.length}`);
      console.log(
        `[POReceipt] File details:`,
        JSON.stringify(uploadedFilesInfo)
      );

      const result = await savePOReceiptConfirmation({
        poId,
        projectId,
        filesToSave: uploadedFilesInfo,
        remarks,
      });

      console.log(`[POReceipt] PO receipt confirmation saved successfully`);
      console.log(`[POReceipt] Result:`, result);

      setLoading(false);
      setUploadProgress(0);
      return result;
    } catch (err) {
      console.error('Confirm receipt process failed:', err);
      console.error('[POReceipt] Error stack:', err.stack);
      const errorMessage =
        err.details?.message || err.message || 'Kh√¥ng th·ªÉ x√°c nh·∫≠n PO.';
      setError(errorMessage);
      Alert.alert('L·ªói', errorMessage);
      setLoading(false);
      setUploadProgress(0);
      // Kh√¥ng c·∫ßn throw err n·ªØa v√¨ ƒë√£ x·ª≠ l√Ω ·ªü ƒë√¢y
    }
  };

  return { confirmReceipt, loading, error, uploadProgress };
};

export default usePOReceipt;


--- END: src\hooks\usePOReceipt.js ---


--- START: src\hooks\useProjectDetails.js ---
//src/hooks/useProjectDetails.js
import { useState, useEffect, useCallback } from 'react';
import { useFocusEffect } from '@react-navigation/native';
import { getProjectById } from '../api/projectService';

export const useProjectDetails = (projectId) => {
  const [project, setProject] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const fetchProjectData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await getProjectById(projectId);

      if (data) {
        setProject(data);
      } else {
        setError('Kh√¥ng t√¨m th·∫•y th√¥ng tin d·ª± √°n');
      }
    } catch (err) {
      console.error('L·ªói khi t·∫£i th√¥ng tin d·ª± √°n:', err);
      setError('Kh√¥ng th·ªÉ t·∫£i th√¥ng tin d·ª± √°n. Vui l√≤ng th·ª≠ l·∫°i sau.');
    } finally {
      setLoading(false);
    }
  }, [projectId]);

  // Initial fetch when the component mounts
  useEffect(() => {
    if (projectId) {
      fetchProjectData();
    }
  }, [fetchProjectData, projectId]);

  // Re-fetch when the screen comes into focus
  useFocusEffect(
    useCallback(() => {
      if (projectId) {
        fetchProjectData();
      }
    }, [fetchProjectData, projectId])
  );

  return { project, loading, error, fetchProjectData };
};


--- END: src\hooks\useProjectDetails.js ---


--- START: src\hooks\usePurchaseOrderGenerator.js ---
// src/hooks/usePurchaseOrderGenerator.js
import { useState, useContext } from 'react';
import { httpsCallable, getFunctions } from 'firebase/functions';
import { Alert, Linking } from 'react-native';
import AuthContext from '../contexts/AuthContext';
import { GoogleSignin } from '@react-native-google-signin/google-signin';

const usePurchaseOrderGenerator = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const { currentUser } = useContext(AuthContext);

  /**
   * Generate a Purchase Order Excel file for a project
   *
   * @param {Object} poData - The purchase order data
   * @param {string} projectId - The ID of the project
   * @returns {Promise<Object>} - The response object with file URL
   */
  const generatePurchaseOrder = async (poData, projectId) => {
    setLoading(true);
    setError(null);

    try {
      // Ensure Google user is signed in and get accessToken
      const signedIn = await GoogleSignin.isSignedIn();
      if (!signedIn) {
        console.log('Google user not signed in, attempting to sign in...');
        await GoogleSignin.signIn();
      }

      console.log('Getting Google access token...');
      const { accessToken } = await GoogleSignin.getTokens();
      if (!accessToken) {
        throw new Error('Could not get Google access token.');
      }
      console.log('Access token obtained successfully');

      const formattedData = formatPOData(poData);
      console.log('Formatted PO data:', JSON.stringify(formattedData));

      const functions = getFunctions(undefined, 'asia-southeast1');
      const generateExcelPurchaseOrder = httpsCallable(
        functions,
        'generateExcelPurchaseOrder'
      );

      console.log('Calling Firebase function with projectId:', projectId);
      const result = await generateExcelPurchaseOrder({
        formattedData,
        projectId,
        accessToken, // Pass the Google OAuth token
      });

      console.log('Firebase function result:', JSON.stringify(result.data));

      if (result.data && result.data.success) {
        if (result.data.fileUrl) {
          await Linking.openURL(result.data.fileUrl);
        }
        setLoading(false);
        return result.data;
      } else {
        throw new Error(
          result.data?.message || 'Failed to generate Purchase Order'
        );
      }
    } catch (err) {
      console.error('Purchase Order generation error:', err);
      let errorMessage = 'Kh√¥ng th·ªÉ t·∫°o ƒë∆°n ƒë·∫∑t h√†ng.';

      if (err.message?.includes('unauthenticated')) {
        errorMessage =
          'L·ªói x√°c th·ª±c Google. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i v√† th·ª≠ l·∫°i.';
        // Try to reset Google Sign-In
        try {
          await GoogleSignin.signOut();
          console.log('Google sign-out complete, user should re-authenticate');
        } catch (signOutErr) {
          console.error('Error signing out from Google:', signOutErr);
        }
      }

      setError(errorMessage);
      Alert.alert('L·ªói', errorMessage);
      setLoading(false);
      throw err;
    }
  };

  /**
   * Format the data for the PO generator
   *
   * @param {Object} data - The raw data to format
   * @returns {Object} - The formatted data
   */
  const formatPOData = (data) => {
    // Calculate the totals
    const subTotal = calculateSubTotal(data.materials);
    const vatPercentage = data.vatPercentage || 10;
    const vatAmount = (subTotal * vatPercentage) / 100;
    const grandTotal = subTotal + vatAmount;

    return {
      metadata: {
        projectName: data.projectName,
        supplierName: data.supplierName,
        supplierAddress: data.supplierAddress,
        supplierPhone: data.supplierPhone,
        supplierEmail: data.supplierEmail,
        supplierTaxCode: data.supplierTaxCode,
        supplierContactPerson: data.supplierContactPerson,
        poNumber: data.poNumber || `PO-${Date.now().toString().substr(-6)}`,
        poDate: data.poDate || new Date().toLocaleDateString('vi-VN'),
        deliveryTime: data.deliveryTime,
        paymentTerms: data.paymentTerms,
      },
      materials: data.materials.map((item, index) => ({
        ...item,
        no: index + 1,
        name: item.name || '',
        unit: item.unit || '',
        quantity: parseFloat(item.quantity) || 0,
        unitPrice: parseFloat(item.unitPrice) || 0,
        total:
          (parseFloat(item.quantity) || 0) * (parseFloat(item.unitPrice) || 0),
      })),
      summary: {
        subTotal,
        vatPercentage,
        vatAmount,
        grandTotal,
      },
    };
  };

  /**
   * Calculate the subtotal of all materials
   *
   * @param {Array} materials - List of material items
   * @returns {number} - The calculated subtotal
   */
  const calculateSubTotal = (materials) => {
    return materials.reduce((sum, item) => {
      const quantity = parseFloat(item.quantity) || 0;
      const unitPrice = parseFloat(item.unitPrice) || 0;
      return sum + quantity * unitPrice;
    }, 0);
  };

  return {
    generatePurchaseOrder,
    loading,
    error,
  };
};

export default usePurchaseOrderGenerator;


--- END: src\hooks\usePurchaseOrderGenerator.js ---


--- START: src\hooks\useQuotationGenerator.js ---
import { useState } from 'react';
import * as FileSystem from 'expo-file-system';
import * as Sharing from 'expo-sharing';
import { Alert } from 'react-native';
import { httpsCallable, getFunctions } from 'firebase/functions';
import app, { functions as firebaseFunctions } from '../config/firebaseConfig';
import { GoogleSignin } from '@react-native-google-signin/google-signin';
import { saveQuotation } from '../api/quotationService';

// Import hook qu·∫£n l√Ω kho
import useInventory from './useInventory';

/**
 * Custom hook for generating quotations in Excel format
 * @param {Object} options - Configuration options
 * @returns {Object} - Functions and state for quotation generation
 */
const useQuotationGenerator = ({ projectId, customerData, materials }) => {
  const [isLoading, setIsLoading] = useState(false);
  const [excelUrl, setExcelUrl] = useState(null);
  const [pdfUrl, setPdfUrl] = useState(null);
  const [isPdfLoading, setIsPdfLoading] = useState(false);

  // Trong hook useQuotationGenerator, th√™m ƒëo·∫°n code sau
  const { inventoryItems, fetchInventoryItems } = useInventory();

  /**
   * Formats quotation data for Excel export according to the specified template
   * @param {Object} quotationData - All quotation data
   * @returns {Object} - Formatted data for Excel
   */
  const formatQuotationDataForExcel = (quotationData) => {
    const {
      quotationNumber,
      quotationDate,
      projectName,
      customerData = {},
      metadata = {},
      materials = [],
      subTotal,
      discountPercentage,
      discountAmount,
      vatPercentage,
      vatAmount,
      grandTotal,
      amountInWords,
      quoteValidity,
      deliveryTime,
    } = quotationData;

    // Build data structure matching the Excel template
    return {
      metadata: {
        // Header/company info
        companyName:
          'C√îNG TY TNHH S·∫¢N XU·∫§T C∆† KH√ç TH∆Ø∆†NG M·∫†I D·ªäCH V·ª§ T√ÇN H√íA PH√ÅT',
        companyAddress:
          'S·ªë 7 Qu·ªëc l·ªô 1A, KP3B, Ph∆∞·ªùng Thanh L·ªôc, Qu·∫≠n 12, TP.HCM',
        companyPhone: '0978.268.559',
        companyEmail: 'chomcauinoxtanhoaphat.com.vn',
        taxCode: '0315155409',

        // Customer info - S·ª≠ d·ª•ng metadata n·∫øu c√≥, kh√¥ng th√¨ d√πng customerData, kh√¥ng hi·ªÉn th·ªã N/A
        customerName: metadata?.customerName || customerData?.name || '',
        customerAddress:
          metadata?.customerAddress || customerData?.address || '',
        customerPhone: metadata?.customerPhone || customerData?.phone || '',
        customerEmail: metadata?.customerEmail || customerData?.email || '',
        customerTaxCode:
          metadata?.customerTaxCode || customerData?.taxCode || '',
        customerContactPerson:
          metadata?.customerContactPerson || customerData?.contactPerson || '',

        // Quotation info
        quotationNumber,
        quotationDate: new Date(quotationDate).toLocaleDateString('vi-VN'),
        projectName,
        quoteValidity,
        deliveryTime,
      },

      // Materials will be added from row 8 onwards
      materials: materials.map((item, index) => {
        // Handle note rows differently. If isNote flag is already true OR
        // unit & quantity are both empty/zero and material field empty, treat as note.
        const startsWithPlus = (item.name || '').trim().startsWith('+');
        const nameIsNote = (item.name || '').toUpperCase().includes('GHI CH√ö');
        const inferredNote =
          item.isNote ||
          nameIsNote ||
          startsWithPlus ||
          ((!item.unit || item.unit === '') &&
            (!item.material || item.material === '') &&
            (item.quantity === null ||
              item.quantity === undefined ||
              item.quantity === 0));
        if (inferredNote) {
          return {
            isNote: true,
            no: null, // No sequence number for notes
            stt: null,
            name: item.name || '',
            material: '', // No material for notes
            unit: '', // No unit for notes
            quantity: null, // No quantity for notes
            unitPrice: null,
            total: null,
            weight: null,
          };
        }

        const weight = item.weight ?? 0;
        const inputUnitPrice = item.unitPrice || item.price || 0;

        // N·∫øu kh√¥ng c√≥ tr·ªçng l∆∞·ª£ng (b√°o gi√° th·ªß c√¥ng) -> d√πng ƒë∆°n gi√° tr·ª±c ti·∫øp
        const calculatedUnitPrice =
          weight && weight > 0 ? weight * inputUnitPrice : inputUnitPrice;

        const quantity = item.quantity || 0;
        const totalPrice = quantity * calculatedUnitPrice;

        // ƒê·∫£m b·∫£o gi√° tr·ªã STT ƒë∆∞·ª£c l∆∞u ƒë√∫ng ƒë·ªãnh d·∫°ng
        console.log(
          `Formatting Item STT: ${item.stt}, Type: ${typeof item.stt}`
        );

        // X√°c ƒë·ªãnh gi√° tr·ªã STT cu·ªëi c√πng
        let finalStt = '';
        if (
          item.stt !== undefined &&
          item.stt !== null &&
          String(item.stt).trim() !== ''
        ) {
          finalStt = String(item.stt).trim();
        } else if (
          item.no !== undefined &&
          item.no !== null &&
          String(item.no).trim() !== ''
        ) {
          finalStt = String(item.no).trim();
        } else {
          finalStt = String(index + 1);
        }

        return {
          isNote: false,
          no: finalStt,
          stt: finalStt, // ƒê·∫£m b·∫£o stt c≈©ng ƒë∆∞·ª£c g√°n gi√° tr·ªã
          name: item.name || '',
          material: item.material || item.type || '',
          unit: item.unit || '',
          quantity: quantity,
          unitPrice: calculatedUnitPrice, // ƒê∆°n gi√° ƒë√£ ƒë∆∞·ª£c t√≠nh = ƒë∆°n gi√°/kg * kh·ªëi l∆∞·ª£ng
          total: totalPrice || item.totalPrice || item.total || 0,
          weight: weight, // Th√™m tr∆∞·ªùng weight ƒë·ªÉ Cloud Function c√≥ th·ªÉ s·ª≠ d·ª•ng n·∫øu c·∫ßn
        };
      }),

      // Summary data
      summary: {
        subTotal,
        discountPercentage: discountPercentage || 0,
        discountAmount: discountAmount || 0,
        vatPercentage: vatPercentage || 0,
        vatAmount: vatAmount || 0,
        grandTotal: grandTotal || 0,
        amountInWords: amountInWords || 'Kh√¥ng ƒë·ªìng',
      },
    };
  };

  /**
   * Generate and save a quotation in Excel format
   * @param {Object} quotationData - Complete quotation data
   * @returns {Promise<string>} URL to the generated Excel file
   */
  const generateExcelQuotation = async (quotationData) => {
    try {
      setIsLoading(true);

      // Format the data for Excel export
      const formattedData = formatQuotationDataForExcel(quotationData);

      // Ensure we have a Google access token
      const signedIn = await GoogleSignin.isSignedIn();
      if (!signedIn) {
        await GoogleSignin.signIn();
      }
      const { accessToken } = await GoogleSignin.getTokens();
      if (!accessToken) {
        throw new Error('Kh√¥ng th·ªÉ l·∫•y Google access token');
      }

      // Call cloud function to generate Excel file (with user token)
      const generateExcelFunc = httpsCallable(
        firebaseFunctions,
        'generateExcelQuotation'
      );
      const result = await generateExcelFunc({
        formattedData,
        projectId,
        accessToken,
      });

      // Get the Excel file URL
      const { excelUrl, spreadsheetId } = result.data;
      setExcelUrl(excelUrl);

      // Automatically convert to PDF
      const pdfUrl = await convertExcelToPdf(
        spreadsheetId,
        quotationData.quotationNumber
      );

      // Save quotation metadata to Firestore with both URLs
      await saveQuotation(projectId, {
        ...quotationData,
        excelUrl,
        pdfUrl: pdfUrl || excelUrl, // Using the PDF URL if available, otherwise Excel URL
        createdBy: quotationData.createdBy,
      });

      // Offer PDF share if available
      if (pdfUrl) {
        try {
          await Sharing.shareAsync(pdfUrl);
        } catch (_) {}
      }

      return { excelUrl, pdfUrl, spreadsheetId };
    } catch (error) {
      console.error('Error generating Excel quotation:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫°o b√°o gi√° Excel: ' + error.message);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  /**
   * Convert Excel to PDF using the new Cloud Function
   * @param {string} spreadsheetId - ID of the Google Sheet to convert
   * @param {string} fileName - Name for the generated PDF file
   * @returns {Promise<string>} URL to the generated PDF file
   */
  const convertExcelToPdf = async (spreadsheetId, fileName) => {
    if (!spreadsheetId) {
      console.error('Missing spreadsheetId for PDF conversion');
      return null;
    }

    try {
      setIsPdfLoading(true);

      // Get Google access token
      const { accessToken } = await GoogleSignin.getTokens();

      // Call the PDF function deployed in us-central1
      const functionsUS = getFunctions(app, 'us-central1');
      const exportToPdfFunc = httpsCallable(functionsUS, 'exportSheetToPdf');

      const result = await exportToPdfFunc({
        spreadsheetId,
        fileName,
        projectId,
        accessToken,
      });

      // Get the PDF file URL
      const { pdfUrl } = result.data;
      setPdfUrl(pdfUrl);

      return pdfUrl;
    } catch (error) {
      console.error('Error converting Excel to PDF:', error);
      Alert.alert(
        'Th√¥ng b√°o',
        'ƒê√£ t·∫°o b√°o gi√° Excel th√†nh c√¥ng, nh∆∞ng kh√¥ng th·ªÉ chuy·ªÉn ƒë·ªïi sang PDF. B·∫°n v·∫´n c√≥ th·ªÉ chia s·∫ª file Excel.'
      );
      return null;
    } finally {
      setIsPdfLoading(false);
    }
  };

  /**
   * Share the generated Excel file
   */
  const shareExcelQuotation = async () => {
    try {
      if (!excelUrl) {
        Alert.alert('L·ªói', 'Ch∆∞a c√≥ file b√°o gi√° Excel ƒë·ªÉ chia s·∫ª.');
        return;
      }

      const fileUri = `${FileSystem.documentDirectory}quotation.xlsx`;
      const downloadResult = await FileSystem.downloadAsync(excelUrl, fileUri);

      if (downloadResult.status === 200) {
        await Sharing.shareAsync(fileUri);
      } else {
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i file b√°o gi√° Excel.');
      }
    } catch (error) {
      console.error('Error sharing Excel quotation:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ chia s·∫ª b√°o gi√° Excel: ' + error.message);
    }
  };

  // Quick share PDF helper if needed elsewhere
  const sharePdf = async () => {
    if (!pdfUrl) {
      Alert.alert('L·ªói', 'Ch∆∞a c√≥ file b√°o gi√° PDF ƒë·ªÉ chia s·∫ª.');
      return;
    }
    try {
      await Sharing.shareAsync(pdfUrl);
    } catch (error) {
      console.error('Error sharing PDF:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ chia s·∫ª PDF: ' + error.message);
    }
  };

  /**
   * Share the generated PDF file
   */
  const sharePdfQuotation = async () => {
    try {
      if (!pdfUrl) {
        Alert.alert('L·ªói', 'Ch∆∞a c√≥ file b√°o gi√° PDF ƒë·ªÉ chia s·∫ª.');
        return;
      }

      const fileUri = `${FileSystem.documentDirectory}quotation.pdf`;
      const downloadResult = await FileSystem.downloadAsync(pdfUrl, fileUri);

      if (downloadResult.status === 200) {
        await Sharing.shareAsync(fileUri, {
          mimeType: 'application/pdf',
          UTI: 'com.adobe.pdf',
        });
      } else {
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i file b√°o gi√° PDF.');
      }
    } catch (error) {
      console.error('Error sharing PDF quotation:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ chia s·∫ª b√°o gi√° PDF: ' + error.message);
    }
  };

  // Th√™m h√†m t√¨m ki·∫øm v·∫≠t t∆∞ t·ª´ kho
  const searchInventoryItems = async (keyword) => {
    if (!inventoryItems.length) {
      await fetchInventoryItems();
    }

    if (!keyword) return [];

    const normalizedKeyword = keyword.toLowerCase().trim();
    return inventoryItems.filter(
      (item) =>
        item.name?.toLowerCase().includes(normalizedKeyword) ||
        item.code?.toLowerCase().includes(normalizedKeyword) ||
        item.material?.toLowerCase().includes(normalizedKeyword)
    );
  };

  // Th√™m h√†m √°p d·ª•ng v·∫≠t t∆∞ t·ª´ kho v√†o b√°o gi√°
  const applyInventoryItemToQuotation = (item) => {
    if (!item) return;

    const newMaterial = {
      name: item.name,
      material: item.material || '',
      unit: item.unit || '',
      quantity: 1,
      unitPrice: item.price || 0,
      weight: item.weight || 0,
      total: 1 * (item.price || 0),
    };

    // Assuming 'materials' state is managed by the parent component or passed as a prop
    // For now, we'll just add it to the current materials array for display
    // In a real app, you'd update the 'materials' prop or state
    // setMaterials(prevMaterials => [...prevMaterials, newMaterial]); // This line would cause an error if 'materials' is not a state variable
    // calculateTotals([...materials, newMaterial]); // This line would cause an error if 'materials' is not a state variable
  };

  return {
    generateExcelQuotation,
    convertExcelToPdf,
    shareExcelQuotation,
    sharePdf,
    sharePdfQuotation,
    isLoading,
    isPdfLoading,
    excelUrl,
    pdfUrl,
    searchInventoryItems,
    applyInventoryItemToQuotation,
    inventoryItems,
  };
};

export default useQuotationGenerator;


--- END: src\hooks\useQuotationGenerator.js ---


--- START: src\modules\inventory\screens\MaterialListScreen.js ---
/**
 * M√†n h√¨nh danh s√°ch v·∫≠t li·ªáu
 */

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const MaterialListScreen = ({ navigation }) => {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Danh s√°ch v·∫≠t li·ªáu</Text>
      <Text style={styles.subtitle}>M√†n h√¨nh ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
});

export default MaterialListScreen;


--- END: src\modules\inventory\screens\MaterialListScreen.js ---


--- START: src\navigation\AppNavigator.js ---
import React from 'react';
import { Text, View, TouchableOpacity, Alert } from 'react-native';
import {
  NavigationContainer,
  DefaultTheme,
  DarkTheme,
} from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Ionicons } from '@expo/vector-icons';
import { useAuth } from '../contexts/AuthContext';
import { useTheme } from '../contexts/ThemeContext';
import messaging from '@react-native-firebase/messaging';
import { useEffect, useState } from 'react';
import { collection, where, query, onSnapshot } from 'firebase/firestore';
import { db } from '../config/firebaseConfig';

// Import c√°c m√†n h√¨nh
import LoginScreen from '../screens/LoginScreen';
import HomeScreen from '../screens/HomeScreen';
import CustomerManagementScreen from '../screens/CustomerManagementScreen';
import CustomerDetailScreen from '../screens/CustomerDetailScreen';
import AddCustomerScreen from '../screens/AddCustomerScreen';
import EditCustomerScreen from '../screens/EditCustomerScreen';

// Import c√°c m√†n h√¨nh qu·∫£n l√Ω d·ª± √°n
import ProjectManagementScreen from '../screens/ProjectManagementScreen';
import ProjectDetailScreen from '../screens/ProjectDetailScreen';
import AddProjectScreen from '../screens/AddProjectScreen';
import EditProjectScreen from '../screens/EditProjectScreen';
import FinalizeQuotationScreen from '../screens/FinalizeQuotationScreen';
import QuotationScreen from '../screens/QuotationScreen';
import ManualQuotationScreen from '../screens/ManualQuotationScreen';
import StageDetailScreen from '../screens/StageDetailScreen';
import MaterialPurchaseScreen from '../screens/MaterialPurchaseScreen';
import CreateProposalScreen from '../screens/CreateProposalScreen';
import ProposalListScreen from '../screens/ProposalListScreen';
import CreatePOScreen from '../screens/CreatePOScreen';
import POListScreen from '../screens/POListScreen';
import CreateDeliveryNoteScreen from '../screens/CreateDeliveryNoteScreen';
import ProjectCostScreen from '../screens/ProjectCostScreen';
// import StagingScreen from '../screens/StagingScreen';

// Import m√†n h√¨nh t√†i kho·∫£n
import AccountScreen from '../screens/AccountScreen';

// Import m√†n h√¨nh b√°o c√°o c√¥ng vi·ªác
import TaskReportScreen from '../screens/TaskReportScreen';
import TaskDetailScreen from '../screens/TaskDetailScreen';
import AttendanceScreen from '../screens/AttendanceScreen';
import UserManagementScreen from '../screens/UserManagementScreen';

// Import m√†n h√¨nh dashboard cho gi√°m ƒë·ªëc
import DirectorDashboardScreen from '../screens/DirectorDashboardScreen';

// Import m√†n h√¨nh c√†i ƒë·∫∑t icon
import IconSettingsScreen from '../screens/IconSettingsScreen';
import CustomIconDebug from '../components/CustomIconDebug';
import DebtDashboard from '../screens/DebtDashboard';
import NotificationsScreen from '../screens/NotificationsScreen'; // Import NotificationsScreen
import FinancialDashboardScreen from '../screens/FinancialDashboardScreen';

// Import c√°c m√†n h√¨nh qu·∫£n l√Ω nh√† cung c·∫•p
import SupplierManagementScreen from '../screens/SupplierManagementScreen';
import AddSupplierScreen from '../screens/AddSupplierScreen';
import EditSupplierScreen from '../screens/EditSupplierScreen';
import SupplierDetailScreen from '../screens/SupplierDetailScreen';
import ConfirmPOReceiptScreen from '../screens/ConfirmPOReceiptScreen';

// Import m√†n h√¨nh qu·∫£n l√Ω kho
import InventoryScreen from '../screens/InventoryScreen';
import AddInventoryItemScreen from '../screens/AddInventoryItemScreen';
import EditInventoryItemScreen from '../screens/EditInventoryItemScreen';
import InventoryItemDetailScreen from '../screens/InventoryItemDetailScreen';
import InventoryTransactionScreen from '../screens/InventoryTransactionScreen';
import InventoryReportScreen from '../screens/InventoryReportScreen';
import AssignSalaryScreen from '../screens/AssignSalaryScreen';

// Import m√†n h√¨nh qu·∫£n l√Ω l∆∞∆°ng
import FixedFeesManagementScreen from '../screens/FixedFeesManagementScreen';
import SalarySlipCreationScreen from '../screens/SalarySlipCreationScreen';
import TotalSalaryReportScreen from '../screens/TotalSalaryReportScreen';

// Import expense tracking screens
import ExpenseListScreen from '../screens/ExpenseListScreen';

// Import the AddCompanyExpenseScreen
import AddCompanyExpenseScreen from '../screens/AddCompanyExpenseScreen';

// Import material management screen
import MaterialManagementScreen from '../screens/MaterialManagementScreen';
import MonthlyCostReportScreen from '../screens/MonthlyCostReportScreen';
import CustomerImportScreen from '../screens/CustomerImportScreen';

// Import the payment screens
import PaymentRequestListScreen from '../screens/PaymentRequestListScreen';
import CreatePaymentRequestScreen from '../screens/CreatePaymentRequestScreen';
import PaymentRequestDetailScreen from '../screens/PaymentRequestDetailScreen';

// Import production screens
import KioskScreen from '../screens/KioskScreen';
import StarboardScreen from '../screens/StarboardScreen';
import ProductionDashboard from '../screens/ProductionDashboard';
import WorkAllocationScreen from '../screens/WorkAllocationScreen';

// Import AI Chat screen
import AIChatScreen from '../screens/AIChatScreen';

// Import Worker screens
import WorkerAttendanceScreen from '../screens/WorkerAttendanceScreen';
import LeaveRequestScreen from '../screens/LeaveRequestScreen';
import AdvanceSalaryScreen from '../screens/AdvanceSalaryScreen';

// Import Project Discussion screen
import ProjectDiscussionScreen from '../screens/ProjectDiscussionScreen';

// Import MachinesManagementScreen
import MachinesManagementScreen from '../screens/MachinesManagementScreen';

// T·∫°o Stack Navigator cho qu·∫£n l√Ω d·ª± √°n
const ProjectStack = createNativeStackNavigator();

const ProjectStackNavigator = () => {
  const { theme } = useTheme();

  return (
    <ProjectStack.Navigator
      screenOptions={{
        headerShown: true,
        headerStyle: {
          backgroundColor: theme.background,
        },
        headerTitleStyle: {
          color: theme.text,
        },
        headerTintColor: theme.text,
        contentStyle: { backgroundColor: theme.background },
      }}
    >
      <ProjectStack.Screen
        name="ProjectManagement"
        component={ProjectManagementScreen}
        options={{ headerShown: false }}
      />
      <ProjectStack.Screen
        name="ProjectDetail"
        component={ProjectDetailScreen}
        options={{ headerShown: false }}
      />
      <ProjectStack.Screen
        name="AddProject"
        component={AddProjectScreen}
        options={{ title: 'Th√™m D·ª± √°n M·ªõi', headerRight: null }}
      />
      <ProjectStack.Screen
        name="EditProject"
        component={EditProjectScreen}
        options={{ title: 'Ch·ªânh s·ª≠a D·ª± √°n', headerRight: null }}
      />
      <ProjectStack.Screen
        name="Quotation"
        component={QuotationScreen}
        options={{ headerShown: false }}
      />
      <ProjectStack.Screen
        name="ManualQuotation"
        component={ManualQuotationScreen}
        options={{ title: 'B√°o gi√° Th·ªß c√¥ng' }}
      />
      <ProjectStack.Screen
        name="FinalizeQuotation"
        component={FinalizeQuotationScreen}
        options={{ headerShown: false }}
      />
      <ProjectStack.Screen
        name="StageDetail"
        component={StageDetailScreen}
        options={{ title: 'Chi ti·∫øt C√¥ng ƒëo·∫°n' }}
      />
      <ProjectStack.Screen
        name="MaterialPurchase"
        component={MaterialPurchaseScreen}
        options={{ title: 'Qu·∫£n l√Ω Mua V·∫≠t T∆∞' }}
      />
      <ProjectStack.Screen
        name="AIChat"
        component={AIChatScreen}
        options={{ headerShown: false }}
      />
      <ProjectStack.Screen
        name="CreateProposal"
        component={CreateProposalScreen}
        options={{ title: 'T·∫°o ƒê·ªÅ Xu·∫•t' }}
      />
      <ProjectStack.Screen
        name="CreatePO"
        component={CreatePOScreen}
        options={{ title: 'T·∫°o PO' }}
      />
      <ProjectStack.Screen
        name="ProposalList"
        component={ProposalListScreen}
        options={{ title: 'Duy·ªát ƒê·ªÅ Xu·∫•t' }}
      />
      <ProjectStack.Screen
        name="POList"
        component={POListScreen}
        options={{ title: 'ƒê∆°n ƒë·∫∑t h√†ng' }}
      />
      <ProjectStack.Screen
        name="ProjectCost"
        component={ProjectCostScreen}
        options={{ title: 'Chi ph√≠ d·ª± √°n', headerShown: false }}
      />
      <ProjectStack.Screen
        name="ProjectDiscussion"
        component={ProjectDiscussionScreen}
        options={{ headerShown: false }}
      />
    </ProjectStack.Navigator>
  );
};

// T·∫°o Stack Navigator cho qu·∫£n l√Ω kho
const InventoryStack = createNativeStackNavigator();

const InventoryStackNavigator = () => {
  const { theme } = useTheme();

  return (
    <InventoryStack.Navigator
      initialRouteName="InventoryMain"
      screenOptions={{
        headerShown: true,
        headerStyle: {
          backgroundColor: theme.background,
        },
        headerTitleStyle: {
          color: theme.text,
        },
        headerTintColor: theme.text,
        contentStyle: { backgroundColor: theme.background },
      }}
    >
      <InventoryStack.Screen
        name="InventoryMain"
        component={InventoryScreen}
        options={({ navigation }) => ({
          title: 'Qu·∫£n l√Ω Kho',
          headerRight: () => (
            <TouchableOpacity
              onPress={() => navigation.navigate('AddInventoryItem')}
              style={{
                marginRight: 15,
                backgroundColor: theme.primary,
                width: 36,
                height: 36,
                borderRadius: 18,
                justifyContent: 'center',
                alignItems: 'center',
              }}
            >
              <Ionicons name="add" size={24} color="#fff" />
            </TouchableOpacity>
          ),
        })}
      />
      <InventoryStack.Screen
        name="AddInventoryItem"
        component={AddInventoryItemScreen}
        options={({ navigation }) => ({
          title: 'Th√™m V·∫≠t T∆∞ M·ªõi',
          headerTitleAlign: 'center', // CƒÉn gi·ªØa ho√†n to√†n
          headerTitleStyle: {
            textAlign: 'center',
            flex: 1,
            marginLeft: -60, // TƒÉng kho·∫£ng c√°ch ƒë·ªÉ cƒÉn gi·ªØa t·ªët h∆°n
            marginRight: -20, // Th√™m margin b√™n ph·∫£i ƒë·ªÉ c√¢n b·∫±ng
          },
          headerLeft: () => (
            <TouchableOpacity
              onPress={() => navigation.navigate('InventoryMain')}
              style={{ marginLeft: 10 }}
            >
              <Ionicons name="arrow-back" size={24} color={theme.text} />
            </TouchableOpacity>
          ),
        })}
      />
      <InventoryStack.Screen
        name="EditInventoryItem"
        component={EditInventoryItemScreen}
        options={({ navigation }) => ({
          title: 'Ch·ªânh s·ª≠a V·∫≠t T∆∞',
          headerLeft: () => (
            <TouchableOpacity
              onPress={() => navigation.navigate('InventoryMain')}
              style={{ marginLeft: 10 }}
            >
              <Ionicons name="arrow-back" size={24} color={theme.text} />
            </TouchableOpacity>
          ),
        })}
      />
      <InventoryStack.Screen
        name="InventoryItemDetail"
        component={InventoryItemDetailScreen}
        options={({ navigation }) => ({
          title: 'Chi Ti·∫øt V·∫≠t T∆∞',
          headerLeft: () => (
            <TouchableOpacity
              onPress={() => navigation.navigate('InventoryMain')}
              style={{ marginLeft: 10 }}
            >
              <Ionicons name="arrow-back" size={24} color={theme.text} />
            </TouchableOpacity>
          ),
        })}
      />
      <InventoryStack.Screen
        name="InventoryTransaction"
        component={InventoryTransactionScreen}
        options={({ navigation }) => ({
          title: 'Giao D·ªãch Kho',
          headerLeft: () => (
            <TouchableOpacity
              onPress={() => navigation.navigate('InventoryMain')}
              style={{ marginLeft: 10 }}
            >
              <Ionicons name="arrow-back" size={24} color={theme.text} />
            </TouchableOpacity>
          ),
        })}
      />
      <InventoryStack.Screen
        name="InventoryReport"
        component={InventoryReportScreen}
        options={({ navigation }) => ({
          title: 'B√°o C√°o Kho',
          headerLeft: () => (
            <TouchableOpacity
              onPress={() => navigation.navigate('InventoryMain')}
              style={{ marginLeft: 10 }}
            >
              <Ionicons name="arrow-back" size={24} color={theme.text} />
            </TouchableOpacity>
          ),
        })}
      />
    </InventoryStack.Navigator>
  );
};

// T·∫°o Tab Navigator
const Tab = createBottomTabNavigator();

const MainTabNavigator = () => {
  const { theme } = useTheme();
  const { user } = useAuth();
  const [pendingLeaveCount, setPendingLeaveCount] = useState(0);
  const [pendingAdvanceCount, setPendingAdvanceCount] = useState(0);

  // Check if user has director role - support both English and Vietnamese role names
  const isDirector = ['director', 'Gi√°m ƒë·ªëc', 'giam_doc'].includes(user?.role);
  const canManageAttendance = ['pho_giam_doc'].includes(user?.role);
  const canManageUsers = ['admin', 'giam_doc'].includes(user?.role);
  // Ki·ªÉm tra quy·ªÅn truy c·∫≠p v√†o module kho
  const canAccessInventory = ['thuong_mai', 'ky_su', 'ke_toan'].includes(
    user?.role
  );

  console.log(
    'User role:',
    user?.role,
    'Is Director:',
    isDirector,
    'Can Access Inventory:',
    canAccessInventory
  );

  // Realtime badge for pending approval requests
  useEffect(() => {
    const leaveQ = query(
      collection(db, 'leave_requests'),
      where('status', '==', 'pending')
    );
    const advQ = query(
      collection(db, 'advance_requests'),
      where('status', '==', 'pending')
    );
    const un1 = onSnapshot(leaveQ, (snap) => {
      setPendingLeaveCount(snap.size || 0);
    });
    const un2 = onSnapshot(advQ, (snap) => {
      setPendingAdvanceCount(snap.size || 0);
    });
    return () => {
      un1();
      un2();
    };
  }, []);

  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName;

          if (route.name === 'Home') {
            iconName = focused ? 'home' : 'home-outline';
          } else if (route.name === 'Customers') {
            iconName = focused ? 'people' : 'people-outline';
          } else if (route.name === 'Projects') {
            iconName = focused ? 'briefcase' : 'briefcase-outline';
          } else if (route.name === 'Inventory') {
            iconName = focused ? 'cube' : 'cube-outline';
          } else if (route.name === 'Tasks') {
            iconName = focused ? 'file-tray-full' : 'file-tray-full-outline';
          } else if (route.name === 'Attendance') {
            iconName = focused ? 'checkbox' : 'square-outline';
          } else if (route.name === 'UserManagement') {
            iconName = focused ? 'people' : 'people-outline';
          } else if (route.name === 'Account') {
            iconName = focused ? 'person-circle' : 'person-circle-outline';
          } else if (route.name === 'Dashboard') {
            iconName = focused ? 'stats-chart' : 'stats-chart-outline';
          } else if (route.name === 'Inventory') {
            iconName = focused ? 'cube' : 'cube-outline';
          }

          return <Ionicons name={iconName} size={size} color={color} />;
        },
        tabBarActiveTintColor: theme.primary,
        tabBarInactiveTintColor: theme.textMuted,
        headerShown: true,
        headerStyle: {
          backgroundColor: theme.background,
        },
        headerTitleStyle: {
          color: theme.text,
        },
        tabBarStyle: {
          backgroundColor: theme.background,
          borderTopColor: theme.border,
        },
        contentStyle: {
          backgroundColor: theme.background,
        },
      })}
    >
      {isDirector ? (
        // Director sees Dashboard as first tab
        <Tab.Screen
          name="Dashboard"
          component={DirectorDashboardScreen}
          options={{ title: 'T·ªïng Quan' }}
        />
      ) : (
        // Other users see Home as first tab
        <Tab.Screen
          name="Home"
          component={HomeScreen}
          options={{ title: 'Trang Ch·ªß' }}
        />
      )}
      <Tab.Screen
        name="Customers"
        component={CustomerManagementScreen}
        options={{ title: 'Kh√°ch H√†ng', headerShown: false }}
      />
      <Tab.Screen
        name="Projects"
        component={ProjectStackNavigator}
        options={{
          title: 'D·ª± √Ån',
          headerShown: false,
        }}
      />
      {canManageAttendance ? (
        <Tab.Screen
          name="Attendance"
          component={AttendanceScreen}
          options={{ title: 'Ch·∫•m c√¥ng', headerShown: false }}
        />
      ) : (
        <Tab.Screen
          name="Tasks"
          component={TaskReportScreen}
          options={{
            title: 'B√°o c√°o',
            headerShown: false,
            tabBarBadge:
              pendingLeaveCount + pendingAdvanceCount > 0
                ? pendingLeaveCount + pendingAdvanceCount
                : undefined,
            tabBarBadgeStyle: {
              backgroundColor: '#E53935',
              color: '#fff',
            },
          }}
        />
      )}

      {canManageUsers && (
        <Tab.Screen
          name="UserManagement"
          component={UserManagementScreen}
          options={{ title: 'Nh√¢n vi√™n' }}
        />
      )}

      {canAccessInventory && (
        <Tab.Screen
          name="Inventory"
          component={InventoryStackNavigator}
          options={{ title: 'Kho V·∫≠t T∆∞', headerShown: false }}
        />
      )}

      <Tab.Screen
        name="Account"
        component={AccountScreen}
        options={{ title: 'T√†i kho·∫£n' }}
      />
    </Tab.Navigator>
  );
};

// T·∫°o Stack Navigator cho lu·ªìng x√°c th·ª±c v√† c√°c m√†n h√¨nh kh√°c
const Stack = createNativeStackNavigator();

const AppNavigator = () => {
  // S·ª≠ d·ª•ng tr·∫°ng th√°i ƒëƒÉng nh·∫≠p t·ª´ AuthContext
  const { isSignedIn, loadingAuth } = useAuth();
  const { theme, isDarkMode } = useTheme();

  // T·∫°o theme cho NavigationContainer d·ª±a tr√™n theme hi·ªán t·∫°i
  const navigationTheme = {
    ...(isDarkMode ? DarkTheme : DefaultTheme),
    colors: {
      ...(isDarkMode ? DarkTheme.colors : DefaultTheme.colors),
      primary: theme.primary,
      background: theme.background,
      card: theme.card,
      text: theme.text,
      border: theme.border,
      notification: theme.primary,
    },
  };

  // X·ª≠ l√Ω FCM notifications
  useEffect(() => {
    // X·ª≠ l√Ω khi app ƒëang ch·∫°y (foreground)
    const unsubscribeOnMessage = messaging().onMessage(
      async (remoteMessage) => {
        console.log('FCM Message received in foreground:', remoteMessage);
        Alert.alert(
          remoteMessage.notification.title,
          remoteMessage.notification.body
        );
      }
    );

    // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng nh·∫•n v√†o notification (app ƒëang ·ªü background)
    messaging().onNotificationOpenedApp((remoteMessage) => {
      console.log(
        'Notification caused app to open from background:',
        remoteMessage
      );
      const { projectId, projectName } = remoteMessage.data;
      if (projectId) {
        // C·∫ßn navigation reference ƒë·ªÉ ƒëi·ªÅu h∆∞·ªõng
        // T·∫°m th·ªùi ch·ªâ log ra
        console.log('Should navigate to ProjectDiscussion with:', {
          projectId,
          projectName,
        });
      }
    });

    // Ki·ªÉm tra n·∫øu app ƒë∆∞·ª£c m·ªü t·ª´ tr·∫°ng th√°i t·∫Øt (killed)
    messaging()
      .getInitialNotification()
      .then((remoteMessage) => {
        if (remoteMessage) {
          console.log(
            'Notification caused app to open from quit state:',
            remoteMessage
          );
          const { projectId, projectName } = remoteMessage.data;
          if (projectId) {
            // C·∫ßn m·ªôt c∆° ch·∫ø ƒë·ªÉ ƒëi·ªÅu h∆∞·ªõng sau khi app ƒë√£ s·∫µn s√†ng
            // V√≠ d·ª•: l∆∞u v√†o m·ªôt state global v√† ƒëi·ªÅu h∆∞·ªõng sau
            // T·∫°m th·ªùi ch·ªâ log ra
            console.log('Should navigate to ProjectDiscussion with:', {
              projectId,
              projectName,
            });
          }
        }
      });

    return unsubscribeOnMessage;
  }, []);

  // Hi·ªÉn th·ªã m√†n h√¨nh loading n·∫øu ƒëang ki·ªÉm tra tr·∫°ng th√°i ƒëƒÉng nh·∫≠p
  if (loadingAuth) {
    return (
      <View
        style={{
          flex: 1,
          justifyContent: 'center',
          alignItems: 'center',
          backgroundColor: theme.background,
        }}
      >
        <Text style={{ color: theme.text }}>ƒêang t·∫£i...</Text>
      </View>
    );
  }

  return (
    <NavigationContainer theme={navigationTheme}>
      <Stack.Navigator
        screenOptions={{
          contentStyle: { backgroundColor: theme.background },
        }}
      >
        {isSignedIn ? (
          // Ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng nh·∫≠p
          <>
            <Stack.Screen
              name="Main"
              component={MainTabNavigator}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="CustomerDetail"
              component={CustomerDetailScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="AddCustomer"
              component={AddCustomerScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="EditCustomer"
              component={EditCustomerScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="ProjectDetail"
              component={ProjectDetailScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="TaskDetail"
              component={TaskDetailScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="AddProject"
              component={AddProjectScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="EditProject"
              component={EditProjectScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="FinalizeQuotation"
              component={FinalizeQuotationScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="Quotation"
              component={QuotationScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="StageDetail"
              component={StageDetailScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="DebtDashboard"
              component={DebtDashboard}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="ProposalList"
              component={ProposalListScreen}
              options={{
                title: 'Duy·ªát ƒê·ªÅ Xu·∫•t',
                headerStyle: {
                  backgroundColor: theme.background,
                },
                headerTintColor: theme.text,
                headerTitleStyle: {
                  color: theme.text,
                },
              }}
            />
            <Stack.Screen
              name="DirectorDashboard"
              component={DirectorDashboardScreen}
              options={{ title: 'Trang c·ªßa gi√°m ƒë·ªëc' }}
            />
            <Stack.Screen
              name="Notifications"
              component={NotificationsScreen}
              options={{ title: 'Th√¥ng b√°o' }}
            />

            {/* Th√™m c√°c m√†n h√¨nh qu·∫£n l√Ω nh√† cung c·∫•p */}
            <Stack.Screen
              name="SupplierManagement"
              component={SupplierManagementScreen}
            />
            <Stack.Screen name="AddSupplier" component={AddSupplierScreen} />
            <Stack.Screen name="EditSupplier" component={EditSupplierScreen} />
            <Stack.Screen
              name="SupplierDetail"
              component={SupplierDetailScreen}
            />
            <Stack.Screen
              name="ConfirmPOReceipt"
              component={ConfirmPOReceiptScreen}
              options={{ title: 'X√°c nh·∫≠n giao h√†ng', headerShown: true }}
            />

            {/* Th√™m c√°c m√†n h√¨nh qu·∫£n l√Ω kho */}
            <Stack.Screen name="Inventory" component={InventoryScreen} />
            {/* ƒê√£ x√≥a duplicate AddInventoryItem - ch·ªâ gi·ªØ trong InventoryStackNavigator */}
            <Stack.Screen
              name="EditInventoryItem"
              component={EditInventoryItemScreen}
            />
            <Stack.Screen
              name="InventoryItemDetail"
              component={InventoryItemDetailScreen}
            />
            <Stack.Screen
              name="InventoryTransaction"
              component={InventoryTransactionScreen}
            />
            <Stack.Screen
              name="InventoryReport"
              component={InventoryReportScreen}
            />
            <Stack.Screen
              name="CreateDeliveryNote"
              component={CreateDeliveryNoteScreen}
            />
            <Stack.Screen
              name="Attendance"
              component={AttendanceScreen}
              options={{ title: 'B·∫£ng Ch·∫•m C√¥ng' }}
            />
            <Stack.Screen
              name="AssignSalary"
              component={AssignSalaryScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="ProjectCost"
              component={ProjectCostScreen}
              options={{ headerShown: false }}
            />
            {/* <Stack.Screen name="Staging" component={StagingScreen} /> */}

            {/* Add the new expense tracking screens */}
            <Stack.Screen
              name="ExpenseList"
              component={ExpenseListScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="AddCompanyExpense"
              component={AddCompanyExpenseScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="PaymentRequestList"
              component={PaymentRequestListScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="CreatePaymentRequest"
              component={CreatePaymentRequestScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="PaymentRequestDetail"
              component={PaymentRequestDetailScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="FinancialDashboard"
              component={FinancialDashboardScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="Kiosk"
              component={KioskScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="Starboard"
              component={StarboardScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="ProductionDashboard"
              component={ProductionDashboard}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="WorkAllocation"
              component={WorkAllocationScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="MaterialManagement"
              component={MaterialManagementScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="MonthlyCostReport"
              component={MonthlyCostReportScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="CustomerImport"
              component={CustomerImportScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="IconSettings"
              component={IconSettingsScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="CustomIconDebug"
              component={CustomIconDebug}
              options={{ headerShown: false }}
            />

            {/* Worker Screens */}
            <Stack.Screen
              name="WorkerAttendance"
              component={WorkerAttendanceScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="LeaveRequest"
              component={LeaveRequestScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="AdvanceSalary"
              component={AdvanceSalaryScreen}
              options={{ headerShown: false }}
            />

            {/* Salary Management Screens */}
            <Stack.Screen
              name="FixedFeesManagement"
              component={FixedFeesManagementScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="SalarySlipCreation"
              component={SalarySlipCreationScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="TotalSalaryReport"
              component={TotalSalaryReportScreen}
              options={{ headerShown: false }}
            />

            {/* Machines Management Screen */}
            <Stack.Screen
              name="MachinesManagement"
              component={MachinesManagementScreen}
              options={{ title: 'Qu·∫£n l√Ω m√°y m√≥c', headerShown: false }}
            />
          </>
        ) : (
          // Ng∆∞·ªùi d√πng ch∆∞a ƒëƒÉng nh·∫≠p
          <Stack.Screen
            name="Login"
            component={LoginScreen}
            options={{ headerShown: false }}
          />
        )}
      </Stack.Navigator>
    </NavigationContainer>
  );
};

export default AppNavigator;


--- END: src\navigation\AppNavigator.js ---


--- START: src\screens\AccountScreen.js ---
//src/screens/AccountScreen.js
import React, { useContext, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Switch,
  ScrollView,
  Alert,
  LayoutAnimation,
  UIManager,
  Platform,
} from 'react-native';
import * as Clipboard from 'expo-clipboard';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { useAuth } from '../contexts/AuthContext';
import { useTheme } from '../contexts/ThemeContext';
import {
  GoogleSignin,
  statusCodes,
} from '@react-native-google-signin/google-signin';

if (
  Platform.OS === 'android' &&
  UIManager.setLayoutAnimationEnabledExperimental
) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

const SettingItem = ({
  icon,
  title,
  value,
  onPress,
  type = 'chevron',
  color,
}) => {
  const { theme } = useTheme();

  return (
    <TouchableOpacity
      style={[styles.settingItem, { borderBottomColor: theme.border }]}
      onPress={onPress}
      disabled={type === 'switch'}
    >
      <View style={styles.settingLeft}>
        <Ionicons
          name={icon}
          size={22}
          color={color || theme.text}
          style={styles.settingIcon}
        />
        <Text style={[styles.settingTitle, { color: theme.text }]}>
          {title}
        </Text>
      </View>

      <View style={styles.settingRight}>
        {type === 'switch' && (
          <Switch
            value={value}
            onValueChange={onPress}
            trackColor={{ false: theme.border, true: theme.primary }}
            thumbColor={value ? '#fff' : '#f4f3f4'}
          />
        )}
        {type === 'value' && (
          <Text style={[styles.settingValue, { color: theme.textSecondary }]}>
            {value}
          </Text>
        )}
        {type === 'chevron' && (
          <Ionicons name="chevron-forward" size={20} color={theme.textMuted} />
        )}
      </View>
    </TouchableOpacity>
  );
};

// Helper function to map role keys to display labels
const getRoleLabel = (role) => {
  switch (role) {
    case 'admin':
      return 'Qu·∫£n tr·ªã vi√™n';
    case 'giam_doc':
      return 'Gi√°m ƒë·ªëc';
    case 'pho_giam_doc':
      return 'Ph√≥ Gi√°m ƒë·ªëc';
    case 'quan_ly':
      return 'Qu·∫£n l√Ω';
    case 'ky_su':
      return 'K·ªπ s∆∞';
    case 'ke_toan':
      return 'K·∫ø to√°n';
    case 'thuong_mai':
      return 'Th∆∞∆°ng m·∫°i';
    case 'cong_nhan':
      return 'C√¥ng nh√¢n';
    case 'user':
      return 'Ng∆∞·ªùi d√πng';
    default:
      return 'Kh√¥ng x√°c ƒë·ªãnh';
  }
};

// Helper function to get style based on role
const getRoleStyle = (role) => {
  switch (role) {
    case 'giam_doc':
      return { backgroundColor: '#FFD700', textColor: '#8C6D00' };
    case 'pho_giam_doc':
      return { backgroundColor: '#E6E6FA', textColor: '#483D8B' };
    case 'ky_su':
      return {
        backgroundColor: 'rgba(0, 102, 204, 0.2)',
        textColor: '#0066cc',
      };
    case 'ke_toan':
      return {
        backgroundColor: 'rgba(46, 204, 113, 0.2)',
        textColor: '#27AE60',
      };
    case 'thuong_mai':
      return {
        backgroundColor: 'rgba(243, 156, 18, 0.2)',
        textColor: '#D35400',
      };
    case 'cong_nhan':
      return { backgroundColor: '#f0f0f0', textColor: '#555' };
    case 'admin':
    case 'quan_ly':
    case 'user':
    default:
      return {
        backgroundColor: 'rgba(108, 122, 137, 0.2)',
        textColor: '#6C7A89',
      };
  }
};

const AccountScreen = ({ navigation }) => {
  const { logout, currentUser, userRole } = useAuth();
  const { theme, isDarkMode, toggleTheme, followSystem, toggleFollowSystem } =
    useTheme();

  useEffect(() => {
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
  }, []);

  const handleLogout = () => {
    Alert.alert(
      'X√°c nh·∫≠n ƒëƒÉng xu·∫•t',
      'B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën ƒëƒÉng xu·∫•t kh√¥ng?',
      [
        {
          text: 'H·ªßy',
          style: 'cancel',
        },
        {
          text: 'ƒêƒÉng xu·∫•t',
          onPress: () => logout(),
          style: 'destructive',
        },
      ],
      { cancelable: true }
    );
  };

  const switchGoogleAccount = async () => {
    try {
      // Ng·∫Øt k·∫øt n·ªëi t√†i kho·∫£n Google hi·ªán t·∫°i
      await GoogleSignin.revokeAccess();
      await GoogleSignin.signOut();

      Alert.alert(
        'ƒê√£ ng·∫Øt k·∫øt n·ªëi',
        'T√†i kho·∫£n Google ƒë√£ ƒë∆∞·ª£c ng·∫Øt k·∫øt n·ªëi. B·∫°n c√≥ th·ªÉ k·∫øt n·ªëi l·∫°i khi c·∫ßn thi·∫øt trong m√†n h√¨nh chi ti·∫øt d·ª± √°n.'
      );
    } catch (error) {
      if (error.code === statusCodes.SIGN_IN_REQUIRED) {
        // This error is expected after a sign-out or if the user isn't signed in.
        // We can safely ignore it.
        console.log(
          'User is not signed in, which is expected after revokeAccess.'
        );
        Alert.alert(
          'ƒê√£ ng·∫Øt k·∫øt n·ªëi',
          'T√†i kho·∫£n Google ƒë√£ ƒë∆∞·ª£c ng·∫Øt k·∫øt n·ªëi th√†nh c√¥ng.'
        );
      } else {
        // For any other unexpected errors, show an alert to the user.
        console.error('L·ªói khi chuy·ªÉn t√†i kho·∫£n Google:', error);
        Alert.alert(
          'L·ªói',
          'Kh√¥ng th·ªÉ ng·∫Øt k·∫øt n·ªëi t√†i kho·∫£n Google. Vui l√≤ng th·ª≠ l·∫°i.'
        );
      }
    }
  };

  // Get dynamic style for role badge
  const roleStyle = getRoleStyle(currentUser?.role);

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <ScrollView
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.scrollViewContent}
      >
        {/* Header */}
        <View style={styles.header}>
          <View style={[styles.profileCard, { backgroundColor: theme.card }]}>
            <View
              style={[
                styles.avatarContainer,
                { backgroundColor: theme.primaryLight },
              ]}
            >
              <Text style={[styles.avatarText, { color: theme.primary }]}>
                {currentUser?.displayName
                  ? currentUser.displayName[0].toUpperCase()
                  : currentUser?.email
                  ? currentUser.email[0].toUpperCase()
                  : 'U'}
              </Text>
            </View>
            <View style={styles.userInfoContainer}>
              <Text style={[styles.nameText, { color: theme.text }]}>
                {currentUser?.displayName || 'T√™n Ng∆∞·ªùi D√πng'}
              </Text>
              <View
                style={[
                  styles.roleBadge,
                  { backgroundColor: roleStyle.backgroundColor },
                ]}
              >
                <Text
                  style={[styles.roleBadgeText, { color: roleStyle.textColor }]}
                >
                  {getRoleLabel(currentUser?.role)}
                </Text>
              </View>
            </View>
          </View>
        </View>

        {/* Settings Groups */}
        <View style={[styles.settingsGroup, { backgroundColor: theme.card }]}>
          <Text style={[styles.groupTitle, { color: theme.textSecondary }]}>
            Giao di·ªán
          </Text>
          <SettingItem
            icon="contrast-outline"
            title="Ch·∫ø ƒë·ªô t·ªëi"
            value={isDarkMode}
            onPress={toggleTheme}
            type="switch"
          />
          <SettingItem
            icon="phone-portrait-outline"
            title="Theo h·ªá th·ªëng"
            value={followSystem}
            onPress={toggleFollowSystem}
            type="switch"
          />
        </View>

        <View style={[styles.settingsGroup, { backgroundColor: theme.card }]}>
          <Text style={[styles.groupTitle, { color: theme.textSecondary }]}>
            T√†i kho·∫£n
          </Text>
          <SettingItem
            icon="person-outline"
            title="Th√¥ng tin c√° nh√¢n"
            onPress={() => Alert.alert('T√≠nh nƒÉng ƒëang ph√°t tri·ªÉn')}
          />
          <SettingItem
            icon="key-outline"
            title="ƒê·ªïi m·∫≠t kh·∫©u"
            onPress={() => Alert.alert('T√≠nh nƒÉng ƒëang ph√°t tri·ªÉn')}
          />
          <SettingItem
            icon="swap-horizontal-outline"
            title="Chuy·ªÉn t√†i kho·∫£n Google"
            onPress={switchGoogleAccount}
            color="#4285F4"
          />
          <SettingItem
            icon="location-outline"
            title="ƒê·ªãa ch·ªâ X∆∞·ªüng ngo√†i (X∆∞·ªüng 1)"
            onPress={async () => {
              await Clipboard.setStringAsync(
                'https://www.google.com/maps/place/X%C6%B0%E1%BB%9Fng+CK+MT+-+T%C3%A2n+H%C3%B2a+Ph%C3%A1t+1/@10.7782508,106.5291403,12z/data=!4m10!1m2!2m1!1zY8ahIGtow60gdMOibiBow7JhIHBow6F0!3m6!1s0x3175290ffa823bfb:0x23c923d5a8d1a031!8m2!3d10.8614882!4d106.6831661!15sChhjxqEga2jDrSB0w6JuIGjDsmEgcGjDoXSSARVtZWNoYW5pY2FsX2NvbnRyYWN0b3KqAVAKDS9nLzExc2s2djkwODYQATIfEAEiG23AjuWtNDJVRipKVSAA9Rbpkjo81fIfZYNOsDIcEAIiGGPGoSBraMOtIHTDom4gaMOyYSBwaMOhdOABAA!16s%2Fg%2F11h6gd6mg4?entry=ttu&g_ep=EgoyMDI1MDgxOS4wIKXMDSoASAFQAw%3D%3D'
              );
              Alert.alert(
                'ƒê√£ sao ch√©p',
                'Li√™n k·∫øt ƒë·ªãa ch·ªâ X∆∞·ªüng 1 ƒë√£ ƒë∆∞·ª£c copy'
              );
            }}
            color={theme.primary}
          />
          <SettingItem
            icon="location-outline"
            title="ƒê·ªãa ch·ªâ X∆∞·ªüng trong (X∆∞·ªüng 2)"
            onPress={async () => {
              await Clipboard.setStringAsync(
                'https://www.google.com/maps/place/102+%C4%90.+Th%E1%BA%A1nh+L%E1%BB%99c+15,+Th%E1%BA%A1nh+L%E1%BB%99c,+Qu%E1%BA%ADn+12,+H%E1%BB%93+Ch%C3%AD+Minh,+Vi%E1%BB%87t+Nam/@10.8675172,106.6876414,17z/data=!3m1!4b1!4m5!3m4!1s0x3175282515d55d23:0xdf8406f9ca9fa24a!8m2!3d10.8675119!4d106.6902163?entry=ttu&g_ep=EgoyMDI1MDgxOS4wIKXMDSoASAFQAw%3D%3D'
              );
              Alert.alert(
                'ƒê√£ sao ch√©p',
                'Li√™n k·∫øt ƒë·ªãa ch·ªâ X∆∞·ªüng 2 ƒë√£ ƒë∆∞·ª£c copy'
              );
            }}
            color={theme.primary}
          />
          {(userRole === 'giam_doc' || userRole === 'admin') && (
            <>
              <SettingItem
                icon="people-outline"
                title="Qu·∫£n l√Ω nh√¢n vi√™n"
                onPress={() => navigation.navigate('UserManagement')}
                color={theme.primary}
              />
              <SettingItem
                icon="color-palette-outline"
                title="C√†i ƒë·∫∑t Icon Stage"
                onPress={() => navigation.navigate('IconSettings')}
                color="#FF6B35"
              />
              <SettingItem
                icon="bug-outline"
                title="Debug Custom Icons"
                onPress={() => navigation.navigate('CustomIconDebug')}
                color="#9C27B0"
              />
            </>
          )}
        </View>

        <View style={[styles.settingsGroup, { backgroundColor: theme.card }]}>
          <Text style={[styles.groupTitle, { color: theme.textSecondary }]}>
            ·ª®ng d·ª•ng
          </Text>
          <SettingItem
            icon="information-circle-outline"
            title="Th√¥ng tin ·ª©ng d·ª•ng"
            value="1.0.0"
            type="value"
            onPress={() => {}}
          />
          <SettingItem
            icon="help-circle-outline"
            title="Tr·ª£ gi√∫p & H·ªó tr·ª£"
            onPress={() => {}}
          />
        </View>

        {/* Logout Button */}
        <TouchableOpacity
          style={[styles.logoutButton, { backgroundColor: theme.danger }]}
          onPress={handleLogout}
        >
          <Ionicons
            name="log-out-outline"
            size={20}
            color="#fff"
            style={styles.logoutIcon}
          />
          <Text style={styles.logoutText}>ƒêƒÉng xu·∫•t</Text>
        </TouchableOpacity>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  scrollViewContent: {
    paddingVertical: 16,
  },
  header: {
    paddingHorizontal: 16,
    marginBottom: 24,
  },
  profileCard: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderRadius: 16,
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  avatarContainer: {
    width: 72,
    height: 72,
    borderRadius: 36,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 16,
  },
  avatarText: {
    fontSize: 30,
    fontWeight: 'bold',
  },
  userInfoContainer: {
    flex: 1,
    justifyContent: 'center',
  },
  nameText: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 8,
    marginLeft: 2,
  },
  roleBadge: {
    alignSelf: 'flex-start',
    paddingVertical: 4,
    paddingHorizontal: 12,
    borderRadius: 12,
  },
  roleBadgeText: {
    fontSize: 12,
    fontWeight: '600',
  },
  settingsGroup: {
    marginHorizontal: 16,
    marginVertical: 8,
    borderRadius: 12,
    overflow: 'hidden',
  },
  groupTitle: {
    fontSize: 14,
    fontWeight: '600',
    textTransform: 'uppercase',
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 8,
  },
  settingItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 14,
    paddingHorizontal: 16,
    borderBottomWidth: 0.5,
  },
  settingLeft: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  settingIcon: {
    marginRight: 12,
  },
  settingTitle: {
    fontSize: 16,
  },
  settingRight: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  settingValue: {
    fontSize: 16,
    marginRight: 8,
  },
  logoutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginHorizontal: 16,
    marginTop: 24,
    paddingVertical: 14,
    borderRadius: 12,
  },
  logoutIcon: {
    marginRight: 8,
  },
  logoutText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '500',
  },
});

export default AccountScreen;


--- END: src\screens\AccountScreen.js ---


--- START: src\screens\AddCompanyExpenseScreen.js ---
import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  TextInput,
  ScrollView,
  Alert,
  ActivityIndicator,
  Modal,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import DateTimePicker from '@react-native-community/datetimepicker';
import { useAuth } from '../contexts/AuthContext';
import { useTheme } from '../contexts/ThemeContext';
import ExpenseService from '../api/expenseService';

const AddCompanyExpenseScreen = ({ navigation }) => {
  const { currentUser } = useAuth();
  const { theme } = useTheme();
  const [loading, setLoading] = useState(false);

  // Form state
  const [description, setDescription] = useState('');
  const [amount, setAmount] = useState('');
  const [date, setDate] = useState(new Date());
  const [relatedDocId, setRelatedDocId] = useState('');
  const [expenseType, setExpenseType] = useState('other');

  // UI state
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [showTypeModal, setShowTypeModal] = useState(false);
  const [errors, setErrors] = useState({});

  // List of available expense types
  const expenseTypes = [
    { id: 'rent', label: 'Ti·ªÅn thu√™ m·∫∑t b·∫±ng' },
    { id: 'utilities', label: 'ƒêi·ªán, n∆∞·ªõc, internet' },
    { id: 'administrative', label: 'Chi ph√≠ h√†nh ch√≠nh' },
    { id: 'taxes', label: 'Thu·∫ø, ph√≠' },
    { id: 'insurance', label: 'B·∫£o hi·ªÉm' },
    { id: 'maintenance', label: 'B·∫£o tr√¨ thi·∫øt b·ªã' },
    { id: 'transport', label: 'V·∫≠n chuy·ªÉn' },
    { id: 'other', label: 'Chi ph√≠ kh√°c' },
  ];

  // Check user role for access control
  const hasAccess =
    currentUser?.role === 'ke_toan' ||
    currentUser?.role === 'giam_doc' ||
    currentUser?.role === 'thuong_mai';
  if (!hasAccess) {
    return (
      <View style={[styles.container, { backgroundColor: theme.background }]}>
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
          >
            <Ionicons name="arrow-back" size={24} color={theme.text} />
          </TouchableOpacity>
          <Text style={[styles.headerTitle, { color: theme.text }]}>
            Th√™m Chi Ph√≠ C√¥ng Ty
          </Text>
        </View>

        <View style={styles.accessDenied}>
          <Ionicons name="lock-closed" size={48} color={theme.danger} />
          <Text style={[styles.accessDeniedText, { color: theme.text }]}>
            B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p t√≠nh nƒÉng n√†y.
          </Text>
          <Text
            style={[styles.accessDeniedSubtext, { color: theme.textSecondary }]}
          >
            Ch·ªâ k·∫ø to√°n, gi√°m ƒë·ªëc v√† th∆∞∆°ng m·∫°i m·ªõi c√≥ th·ªÉ th√™m chi ph√≠ c√¥ng ty.
          </Text>
        </View>
      </View>
    );
  }

  // Date picker handler
  const handleDateChange = (event, selectedDate) => {
    setShowDatePicker(false);
    if (selectedDate) {
      setDate(selectedDate);
    }
  };

  // Format date for display
  const formatDate = (date) => {
    return date.toLocaleDateString('vi-VN');
  };

  // Format currency for display
  const formatCurrency = (value) => {
    if (!value) return '';
    return value.toString().replace(/\B(?=(\d{3})+(?!\d))/g, '.');
  };

  // Handle type selection
  const handleSelectType = (typeId) => {
    setExpenseType(typeId);
    setShowTypeModal(false);
  };

  // Get type label based on ID
  const getTypeLabel = (typeId) => {
    const type = expenseTypes.find((t) => t.id === typeId);
    return type ? type.label : 'Chi ph√≠ kh√°c';
  };

  // Validation
  const validateForm = () => {
    const newErrors = {};

    if (!description.trim()) {
      newErrors.description = 'Vui l√≤ng nh·∫≠p m√¥ t·∫£ chi ph√≠';
    }

    if (!amount.trim()) {
      newErrors.amount = 'Vui l√≤ng nh·∫≠p s·ªë ti·ªÅn';
    } else if (isNaN(Number(amount)) || Number(amount) <= 0) {
      newErrors.amount = 'S·ªë ti·ªÅn ph·∫£i l·ªõn h∆°n 0';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Handle form submission
  const handleSaveExpense = async () => {
    if (!validateForm()) {
      return;
    }

    setLoading(true);

    try {
      const expenseData = {
        description,
        amount: parseFloat(amount.replace(/\./g, '')), // Remove thousand separators
        date,
        type: 'other', // Default type for the expenses collection
        expenseCategory: expenseType, // Additional field for company expenses
        relatedDocId: relatedDocId.trim() || null,
        createdBy: currentUser.uid,
      };

      const expenseId = await ExpenseService.addExpense(expenseData);

      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ l∆∞u chi ph√≠ c√¥ng ty th√†nh c√¥ng', [
        {
          text: 'Th√™m ti·∫øp',
          onPress: () => {
            // Reset form but keep the date
            setDescription('');
            setAmount('');
            setRelatedDocId('');
            setExpenseType('other');
            // Keep the current date for convenience
          },
        },
        {
          text: 'Ho√†n th√†nh',
          onPress: () => {
            navigation.goBack();
          },
        },
      ]);
    } catch (error) {
      console.error('Error saving company expense:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ l∆∞u chi ph√≠. Vui l√≤ng th·ª≠ l·∫°i sau.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <KeyboardAvoidingView
      style={{ flex: 1 }}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <View style={[styles.container, { backgroundColor: theme.background }]}>
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
          >
            <Ionicons name="arrow-back" size={24} color={theme.text} />
          </TouchableOpacity>
          <Text style={[styles.headerTitle, { color: theme.text }]}>
            Th√™m Chi Ph√≠ C√¥ng Ty
          </Text>
        </View>

        <ScrollView
          style={styles.content}
          contentContainerStyle={styles.contentContainer}
          keyboardShouldPersistTaps="handled"
        >
          <View
            style={[styles.card, { backgroundColor: theme.cardBackground }]}
          >
            <Text style={[styles.cardTitle, { color: theme.text }]}>
              Th√¥ng tin chi ph√≠
            </Text>

            {/* Description Field */}
            <View style={styles.fieldContainer}>
              <Text style={[styles.fieldLabel, { color: theme.text }]}>
                M√¥ t·∫£ chi ph√≠ *
              </Text>
              <TextInput
                style={[
                  styles.input,
                  {
                    backgroundColor: theme.inputBackground,
                    color: theme.text,
                    borderColor: errors.description
                      ? theme.danger
                      : theme.border,
                  },
                ]}
                placeholder="Nh·∫≠p m√¥ t·∫£ chi ph√≠"
                placeholderTextColor={theme.textPlaceholder}
                value={description}
                onChangeText={setDescription}
              />
              {errors.description && (
                <Text style={[styles.errorText, { color: theme.danger }]}>
                  {errors.description}
                </Text>
              )}
            </View>

            {/* Amount Field */}
            <View style={styles.fieldContainer}>
              <Text style={[styles.fieldLabel, { color: theme.text }]}>
                S·ªë ti·ªÅn (VNƒê) *
              </Text>
              <TextInput
                style={[
                  styles.input,
                  {
                    backgroundColor: theme.inputBackground,
                    color: theme.text,
                    borderColor: errors.amount ? theme.danger : theme.border,
                  },
                ]}
                placeholder="Nh·∫≠p s·ªë ti·ªÅn"
                placeholderTextColor={theme.textPlaceholder}
                keyboardType="numeric"
                value={formatCurrency(amount)}
                onChangeText={(text) => {
                  // Remove non-numeric characters for processing
                  const numericValue = text.replace(/[^0-9]/g, '');
                  setAmount(numericValue);
                }}
              />
              {errors.amount && (
                <Text style={[styles.errorText, { color: theme.danger }]}>
                  {errors.amount}
                </Text>
              )}
            </View>

            {/* Expense Type Field */}
            <View style={styles.fieldContainer}>
              <Text style={[styles.fieldLabel, { color: theme.text }]}>
                Lo·∫°i chi ph√≠
              </Text>
              <TouchableOpacity
                style={[
                  styles.selectButton,
                  {
                    backgroundColor: theme.inputBackground,
                    borderColor: theme.border,
                  },
                ]}
                onPress={() => setShowTypeModal(true)}
              >
                <Text style={{ color: theme.text }}>
                  {getTypeLabel(expenseType)}
                </Text>
                <Ionicons
                  name="chevron-down"
                  size={20}
                  color={theme.textSecondary}
                />
              </TouchableOpacity>
            </View>

            {/* Date Field */}
            <View style={styles.fieldContainer}>
              <Text style={[styles.fieldLabel, { color: theme.text }]}>
                Ng√†y
              </Text>
              <TouchableOpacity
                style={[
                  styles.selectButton,
                  {
                    backgroundColor: theme.inputBackground,
                    borderColor: theme.border,
                  },
                ]}
                onPress={() => setShowDatePicker(true)}
              >
                <Text style={{ color: theme.text }}>{formatDate(date)}</Text>
                <Ionicons
                  name="calendar"
                  size={20}
                  color={theme.textSecondary}
                />
              </TouchableOpacity>
              {showDatePicker && (
                <DateTimePicker
                  value={date}
                  mode="date"
                  display="default"
                  onChange={handleDateChange}
                  maximumDate={new Date()}
                />
              )}
            </View>

            {/* Document ID Field */}
            <View style={styles.fieldContainer}>
              <Text style={[styles.fieldLabel, { color: theme.text }]}>
                S·ªë h√≥a ƒë∆°n/ch·ª©ng t·ª´ (kh√¥ng b·∫Øt bu·ªôc)
              </Text>
              <TextInput
                style={[
                  styles.input,
                  {
                    backgroundColor: theme.inputBackground,
                    color: theme.text,
                    borderColor: theme.border,
                  },
                ]}
                placeholder="Nh·∫≠p s·ªë h√≥a ƒë∆°n ho·∫∑c ch·ª©ng t·ª´"
                placeholderTextColor={theme.textPlaceholder}
                value={relatedDocId}
                onChangeText={setRelatedDocId}
              />
            </View>
          </View>

          <View style={styles.footerContainer}>
            <TouchableOpacity
              style={[styles.cancelButton, { borderColor: theme.border }]}
              onPress={() => navigation.goBack()}
            >
              <Text style={{ color: theme.textSecondary }}>H·ªßy</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.saveButton,
                { backgroundColor: theme.primary },
                loading && { opacity: 0.7 },
              ]}
              onPress={handleSaveExpense}
              disabled={loading}
            >
              {loading ? (
                <ActivityIndicator size="small" color="#ffffff" />
              ) : (
                <>
                  <Ionicons
                    name="save-outline"
                    size={20}
                    color="#ffffff"
                    style={styles.buttonIcon}
                  />
                  <Text style={styles.saveButtonText}>L∆∞u chi ph√≠</Text>
                </>
              )}
            </TouchableOpacity>
          </View>
        </ScrollView>

        {/* Expense Type Selection Modal */}
        <Modal
          visible={showTypeModal}
          transparent={true}
          animationType="fade"
          onRequestClose={() => setShowTypeModal(false)}
        >
          <View style={styles.modalOverlay}>
            <View
              style={[
                styles.modalContainer,
                { backgroundColor: theme.cardBackground },
              ]}
            >
              <View style={styles.modalHeader}>
                <Text style={[styles.modalTitle, { color: theme.text }]}>
                  Ch·ªçn lo·∫°i chi ph√≠
                </Text>
                <TouchableOpacity onPress={() => setShowTypeModal(false)}>
                  <Ionicons name="close" size={24} color={theme.text} />
                </TouchableOpacity>
              </View>

              <ScrollView style={styles.modalContent}>
                {expenseTypes.map((type) => (
                  <TouchableOpacity
                    key={type.id}
                    style={[
                      styles.typeOption,
                      expenseType === type.id && {
                        backgroundColor: theme.primaryLight,
                      },
                    ]}
                    onPress={() => handleSelectType(type.id)}
                  >
                    <Text
                      style={[
                        styles.typeOptionText,
                        {
                          color:
                            expenseType === type.id
                              ? theme.primary
                              : theme.text,
                        },
                      ]}
                    >
                      {type.label}
                    </Text>
                    {expenseType === type.id && (
                      <Ionicons
                        name="checkmark"
                        size={20}
                        color={theme.primary}
                      />
                    )}
                  </TouchableOpacity>
                ))}
              </ScrollView>
            </View>
          </View>
        </Modal>
      </View>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  backButton: {
    marginRight: 16,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  content: {
    flex: 1,
  },
  contentContainer: {
    padding: 16,
    paddingBottom: 40,
  },
  card: {
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  cardTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  fieldContainer: {
    marginBottom: 16,
  },
  fieldLabel: {
    fontSize: 14,
    marginBottom: 8,
    fontWeight: '500',
  },
  input: {
    borderWidth: 1,
    borderRadius: 4,
    padding: 12,
    fontSize: 16,
  },
  selectButton: {
    borderWidth: 1,
    borderRadius: 4,
    padding: 12,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  errorText: {
    fontSize: 12,
    marginTop: 4,
  },
  footerContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 32,
  },
  cancelButton: {
    borderWidth: 1,
    borderRadius: 4,
    paddingVertical: 12,
    paddingHorizontal: 24,
    alignItems: 'center',
    justifyContent: 'center',
    minWidth: '45%',
  },
  saveButton: {
    flexDirection: 'row',
    borderRadius: 4,
    paddingVertical: 12,
    paddingHorizontal: 24,
    alignItems: 'center',
    justifyContent: 'center',
    minWidth: '45%',
  },
  buttonIcon: {
    marginRight: 8,
  },
  saveButtonText: {
    color: '#ffffff',
    fontWeight: 'bold',
    fontSize: 16,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    width: '80%',
    maxHeight: '80%',
    borderRadius: 8,
    padding: 16,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  modalContent: {
    maxHeight: '80%',
  },
  typeOption: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 4,
    marginBottom: 8,
  },
  typeOptionText: {
    fontSize: 16,
  },
  accessDenied: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  accessDeniedText: {
    fontSize: 18,
    fontWeight: 'bold',
    marginTop: 16,
    textAlign: 'center',
  },
  accessDeniedSubtext: {
    fontSize: 14,
    textAlign: 'center',
    marginTop: 8,
    maxWidth: '80%',
  },
});

export default AddCompanyExpenseScreen;


--- END: src\screens\AddCompanyExpenseScreen.js ---


--- START: src\screens\AddCustomerScreen.js ---
//src/screens/AddCustomerScreen.js
import React, { useState, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
  Keyboard,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { createCustomer } from '../api/customerService';
import { useAuth } from '../contexts/AuthContext';
import { SafeAreaView } from 'react-native-safe-area-context';
import StyledTextInput from '../components/StyledTextInput';

const AddCustomerScreen = ({ navigation }) => {
  const { currentUser } = useAuth();
  const [isLoading, setIsLoading] = useState(false);
  const [formData, setFormData] = useState({
    name: '',
    contactPerson: '',
    phone: '',
    email: '',
    address: '',
    type: 'regular', // m·∫∑c ƒë·ªãnh l√† kh√°ch h√†ng th∆∞·ªùng xuy√™n
    taxCode: '',
  });

  // Refs cho c√°c input ƒë·ªÉ ƒëi·ªÅu h∆∞·ªõng focus
  const contactPersonRef = useRef(null);
  const phoneRef = useRef(null);
  const emailRef = useRef(null);
  const addressRef = useRef(null);
  const taxCodeRef = useRef(null);

  // C·∫≠p nh·∫≠t gi√° tr·ªã form
  const handleChange = (field, value) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));
  };

  // Ki·ªÉm tra form h·ª£p l·ªá
  const validateForm = () => {
    if (!formData.name.trim()) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p t√™n kh√°ch h√†ng');
      return false;
    }

    if (!formData.contactPerson.trim()) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p t√™n ng∆∞·ªùi li√™n h·ªá');
      return false;
    }

    if (formData.email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
      Alert.alert('L·ªói', 'Email kh√¥ng h·ª£p l·ªá');
      return false;
    }

    return true;
  };

  // X·ª≠ l√Ω l∆∞u kh√°ch h√†ng
  const handleSave = async () => {
    if (!validateForm()) {
      return;
    }

    Keyboard.dismiss();
    setIsLoading(true);

    try {
      // G·ªçi API t·∫°o kh√°ch h√†ng m·ªõi
      await createCustomer(formData, currentUser?.uid);

      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ th√™m kh√°ch h√†ng m·ªõi th√†nh c√¥ng', [
        {
          text: 'OK',
          onPress: () => navigation.goBack(),
        },
      ]);
    } catch (error) {
      if (error.code === 'permission-denied') {
        Alert.alert(
          'L·ªói quy·ªÅn',
          'B·∫°n kh√¥ng c√≥ ƒë·ªß quy·ªÅn ƒë·ªÉ th·ª±c hi·ªán h√†nh ƒë·ªông n√†y.'
        );
      } else {
        console.error('L·ªói khi th√™m kh√°ch h√†ng:', error);
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ th√™m kh√°ch h√†ng. Vui l√≤ng th·ª≠ l·∫°i sau.');
      }
    } finally {
      setIsLoading(false);
    }
  };

  // X·ª≠ l√Ω thay ƒë·ªïi lo·∫°i kh√°ch h√†ng
  const handleSelectType = (type) => {
    handleChange('type', type);
  };

  return (
    <SafeAreaView style={styles.safeArea}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.container}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 0 : 20}
      >
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
          >
            <Ionicons name="arrow-back" size={24} color="#333" />
          </TouchableOpacity>
          <Text style={styles.headerTitle}>Th√™m kh√°ch h√†ng m·ªõi</Text>
          <View style={styles.placeholder} />
        </View>

        <ScrollView
          style={styles.formContainer}
          contentContainerStyle={styles.formContent}
          keyboardShouldPersistTaps="handled"
          showsVerticalScrollIndicator={false}
        >
          <StyledTextInput
            label="T√™n c√¥ng ty / T·ªï ch·ª©c"
            value={formData.name}
            onChangeText={(text) => handleChange('name', text)}
            placeholder="Nh·∫≠p t√™n c√¥ng ty ho·∫∑c t·ªï ch·ª©c"
            required={true}
            returnKeyType="next"
            blurOnSubmit={false}
            onSubmitEditing={() => contactPersonRef.current.focus()}
          />

          <StyledTextInput
            ref={contactPersonRef}
            label="Ng∆∞·ªùi li√™n h·ªá"
            value={formData.contactPerson}
            onChangeText={(text) => handleChange('contactPerson', text)}
            placeholder="Nh·∫≠p t√™n ng∆∞·ªùi li√™n h·ªá"
            required={true}
            returnKeyType="next"
            blurOnSubmit={false}
            onSubmitEditing={() => phoneRef.current.focus()}
          />

          <StyledTextInput
            ref={phoneRef}
            label="S·ªë ƒëi·ªán tho·∫°i"
            value={formData.phone}
            onChangeText={(text) => handleChange('phone', text)}
            placeholder="Nh·∫≠p s·ªë ƒëi·ªán tho·∫°i"
            keyboardType="phone-pad"
            returnKeyType="next"
            blurOnSubmit={false}
            onSubmitEditing={() => emailRef.current.focus()}
          />

          <StyledTextInput
            ref={emailRef}
            label="Email"
            value={formData.email}
            onChangeText={(text) => handleChange('email', text)}
            placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ email"
            keyboardType="email-address"
            autoCapitalize="none"
            returnKeyType="next"
            blurOnSubmit={false}
            onSubmitEditing={() => addressRef.current.focus()}
          />

          <StyledTextInput
            ref={addressRef}
            label="ƒê·ªãa ch·ªâ"
            value={formData.address}
            onChangeText={(text) => handleChange('address', text)}
            placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ"
            multiline
            numberOfLines={3}
            inputStyle={styles.textArea}
            returnKeyType="next"
            blurOnSubmit={false}
            onSubmitEditing={() => taxCodeRef.current.focus()}
          />

          <StyledTextInput
            ref={taxCodeRef}
            label="M√£ s·ªë thu·∫ø"
            value={formData.taxCode}
            onChangeText={(text) => handleChange('taxCode', text)}
            placeholder="Nh·∫≠p m√£ s·ªë thu·∫ø"
            returnKeyType="done"
          />

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Lo·∫°i kh√°ch h√†ng</Text>
            <View style={styles.typeButtonsContainer}>
              <TouchableOpacity
                style={[
                  styles.typeButton,
                  formData.type === 'potential' && styles.selectedTypeButton,
                ]}
                onPress={() => handleSelectType('potential')}
              >
                <Text
                  style={[
                    styles.typeButtonText,
                    formData.type === 'potential' &&
                      styles.selectedTypeButtonText,
                  ]}
                >
                  Ti·ªÅm nƒÉng
                </Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.typeButton,
                  formData.type === 'regular' && styles.selectedTypeButton,
                ]}
                onPress={() => handleSelectType('regular')}
              >
                <Text
                  style={[
                    styles.typeButtonText,
                    formData.type === 'regular' &&
                      styles.selectedTypeButtonText,
                  ]}
                >
                  Th∆∞·ªùng xuy√™n
                </Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.typeButton,
                  formData.type === 'vip' && styles.selectedTypeButton,
                ]}
                onPress={() => handleSelectType('vip')}
              >
                <Text
                  style={[
                    styles.typeButtonText,
                    formData.type === 'vip' && styles.selectedTypeButtonText,
                  ]}
                >
                  VIP
                </Text>
              </TouchableOpacity>
            </View>
          </View>

          <TouchableOpacity
            style={styles.saveButton}
            onPress={handleSave}
            disabled={isLoading}
          >
            {isLoading ? (
              <ActivityIndicator color="#fff" size="small" />
            ) : (
              <>
                <Ionicons
                  name="save-outline"
                  size={20}
                  color="#fff"
                  style={styles.saveIcon}
                />
                <Text style={styles.saveButtonText}>L∆∞u kh√°ch h√†ng</Text>
              </>
            )}
          </TouchableOpacity>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  placeholder: {
    width: 24,
  },
  formContainer: {
    flex: 1,
  },
  formContent: {
    padding: 16,
  },
  inputGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    marginBottom: 6,
  },
  required: {
    color: '#e74c3c',
  },
  textArea: {
    height: 100,
    textAlignVertical: 'top',
    paddingTop: 12,
  },
  typeButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  typeButton: {
    flex: 1,
    backgroundColor: '#f0f0f0',
    paddingVertical: 12,
    paddingHorizontal: 8,
    borderRadius: 6,
    alignItems: 'center',
    marginHorizontal: 4,
  },
  selectedTypeButton: {
    backgroundColor: '#0066cc',
  },
  typeButtonText: {
    color: '#333',
    fontWeight: '500',
  },
  selectedTypeButtonText: {
    color: '#fff',
  },
  saveButton: {
    backgroundColor: '#0066cc',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    borderRadius: 8,
    marginTop: 20,
    marginBottom: 30,
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  saveIcon: {
    marginRight: 8,
  },
});

export default AddCustomerScreen;


--- END: src\screens\AddCustomerScreen.js ---


--- START: src\screens\AddInventoryItemScreen.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  Image,
  Alert,
  Platform,
} from 'react-native';
import {
  TextInput,
  Button,
  Text,
  Appbar,
  HelperText,
  Divider,
  Dialog,
  Portal,
  List,
} from 'react-native-paper';
import { useNavigation } from '@react-navigation/native';
import * as ImagePicker from 'expo-image-picker';

import { firebase } from '../config/firebaseConfig';
import useInventory from '../hooks/useInventory';

const AddInventoryItemScreen = () => {
  const navigation = useNavigation();
  const { addInventoryItem } = useInventory();

  // State cho form th√™m v·∫≠t t∆∞
  const [formData, setFormData] = useState({
    name: '',
    code: '',
    description: '',
    categoryId: '',
    unit: '',
    stockQuantity: 0,
    minQuantity: 0,
    price: 0,
    weight: 0,
    material: '',
    totalPrice: 0,
    imageBase64: '', // Th√™m field ƒë·ªÉ l∆∞u ·∫£nh base64
  });
  const [image, setImage] = useState(null);
  const [uploadingImage, setUploadingImage] = useState(false); // Thay ƒë·ªïi t·ª´ imageBlob sang uploadingImage
  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState({});
  const [categories, setCategories] = useState([]);
  const [selectedCategory, setSelectedCategory] = useState(null);
  const [categoryDialogVisible, setCategoryDialogVisible] = useState(false);
  const [units] = useState([
    'c√°i',
    'b·ªô',
    't·∫•m',
    'kg',
    'm√©t',
    'm2',
    'cu·ªôn',
    'l√≠t',
    'lon',
  ]);
  const [unitDialogVisible, setUnitDialogVisible] = useState(false);

  // Load danh s√°ch danh m·ª•c khi m√†n h√¨nh ƒë∆∞·ª£c mount
  useEffect(() => {
    console.log('=== USEEFFECT: MOUNT SCREEN ===');
    fetchCategories();
    requestPermissions();
  }, []);

  // H√†m l·∫•y danh s√°ch danh m·ª•c t·ª´ Firestore
  const fetchCategories = async () => {
    try {
      console.log('=== FETCHCATEGORIES: B·∫ÆT ƒê·∫¶U ===');
      const snapshot = await firebase
        .firestore()
        .collection('inventory_categories')
        .get();

      const fetchedCategories = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));

      console.log('=== FETCHCATEGORIES: K·∫æT QU·∫¢ ===');
      console.log('S·ªë l∆∞·ª£ng categories:', fetchedCategories.length);
      console.log('Categories:', JSON.stringify(fetchedCategories, null, 2));

      setCategories(fetchedCategories);
    } catch (error) {
      console.error('=== FETCHCATEGORIES: L·ªñI ===');
      console.error('L·ªói khi l·∫•y danh m·ª•c:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ l·∫•y danh s√°ch danh m·ª•c');
    }
  };

  // Y√™u c·∫ßu quy·ªÅn truy c·∫≠p camera v√† th∆∞ vi·ªán ·∫£nh
  const requestPermissions = async () => {
    if (Platform.OS !== 'web') {
      const { status: cameraStatus } =
        await ImagePicker.requestCameraPermissionsAsync();
      const { status: libraryStatus } =
        await ImagePicker.requestMediaLibraryPermissionsAsync();

      if (cameraStatus !== 'granted' || libraryStatus !== 'granted') {
        Alert.alert(
          'C·∫ßn quy·ªÅn truy c·∫≠p',
          'B·∫°n c·∫ßn c·∫•p quy·ªÅn ƒë·ªÉ s·ª≠ d·ª•ng camera v√† th∆∞ vi·ªán ·∫£nh.'
        );
      }
    }
  };

  // X·ª≠ l√Ω thay ƒë·ªïi gi√° tr·ªã c√°c tr∆∞·ªùng
  const handleChange = (field, value) => {
    console.log(`=== HANDLECHANGE: ${field} ===`);
    console.log('Gi√° tr·ªã m·ªõi:', value);
    console.log('formData hi·ªán t·∫°i:', JSON.stringify(formData, null, 2));

    // X·ª≠ l√Ω cho tr∆∞·ªùng s·ªë
    if (['stockQuantity', 'minQuantity', 'price', 'weight'].includes(field)) {
      const numericValue = parseFloat(value.replace(/[^0-9.]/g, ''));
      const updatedValue = isNaN(numericValue) ? 0 : numericValue;

      const updatedFormData = {
        ...formData,
        [field]: updatedValue,
      };

      // T√≠nh to√°n l·∫°i gi√° tr·ªã totalPrice n·∫øu thay ƒë·ªïi s·ªë l∆∞·ª£ng ho·∫∑c ƒë∆°n gi√°
      if (field === 'stockQuantity' || field === 'price') {
        updatedFormData.totalPrice =
          updatedFormData.stockQuantity * updatedFormData.price;
      }

      console.log(
        'formData sau khi c·∫≠p nh·∫≠t:',
        JSON.stringify(updatedFormData, null, 2)
      );
      setFormData(updatedFormData);
    } else {
      const updatedFormData = {
        ...formData,
        [field]: value,
      };

      console.log(
        'formData sau khi c·∫≠p nh·∫≠t:',
        JSON.stringify(updatedFormData, null, 2)
      );
      setFormData(updatedFormData);
    }

    // X√≥a l·ªói khi ng∆∞·ªùi d√πng ƒëi·ªÅn l·∫°i
    if (errors[field]) {
      setErrors({
        ...errors,
        [field]: null,
      });
    }
  };

  // Ch·ªçn danh m·ª•c
  const handleCategorySelect = (category) => {
    console.log('=== HANDLECATEGORYSELECT ===');
    console.log('Category ƒë∆∞·ª£c ch·ªçn:', JSON.stringify(category, null, 2));
    console.log(
      'formData tr∆∞·ªõc khi c·∫≠p nh·∫≠t:',
      JSON.stringify(formData, null, 2)
    );

    setSelectedCategory(category);
    const updatedFormData = {
      ...formData,
      categoryId: category.id,
    };

    console.log(
      'formData sau khi c·∫≠p nh·∫≠t categoryId:',
      JSON.stringify(updatedFormData, null, 2)
    );
    setFormData(updatedFormData);
    setCategoryDialogVisible(false);

    // X√≥a l·ªói danh m·ª•c n·∫øu c√≥
    if (errors.categoryId) {
      setErrors({
        ...errors,
        categoryId: null,
      });
    }
  };

  // Ch·ªçn ƒë∆°n v·ªã t√≠nh
  const handleUnitSelect = (unit) => {
    console.log('=== HANDLEUNITSELECT ===');
    console.log('Unit ƒë∆∞·ª£c ch·ªçn:', unit);
    console.log(
      'formData tr∆∞·ªõc khi c·∫≠p nh·∫≠t:',
      JSON.stringify(formData, null, 2)
    );

    const updatedFormData = {
      ...formData,
      unit,
    };

    console.log(
      'formData sau khi c·∫≠p nh·∫≠t unit:',
      JSON.stringify(updatedFormData, null, 2)
    );
    setFormData(updatedFormData);
    setUnitDialogVisible(false);

    // X√≥a l·ªói ƒë∆°n v·ªã n·∫øu c√≥
    if (errors.unit) {
      setErrors({
        ...errors,
        unit: null,
      });
    }
  };

  // Ch·ªçn ·∫£nh t·ª´ th∆∞ vi·ªán
  const pickImage = async () => {
    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        aspect: [4, 3],
        quality: 0.7,
        base64: true, // B·∫≠t base64 ƒë·ªÉ l·∫•y d·ªØ li·ªáu tr·ª±c ti·∫øp
      });

      if (!result.canceled && result.assets && result.assets[0]) {
        const asset = result.assets[0];
        const imageUri = asset.uri;
        setImage(imageUri);

        // L·∫•y base64 data tr·ª±c ti·∫øp t·ª´ ImagePicker
        if (asset.base64) {
          setUploadingImage(true);
          try {
            // T·∫°o data URL v·ªõi MIME type ph√π h·ª£p
            const fileExtension = imageUri.split('.').pop() || 'jpg';
            const mimeType = `image/${fileExtension}`;
            const dataURL = `data:${mimeType};base64,${asset.base64}`;

            setFormData((prev) => ({
              ...prev,
              imageBase64: dataURL,
            }));

            console.log('Base64 image saved successfully');
          } finally {
            setUploadingImage(false);
          }
        } else {
          Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu ·∫£nh');
        }
      }
    } catch (error) {
      console.error('L·ªói khi ch·ªçn ·∫£nh:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ch·ªçn ·∫£nh');
    }
  };

  // Ch·ª•p ·∫£nh t·ª´ camera
  const takePhoto = async () => {
    try {
      const result = await ImagePicker.launchCameraAsync({
        allowsEditing: true,
        aspect: [4, 3],
        quality: 0.7,
        base64: true, // B·∫≠t base64 ƒë·ªÉ l·∫•y d·ªØ li·ªáu tr·ª±c ti·∫øp
      });

      if (!result.canceled && result.assets && result.assets[0]) {
        const asset = result.assets[0];
        const imageUri = asset.uri;
        setImage(imageUri);

        // L·∫•y base64 data tr·ª±c ti·∫øp t·ª´ ImagePicker
        if (asset.base64) {
          setUploadingImage(true);
          try {
            // T·∫°o data URL v·ªõi MIME type ph√π h·ª£p
            const fileExtension = imageUri.split('.').pop() || 'jpg';
            const mimeType = `image/${fileExtension}`;
            const dataURL = `data:${mimeType};base64,${asset.base64}`;

            setFormData((prev) => ({
              ...prev,
              imageBase64: dataURL,
            }));

            console.log('Base64 image saved successfully');
          } finally {
            setUploadingImage(false);
          }
        } else {
          Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu ·∫£nh');
        }
      }
    } catch (error) {
      console.error('L·ªói khi ch·ª•p ·∫£nh:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ch·ª•p ·∫£nh');
    }
  };

  // Ki·ªÉm tra form tr∆∞·ªõc khi l∆∞u
  const validateForm = () => {
    console.log('=== VALIDATEFORM ===');
    console.log('formData ƒë·ªÉ validate:', JSON.stringify(formData, null, 2));

    const newErrors = {};

    if (!formData.name.trim()) {
      newErrors.name = 'Vui l√≤ng nh·∫≠p t√™n v·∫≠t t∆∞';
      console.log('L·ªói: Thi·∫øu t√™n v·∫≠t t∆∞');
    }

    if (!formData.code.trim()) {
      newErrors.code = 'Vui l√≤ng nh·∫≠p m√£ v·∫≠t t∆∞';
      console.log('L·ªói: Thi·∫øu m√£ v·∫≠t t∆∞');
    }

    if (!formData.categoryId) {
      newErrors.categoryId = 'Vui l√≤ng ch·ªçn danh m·ª•c';
      console.log('L·ªói: Thi·∫øu categoryId');
    }

    if (!formData.unit.trim()) {
      newErrors.unit = 'Vui l√≤ng ch·ªçn ƒë∆°n v·ªã t√≠nh';
      console.log('L·ªói: Thi·∫øu ƒë∆°n v·ªã t√≠nh');
    }

    console.log('C√°c l·ªói validation:', newErrors);
    console.log('K·∫øt qu·∫£ validation:', Object.keys(newErrors).length === 0);

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // L∆∞u v·∫≠t t∆∞ m·ªõi
  const handleSave = async () => {
    if (!validateForm()) return;

    setLoading(true);

    try {
      // Log d·ªØ li·ªáu tr∆∞·ªõc khi g·ª≠i
      console.log('=== D·ªÆ LI·ªÜU V·∫¨T T∆Ø TR∆Ø·ªöC KHI G·ª¨I ===');
      console.log('formData:', JSON.stringify(formData, null, 2));
      console.log('selectedCategory:', selectedCategory);
      console.log('=== END D·ªÆ LI·ªÜU ===');

      // Ki·ªÉm tra d·ªØ li·ªáu b·∫Øt bu·ªôc
      if (
        !formData.name ||
        !formData.code ||
        !formData.categoryId ||
        !formData.unit
      ) {
        const missingFields = [];
        if (!formData.name) missingFields.push('T√™n v·∫≠t t∆∞');
        if (!formData.code) missingFields.push('M√£ v·∫≠t t∆∞');
        if (!formData.categoryId) missingFields.push('Danh m·ª•c');
        if (!formData.unit) missingFields.push('ƒê∆°n v·ªã t√≠nh');

        throw new Error(
          `Thi·∫øu th√¥ng tin b·∫Øt bu·ªôc: ${missingFields.join(', ')}`
        );
      }

      // Th√™m v·∫≠t t∆∞ m·ªõi s·ª≠ d·ª•ng useInventory hook ƒë·ªÉ ƒë·∫£m b·∫£o refresh
      // ·∫¢nh ƒë√£ ƒë∆∞·ª£c l∆∞u tr·ª±c ti·∫øp v√†o formData.imageBase64, kh√¥ng c·∫ßn upload ri√™ng
      console.log('B·∫Øt ƒë·∫ßu g·ªçi addInventoryItem...');
      const result = await addInventoryItem(formData);
      console.log('K·∫øt qu·∫£ addInventoryItem:', result);

      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ th√™m v·∫≠t t∆∞ m·ªõi v√†o kho', [
        { text: 'OK', onPress: () => navigation.goBack() },
      ]);
    } catch (error) {
      console.error('=== L·ªñI CHI TI·∫æT KHI L∆ØU V·∫¨T T∆Ø ===');
      console.error('Error object:', error);
      console.error('Error message:', error.message);
      console.error('Error code:', error.code);
      console.error('Error details:', error.details);
      console.error('=== END L·ªñI CHI TI·∫æT ===');

      let errorMessage = 'Kh√¥ng th·ªÉ l∆∞u v·∫≠t t∆∞';

      if (error.code === 'unauthenticated') {
        errorMessage = 'B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ th·ª±c hi·ªán ch·ª©c nƒÉng n√†y';
      } else if (error.code === 'invalid-argument') {
        errorMessage = error.message || 'D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá';
      } else if (error.code === 'already-exists') {
        errorMessage = error.message || 'M√£ v·∫≠t t∆∞ ƒë√£ t·ªìn t·∫°i';
      } else if (error.message) {
        errorMessage = error.message;
      }

      Alert.alert('L·ªói', errorMessage);
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={styles.container}>
      {/* ƒê√£ x√≥a header th·ª© 2 - ch·ªâ gi·ªØ l·∫°i n·ªôi dung form */}

      <ScrollView style={styles.scrollView}>
        {/* Th√¥ng tin c∆° b·∫£n */}
        <Text style={styles.sectionTitle}>Th√¥ng tin c∆° b·∫£n</Text>

        <TextInput
          label="T√™n v·∫≠t t∆∞ *"
          value={formData.name}
          onChangeText={(text) => handleChange('name', text)}
          style={styles.input}
          error={!!errors.name}
        />
        {errors.name && <HelperText type="error">{errors.name}</HelperText>}

        <TextInput
          label="M√£ v·∫≠t t∆∞ *"
          value={formData.code}
          onChangeText={(text) => handleChange('code', text)}
          style={styles.input}
          error={!!errors.code}
        />
        {errors.code && <HelperText type="error">{errors.code}</HelperText>}

        <TouchableOpacity
          onPress={() => setCategoryDialogVisible(true)}
          style={styles.input}
        >
          <TextInput
            label="Danh m·ª•c *"
            value={selectedCategory ? selectedCategory.name : ''}
            editable={false}
            right={<TextInput.Icon icon="menu-down" />}
            error={!!errors.categoryId}
          />
        </TouchableOpacity>
        {errors.categoryId && (
          <HelperText type="error">{errors.categoryId}</HelperText>
        )}

        <TouchableOpacity
          onPress={() => setUnitDialogVisible(true)}
          style={styles.input}
        >
          <TextInput
            label="ƒê∆°n v·ªã t√≠nh *"
            value={formData.unit}
            editable={false}
            right={<TextInput.Icon icon="menu-down" />}
            error={!!errors.unit}
          />
        </TouchableOpacity>
        {errors.unit && <HelperText type="error">{errors.unit}</HelperText>}

        <TextInput
          label="M√¥ t·∫£"
          value={formData.description}
          onChangeText={(text) => handleChange('description', text)}
          multiline
          numberOfLines={3}
          style={styles.input}
        />

        <Divider style={styles.divider} />

        {/* Th√¥ng tin s·ªë l∆∞·ª£ng v√† ƒë∆°n gi√° */}
        <Text style={styles.sectionTitle}>Th√¥ng tin s·ªë l∆∞·ª£ng v√† ƒë∆°n gi√°</Text>

        <TextInput
          label="S·ªë l∆∞·ª£ng ban ƒë·∫ßu"
          value={formData.stockQuantity.toString()}
          onChangeText={(text) => handleChange('stockQuantity', text)}
          keyboardType="numeric"
          style={styles.input}
        />

        <TextInput
          label="S·ªë l∆∞·ª£ng t·ªìn t·ªëi thi·ªÉu"
          value={formData.minQuantity.toString()}
          onChangeText={(text) => handleChange('minQuantity', text)}
          keyboardType="numeric"
          style={styles.input}
        />

        <TextInput
          label={`ƒê∆°n gi√° (VNƒê/${formData.unit || 'ƒë∆°n v·ªã'})`}
          value={formData.price.toString()}
          onChangeText={(text) => handleChange('price', text)}
          keyboardType="numeric"
          style={styles.input}
        />

        <View style={styles.totalPriceContainer}>
          <Text style={styles.totalPriceLabel}>T·ªïng gi√° tr·ªã:</Text>
          <Text style={styles.totalPriceValue}>
            {(formData.totalPrice || 0).toLocaleString('vi-VN')} VNƒê
          </Text>
        </View>

        <Divider style={styles.divider} />

        {/* Th√¥ng tin b·ªï sung */}
        <Text style={styles.sectionTitle}>Th√¥ng tin b·ªï sung</Text>

        <TextInput
          label="V·∫≠t li·ªáu"
          value={formData.material}
          onChangeText={(text) => handleChange('material', text)}
          style={styles.input}
        />

        <TextInput
          label="Kh·ªëi l∆∞·ª£ng (kg)"
          value={formData.weight.toString()}
          onChangeText={(text) => handleChange('weight', text)}
          keyboardType="numeric"
          style={styles.input}
        />

        {/* Ph·∫ßn upload h√¨nh ·∫£nh */}
        <Text style={styles.sectionTitle}>H√¨nh ·∫£nh v·∫≠t t∆∞</Text>

        <View style={styles.imageContainer}>
          {formData.imageBase64 ? (
            <Image
              source={{ uri: formData.imageBase64 }}
              style={styles.image}
            />
          ) : (
            <View style={styles.imagePlaceholder}>
              <Text style={styles.placeholderText}>Ch∆∞a c√≥ ·∫£nh</Text>
            </View>
          )}

          <View style={styles.imageButtons}>
            <Button
              mode="contained"
              onPress={pickImage}
              style={styles.imageButton}
              loading={uploadingImage}
              disabled={uploadingImage}
            >
              Ch·ªçn ·∫£nh
            </Button>
            <Button
              mode="outlined"
              onPress={takePhoto}
              style={styles.imageButton}
              loading={uploadingImage}
              disabled={uploadingImage}
            >
              Ch·ª•p ·∫£nh
            </Button>
          </View>
        </View>

        {/* N√∫t l∆∞u */}
        <Button
          mode="contained"
          onPress={handleSave}
          style={styles.saveButton}
          loading={loading}
          disabled={loading}
        >
          L∆∞u v·∫≠t t∆∞
        </Button>
      </ScrollView>

      {/* Dialog ch·ªçn danh m·ª•c */}
      <Portal>
        <Dialog
          visible={categoryDialogVisible}
          onDismiss={() => setCategoryDialogVisible(false)}
        >
          <Dialog.Title>Ch·ªçn danh m·ª•c</Dialog.Title>
          <Dialog.Content>
            <ScrollView style={{ maxHeight: 300 }}>
              {categories.map((category) => (
                <List.Item
                  key={category.id}
                  title={category.name}
                  description={category.description}
                  onPress={() => handleCategorySelect(category)}
                />
              ))}
            </ScrollView>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setCategoryDialogVisible(false)}>
              ƒê√≥ng
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* Dialog ch·ªçn ƒë∆°n v·ªã t√≠nh */}
      <Portal>
        <Dialog
          visible={unitDialogVisible}
          onDismiss={() => setUnitDialogVisible(false)}
        >
          <Dialog.Title>Ch·ªçn ƒë∆°n v·ªã t√≠nh</Dialog.Title>
          <Dialog.Content>
            <ScrollView style={{ maxHeight: 300 }}>
              {units.map((unit) => (
                <List.Item
                  key={unit}
                  title={unit}
                  onPress={() => handleUnitSelect(unit)}
                />
              ))}
            </ScrollView>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setUnitDialogVisible(false)}>ƒê√≥ng</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollView: {
    flex: 1,
    padding: 16,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginVertical: 12,
  },
  input: {
    marginBottom: 8,
    backgroundColor: 'white',
  },
  divider: {
    marginVertical: 16,
  },
  imageContainer: {
    marginVertical: 10,
    alignItems: 'center',
  },
  image: {
    width: '100%',
    height: 200,
    borderRadius: 8,
    marginBottom: 10,
  },
  imagePlaceholder: {
    width: '100%',
    height: 200,
    borderRadius: 8,
    backgroundColor: '#e0e0e0',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 10,
  },
  placeholderText: {
    color: '#757575',
  },
  imageButtons: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    width: '100%',
  },
  imageButton: {
    flex: 1,
    marginHorizontal: 5,
  },
  saveButton: {
    marginVertical: 24,
    paddingVertical: 6,
    backgroundColor: '#3f51b5',
  },
  totalPriceContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    backgroundColor: '#f0f0f0',
    borderRadius: 8,
    marginBottom: 16,
  },
  totalPriceLabel: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  totalPriceValue: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#3f51b5',
  },
});

export default AddInventoryItemScreen;


--- END: src\screens\AddInventoryItemScreen.js ---


--- START: src\screens\AddProjectScreen.js ---
//src/screens/AddProjectScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
  Modal,
  FlatList,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import DateTimePicker from '@react-native-community/datetimepicker';
import { createProject } from '../api/projectService';
import { getCustomers } from '../api/customerService';
import { useAuth } from '../contexts/AuthContext';
import { functions } from '../config/firebaseConfig';
import { httpsCallable } from 'firebase/functions';

const AddProjectScreen = ({ navigation }) => {
  const { currentUser } = useAuth();
  const [isLoading, setIsLoading] = useState(false);
  const [customers, setCustomers] = useState([]);
  const [loadingCustomers, setLoadingCustomers] = useState(true);
  const [customerModalVisible, setCustomerModalVisible] = useState(false);
  const [customerSearchQuery, setCustomerSearchQuery] = useState('');
  const [filteredCustomers, setFilteredCustomers] = useState([]);

  // Th√™m state cho date picker
  const [showStartDatePicker, setShowStartDatePicker] = useState(false);
  const [showEndDatePicker, setShowEndDatePicker] = useState(false);

  const [formData, setFormData] = useState({
    name: '',
    description: '',
    customerId: '',
    customerName: '',
    status: 'pending',
    startDate: null,
    endDate: null,
    durationInDays: '',
    location: 'workshop', // 'workshop' (t·∫°i x∆∞·ªüng) ho·∫∑c 'site' (t·∫°i c√¥ng tr√¨nh)
    budget: '',
    notes: '',
  });

  // L·∫•y danh s√°ch kh√°ch h√†ng khi m√†n h√¨nh ƒë∆∞·ª£c t·∫£i
  useEffect(() => {
    const fetchCustomers = async () => {
      try {
        setLoadingCustomers(true);
        const data = await getCustomers();
        setCustomers(data);
        setFilteredCustomers(data);
      } catch (error) {
        console.error('L·ªói khi l·∫•y danh s√°ch kh√°ch h√†ng:', error);
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch kh√°ch h√†ng');
      } finally {
        setLoadingCustomers(false);
      }
    };

    fetchCustomers();
  }, []);

  // L·ªçc danh s√°ch kh√°ch h√†ng khi t·ª´ kh√≥a t√¨m ki·∫øm thay ƒë·ªïi
  useEffect(() => {
    if (!customerSearchQuery.trim()) {
      setFilteredCustomers(customers);
      return;
    }

    const query = customerSearchQuery.toLowerCase().trim();
    const filtered = customers.filter((customer) => {
      const name = (customer.name || '').toLowerCase();
      const contact = (customer.contactPerson || '').toLowerCase();
      const email = (customer.email || '').toLowerCase();

      return (
        name.includes(query) || contact.includes(query) || email.includes(query)
      );
    });

    setFilteredCustomers(filtered);
  }, [customerSearchQuery, customers]);

  // C·∫≠p nh·∫≠t gi√° tr·ªã form
  const handleChange = (field, value) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));
  };

  // X·ª≠ l√Ω khi ch·ªçn ng√†y b·∫Øt ƒë·∫ßu
  const handleStartDateChange = (event, selectedDate) => {
    setShowStartDatePicker(false);
    if (selectedDate) {
      handleChange('startDate', selectedDate);

      // T·ª± ƒë·ªông t√≠nh ng√†y k·∫øt th√∫c n·∫øu c√≥ s·ªë ng√†y thi c√¥ng
      if (formData.durationInDays) {
        const endDate = new Date(selectedDate);
        endDate.setDate(endDate.getDate() + Number(formData.durationInDays));
        handleChange('endDate', endDate);
      }
    }
  };

  // X·ª≠ l√Ω khi nh·∫≠p s·ªë ng√†y thi c√¥ng
  const handleDurationChange = (text) => {
    handleChange('durationInDays', text);

    // T·ª± ƒë·ªông t√≠nh ng√†y k·∫øt th√∫c n·∫øu c√≥ ng√†y b·∫Øt ƒë·∫ßu
    if (formData.startDate && text) {
      const endDate = new Date(formData.startDate);
      endDate.setDate(endDate.getDate() + Number(text));
      handleChange('endDate', endDate);
    }
  };

  // X·ª≠ l√Ω khi ch·ªçn v·ªã tr√≠
  const handleLocationChange = (location) => {
    handleChange('location', location);
  };

  // ƒê·ªãnh d·∫°ng ng√†y ƒë·ªÉ hi·ªÉn th·ªã
  const formatDate = (date) => {
    if (!date) return '';
    return date.toLocaleDateString('vi-VN');
  };

  // Ki·ªÉm tra form h·ª£p l·ªá
  const validateForm = () => {
    if (!formData.name.trim()) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p t√™n d·ª± √°n');
      return false;
    }

    return true;
  };

  // X·ª≠ l√Ω l∆∞u d·ª± √°n
  const handleSave = async () => {
    if (!validateForm()) {
      return;
    }

    setIsLoading(true);

    try {
      // Chu·∫©n b·ªã d·ªØ li·ªáu ƒë·ªÉ l∆∞u
      const projectData = {
        ...formData,
        budget: formData.budget ? Number(formData.budget) : null,
        durationInDays: formData.durationInDays
          ? Number(formData.durationInDays)
          : null,
      };

      // G·ªçi API t·∫°o d·ª± √°n m·ªõi
      const projectId = await createProject(projectData, currentUser?.uid);

      // Sau khi t·∫°o d·ª± √°n th√†nh c√¥ng, g·ªçi h√†m t·∫°o folder
      if (projectId) {
        try {
          const createFoldersFn = httpsCallable(
            functions,
            'createProjectFolders'
          );
          await createFoldersFn({ projectId });
        } catch (folderError) {
          // Log l·ªói nh∆∞ng kh√¥ng ch·∫∑n ng∆∞·ªùi d√πng
          console.error('L·ªói khi t·∫°o th∆∞ m·ª•c d·ª± √°n tr√™n Drive:', folderError);
          Alert.alert(
            'T·∫°o d·ª± √°n th√†nh c√¥ng',
            'D·ª± √°n ƒë√£ ƒë∆∞·ª£c t·∫°o, nh∆∞ng c√≥ l·ªói x·∫£y ra khi t·∫°o th∆∞ m·ª•c tr√™n Google Drive. B·∫°n c√≥ th·ªÉ th·ª≠ l·∫°i sau.'
          );
        }
      }

      Alert.alert(
        'Th√†nh c√¥ng',
        'ƒê√£ th√™m d·ª± √°n m·ªõi v√† t·∫°o th∆∞ m·ª•c th√†nh c√¥ng!',
        [
          {
            text: 'OK',
            onPress: () => navigation.goBack(),
          },
        ]
      );
    } catch (error) {
      if (error.code === 'permission-denied') {
        Alert.alert(
          'L·ªói quy·ªÅn',
          'B·∫°n kh√¥ng c√≥ ƒë·ªß quy·ªÅn ƒë·ªÉ th·ª±c hi·ªán h√†nh ƒë·ªông n√†y.'
        );
      } else {
        console.error('L·ªói khi th√™m d·ª± √°n:', error);
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ th√™m d·ª± √°n. Vui l√≤ng th·ª≠ l·∫°i sau.');
      }
    } finally {
      setIsLoading(false);
    }
  };

  // X·ª≠ l√Ω thay ƒë·ªïi tr·∫°ng th√°i d·ª± √°n
  const handleSelectStatus = (status) => {
    handleChange('status', status);
  };

  // X·ª≠ l√Ω m·ªü modal ch·ªçn kh√°ch h√†ng
  const handleOpenCustomerModal = () => {
    setCustomerModalVisible(true);
  };

  // X·ª≠ l√Ω ƒë√≥ng modal ch·ªçn kh√°ch h√†ng
  const handleCloseCustomerModal = () => {
    setCustomerModalVisible(false);
    setCustomerSearchQuery('');
  };

  // X·ª≠ l√Ω khi ch·ªçn kh√°ch h√†ng
  const handleSelectCustomer = (customer) => {
    setFormData((prev) => ({
      ...prev,
      customerId: customer.id,
      customerName: customer.name,
    }));
    handleCloseCustomerModal();
  };

  // X·ª≠ l√Ω khi t√¨m ki·∫øm kh√°ch h√†ng
  const handleSearchCustomer = (text) => {
    setCustomerSearchQuery(text);
  };

  // X·ª≠ l√Ω khi x√≥a kh√°ch h√†ng ƒë√£ ch·ªçn
  const handleClearCustomer = () => {
    setFormData((prev) => ({
      ...prev,
      customerId: '',
      customerName: '',
    }));
  };

  // Render m·ªôt item trong danh s√°ch kh√°ch h√†ng
  const renderCustomerItem = ({ item }) => (
    <TouchableOpacity
      style={styles.customerItem}
      onPress={() => handleSelectCustomer(item)}
    >
      <View>
        <Text style={styles.customerName}>{item.name}</Text>
        {item.contactPerson && (
          <Text style={styles.customerDetail}>
            Ng∆∞·ªùi li√™n h·ªá: {item.contactPerson}
          </Text>
        )}
        {item.email && (
          <Text style={styles.customerDetail}>Email: {item.email}</Text>
        )}
      </View>
      <Ionicons name="chevron-forward" size={20} color="#999" />
    </TouchableOpacity>
  );

  return (
    <KeyboardAvoidingView
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      style={styles.container}
    >
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Th√™m d·ª± √°n m·ªõi</Text>
        <View style={styles.placeholder} />
      </View>

      <ScrollView
        style={styles.formContainer}
        contentContainerStyle={styles.formContent}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.inputGroup}>
          <Text style={styles.label}>
            T√™n d·ª± √°n <Text style={styles.required}>*</Text>
          </Text>
          <TextInput
            style={styles.input}
            value={formData.name}
            onChangeText={(text) => handleChange('name', text)}
            placeholder="Nh·∫≠p t√™n d·ª± √°n"
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>M√¥ t·∫£</Text>
          <TextInput
            style={[styles.input, styles.textArea]}
            value={formData.description}
            onChangeText={(text) => handleChange('description', text)}
            placeholder="Nh·∫≠p m√¥ t·∫£ d·ª± √°n"
            multiline
            numberOfLines={3}
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>Kh√°ch h√†ng</Text>
          {formData.customerName ? (
            <View style={styles.selectedCustomerContainer}>
              <View style={styles.selectedCustomer}>
                <Ionicons name="business-outline" size={20} color="#0066cc" />
                <Text style={styles.selectedCustomerText}>
                  {formData.customerName}
                </Text>
              </View>
              <TouchableOpacity
                style={styles.clearCustomerButton}
                onPress={handleClearCustomer}
              >
                <Ionicons name="close-circle" size={20} color="#999" />
              </TouchableOpacity>
            </View>
          ) : (
            <TouchableOpacity
              style={styles.customerSelectButton}
              onPress={handleOpenCustomerModal}
            >
              <Ionicons name="add-circle-outline" size={20} color="#0066cc" />
              <Text style={styles.customerSelectButtonText}>
                Ch·ªçn kh√°ch h√†ng
              </Text>
            </TouchableOpacity>
          )}
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>Tr·∫°ng th√°i</Text>
          <View style={styles.statusButtonsContainer}>
            <TouchableOpacity
              style={[
                styles.statusButton,
                formData.status === 'pending' && styles.selectedStatusButton,
              ]}
              onPress={() => handleSelectStatus('pending')}
            >
              <Text
                style={[
                  styles.statusButtonText,
                  formData.status === 'pending' &&
                    styles.selectedStatusButtonText,
                ]}
              >
                Ch·ªù x·ª≠ l√Ω
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.statusButton,
                formData.status === 'in-progress' &&
                  styles.selectedStatusButton,
              ]}
              onPress={() => handleSelectStatus('in-progress')}
            >
              <Text
                style={[
                  styles.statusButtonText,
                  formData.status === 'in-progress' &&
                    styles.selectedStatusButtonText,
                ]}
              >
                ƒêang th·ª±c hi·ªán
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.statusButton,
                formData.status === 'completed' && styles.selectedStatusButton,
              ]}
              onPress={() => handleSelectStatus('completed')}
            >
              <Text
                style={[
                  styles.statusButtonText,
                  formData.status === 'completed' &&
                    styles.selectedStatusButtonText,
                ]}
              >
                Ho√†n th√†nh
              </Text>
            </TouchableOpacity>
          </View>

          <View style={[styles.statusButtonsContainer, { marginTop: 8 }]}>
            <TouchableOpacity
              style={[
                styles.statusButton,
                formData.status === 'cancelled' && styles.selectedStatusButton,
              ]}
              onPress={() => handleSelectStatus('cancelled')}
            >
              <Text
                style={[
                  styles.statusButtonText,
                  formData.status === 'cancelled' &&
                    styles.selectedStatusButtonText,
                ]}
              >
                ƒê√£ h·ªßy
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        {/* Th√™m tr∆∞·ªùng ng√†y b·∫Øt ƒë·∫ßu */}
        <View style={styles.inputGroup}>
          <Text style={styles.label}>Ng√†y b·∫Øt ƒë·∫ßu</Text>
          <TouchableOpacity
            style={styles.dateButton}
            onPress={() => setShowStartDatePicker(true)}
          >
            <Ionicons name="calendar-outline" size={20} color="#0066cc" />
            <Text style={styles.dateButtonText}>
              {formData.startDate
                ? formatDate(formData.startDate)
                : 'Ch·ªçn ng√†y b·∫Øt ƒë·∫ßu'}
            </Text>
          </TouchableOpacity>
          {showStartDatePicker && (
            <DateTimePicker
              value={formData.startDate || new Date()}
              mode="date"
              display="default"
              onChange={handleStartDateChange}
            />
          )}
        </View>

        {/* Th√™m tr∆∞·ªùng s·ªë ng√†y thi c√¥ng */}
        <View style={styles.inputGroup}>
          <Text style={styles.label}>S·ªë ng√†y thi c√¥ng</Text>
          <TextInput
            style={styles.input}
            value={formData.durationInDays}
            onChangeText={handleDurationChange}
            placeholder="Nh·∫≠p s·ªë ng√†y thi c√¥ng"
            keyboardType="numeric"
          />
        </View>

        {/* Hi·ªÉn th·ªã ng√†y k·∫øt th√∫c (ch·ªâ ƒë·ªçc) */}
        <View style={styles.inputGroup}>
          <Text style={styles.label}>Ng√†y k·∫øt th√∫c (t·ª± ƒë·ªông t√≠nh)</Text>
          <View style={styles.readOnlyField}>
            <Ionicons name="calendar-outline" size={20} color="#666" />
            <Text style={styles.readOnlyText}>
              {formData.endDate
                ? formatDate(formData.endDate)
                : 'Ch∆∞a x√°c ƒë·ªãnh'}
            </Text>
          </View>
        </View>

        {/* Th√™m tr∆∞·ªùng v·ªã tr√≠ */}
        <View style={styles.inputGroup}>
          <Text style={styles.label}>V·ªã tr√≠ thi c√¥ng</Text>
          <View style={styles.locationButtonsContainer}>
            <TouchableOpacity
              style={[
                styles.locationButton,
                formData.location === 'workshop' &&
                  styles.selectedLocationButton,
              ]}
              onPress={() => handleLocationChange('workshop')}
            >
              <Text
                style={[
                  styles.locationButtonText,
                  formData.location === 'workshop' &&
                    styles.selectedLocationButtonText,
                ]}
              >
                T·∫°i x∆∞·ªüng
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.locationButton,
                formData.location === 'site' && styles.selectedLocationButton,
              ]}
              onPress={() => handleLocationChange('site')}
            >
              <Text
                style={[
                  styles.locationButtonText,
                  formData.location === 'site' &&
                    styles.selectedLocationButtonText,
                ]}
              >
                T·∫°i c√¥ng tr√¨nh
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>Ng√¢n s√°ch</Text>
          <TextInput
            style={styles.input}
            value={formData.budget}
            onChangeText={(text) => handleChange('budget', text)}
            placeholder="Nh·∫≠p ng√¢n s√°ch d·ª± √°n"
            keyboardType="numeric"
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>Ghi ch√∫</Text>
          <TextInput
            style={[styles.input, styles.textArea]}
            value={formData.notes}
            onChangeText={(text) => handleChange('notes', text)}
            placeholder="Nh·∫≠p ghi ch√∫"
            multiline
            numberOfLines={3}
          />
        </View>
      </ScrollView>

      <View style={styles.footer}>
        <TouchableOpacity
          style={styles.saveButton}
          onPress={handleSave}
          disabled={isLoading}
        >
          {isLoading ? (
            <ActivityIndicator color="#fff" size="small" />
          ) : (
            <>
              <Ionicons name="save-outline" size={20} color="#fff" />
              <Text style={styles.saveButtonText}>L∆∞u d·ª± √°n</Text>
            </>
          )}
        </TouchableOpacity>
      </View>

      {/* Modal ch·ªçn kh√°ch h√†ng */}
      <Modal
        visible={customerModalVisible}
        animationType="slide"
        transparent={true}
        onRequestClose={handleCloseCustomerModal}
      >
        <View style={styles.modalContainer}>
          <View style={styles.modalContent}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Ch·ªçn kh√°ch h√†ng</Text>
              <TouchableOpacity
                style={styles.closeButton}
                onPress={handleCloseCustomerModal}
              >
                <Ionicons name="close" size={24} color="#333" />
              </TouchableOpacity>
            </View>

            <View style={styles.searchContainer}>
              <Ionicons
                name="search"
                size={20}
                color="#999"
                style={styles.searchIcon}
              />
              <TextInput
                style={styles.searchInput}
                placeholder="T√¨m ki·∫øm kh√°ch h√†ng..."
                value={customerSearchQuery}
                onChangeText={handleSearchCustomer}
              />
              {customerSearchQuery.length > 0 && (
                <TouchableOpacity
                  onPress={() => setCustomerSearchQuery('')}
                  style={styles.clearSearchButton}
                >
                  <Ionicons name="close-circle" size={18} color="#999" />
                </TouchableOpacity>
              )}
            </View>

            {loadingCustomers ? (
              <View style={styles.loadingContainer}>
                <ActivityIndicator size="large" color="#0066cc" />
                <Text style={styles.loadingText}>
                  ƒêang t·∫£i danh s√°ch kh√°ch h√†ng...
                </Text>
              </View>
            ) : (
              <FlatList
                data={filteredCustomers}
                keyExtractor={(item) => item.id}
                renderItem={renderCustomerItem}
                contentContainerStyle={styles.customersList}
                ListEmptyComponent={() => (
                  <View style={styles.emptyListContainer}>
                    <Ionicons name="search-outline" size={40} color="#ccc" />
                    <Text style={styles.emptyListText}>
                      Kh√¥ng t√¨m th·∫•y kh√°ch h√†ng ph√π h·ª£p
                    </Text>
                  </View>
                )}
              />
            )}
          </View>
        </View>
      </Modal>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  placeholder: {
    width: 24,
  },
  formContainer: {
    flex: 1,
  },
  formContent: {
    padding: 16,
  },
  inputGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    marginBottom: 6,
    color: '#333',
  },
  required: {
    color: '#e74c3c',
  },
  input: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    color: '#333',
  },
  textArea: {
    minHeight: 80,
    textAlignVertical: 'top',
  },
  statusButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  statusButton: {
    flex: 1,
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 8,
    borderRadius: 8,
    marginHorizontal: 4,
    alignItems: 'center',
  },
  selectedStatusButton: {
    backgroundColor: '#0066cc',
  },
  statusButtonText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '500',
  },
  selectedStatusButtonText: {
    color: '#fff',
  },
  // Th√™m style cho c√°c tr∆∞·ªùng m·ªõi
  dateButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
  },
  dateButtonText: {
    fontSize: 16,
    color: '#333',
    marginLeft: 8,
  },
  locationButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  locationButton: {
    flex: 1,
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 8,
    borderRadius: 8,
    marginHorizontal: 4,
    alignItems: 'center',
  },
  selectedLocationButton: {
    backgroundColor: '#0066cc',
  },
  locationButtonText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '500',
  },
  selectedLocationButtonText: {
    color: '#fff',
  },
  customerSelectButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
  },
  customerSelectButtonText: {
    fontSize: 16,
    color: '#0066cc',
    marginLeft: 8,
  },
  selectedCustomerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
  },
  selectedCustomer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  selectedCustomerText: {
    fontSize: 16,
    color: '#333',
    marginLeft: 8,
  },
  clearCustomerButton: {
    padding: 4,
  },
  footer: {
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  saveButton: {
    backgroundColor: '#0066cc',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    borderRadius: 8,
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  modalContainer: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: '#fff',
    borderTopLeftRadius: 16,
    borderTopRightRadius: 16,
    height: '80%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  closeButton: {
    padding: 4,
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    margin: 16,
    borderRadius: 8,
    paddingHorizontal: 12,
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    height: 40,
    fontSize: 16,
  },
  clearSearchButton: {
    padding: 4,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
  },
  customersList: {
    padding: 16,
    paddingTop: 0,
  },
  customerItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#f9f9f9',
    padding: 12,
    borderRadius: 8,
    marginBottom: 8,
  },
  customerName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 2,
  },
  customerDetail: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  emptyListContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 40,
  },
  emptyListText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  readOnlyField: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
  },
  readOnlyText: {
    fontSize: 16,
    color: '#666',
    marginLeft: 8,
  },
});

export default AddProjectScreen;


--- END: src\screens\AddProjectScreen.js ---


--- START: src\screens\AddSupplierScreen.js ---
// src/screens/AddSupplierScreen.js
import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  ScrollView,
  Alert,
  ActivityIndicator,
  SafeAreaView,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { addSupplier } from '../api/supplierService';
import { useAuth } from '../contexts/AuthContext';

const MATERIAL_CATEGORIES = [
  'Th√©p t·∫•m',
  'Nh√¥m',
  'N∆∞·ªõc',
  'S∆°n',
  'Kh√≠ h√†n',
  'V·∫≠t li·ªáu ho√†n thi·ªán',
  'S·∫Øt',
  'Inox',
  '·ªêng',
  'Th√©p h√¨nh',
  'Long ƒë·ªÅn',
  'Ph·ª• ki·ªán',
  'D·ª•ng c·ª• h√†n',
  'Thi·∫øt b·ªã ƒëo ƒë·∫°c',
  'Kh√°c',
];

const AddSupplierScreen = ({ navigation }) => {
  const { currentUser } = useAuth();
  const [formData, setFormData] = useState({
    name: '',
    contactName: '',
    phone: '',
    email: '',
    address: '',
    taxCode: '',
    bankAccount: '',
    bankName: '',
    description: '',
    categories: [],
    verified: false,
    createdBy: currentUser?.uid || '',
    createdByName: currentUser?.displayName || currentUser?.email || '',
  });
  const [errors, setErrors] = useState({});
  const [saving, setSaving] = useState(false);

  const handleChange = (field, value) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));

    // Clear error when field is edited
    if (errors[field]) {
      setErrors((prev) => ({
        ...prev,
        [field]: null,
      }));
    }
  };

  const toggleCategory = (category) => {
    setFormData((prev) => {
      const updatedCategories = [...prev.categories];

      if (updatedCategories.includes(category)) {
        // Remove category if already selected
        return {
          ...prev,
          categories: updatedCategories.filter((c) => c !== category),
        };
      } else {
        // Add category if not selected
        return {
          ...prev,
          categories: [...updatedCategories, category],
        };
      }
    });
  };

  const validateForm = () => {
    const newErrors = {};

    if (!formData.name.trim()) {
      newErrors.name = 'Vui l√≤ng nh·∫≠p t√™n nh√† cung c·∫•p';
    }

    if (formData.phone && !/^[0-9]{10,11}$/.test(formData.phone.trim())) {
      newErrors.phone = 'S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá';
    }

    if (formData.email && !/\S+@\S+\.\S+/.test(formData.email.trim())) {
      newErrors.email = 'Email kh√¥ng h·ª£p l·ªá';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async () => {
    if (!validateForm()) {
      Alert.alert('L·ªói', 'Vui l√≤ng ki·ªÉm tra l·∫°i th√¥ng tin nh·∫≠p');
      return;
    }

    setSaving(true);
    try {
      await addSupplier(formData);
      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ th√™m nh√† cung c·∫•p m·ªõi', [
        { text: 'OK', onPress: () => navigation.goBack() },
      ]);
    } catch (error) {
      console.error('L·ªói khi th√™m nh√† cung c·∫•p:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ th√™m nh√† cung c·∫•p. Vui l√≤ng th·ª≠ l·∫°i sau.');
    } finally {
      setSaving(false);
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={{ flex: 1 }}
      >
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
          >
            <Ionicons name="arrow-back" size={24} color="#333" />
          </TouchableOpacity>
          <Text style={styles.headerTitle}>Th√™m nh√† cung c·∫•p m·ªõi</Text>
          <View style={{ width: 24 }} />
        </View>

        <ScrollView style={styles.content}>
          <View style={styles.formGroup}>
            <Text style={styles.label}>
              T√™n nh√† cung c·∫•p <Text style={styles.required}>*</Text>
            </Text>
            <TextInput
              style={[styles.input, errors.name && styles.inputError]}
              value={formData.name}
              onChangeText={(text) => handleChange('name', text)}
              placeholder="Nh·∫≠p t√™n nh√† cung c·∫•p"
            />
            {errors.name && <Text style={styles.errorText}>{errors.name}</Text>}
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Ng∆∞·ªùi li√™n h·ªá</Text>
            <TextInput
              style={styles.input}
              value={formData.contactName}
              onChangeText={(text) => handleChange('contactName', text)}
              placeholder="Nh·∫≠p t√™n ng∆∞·ªùi li√™n h·ªá"
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>S·ªë ƒëi·ªán tho·∫°i</Text>
            <TextInput
              style={[styles.input, errors.phone && styles.inputError]}
              value={formData.phone}
              onChangeText={(text) => handleChange('phone', text)}
              placeholder="Nh·∫≠p s·ªë ƒëi·ªán tho·∫°i"
              keyboardType="phone-pad"
            />
            {errors.phone && (
              <Text style={styles.errorText}>{errors.phone}</Text>
            )}
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Email</Text>
            <TextInput
              style={[styles.input, errors.email && styles.inputError]}
              value={formData.email}
              onChangeText={(text) => handleChange('email', text)}
              placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ email"
              keyboardType="email-address"
              autoCapitalize="none"
            />
            {errors.email && (
              <Text style={styles.errorText}>{errors.email}</Text>
            )}
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>ƒê·ªãa ch·ªâ</Text>
            <TextInput
              style={styles.input}
              value={formData.address}
              onChangeText={(text) => handleChange('address', text)}
              placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ"
              multiline
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>M√£ s·ªë thu·∫ø</Text>
            <TextInput
              style={styles.input}
              value={formData.taxCode}
              onChangeText={(text) => handleChange('taxCode', text)}
              placeholder="Nh·∫≠p m√£ s·ªë thu·∫ø"
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>T√†i kho·∫£n ng√¢n h√†ng</Text>
            <TextInput
              style={styles.input}
              value={formData.bankAccount}
              onChangeText={(text) => handleChange('bankAccount', text)}
              placeholder="Nh·∫≠p s·ªë t√†i kho·∫£n"
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>T√™n ng√¢n h√†ng</Text>
            <TextInput
              style={styles.input}
              value={formData.bankName}
              onChangeText={(text) => handleChange('bankName', text)}
              placeholder="Nh·∫≠p t√™n ng√¢n h√†ng"
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Danh m·ª•c v·∫≠t t∆∞ cung c·∫•p</Text>
            <View style={styles.categoriesContainer}>
              {MATERIAL_CATEGORIES.map((category, index) => (
                <TouchableOpacity
                  key={index}
                  style={[
                    styles.categoryTag,
                    formData.categories.includes(category) &&
                      styles.categoryTagSelected,
                  ]}
                  onPress={() => toggleCategory(category)}
                >
                  <Text
                    style={[
                      styles.categoryText,
                      formData.categories.includes(category) &&
                        styles.categoryTextSelected,
                    ]}
                  >
                    {category}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>M√¥ t·∫£</Text>
            <TextInput
              style={[styles.input, styles.textArea]}
              value={formData.description}
              onChangeText={(text) => handleChange('description', text)}
              placeholder="Nh·∫≠p m√¥ t·∫£ v·ªÅ nh√† cung c·∫•p"
              multiline
              numberOfLines={4}
              textAlignVertical="top"
            />
          </View>

          <View style={styles.verifiedContainer}>
            <TouchableOpacity
              style={styles.checkboxContainer}
              onPress={() => handleChange('verified', !formData.verified)}
            >
              <View
                style={[
                  styles.checkbox,
                  formData.verified && styles.checkboxChecked,
                ]}
              >
                {formData.verified && (
                  <Ionicons name="checkmark" size={16} color="#fff" />
                )}
              </View>
              <Text style={styles.checkboxLabel}>ƒê√£ x√°c minh</Text>
            </TouchableOpacity>
          </View>

          <TouchableOpacity
            style={styles.saveButton}
            onPress={handleSubmit}
            disabled={saving}
          >
            {saving ? (
              <ActivityIndicator color="#fff" size="small" />
            ) : (
              <Text style={styles.saveButtonText}>L∆∞u nh√† cung c·∫•p</Text>
            )}
          </TouchableOpacity>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  content: {
    flex: 1,
    padding: 16,
  },
  formGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    color: '#333',
    marginBottom: 6,
  },
  required: {
    color: 'red',
  },
  input: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    fontSize: 16,
  },
  inputError: {
    borderColor: 'red',
  },
  errorText: {
    color: 'red',
    fontSize: 12,
    marginTop: 4,
  },
  textArea: {
    minHeight: 100,
    textAlignVertical: 'top',
  },
  categoriesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginTop: 8,
  },
  categoryTag: {
    backgroundColor: '#f0f0f0',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 16,
    marginRight: 8,
    marginBottom: 8,
  },
  categoryTagSelected: {
    backgroundColor: '#e6f2ff',
    borderWidth: 1,
    borderColor: '#0066cc',
  },
  categoryText: {
    fontSize: 14,
    color: '#666',
  },
  categoryTextSelected: {
    color: '#0066cc',
    fontWeight: '500',
  },
  verifiedContainer: {
    marginBottom: 24,
  },
  checkboxContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  checkbox: {
    width: 20,
    height: 20,
    borderRadius: 4,
    borderWidth: 1,
    borderColor: '#999',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 8,
  },
  checkboxChecked: {
    backgroundColor: '#0066cc',
    borderColor: '#0066cc',
  },
  checkboxLabel: {
    fontSize: 16,
    color: '#333',
  },
  saveButton: {
    backgroundColor: '#0066cc',
    paddingVertical: 14,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 30,
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
});

export default AddSupplierScreen;


--- END: src\screens\AddSupplierScreen.js ---


--- START: src\screens\AdvanceSalaryScreen.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  StatusBar,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
  TextInput,
  Modal,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import {
  submitAdvanceSalaryRequest,
  fetchAdvanceRequestsByUser,
} from '../api/requestService';

const AdvanceSalaryScreen = ({ navigation }) => {
  const { theme, isDarkMode } = useTheme();
  const { user } = useAuth();
  const [loading, setLoading] = useState(false);
  const [advanceRequests, setAdvanceRequests] = useState([]);
  const [showForm, setShowForm] = useState(false);

  // Form state
  const [amount, setAmount] = useState('');
  const [reason, setReason] = useState('');
  const [requestDate, setRequestDate] = useState(new Date());
  const [expectedPaymentDate, setExpectedPaymentDate] = useState(new Date());

  useEffect(() => {
    loadAdvanceRequests();
  }, []);

  const loadAdvanceRequests = async () => {
    try {
      setLoading(true);
      if (!user?.uid) return;
      const requests = await fetchAdvanceRequestsByUser(user.uid);
      setAdvanceRequests(requests);
    } catch (error) {
      console.error('L·ªói khi t·∫£i ƒë∆°n xin ·ª©ng l∆∞∆°ng:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch ƒë∆°n xin ·ª©ng l∆∞∆°ng');
    } finally {
      setLoading(false);
    }
  };

  const getStatusLabel = (status) => {
    switch (status) {
      case 'pending':
        return 'Ch·ªù duy·ªát';
      case 'approved':
        return 'ƒê√£ duy·ªát';
      case 'rejected':
        return 'T·ª´ ch·ªëi';
      default:
        return 'Kh√¥ng x√°c ƒë·ªãnh';
    }
  };

  const getStatusColor = (status) => {
    switch (status) {
      case 'pending':
        return '#FF9800';
      case 'approved':
        return '#4CAF50';
      case 'rejected':
        return '#F44336';
      default:
        return '#9E9E9E';
    }
  };

  const formatDate = (date) => {
    if (!date) return '';
    const d = date.toDate ? date.toDate() : new Date(date);
    if (isNaN(d.getTime())) return '';
    return d.toLocaleDateString('vi-VN');
  };

  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
    }).format(amount);
  };

  const handleSubmitAdvanceRequest = async () => {
    if (!amount.trim() || isNaN(parseFloat(amount))) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p s·ªë ti·ªÅn h·ª£p l·ªá');
      return;
    }

    if (!reason.trim()) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p l√Ω do ·ª©ng l∆∞∆°ng');
      return;
    }

    const amountValue = parseFloat(amount);
    if (amountValue <= 0) {
      Alert.alert('L·ªói', 'S·ªë ti·ªÅn ph·∫£i l·ªõn h∆°n 0');
      return;
    }

    try {
      setLoading(true);
      await submitAdvanceSalaryRequest({
        userId: user.uid,
        userName: user?.displayName || user?.email || '',
        amount: amountValue,
        reason,
        requestDate,
        expectedPaymentDate,
      });

      Alert.alert(
        'Th√†nh c√¥ng',
        'ƒê∆°n xin ·ª©ng l∆∞∆°ng ƒë√£ ƒë∆∞·ª£c g·ª≠i v√† ƒëang ch·ªù duy·ªát'
      );
      setShowForm(false);
      resetForm();
      await loadAdvanceRequests();
    } catch (error) {
      console.error('L·ªói khi g·ª≠i ƒë∆°n xin ·ª©ng l∆∞∆°ng:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ g·ª≠i ƒë∆°n xin ·ª©ng l∆∞∆°ng');
    } finally {
      setLoading(false);
    }
  };

  const resetForm = () => {
    setAmount('');
    setReason('');
    setRequestDate(new Date());
    setExpectedPaymentDate(new Date());
  };

  const getTotalRequested = () => {
    return advanceRequests.reduce((total, request) => {
      return total + request.amount;
    }, 0);
  };

  const getTotalApproved = () => {
    return advanceRequests
      .filter((request) => request.status === 'approved')
      .reduce((total, request) => {
        return total + (request.approvedAmount || request.amount);
      }, 0);
  };

  const getTotalPending = () => {
    return advanceRequests
      .filter((request) => request.status === 'pending')
      .reduce((total, request) => {
        return total + request.amount;
      }, 0);
  };

  if (loading && advanceRequests.length === 0) {
    return (
      <SafeAreaView
        style={[styles.container, { backgroundColor: theme.background }]}
      >
        <StatusBar
          barStyle={isDarkMode ? 'light-content' : 'dark-content'}
          backgroundColor={theme.background}
        />
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
            ƒêang t·∫£i d·ªØ li·ªáu...
          </Text>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <StatusBar
        barStyle={isDarkMode ? 'light-content' : 'dark-content'}
        backgroundColor={theme.background}
      />

      {/* Header */}
      <View style={[styles.header, { backgroundColor: theme.card }]}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={theme.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Xin ·ª®ng L∆∞∆°ng
        </Text>
        <TouchableOpacity
          style={styles.addButton}
          onPress={() => setShowForm(true)}
        >
          <Ionicons name="add" size={24} color={theme.primary} />
        </TouchableOpacity>
      </View>

      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.scrollContent}
      >
        {/* Th·ªëng k√™ */}
        <View
          style={[
            styles.statsCard,
            { backgroundColor: theme.card, borderColor: theme.border },
          ]}
        >
          <Text style={[styles.statsTitle, { color: theme.text }]}>
            Th·ªëng k√™ ·ª©ng l∆∞∆°ng
          </Text>

          <View style={styles.statsGrid}>
            <View style={styles.statItem}>
              <Text style={[styles.statValue, { color: theme.primary }]}>
                {formatCurrency(getTotalApproved())}
              </Text>
              <Text style={[styles.statLabel, { color: theme.textSecondary }]}>
                ƒê√£ duy·ªát
              </Text>
            </View>

            <View style={styles.statItem}>
              <Text style={[styles.statValue, { color: '#FF9800' }]}>
                {formatCurrency(getTotalPending())}
              </Text>
              <Text style={[styles.statLabel, { color: theme.textSecondary }]}>
                Ch·ªù duy·ªát
              </Text>
            </View>

            <View style={styles.statItem}>
              <Text style={[styles.statValue, { color: '#2196F3' }]}>
                {formatCurrency(getTotalRequested())}
              </Text>
              <Text style={[styles.statLabel, { color: theme.textSecondary }]}>
                T·ªïng y√™u c·∫ßu
              </Text>
            </View>
          </View>
        </View>

        {/* Danh s√°ch ƒë∆°n xin ·ª©ng l∆∞∆°ng */}
        <View style={styles.section}>
          <Text style={[styles.sectionTitle, { color: theme.text }]}>
            L·ªãch s·ª≠ ƒë∆°n xin ·ª©ng l∆∞∆°ng
          </Text>

          {advanceRequests.length > 0 ? (
            advanceRequests.map((request) => (
              <View
                key={request.id}
                style={[
                  styles.requestCard,
                  { backgroundColor: theme.card, borderColor: theme.border },
                ]}
              >
                <View style={styles.requestHeader}>
                  <View style={styles.amountInfo}>
                    <Ionicons
                      name="cash-outline"
                      size={20}
                      color={theme.primary}
                    />
                    <Text style={[styles.amountText, { color: theme.text }]}>
                      {formatCurrency(request.amount)}
                    </Text>
                  </View>

                  <View
                    style={[
                      styles.statusBadge,
                      { backgroundColor: getStatusColor(request.status) },
                    ]}
                  >
                    <Text style={styles.statusText}>
                      {getStatusLabel(request.status)}
                    </Text>
                  </View>
                </View>

                <View style={styles.requestDetails}>
                  <View style={styles.reasonRow}>
                    <Ionicons
                      name="chatbubble-outline"
                      size={16}
                      color={theme.textSecondary}
                    />
                    <Text style={[styles.reasonText, { color: theme.text }]}>
                      {request.reason}
                    </Text>
                  </View>

                  <View style={styles.dateRow}>
                    <Ionicons
                      name="calendar-outline"
                      size={16}
                      color={theme.textSecondary}
                    />
                    <Text
                      style={[styles.dateText, { color: theme.textSecondary }]}
                    >
                      Ng√†y y√™u c·∫ßu: {formatDate(request.requestDate)}
                    </Text>
                  </View>

                  <View style={styles.dateRow}>
                    <Ionicons
                      name="time-outline"
                      size={16}
                      color={theme.textSecondary}
                    />
                    <Text
                      style={[styles.dateText, { color: theme.textSecondary }]}
                    >
                      D·ª± ki·∫øn chi: {formatDate(request.expectedPaymentDate)}
                    </Text>
                  </View>

                  <View style={styles.submittedRow}>
                    <Ionicons
                      name="time-outline"
                      size={16}
                      color={theme.textSecondary}
                    />
                    <Text
                      style={[
                        styles.submittedText,
                        { color: theme.textSecondary },
                      ]}
                    >
                      G·ª≠i l√∫c: {formatDate(request.submittedAt)}
                    </Text>
                  </View>

                  {request.status === 'approved' && request.approvedAmount && (
                    <View style={styles.approvedRow}>
                      <Ionicons
                        name="checkmark-circle-outline"
                        size={16}
                        color={theme.primary}
                      />
                      <Text
                        style={[styles.approvedText, { color: theme.primary }]}
                      >
                        S·ªë ti·ªÅn ƒë∆∞·ª£c duy·ªát:{' '}
                        {formatCurrency(request.approvedAmount)}
                      </Text>
                    </View>
                  )}

                  {request.status === 'rejected' && request.rejectionReason && (
                    <View style={styles.rejectedRow}>
                      <Ionicons
                        name="close-circle-outline"
                        size={16}
                        color={theme.error}
                      />
                      <Text
                        style={[styles.rejectedText, { color: theme.error }]}
                      >
                        L√Ω do t·ª´ ch·ªëi: {request.rejectionReason}
                      </Text>
                    </View>
                  )}
                </View>
              </View>
            ))
          ) : (
            <View
              style={[
                styles.emptyCard,
                { backgroundColor: theme.card, borderColor: theme.border },
              ]}
            >
              <Ionicons name="cash-outline" size={48} color={theme.textMuted} />
              <Text style={[styles.emptyText, { color: theme.textMuted }]}>
                Ch∆∞a c√≥ ƒë∆°n xin ·ª©ng l∆∞∆°ng n√†o
              </Text>
            </View>
          )}
        </View>
      </ScrollView>

      {/* Modal form xin ·ª©ng l∆∞∆°ng */}
      <Modal
        visible={showForm}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setShowForm(false)}
      >
        <View style={styles.modalOverlay}>
          <View
            style={[styles.modalContent, { backgroundColor: theme.background }]}
          >
            <View style={styles.modalHeader}>
              <Text style={[styles.modalTitle, { color: theme.text }]}>
                ƒêƒÉng k√Ω ·ª©ng l∆∞∆°ng
              </Text>
              <TouchableOpacity
                style={styles.closeButton}
                onPress={() => setShowForm(false)}
              >
                <Ionicons name="close" size={24} color={theme.text} />
              </TouchableOpacity>
            </View>

            <ScrollView style={styles.formScroll}>
              {/* S·ªë ti·ªÅn */}
              <View style={styles.formSection}>
                <Text style={[styles.formLabel, { color: theme.text }]}>
                  S·ªë ti·ªÅn ·ª©ng l∆∞∆°ng (VND)
                </Text>
                <TextInput
                  style={[
                    styles.amountInput,
                    {
                      backgroundColor: theme.card,
                      borderColor: theme.border,
                      color: theme.text,
                    },
                  ]}
                  placeholder="Nh·∫≠p s·ªë ti·ªÅn..."
                  placeholderTextColor={theme.textMuted}
                  value={amount}
                  onChangeText={setAmount}
                  keyboardType="numeric"
                />
                {amount && !isNaN(parseFloat(amount)) && (
                  <Text
                    style={[
                      styles.amountPreview,
                      { color: theme.textSecondary },
                    ]}
                  >
                    {formatCurrency(parseFloat(amount))}
                  </Text>
                )}
              </View>

              {/* L√Ω do */}
              <View style={styles.formSection}>
                <Text style={[styles.formLabel, { color: theme.text }]}>
                  L√Ω do ·ª©ng l∆∞∆°ng
                </Text>
                <TextInput
                  style={[
                    styles.reasonInput,
                    {
                      backgroundColor: theme.card,
                      borderColor: theme.border,
                      color: theme.text,
                    },
                  ]}
                  placeholder="Nh·∫≠p l√Ω do ·ª©ng l∆∞∆°ng..."
                  placeholderTextColor={theme.textMuted}
                  value={reason}
                  onChangeText={setReason}
                  multiline
                  numberOfLines={4}
                  textAlignVertical="top"
                />
              </View>

              {/* Th√¥ng tin t·ªïng quan */}
              <View
                style={[
                  styles.summaryInfo,
                  { backgroundColor: theme.cardBackground },
                ]}
              >
                <Text style={[styles.summaryInfoTitle, { color: theme.text }]}>
                  T·ªïng quan
                </Text>
                <Text
                  style={[
                    styles.summaryInfoText,
                    { color: theme.textSecondary },
                  ]}
                >
                  S·ªë ti·ªÅn y√™u c·∫ßu:{' '}
                  {amount ? formatCurrency(parseFloat(amount)) : '0 VND'}
                </Text>
              </View>
            </ScrollView>

            {/* N√∫t g·ª≠i */}
            <View style={styles.formActions}>
              <TouchableOpacity
                style={[styles.cancelButton, { borderColor: theme.border }]}
                onPress={() => setShowForm(false)}
              >
                <Text style={[styles.cancelButtonText, { color: theme.text }]}>
                  H·ªßy
                </Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.submitButton,
                  { backgroundColor: theme.primary },
                ]}
                onPress={handleSubmitAdvanceRequest}
                disabled={loading}
              >
                {loading ? (
                  <ActivityIndicator color="#fff" size="small" />
                ) : (
                  <Text style={styles.submitButtonText}>G·ª≠i ƒë∆°n</Text>
                )}
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  addButton: {
    padding: 4,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    padding: 16,
    paddingBottom: 32,
  },
  statsCard: {
    borderRadius: 12,
    padding: 20,
    marginBottom: 20,
    borderWidth: 1,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  statsTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 16,
    textAlign: 'center',
  },
  statsGrid: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  statItem: {
    alignItems: 'center',
  },
  statValue: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  statLabel: {
    fontSize: 12,
    textAlign: 'center',
  },
  section: {
    marginBottom: 24,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  requestCard: {
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  requestHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  amountInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  amountText: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  statusBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  statusText: {
    fontSize: 12,
    fontWeight: '500',
    color: 'white',
  },
  requestDetails: {
    gap: 8,
  },
  reasonRow: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    gap: 8,
  },
  reasonText: {
    fontSize: 14,
    flex: 1,
  },
  dateRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  dateText: {
    fontSize: 14,
  },
  submittedRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  submittedText: {
    fontSize: 12,
  },
  approvedRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  approvedText: {
    fontSize: 14,
    fontWeight: '500',
  },
  rejectedRow: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    gap: 8,
  },
  rejectedText: {
    fontSize: 14,
    fontWeight: '500',
  },
  emptyCard: {
    borderRadius: 12,
    padding: 40,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderStyle: 'dashed',
  },
  emptyText: {
    fontSize: 16,
    marginTop: 12,
    textAlign: 'center',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    minHeight: '80%',
    maxHeight: '90%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  closeButton: {
    padding: 4,
  },
  formScroll: {
    padding: 20,
  },
  formSection: {
    marginBottom: 20,
  },
  formLabel: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 8,
  },
  amountInput: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 8,
    borderWidth: 1,
    fontSize: 18,
    fontWeight: '500',
  },
  amountPreview: {
    fontSize: 14,
    marginTop: 4,
    fontStyle: 'italic',
  },
  reasonInput: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 8,
    borderWidth: 1,
    fontSize: 16,
    minHeight: 100,
  },
  dateDisplay: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 8,
    borderWidth: 1,
    gap: 12,
  },
  dateDisplayText: {
    fontSize: 16,
  },
  summaryInfo: {
    padding: 16,
    borderRadius: 8,
    marginTop: 20,
  },
  summaryInfoTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  summaryInfoText: {
    fontSize: 14,
    marginBottom: 4,
  },
  formActions: {
    flexDirection: 'row',
    padding: 20,
    gap: 12,
    borderTopWidth: 1,
    borderTopColor: '#e0e0e0',
  },
  cancelButton: {
    flex: 1,
    paddingVertical: 16,
    borderRadius: 8,
    borderWidth: 1,
    alignItems: 'center',
  },
  cancelButtonText: {
    fontSize: 16,
    fontWeight: '500',
  },
  submitButton: {
    flex: 2,
    paddingVertical: 16,
    borderRadius: 8,
    alignItems: 'center',
  },
  submitButtonText: {
    fontSize: 16,
    fontWeight: '500',
    color: '#fff',
  },
});

export default AdvanceSalaryScreen;




--- END: src\screens\AdvanceSalaryScreen.js ---


--- START: src\screens\AIChatScreen.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  SafeAreaView,
  TouchableOpacity,
  Alert,
  Modal,
  ScrollView,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useNavigation, useRoute } from '@react-navigation/native';
import AIChatComponent from '../components/AIChatComponent';
import { useAIChat } from '../contexts/AIChatContext';

const AIChatScreen = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { currentProject, setCurrentProject, chatMode, CHAT_MODES } =
    useAIChat();

  // Get project and initial question from route params if available
  const projectFromRoute = route.params?.project;
  const initialQuestion = route.params?.initialQuestion;

  useEffect(() => {
    if (projectFromRoute) {
      setCurrentProject(projectFromRoute);
    }
  }, [projectFromRoute]);

  // Handle initial question if provided
  useEffect(() => {
    if (initialQuestion) {
      // Add the initial question to chat after a short delay
      setTimeout(() => {
        // This will be handled by the AIChatComponent
        console.log('Initial question received:', initialQuestion);
      }, 1000);
    }
  }, [initialQuestion]);

  const handleBack = () => {
    if (navigation.canGoBack()) {
      navigation.goBack();
    } else {
      navigation.navigate('Home');
    }
  };

  const handleProjectInfo = () => {
    if (currentProject) {
      Alert.alert(
        'Th√¥ng tin d·ª± √°n',
        `T√™n: ${currentProject.name || 'Kh√¥ng c√≥ t√™n'}
M√¥ t·∫£: ${currentProject.description || 'Kh√¥ng c√≥ m√¥ t·∫£'}
Tr·∫°ng th√°i: ${currentProject.status || 'Kh√¥ng x√°c ƒë·ªãnh'}
Kh√°ch h√†ng: ${currentProject.customerName || 'Kh√¥ng c√≥ th√¥ng tin'}
Ng√†y b·∫Øt ƒë·∫ßu: ${currentProject.startDate || 'Kh√¥ng x√°c ƒë·ªãnh'}
Ng√†y k·∫øt th√∫c d·ª± ki·∫øn: ${currentProject.endDate || 'Kh√¥ng x√°c ƒë·ªãnh'}`,
        [{ text: 'ƒê√≥ng', style: 'default' }]
      );
    } else {
      Alert.alert(
        'Th√¥ng tin',
        'B·∫°n ƒëang chat v·ªõi AI Assistant chung. H√£y ch·ªçn m·ªôt image.png ƒë·ªÉ c√≥ context t·ªët h∆°n.',
        [{ text: 'ƒê√≥ng', style: 'default' }]
      );
    }
  };

  const handleExportChat = () => {
    Alert.alert(
      'Xu·∫•t l·ªãch s·ª≠ chat',
      'T√≠nh nƒÉng n√†y s·∫Ω ƒë∆∞·ª£c ph√°t tri·ªÉn trong phi√™n b·∫£n ti·∫øp theo.',
      [{ text: 'ƒê√≥ng', style: 'default' }]
    );
  };

  const renderHeader = () => (
    <View style={styles.header}>
      <TouchableOpacity onPress={handleBack} style={styles.backButton}>
        <Ionicons name="arrow-back" size={24} color="#007AFF" />
      </TouchableOpacity>

      <View style={styles.headerCenter}>
        <Text style={styles.headerTitle}>
          {currentProject ? `Tr·ª£ l√Ω AI` : 'Tr·ª£ l√Ω AI'}
        </Text>
      </View>

      <View style={styles.headerActions}>
        <TouchableOpacity onPress={handleProjectInfo} style={styles.infoButton}>
          <Ionicons
            name="information-circle-outline"
            size={24}
            color="#007AFF"
          />
        </TouchableOpacity>
        {currentProject && (
          <TouchableOpacity
            onPress={handleExportChat}
            style={styles.exportButton}
          >
            <Ionicons name="download-outline" size={24} color="#34C759" />
          </TouchableOpacity>
        )}
      </View>
    </View>
  );

  return (
    <SafeAreaView style={styles.container}>
      {renderHeader()}

      <View style={styles.chatContainer}>
        <AIChatComponent
          project={currentProject}
          initialQuestion={initialQuestion}
        />
      </View>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F2F2F7',
  },

  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: '#FFFFFF',
    borderBottomWidth: 1,
    borderBottomColor: '#E5E5EA',
  },

  backButton: {
    padding: 8,
    marginRight: 8,
  },

  headerCenter: {
    flex: 1,
    alignItems: 'center',
  },

  headerTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#000000',
    textAlign: 'center',
  },

  headerActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },

  infoButton: {
    padding: 8,
    marginRight: 8,
  },

  exportButton: {
    padding: 8,
  },

  chatContainer: {
    flex: 1,
  },
});

export default AIChatScreen;


--- END: src\screens\AIChatScreen.js ---


--- START: src\screens\AssignSalaryScreen.js ---
// src/screens/AssignSalaryScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  Modal,
  TextInput,
  ActivityIndicator,
  Alert,
  Image,
  SafeAreaView,
  ScrollView,
  Switch,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import {
  collection,
  getDocs,
  doc,
  updateDoc,
  query,
  orderBy,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';

const AssignSalaryScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [selectedUser, setSelectedUser] = useState(null);
  const [editModalVisible, setEditModalVisible] = useState(false);
  const [editData, setEditData] = useState({
    displayName: '',
    dailySalary: '',
    monthlySalary: '',
    salaryType: 'daily', // 'daily' or 'monthly'
  });
  const [savingUser, setSavingUser] = useState(false);

  // Load users
  useEffect(() => {
    const fetchUsers = async () => {
      try {
        setLoading(true);
        const usersRef = collection(db, 'users');
        const q = query(usersRef, orderBy('displayName'));
        const snapshot = await getDocs(q);
        const usersList = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        }));
        setUsers(usersList);
      } catch (error) {
        console.error('Error loading users:', error);
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch ng∆∞·ªùi d√πng');
      } finally {
        setLoading(false);
      }
    };

    fetchUsers();
  }, []);

  // Handle user selection for editing salary
  const handleEditSalary = (user) => {
    setSelectedUser(user);

    // Determine salary type based on existing data
    let salaryType = 'daily';
    if (user.monthlySalary && (!user.dailySalary || user.monthlySalary > 0)) {
      salaryType = 'monthly';
    }

    setEditData({
      displayName: user.displayName || '',
      dailySalary: user.dailySalary ? String(user.dailySalary) : '',
      monthlySalary: user.monthlySalary ? String(user.monthlySalary) : '',
      salaryType: salaryType,
    });
    setEditModalVisible(true);
  };

  // Save salary changes
  const saveSalaryChanges = async () => {
    if (!selectedUser) return;

    try {
      // Validate salary inputs
      if (editData.salaryType === 'daily' && !editData.dailySalary) {
        Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p l∆∞∆°ng theo ng√†y');
        return;
      }

      if (editData.salaryType === 'monthly' && !editData.monthlySalary) {
        Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p l∆∞∆°ng c·ªë ƒë·ªãnh theo th√°ng');
        return;
      }

      setSavingUser(true);

      // Set salary data based on selected type
      const salaryData = {
        dailySalary:
          editData.salaryType === 'daily'
            ? parseFloat(editData.dailySalary)
            : null,
        monthlySalary:
          editData.salaryType === 'monthly'
            ? parseFloat(editData.monthlySalary)
            : null,
      };

      // Update user in Firestore
      const userRef = doc(db, 'users', selectedUser.id);
      await updateDoc(userRef, salaryData);

      // Update local state
      setUsers((prevUsers) =>
        prevUsers.map((u) =>
          u.id === selectedUser.id ? { ...u, ...salaryData } : u
        )
      );

      // Close modal
      setEditModalVisible(false);
      setSelectedUser(null);
      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ c·∫≠p nh·∫≠t l∆∞∆°ng cho nh√¢n vi√™n');
    } catch (error) {
      console.error('Error updating salary:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t l∆∞∆°ng');
    } finally {
      setSavingUser(false);
    }
  };

  // Toggle salary type
  const toggleSalaryType = () => {
    setEditData((prev) => ({
      ...prev,
      salaryType: prev.salaryType === 'daily' ? 'monthly' : 'daily',
    }));
  };

  // Render user item in list
  const renderUserItem = ({ item }) => (
    <TouchableOpacity
      style={[styles.userCard, { backgroundColor: theme.card }]}
      onPress={() => handleEditSalary(item)}
    >
      <View style={styles.userCardLeft}>
        {item.photoURL ? (
          <Image source={{ uri: item.photoURL }} style={styles.avatar} />
        ) : (
          <View
            style={[
              styles.avatarPlaceholder,
              { backgroundColor: theme.primaryLight },
            ]}
          >
            <Text style={[styles.avatarText, { color: theme.primary }]}>
              {(item.displayName || '?')[0].toUpperCase()}
            </Text>
          </View>
        )}
      </View>
      <View style={styles.userCardMiddle}>
        <Text style={[styles.userName, { color: theme.text }]}>
          {item.displayName || 'Kh√¥ng c√≥ t√™n'}
        </Text>
        {item.dailySalary && (
          <Text style={[styles.userSalary, { color: theme.textMuted }]}>
            L∆∞∆°ng ng√†y: {formatCurrency(item.dailySalary)} VND
          </Text>
        )}
        {item.monthlySalary && (
          <Text style={[styles.userSalary, { color: theme.textMuted }]}>
            L∆∞∆°ng th√°ng: {formatCurrency(item.monthlySalary)} VND
          </Text>
        )}
      </View>
      <View style={styles.userCardRight}>
        <Ionicons name="cash-outline" size={20} color={theme.textMuted} />
      </View>
    </TouchableOpacity>
  );

  const formatCurrency = (value) =>
    new Intl.NumberFormat('vi-VN').format(value);

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <View style={[styles.header, { backgroundColor: theme.card }]}>
        <TouchableOpacity
          onPress={() => navigation.goBack()}
          style={styles.backButton}
        >
          <Ionicons name="arrow-back" size={24} color={theme.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          G√°n L∆∞∆°ng Nh√¢n Vi√™n
        </Text>
        <View style={{ width: 24 }} />
      </View>

      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
        </View>
      ) : (
        <FlatList
          data={users}
          renderItem={renderUserItem}
          keyExtractor={(item) => item.id}
          contentContainerStyle={styles.listContent}
        />
      )}

      <Modal
        visible={editModalVisible}
        transparent
        animationType="slide"
        onRequestClose={() => setEditModalVisible(false)}
      >
        <View style={styles.modalBackdrop}>
          <View style={[styles.modalContent, { backgroundColor: theme.card }]}>
            <View style={styles.modalHeader}>
              <Text style={[styles.modalTitle, { color: theme.text }]}>
                C·∫≠p nh·∫≠t l∆∞∆°ng cho {editData.displayName}
              </Text>
              <TouchableOpacity
                onPress={() => setEditModalVisible(false)}
                style={styles.closeButton}
              >
                <Ionicons name="close" size={24} color={theme.textMuted} />
              </TouchableOpacity>
            </View>
            <ScrollView style={styles.modalScrollView}>
              <View style={styles.salaryTypeSelector}>
                <Text style={[styles.label, { color: theme.text }]}>
                  Lo·∫°i l∆∞∆°ng:
                </Text>
                <View style={styles.salaryTypeOptions}>
                  <TouchableOpacity
                    style={[
                      styles.salaryTypeOption,
                      editData.salaryType === 'daily' &&
                        styles.salaryTypeOptionActive,
                      { borderColor: theme.border },
                    ]}
                    onPress={() =>
                      setEditData((prev) => ({ ...prev, salaryType: 'daily' }))
                    }
                  >
                    <Text
                      style={[
                        styles.salaryTypeText,
                        editData.salaryType === 'daily' && {
                          color: theme.primary,
                          fontWeight: 'bold',
                        },
                      ]}
                    >
                      L∆∞∆°ng theo ng√†y
                    </Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[
                      styles.salaryTypeOption,
                      editData.salaryType === 'monthly' &&
                        styles.salaryTypeOptionActive,
                      { borderColor: theme.border },
                    ]}
                    onPress={() =>
                      setEditData((prev) => ({
                        ...prev,
                        salaryType: 'monthly',
                      }))
                    }
                  >
                    <Text
                      style={[
                        styles.salaryTypeText,
                        editData.salaryType === 'monthly' && {
                          color: theme.primary,
                          fontWeight: 'bold',
                        },
                      ]}
                    >
                      L∆∞∆°ng c·ªë ƒë·ªãnh th√°ng
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>

              {editData.salaryType === 'daily' && (
                <View style={styles.formGroup}>
                  <Text style={[styles.label, { color: theme.text }]}>
                    L∆∞∆°ng theo ng√†y (VND)
                  </Text>
                  <TextInput
                    style={[
                      styles.input,
                      { borderColor: theme.border, color: theme.text },
                    ]}
                    value={editData.dailySalary}
                    onChangeText={(text) =>
                      setEditData((prev) => ({
                        ...prev,
                        dailySalary: text.replace(/[^0-9]/g, ''),
                      }))
                    }
                    placeholder="Nh·∫≠p l∆∞∆°ng theo ng√†y"
                    placeholderTextColor={theme.textMuted}
                    keyboardType="numeric"
                  />
                  {editData.dailySalary && (
                    <Text style={styles.formattedSalary}>
                      {formatCurrency(editData.dailySalary)} VND
                    </Text>
                  )}
                </View>
              )}

              {editData.salaryType === 'monthly' && (
                <View style={styles.formGroup}>
                  <Text style={[styles.label, { color: theme.text }]}>
                    L∆∞∆°ng c·ªë ƒë·ªãnh (th√°ng, VND)
                  </Text>
                  <TextInput
                    style={[
                      styles.input,
                      { borderColor: theme.border, color: theme.text },
                    ]}
                    value={editData.monthlySalary}
                    onChangeText={(text) =>
                      setEditData((prev) => ({
                        ...prev,
                        monthlySalary: text.replace(/[^0-9]/g, ''),
                      }))
                    }
                    placeholder="Nh·∫≠p l∆∞∆°ng c·ªë ƒë·ªãnh"
                    placeholderTextColor={theme.textMuted}
                    keyboardType="numeric"
                  />
                  {editData.monthlySalary && (
                    <Text style={styles.formattedSalary}>
                      {formatCurrency(editData.monthlySalary)} VND
                    </Text>
                  )}
                </View>
              )}
            </ScrollView>
            <View style={styles.modalFooter}>
              <TouchableOpacity
                style={[styles.cancelButton, { borderColor: theme.border }]}
                onPress={() => setEditModalVisible(false)}
              >
                <Text style={{ color: theme.text }}>H·ªßy</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.saveButton, { backgroundColor: theme.primary }]}
                onPress={saveSalaryChanges}
                disabled={savingUser}
              >
                {savingUser ? (
                  <ActivityIndicator size="small" color="#fff" />
                ) : (
                  <Text style={styles.saveButtonText}>L∆∞u</Text>
                )}
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1 },
  header: {
    padding: 16,
    borderBottomWidth: 1,
    elevation: 2,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  headerTitle: { fontSize: 18, fontWeight: 'bold' },
  backButton: { padding: 4 },
  loadingContainer: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  listContent: { padding: 12 },
  userCard: {
    flexDirection: 'row',
    padding: 12,
    marginBottom: 8,
    borderRadius: 8,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  userCardLeft: { marginRight: 12 },
  avatar: { width: 50, height: 50, borderRadius: 25 },
  avatarPlaceholder: {
    width: 50,
    height: 50,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
  },
  avatarText: { fontSize: 20, fontWeight: 'bold' },
  userCardMiddle: { flex: 1, justifyContent: 'center' },
  userName: { fontSize: 16, fontWeight: '600', marginBottom: 4 },
  userSalary: { fontSize: 12 },
  userCardRight: { justifyContent: 'center', paddingHorizontal: 8 },
  modalBackdrop: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    width: '90%',
    maxHeight: '70%',
    borderRadius: 12,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
  },
  modalTitle: { fontSize: 18, fontWeight: 'bold', flex: 1 },
  closeButton: { padding: 4 },
  modalScrollView: { padding: 16 },
  formGroup: { marginBottom: 16 },
  label: { marginBottom: 6, fontWeight: '500' },
  input: {
    borderWidth: 1,
    borderRadius: 8,
    padding: 10,
    fontSize: 16,
  },
  modalFooter: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    padding: 16,
    borderTopWidth: 1,
  },
  cancelButton: {
    borderWidth: 1,
    borderRadius: 8,
    paddingVertical: 10,
    paddingHorizontal: 16,
    marginRight: 12,
  },
  saveButton: {
    borderRadius: 8,
    paddingVertical: 10,
    paddingHorizontal: 24,
  },
  saveButtonText: { color: '#fff', fontWeight: '600' },
  salaryTypeSelector: {
    marginBottom: 20,
  },
  salaryTypeOptions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 8,
  },
  salaryTypeOption: {
    flex: 1,
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderWidth: 1,
    borderRadius: 8,
    alignItems: 'center',
    marginHorizontal: 4,
  },
  salaryTypeOptionActive: {
    borderWidth: 2,
    backgroundColor: 'rgba(0, 122, 255, 0.1)',
  },
  salaryTypeText: {
    fontSize: 14,
  },
  formattedSalary: {
    marginTop: 4,
    fontSize: 14,
    color: '#666',
    fontStyle: 'italic',
  },
});

export default AssignSalaryScreen;


--- END: src\screens\AssignSalaryScreen.js ---


--- START: src\screens\AttendanceScreen.js ---
// src/screens/AttendanceScreen.js
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  ActivityIndicator,
  Modal,
  TextInput,
  Alert,
  SafeAreaView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { db } from '../config/firebaseConfig';
import {
  collection,
  getDocs,
  addDoc,
  query,
  orderBy,
  serverTimestamp,
  deleteDoc,
  doc,
} from 'firebase/firestore';
import {
  setPresence,
  getAttendance,
  addOvertime,
} from '../api/attendanceService';
import { getFunctions, httpsCallable } from 'firebase/functions';
import * as WebBrowser from 'expo-web-browser';
import { GoogleSignin } from '@react-native-google-signin/google-signin';
import DateTimePicker from '@react-native-community/datetimepicker';
import { getApp } from 'firebase/app';
import { useAuth } from '../contexts/AuthContext';

const AttendanceScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const { user } = useAuth(); // Get user from AuthContext
  const isAccountant = user?.role === 'ke_toan'; // Check if user is an accountant

  const [employees, setEmployees] = useState([]);
  const [loading, setLoading] = useState(true);
  const [savingId, setSavingId] = useState(null);
  const [savingTarget, setSavingTarget] = useState(null); // 'present' | 'overtime' | 'export' | null
  const [attMap, setAttMap] = useState({}); // uid -> attendance doc
  const [showAddModal, setShowAddModal] = useState(false);
  const [newName, setNewName] = useState('');
  const [newEmail, setNewEmail] = useState('');
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [showOvertimeModal, setShowOvertimeModal] = useState(false);
  const [overtimeHours, setOvertimeHours] = useState('');
  const [selectedEmployee, setSelectedEmployee] = useState(null);
  const functions = getFunctions(getApp(), 'asia-southeast1');

  // Add default overtime hours
  const DEFAULT_OVERTIME_HOURS = 3; // Default 3 hours (20:30)

  // Format date for display
  const formatDisplayDate = (date) => {
    return date.toLocaleDateString('vi-VN', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
    });
  };

  // Format date for document ID
  const formatDateForDoc = (date) => {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  };

  const fetchEmployees = async () => {
    setLoading(true);
    try {
      const usersRef = collection(db, 'users');
      const q = query(usersRef, orderBy('displayName', 'asc'));
      const snap = await getDocs(q);
      const list = snap.docs.map((d) => ({ uid: d.id, ...d.data() }));
      setEmployees(list);
      await fetchAttendanceForDate(selectedDate);
    } catch (err) {
      console.error('Load employees err', err);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch nh√¢n vi√™n');
      setLoading(false);
    }
  };

  const fetchAttendanceForDate = async (date) => {
    setLoading(true);
    try {
      if (!employees.length) return;

      // Format date to YYYY-MM-DD for attendance lookup
      const dateStr = formatDateForDoc(date);

      // load attendance info
      const dateFetchPromises = employees.map((emp) =>
        getAttendance(emp.uid, dateStr)
      );
      const results = await Promise.all(dateFetchPromises);
      const map = {};
      results.forEach((doc) => {
        if (doc) map[doc.userId] = doc;
      });
      setAttMap(map);
    } catch (err) {
      console.error('Load attendance err', err);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu ch·∫•m c√¥ng');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchEmployees();
  }, []);

  useEffect(() => {
    if (employees.length > 0) {
      fetchAttendanceForDate(selectedDate);
    }
  }, [selectedDate, employees.length]);

  const togglePresent = async (emp) => {
    try {
      setSavingId(emp.uid);
      setSavingTarget('present');
      const current = attMap[emp.uid]?.present || false;
      const updated = await setPresence(emp.uid, !current, selectedDate);
      setAttMap((prev) => ({ ...prev, [emp.uid]: updated }));
    } catch (err) {
      console.error(err);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t');
    } finally {
      setSavingId(null);
      setSavingTarget(null);
    }
  };

  const handleDateChange = (event, date) => {
    setShowDatePicker(false);
    if (date) {
      setSelectedDate(date);
    }
  };

  // Add delete employee function
  const deleteEmployee = async (emp) => {
    try {
      setSavingId(emp.uid);
      await deleteDoc(doc(db, 'users', emp.uid));
      setEmployees((prev) => prev.filter((e) => e.uid !== emp.uid));
      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ x√≥a nh√¢n vi√™n');
    } catch (err) {
      console.error(err);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ x√≥a nh√¢n vi√™n');
    } finally {
      setSavingId(null);
    }
  };

  // Improve markAllPresent to be more efficient
  const markAllPresent = async () => {
    try {
      // Use a temporary state to show loading indicators on each row
      const tempIds = employees.map((e) => e.uid);
      setSavingId('present_all'); // Special marker for bulk present
      setSavingTarget('present');
      const promises = employees.map((emp) =>
        setPresence(emp.uid, true, selectedDate)
      );
      await Promise.all(promises);

      // Update local state without full reload
      const newAttMap = { ...attMap };
      employees.forEach((emp) => {
        const uid = emp.uid;
        if (newAttMap[uid]) {
          newAttMap[uid].present = true;
        } else {
          newAttMap[uid] = {
            userId: uid,
            present: true,
            date: formatDateForDoc(selectedDate),
          };
        }
      });
      setAttMap(newAttMap);
      setSavingId(null);
      setSavingTarget(null);
    } catch (err) {
      console.error(err);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t t·∫•t c·∫£');
      setSavingId(null);
      setSavingTarget(null);
    }
  };

  // Add markAllOvertime function
  const markAllOvertime = async () => {
    try {
      setSavingId('overtime_all');
      setSavingTarget('overtime');
      const promises = employees.map((emp) =>
        addOvertime(emp.uid, DEFAULT_OVERTIME_HOURS, selectedDate)
      );
      await Promise.all(promises);

      // Update local state
      const newAttMap = { ...attMap };
      employees.forEach((emp) => {
        const uid = emp.uid;
        if (newAttMap[uid]) {
          newAttMap[uid].overtime = DEFAULT_OVERTIME_HOURS;
        } else {
          newAttMap[uid] = {
            userId: uid,
            overtime: DEFAULT_OVERTIME_HOURS,
            date: formatDateForDoc(selectedDate),
          };
        }
      });
      setAttMap(newAttMap);
      setSavingId(null);
      setSavingTarget(null);
    } catch (err) {
      console.error(err);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tƒÉng ca');
      setSavingId(null);
      setSavingTarget(null);
    }
  };

  // Add a function to toggle overtime directly
  const toggleOvertime = async (emp) => {
    try {
      setSavingId(emp.uid);
      setSavingTarget('overtime');
      const current = attMap[emp.uid]?.overtime || 0;
      const newValue = current > 0 ? 0 : DEFAULT_OVERTIME_HOURS;
      const updated = await addOvertime(emp.uid, newValue, selectedDate);
      setAttMap((prev) => ({ ...prev, [emp.uid]: updated }));
    } catch (err) {
      console.error(err);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tƒÉng ca');
    } finally {
      setSavingId(null);
      setSavingTarget(null);
    }
  };

  const handleAddOvertime = async () => {
    if (!selectedEmployee) return;

    const hours = parseFloat(overtimeHours);
    if (isNaN(hours) || hours < 0) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p s·ªë gi·ªù h·ª£p l·ªá');
      return;
    }

    try {
      setSavingId(selectedEmployee.uid);
      await addOvertime(selectedEmployee.uid, hours, selectedDate);
      setShowOvertimeModal(false);
      setOvertimeHours('');
      setSelectedEmployee(null);
      await fetchAttendanceForDate(selectedDate);
    } catch (err) {
      console.error(err);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ th√™m gi·ªù tƒÉng ca');
    } finally {
      setSavingId(null);
    }
  };

  const openOvertimeModal = (emp) => {
    setSelectedEmployee(emp);
    setOvertimeHours('');
    setShowOvertimeModal(true);
  };

  // Export attendance data to Excel
  const exportToExcel = async () => {
    try {
      setSavingId('export');
      setSavingTarget('export');

      // Get current year and month from selectedDate
      const year = selectedDate.getFullYear();
      const month = selectedDate.getMonth() + 1; // JavaScript months are 0-indexed

      // Show confirmation alert
      Alert.alert(
        'Xu·∫•t b√°o c√°o ch·∫•m c√¥ng',
        `Xu·∫•t d·ªØ li·ªáu ch·∫•m c√¥ng th√°ng ${month}/${year}?`,
        [
          {
            text: 'H·ªßy',
            style: 'cancel',
            onPress: () => setSavingId(null),
          },
          {
            text: 'Xu·∫•t Excel',
            onPress: async () => {
              try {
                // Get the Google access token
                // In a real app, you'd fetch this from your authentication service
                // For now, we'll assume you have a function to get it
                const accessToken = await getGoogleAccessToken();

                if (!accessToken) {
                  Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ l·∫•y Google access token');
                  setSavingId(null);
                  setSavingTarget(null);
                  return;
                }

                // Call the Cloud Function to generate the Excel file
                const generateAttendanceExcel = httpsCallable(
                  functions,
                  'generateExcelAttendance'
                );
                const result = await generateAttendanceExcel({
                  year,
                  month,
                  accessToken,
                });

                // Check if successful
                if (result.data.success) {
                  // Open the Excel file in a browser
                  await WebBrowser.openBrowserAsync(result.data.fileUrl);
                  Alert.alert(
                    'Th√†nh c√¥ng',
                    'ƒê√£ t·∫°o file Excel b√°o c√°o ch·∫•m c√¥ng'
                  );
                } else {
                  Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫°o file Excel');
                }
              } catch (error) {
                console.error('Export Excel error:', error);
                Alert.alert('L·ªói', `Kh√¥ng th·ªÉ xu·∫•t Excel: ${error.message}`);
              } finally {
                setSavingId(null);
                setSavingTarget(null);
              }
            },
          },
        ],
        {
          cancelable: true,
          onDismiss: () => {
            setSavingId(null);
            setSavingTarget(null);
          },
        }
      );
    } catch (error) {
      console.error('Export Excel prepare error:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ chu·∫©n b·ªã xu·∫•t Excel');
      setSavingId(null);
      setSavingTarget(null);
    }
  };

  // Get Google access token using GoogleSignin - same approach as other Excel generators
  const getGoogleAccessToken = async () => {
    try {
      const isSignedIn = await GoogleSignin.isSignedIn();
      if (!isSignedIn) {
        Alert.alert(
          'Ch∆∞a ƒëƒÉng nh·∫≠p Google',
          'Vui l√≤ng ƒëƒÉng nh·∫≠p v·ªõi Google ƒë·ªÉ xu·∫•t d·ªØ li·ªáu.',
          [
            { text: 'ƒê√≥ng', style: 'cancel' },
            {
              text: 'ƒêƒÉng nh·∫≠p',
              onPress: async () => {
                try {
                  await GoogleSignin.hasPlayServices();
                  await GoogleSignin.signIn();
                  // After signing in, retry
                  exportToExcel();
                } catch (error) {
                  console.error('Google Sign In Error:', error);
                  Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ƒëƒÉng nh·∫≠p v·ªõi Google.');
                }
              },
            },
          ]
        );
        return null;
      }

      // User is signed in, get token
      const tokens = await GoogleSignin.getTokens();
      if (!tokens || !tokens.accessToken) {
        throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c token Google');
      }

      console.log('ƒê√£ l·∫•y Google access token th√†nh c√¥ng');
      return tokens.accessToken;
    } catch (error) {
      console.error('Google token error:', error);
      Alert.alert(
        'L·ªói x√°c th·ª±c',
        'Kh√¥ng l·∫•y ƒë∆∞·ª£c token Google: ' + error.message
      );
      return null;
    }
  };

  const renderItem = ({ item }) => {
    const attendance = attMap[item.uid];
    const present = attendance?.present;
    const overtime = attendance?.overtime || 0;
    const isSavingPresent =
      (savingId === item.uid && savingTarget === 'present') ||
      savingId === 'present_all';
    const isSavingOvertime =
      (savingId === item.uid && savingTarget === 'overtime') ||
      savingId === 'overtime_all';

    return (
      <View
        style={[
          styles.row,
          { backgroundColor: theme.card, marginBottom: 8, borderRadius: 8 },
        ]}
      >
        <View style={styles.employeeInfo}>
          <Text
            style={[styles.nameText, { color: theme.text }]}
            numberOfLines={1}
            ellipsizeMode="tail"
          >
            {item.displayName || item.email || item.uid}
          </Text>
          <Text style={[styles.roleText, { color: theme.textSecondary }]}>
            {item.role ? getRoleLabel(item.role) : 'Nh√¢n vi√™n'}
          </Text>
        </View>

        {overtime > 0 && (
          <TouchableOpacity
            style={styles.overtimeBadge}
            onPress={() => !isAccountant && openOvertimeModal(item)}
            disabled={isAccountant}
          >
            <Ionicons
              name="time"
              size={12}
              color="#8B7500"
              style={{ marginRight: 4 }}
            />
            <Text style={styles.overtimeText}>
              {overtime === 2.5 ? '20:30' : `+${overtime}h`}
            </Text>
          </TouchableOpacity>
        )}

        <View style={styles.attendanceActions}>
          <TouchableOpacity
            onPress={() => !isAccountant && togglePresent(item)}
            disabled={isSavingPresent || isAccountant}
            style={styles.checkButton}
          >
            {isSavingPresent ? (
              <ActivityIndicator size="small" color={theme.primary} />
            ) : (
              <Ionicons
                name={present ? 'checkbox' : 'square-outline'}
                size={24}
                color={present ? theme.primary : theme.textMuted}
              />
            )}
          </TouchableOpacity>

          <View style={styles.overtimeActionContainer}>
            <TouchableOpacity
              onPress={() => !isAccountant && toggleOvertime(item)}
              disabled={isSavingOvertime || isAccountant}
              style={styles.checkButtonOvertime}
            >
              {isSavingOvertime ? (
                <ActivityIndicator
                  size="small"
                  color={theme.success || '#4CAF50'}
                />
              ) : (
                <Ionicons
                  name={overtime > 0 ? 'checkbox' : 'square-outline'}
                  size={24}
                  color={
                    overtime > 0 ? theme.success || '#4CAF50' : theme.textMuted
                  }
                />
              )}
            </TouchableOpacity>
          </View>
        </View>
      </View>
    );
  };

  const addEmployee = async () => {
    if (!newName.trim()) {
      Alert.alert('Thi·∫øu t√™n');
      return;
    }
    try {
      const usersRef = collection(db, 'users');
      await addDoc(usersRef, {
        displayName: newName,
        email: newEmail.trim() || '',
        role: 'cong_nhan',
        createdAt: serverTimestamp(),
      });
      setShowAddModal(false);
      setNewName('');
      setNewEmail('');
      fetchEmployees();
    } catch (err) {
      console.error(err);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ th√™m nh√¢n vi√™n');
    }
  };

  // Helper function to format overtime display
  const formatOvertimeForDisplay = (hours) => {
    return `+${hours}h`;
  };

  // Helper function to map role keys to display labels
  const getRoleLabel = (role) => {
    switch (role) {
      case 'admin':
        return 'Qu·∫£n tr·ªã vi√™n';
      case 'giam_doc':
        return 'Gi√°m ƒë·ªëc';
      case 'pho_giam_doc':
        return 'Ph√≥ Gi√°m ƒë·ªëc';
      case 'quan_ly':
        return 'Qu·∫£n l√Ω';
      case 'ky_su':
        return 'K·ªπ s∆∞';
      case 'ke_toan':
        return 'K·∫ø to√°n';
      case 'thuong_mai':
        return 'Th∆∞∆°ng m·∫°i';
      case 'cong_nhan':
        return 'C√¥ng nh√¢n';
      case 'user':
        return 'Ng∆∞·ªùi d√πng';
      default:
        return 'Kh√¥ng x√°c ƒë·ªãnh';
    }
  };

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      {/* Header */}
      <View style={[styles.header, { backgroundColor: theme.card }]}>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Ch·∫•m C√¥ng & TƒÉng Ca
        </Text>

        <TouchableOpacity
          style={[styles.dateButton, { borderColor: theme.border }]}
          onPress={() => setShowDatePicker(true)}
        >
          <Ionicons name="calendar-outline" size={18} color={theme.primary} />
          <Text style={[styles.dateText, { color: theme.text }]}>
            {formatDisplayDate(selectedDate)}
          </Text>
          <Ionicons name="chevron-down" size={16} color={theme.textMuted} />
        </TouchableOpacity>
      </View>

      {/* Action buttons */}
      <View style={styles.actionBar}>
        {!isAccountant && (
          <TouchableOpacity
            style={[
              styles.actionButton,
              { backgroundColor: theme.secondary || '#FF9500' },
            ]}
            onPress={markAllPresent}
            disabled={savingId === 'all' || isAccountant}
          >
            {savingId === 'all' ? (
              <ActivityIndicator size="small" color="#fff" />
            ) : (
              <>
                <Ionicons
                  name="checkbox"
                  size={18}
                  color="#fff"
                  style={styles.actionIcon}
                />
                <Text style={styles.actionText}>Ch·∫•m C√¥ng T·∫•t C·∫£</Text>
              </>
            )}
          </TouchableOpacity>
        )}

        <TouchableOpacity
          style={[
            styles.actionButton,
            { backgroundColor: theme.success || '#4CAF50' },
          ]}
          onPress={() => exportToExcel()}
          disabled={savingId === 'export'}
        >
          {savingId === 'export' ? (
            <ActivityIndicator size="small" color="#fff" />
          ) : (
            <>
              <Ionicons
                name="document-text"
                size={18}
                color="#fff"
                style={styles.actionIcon}
              />
              <Text style={styles.actionText}>Xu·∫•t Excel</Text>
            </>
          )}
        </TouchableOpacity>

        {isAccountant && (
          <TouchableOpacity
            style={[
              styles.actionButton,
              { backgroundColor: theme.info || '#007BFF' },
            ]}
            onPress={() => navigation.navigate('AssignSalary')}
          >
            <Ionicons
              name="cash-outline"
              size={18}
              color="#fff"
              style={styles.actionIcon}
            />
            <Text style={styles.actionText}>G√°n L∆∞∆°ng</Text>
          </TouchableOpacity>
        )}
      </View>

      {/* Employee list */}
      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
            ƒêang t·∫£i d·ªØ li·ªáu...
          </Text>
        </View>
      ) : (
        <FlatList
          data={employees}
          keyExtractor={(item) => item.uid}
          renderItem={renderItem}
          ListHeaderComponent={
            <>
              <View style={styles.listHeaderContainer}>
                <Text style={[styles.listHeaderLabel, { flex: 1 }]}>
                  T√™n nh√¢n vi√™n
                </Text>
                <Text
                  style={[
                    styles.listHeaderLabel,
                    {
                      width: 80,
                      textAlign: 'center',
                      transform: [{ translateX: 3 }],
                    },
                  ]}
                >
                  Ch·∫•m c√¥ng
                </Text>
                <Text
                  style={[
                    styles.listHeaderLabel,
                    {
                      width: 80,
                      textAlign: 'center',
                      transform: [{ translateX: 6 }],
                    },
                  ]}
                >
                  TƒÉng ca
                </Text>
              </View>
              <View
                style={[styles.divider, { backgroundColor: theme.border }]}
              />
            </>
          }
          contentContainerStyle={styles.listContent}
          ListEmptyComponent={
            <View style={styles.emptyContainer}>
              <Ionicons name="people" size={40} color={theme.textMuted} />
              <Text style={[styles.emptyText, { color: theme.textMuted }]}>
                Ch∆∞a c√≥ nh√¢n vi√™n n√†o
              </Text>
            </View>
          }
        />
      )}

      {/* Add employee button */}
      {!isAccountant && (
        <TouchableOpacity
          style={[styles.fab, { backgroundColor: theme.primary }]}
          onPress={() => setShowAddModal(true)}
        >
          <Ionicons name="person-add" size={24} color="#fff" />
        </TouchableOpacity>
      )}

      {/* Date picker */}
      {showDatePicker && (
        <DateTimePicker
          value={selectedDate}
          mode="date"
          display={Platform.OS === 'ios' ? 'spinner' : 'default'}
          onChange={handleDateChange}
        />
      )}

      {/* Add employee modal */}
      <Modal visible={showAddModal} transparent animationType="slide">
        <View style={styles.modalBackdrop}>
          <View style={[styles.modalContent, { backgroundColor: theme.card }]}>
            <Text style={[styles.modalTitle, { color: theme.text }]}>
              Th√™m nh√¢n vi√™n
            </Text>
            <TextInput
              placeholder="T√™n"
              value={newName}
              onChangeText={setNewName}
              style={[
                styles.input,
                { borderColor: theme.border, color: theme.text },
              ]}
              placeholderTextColor={theme.textMuted}
            />
            <TextInput
              placeholder="Email (tu·ª≥ ch·ªçn)"
              value={newEmail}
              onChangeText={setNewEmail}
              style={[
                styles.input,
                { borderColor: theme.border, color: theme.text },
              ]}
              placeholderTextColor={theme.textMuted}
            />
            <View style={styles.modalActions}>
              <TouchableOpacity
                onPress={() => setShowAddModal(false)}
                style={[styles.modalButton, styles.cancelButton]}
              >
                <Text style={{ color: theme.text }}>Hu·ª∑</Text>
              </TouchableOpacity>
              <TouchableOpacity
                onPress={addEmployee}
                style={[
                  styles.modalButton,
                  styles.saveButton,
                  { backgroundColor: theme.primary },
                ]}
              >
                <Text style={styles.saveButtonText}>L∆∞u</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Overtime modal */}
      <Modal visible={showOvertimeModal} transparent animationType="slide">
        <View style={styles.modalBackdrop}>
          <View style={[styles.modalContent, { backgroundColor: theme.card }]}>
            <Text style={[styles.modalTitle, { color: theme.text }]}>
              Th√™m gi·ªù tƒÉng ca
            </Text>
            <Text
              style={[
                styles.overtimeEmployeeName,
                { color: theme.textSecondary },
              ]}
            >
              {selectedEmployee?.displayName || ''}
            </Text>

            <TextInput
              placeholder="S·ªë gi·ªù tƒÉng ca"
              value={overtimeHours}
              onChangeText={setOvertimeHours}
              keyboardType="decimal-pad"
              style={[
                styles.input,
                { borderColor: theme.border, color: theme.text },
              ]}
              placeholderTextColor={theme.textMuted}
            />

            <View style={styles.modalActions}>
              <TouchableOpacity
                onPress={() => setShowOvertimeModal(false)}
                style={[styles.modalButton, styles.cancelButton]}
              >
                <Text style={{ color: theme.text }}>Hu·ª∑</Text>
              </TouchableOpacity>
              <TouchableOpacity
                onPress={handleAddOvertime}
                style={[
                  styles.modalButton,
                  styles.saveButton,
                  { backgroundColor: theme.primary },
                ]}
              >
                <Text style={styles.saveButtonText}>L∆∞u</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    elevation: 2,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  dateButton: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 6,
  },
  dateText: {
    marginHorizontal: 8,
    fontSize: 14,
  },
  actionBar: {
    flexDirection: 'row',
    padding: 12,
    justifyContent: 'space-around',
    gap: 10,
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    flex: 1,
    justifyContent: 'center',
  },
  actionIcon: {
    marginRight: 6,
  },
  actionText: {
    color: '#fff',
    fontWeight: '600',
  },
  divider: {
    height: 1,
    width: '100%',
    marginTop: 8,
  },
  listHeaderContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingTop: 8,
    alignItems: 'center',
  },
  listHeaderLabel: {
    fontWeight: '600',
    fontSize: 14,
  },
  listContent: {
    padding: 12,
  },
  row: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 12,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  employeeInfo: {
    flex: 1,
    marginRight: 4,
  },
  nameText: {
    fontSize: 16,
    fontWeight: '500',
  },
  roleText: {
    fontSize: 12,
    marginTop: 2,
    flexBasis: '100%',
  },
  attendanceActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  overtimeActionContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    width: 80,
    justifyContent: 'center',
  },
  overtimeBadge: {
    backgroundColor: '#FFD700',
    borderRadius: 12,
    paddingHorizontal: 8,
    paddingVertical: 4,
    marginLeft: 4,
    flexDirection: 'row',
    alignItems: 'center',
  },
  overtimeText: {
    color: '#8B7500',
    fontSize: 12,
    fontWeight: 'bold',
  },
  checkButton: {
    width: 80,
    alignItems: 'center',
  },
  checkButtonOvertime: {
    paddingHorizontal: 8,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 12,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 40,
  },
  emptyText: {
    marginTop: 12,
    fontSize: 16,
  },
  fab: {
    position: 'absolute',
    bottom: 20,
    right: 20,
    width: 56,
    height: 56,
    borderRadius: 28,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  modalBackdrop: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    width: '85%',
    borderRadius: 12,
    padding: 20,
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  overtimeEmployeeName: {
    marginBottom: 12,
    fontSize: 16,
  },
  input: {
    borderWidth: 1,
    borderRadius: 8,
    padding: 12,
    marginBottom: 16,
    fontSize: 16,
  },
  modalActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    marginTop: 8,
  },
  modalButton: {
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 8,
    marginLeft: 12,
  },
  cancelButton: {
    backgroundColor: 'transparent',
  },
  saveButton: {
    minWidth: 80,
    alignItems: 'center',
  },
  saveButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
});

export default AttendanceScreen;


--- END: src\screens\AttendanceScreen.js ---


--- START: src\screens\ConfirmPOReceiptScreen.js ---
import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  Image,
  Alert,
  TextInput,
  ActivityIndicator,
  ScrollView,
  ProgressBarAndroid,
  Platform,
  ProgressViewIOS,
  Linking,
} from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import * as ImagePicker from 'expo-image-picker';
import * as FileSystem from 'expo-file-system';
import usePOReceipt from '../hooks/usePOReceipt';
import uuid from 'react-native-uuid';

const ConfirmPOReceiptScreen = () => {
  const route = useRoute();
  const navigation = useNavigation();
  const { po } = route.params || {};

  const { confirmReceipt, loading, uploadProgress } = usePOReceipt();

  const [files, setFiles] = useState([]);
  const [remarks, setRemarks] = useState('');
  const [saving, setSaving] = useState(false);

  if (!po) {
    return (
      <View style={styles.centered}>
        <Text>Kh√¥ng t√¨m th·∫•y th√¥ng tin PO.</Text>
      </View>
    );
  }

  // H√†m ƒë∆°n gi·∫£n ƒë·ªÉ th√™m file v√†o state
  const addFileToState = (asset) => {
    if (!asset || !asset.uri) {
      Alert.alert('L·ªói', 'T·∫≠p tin kh√¥ng h·ª£p l·ªá.');
      return;
    }

    const tempId = uuid.v4();
    const fileInfo = {
      id: tempId, // ID t·∫°m th·ªùi
      uri: asset.uri,
      name: asset.fileName || `image_${tempId}.jpg`,
      mimeType: asset.mimeType || 'image/jpeg',
    };

    setFiles((prev) => [...prev, fileInfo]);
  };

  const pickFile = async () => {
    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
    if (status !== 'granted') {
      Alert.alert('L·ªói', 'C·∫ßn quy·ªÅn truy c·∫≠p th∆∞ vi·ªán ·∫£nh.');
      return;
    }

    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      quality: 0.7,
      allowsMultipleSelection: true,
    });

    if (!result.canceled && result.assets) {
      result.assets.forEach(addFileToState);
    }
  };

  // Capture photo directly using camera
  const takePhoto = async () => {
    const { status } = await ImagePicker.requestCameraPermissionsAsync();
    if (status !== 'granted') {
      Alert.alert('L·ªói', 'C·∫ßn quy·ªÅn truy c·∫≠p camera.');
      return;
    }

    const result = await ImagePicker.launchCameraAsync({ quality: 0.7 });

    if (!result.canceled) {
      addFileToState(result.assets[0]);
    }
  };

  const removeFile = (file) => {
    Alert.alert('X√°c nh·∫≠n', 'X√≥a ·∫£nh n√†y?', [
      { text: 'H·ªßy', style: 'cancel' },
      {
        text: 'X√≥a',
        style: 'destructive',
        onPress: () => {
          setFiles((prev) => prev.filter((f) => f.uri !== file.uri));
        },
      },
    ]);
  };

  const viewFile = (file) => {
    if (file.url) {
      Linking.openURL(file.url).catch(() =>
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ m·ªü t·ªáp.')
      );
    }
  };

  const handleConfirm = async () => {
    if (files.length === 0) {
      Alert.alert('Thi·∫øu ·∫£nh', 'Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt ·∫£nh ƒë·ªÉ x√°c nh·∫≠n.');
      return;
    }

    setSaving(true);
    try {
      console.log('[ConfirmPOScreen] Starting confirmation process');
      console.log('[ConfirmPOScreen] Files count:', files.length);
      // Chu·∫©n b·ªã m·∫£ng file ƒë·ªÉ upload
      const filesToUpload = await Promise.all(
        files.map(async (file, index) => {
          console.log(
            `[ConfirmPOScreen] Processing file ${index + 1}/${files.length}: ${
              file.name
            }`
          );
          // ƒê·ªçc base64 cho m·ªói file
          const base64Data = await FileSystem.readAsStringAsync(file.uri, {
            encoding: FileSystem.EncodingType.Base64,
          });
          console.log(
            `[ConfirmPOScreen] File ${index + 1} base64 data length: ${
              base64Data.length
            }`
          );
          return {
            base64Data,
            fileName: file.name,
            mimeType: file.mimeType || 'image/jpeg',
          };
        })
      );

      console.log(
        '[ConfirmPOScreen] All files prepared, calling confirmReceipt'
      );
      console.log('[ConfirmPOScreen] PO ID:', po.id);
      console.log('[ConfirmPOScreen] Project ID:', po.projectId);

      const result = await confirmReceipt({
        poId: po.id,
        projectId: po.projectId,
        files: filesToUpload,
        remarks,
      });

      console.log('[ConfirmPOScreen] Confirmation successful');

      // Show success message with inventory update info
      Alert.alert(
        'Th√†nh c√¥ng',
        'ƒê√£ x√°c nh·∫≠n nh·∫≠n h√†ng th√†nh c√¥ng. V·∫≠t t∆∞ ƒë√£ ƒë∆∞·ª£c t·ª± ƒë·ªông th√™m v√†o kho.',
        [
          {
            text: 'OK',
            onPress: () => navigation.goBack(),
          },
        ]
      );
    } catch (e) {
      console.error('[ConfirmPOScreen] Confirmation error:', e);
      // L·ªói ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω v√† hi·ªÉn th·ªã b·ªüi hook, kh√¥ng c·∫ßn l√†m g√¨ th√™m ·ªü ƒë√¢y.
      console.log(
        'Handle confirm caught an error, but it should have been handled by the hook.'
      );
    } finally {
      setSaving(false);
    }
  };

  const renderMaterial = ({ item, index }) => (
    <View style={styles.materialRow}>
      <Text style={{ flex: 1 }}>
        {index + 1}. {item.name}
      </Text>
      <Text style={{ width: 80, textAlign: 'right' }}>
        {item.quantity} {item.unit}
      </Text>
    </View>
  );

  return (
    <ScrollView style={styles.container}>
      <Text style={styles.title}>PO: {po.poNumber || po.id}</Text>
      <Text style={styles.label}>Nh√† cung c·∫•p: {po.supplierName}</Text>
      <Text style={styles.label}>
        Ng√†y t·∫°o:{' '}
        {po.createdAt?.seconds
          ? new Date(po.createdAt.seconds * 1000).toLocaleDateString('vi-VN')
          : ''}
      </Text>

      <Text style={[styles.sectionTitle, { marginTop: 12 }]}>V·∫≠t t∆∞</Text>
      <FlatList
        data={po.materials || []}
        keyExtractor={(_, idx) => idx.toString()}
        renderItem={renderMaterial}
        scrollEnabled={false}
      />

      {/* Th√™m th√¥ng b√°o v·ªÅ t·ª± ƒë·ªông c·∫≠p nh·∫≠t kho */}
      <View style={styles.autoUpdateNote}>
        <Ionicons name="information-circle-outline" size={20} color="#0066cc" />
        <Text style={styles.autoUpdateText}>
          V·∫≠t t∆∞ s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông th√™m v√†o kho khi x√°c nh·∫≠n nh·∫≠n h√†ng
        </Text>
      </View>

      <Text style={[styles.sectionTitle, { marginTop: 12 }]}>·∫¢nh x√°c nh·∫≠n</Text>

      {loading && uploadProgress > 0 && (
        <View style={styles.progressContainer}>
          {Platform.OS === 'android' ? (
            <ProgressBarAndroid
              styleAttr="Horizontal"
              indeterminate={false}
              progress={uploadProgress / 100}
              style={styles.progressBar}
            />
          ) : (
            <ProgressViewIOS
              progress={uploadProgress / 100}
              style={styles.progressBar}
            />
          )}
          <Text style={styles.progressText}>
            ƒêang t·∫£i l√™n... {Math.round(uploadProgress)}%
          </Text>
        </View>
      )}

      <View style={styles.imagesContainer}>
        {files.map((file, idx) => (
          <View key={idx} style={styles.fileContainer}>
            <TouchableOpacity
              style={styles.fileThumb}
              onPress={() => viewFile(file)}
            >
              <Image source={{ uri: file.uri }} style={styles.imageThumb} />
              {file.isUploading && (
                <View style={styles.uploadingOverlay}>
                  <ActivityIndicator color="#fff" size="small" />
                </View>
              )}
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.removeBtn}
              onPress={() => removeFile(file)}
            >
              <Ionicons name="close-circle" size={20} color="#ff4444" />
            </TouchableOpacity>
          </View>
        ))}
        <TouchableOpacity style={styles.addImage} onPress={pickFile}>
          <Ionicons name="add" size={28} color="#777" />
        </TouchableOpacity>

        <TouchableOpacity style={styles.addImage} onPress={takePhoto}>
          <Ionicons name="camera" size={26} color="#777" />
        </TouchableOpacity>
      </View>

      <Text style={[styles.sectionTitle, { marginTop: 12 }]}>Ghi ch√∫</Text>
      <TextInput
        style={styles.remarksInput}
        placeholder="Ghi ch√∫ th√™m..."
        value={remarks}
        onChangeText={setRemarks}
        multiline
      />

      <TouchableOpacity
        style={[styles.confirmBtn, (loading || saving) && { opacity: 0.7 }]}
        onPress={handleConfirm}
        disabled={loading || saving}
      >
        {loading || saving ? (
          <ActivityIndicator color="#fff" />
        ) : (
          <Ionicons name="checkmark-circle-outline" size={20} color="#fff" />
        )}
        <Text style={styles.confirmText}>X√°c nh·∫≠n v√† c·∫≠p nh·∫≠t kho</Text>
      </TouchableOpacity>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, padding: 16, backgroundColor: '#fff' },
  centered: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  title: { fontSize: 18, fontWeight: 'bold' },
  label: { fontSize: 14, marginTop: 4 },
  sectionTitle: { fontSize: 16, fontWeight: '600' },
  materialRow: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    paddingVertical: 6,
  },
  autoUpdateNote: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#e3f2fd',
    padding: 10,
    borderRadius: 6,
    marginTop: 10,
  },
  autoUpdateText: {
    color: '#0066cc',
    fontSize: 14,
    marginLeft: 8,
  },
  imagesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginTop: 8,
  },
  fileContainer: {
    position: 'relative',
    marginRight: 8,
    marginBottom: 8,
  },
  fileThumb: {
    width: 80,
    height: 80,
    borderRadius: 4,
    overflow: 'hidden',
  },
  imageThumb: {
    width: 80,
    height: 80,
    borderRadius: 4,
  },
  uploadingOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0,0,0,0.4)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  removeBtn: {
    position: 'absolute',
    top: -8,
    right: -8,
    backgroundColor: '#fff',
    borderRadius: 10,
    elevation: 2,
    shadowColor: '#000',
    shadowOpacity: 0.2,
    shadowOffset: { width: 0, height: 1 },
    shadowRadius: 2,
  },
  addImage: {
    width: 80,
    height: 80,
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 4,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 8,
    marginRight: 8,
  },
  remarksInput: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 4,
    padding: 8,
    minHeight: 80,
    textAlignVertical: 'top',
    marginTop: 4,
  },
  progressContainer: {
    marginVertical: 10,
  },
  progressBar: {
    height: 6,
    marginBottom: 4,
  },
  progressText: {
    fontSize: 12,
    color: '#666',
    textAlign: 'center',
  },
  confirmBtn: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#28a745',
    paddingVertical: 12,
    borderRadius: 6,
    marginTop: 20,
  },
  confirmText: {
    color: '#fff',
    fontSize: 16,
    marginLeft: 8,
    fontWeight: '600',
  },
});

export default ConfirmPOReceiptScreen;


--- END: src\screens\ConfirmPOReceiptScreen.js ---


--- START: src\screens\CreateDeliveryNoteScreen.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  Alert,
  ActivityIndicator,
  FlatList,
  Modal,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import useDeliveryNoteGenerator from '../hooks/useDeliveryNoteGenerator';
import { doc, getDoc } from 'firebase/firestore';
import { db } from '../config/firebaseConfig';
import { GoogleSignin } from '@react-native-google-signin/google-signin';

const CreateDeliveryNoteScreen = ({ route, navigation }) => {
  const { projectId, materials: initialMaterials } = route.params;
  const [projectData, setProjectData] = useState(null);
  const [loadingProject, setLoadingProject] = useState(false);
  const [fileId, setFileId] = useState('');

  const [deliveryNoteNumber, setDeliveryNoteNumber] = useState(
    `BBGH-${new Date().getFullYear()}-${String(
      Math.floor(Math.random() * 1000)
    ).padStart(3, '0')}`
  );
  const [deliveryDate, setDeliveryDate] = useState(new Date());
  const [customerName, setCustomerName] = useState('');
  const [customerTaxCode, setCustomerTaxCode] = useState('');
  const [customerAddress, setCustomerAddress] = useState('');
  const [customerRepresentative, setCustomerRepresentative] = useState('');
  const [customerRepresentativePosition, setCustomerRepresentativePosition] =
    useState('');

  const [items, setItems] = useState([]);

  const {
    generateDeliveryNote,
    shareDeliveryNote,
    isLoading,
    excelUrl,
    latestQuotation,
    isLoadingQuotation,
  } = useDeliveryNoteGenerator({ projectId });

  // Fetch project data including materials and customer info
  useEffect(() => {
    const fetchProjectData = async () => {
      try {
        setLoadingProject(true);
        const projectRef = doc(db, 'projects', projectId);
        const projectSnap = await getDoc(projectRef);

        if (projectSnap.exists()) {
          const project = { id: projectSnap.id, ...projectSnap.data() };
          setProjectData(project);

          // Set customer info
          if (project.customerName) setCustomerName(project.customerName);
          if (project.customerTaxCode)
            setCustomerTaxCode(project.customerTaxCode);
          if (project.customerAddress)
            setCustomerAddress(project.customerAddress);
        }
      } catch (error) {
        console.error('Error fetching project data:', error);
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i th√¥ng tin d·ª± √°n');
      } finally {
        setLoadingProject(false);
      }
    };

    fetchProjectData();
  }, [projectId]);

  // Use materials from latest quotation when available
  useEffect(() => {
    if (
      latestQuotation &&
      latestQuotation.materials &&
      latestQuotation.materials.length > 0
    ) {
      console.log(
        'Using materials from latest quotation:',
        latestQuotation.quotationNumber
      );

      // Transform materials from quotation to the format needed for delivery note
      const transformedItems = latestQuotation.materials.map((item) => ({
        stt: item.stt,
        name: item.name || item.description || '',
        material: item.material || item.type || '',
        unit: item.unit || '',
        quantity: item.quantity || 0,
        selected: false, // Add selected property initialized to false
      }));

      setItems(transformedItems);
    } else if (initialMaterials && initialMaterials.length > 0) {
      // Fallback to materials passed in route params
      console.log('Using materials from route params');
      const transformedItems = initialMaterials.map((item) => ({
        stt: item.stt,
        name: item.name || item.description || '',
        material: item.material || item.type || '',
        unit: item.unit || '',
        quantity: item.quantity || 0,
        selected: false, // Add selected property initialized to false
      }));

      setItems(transformedItems);
    } else {
      // Add an empty item if no materials are found
      console.log('No materials found, adding empty item');
      setItems([
        {
          stt: '',
          name: '',
          material: '',
          unit: '',
          quantity: '',
          selected: false,
        },
      ]);
    }
  }, [latestQuotation, initialMaterials]);

  const handleAddItem = () => {
    setItems([
      ...items,
      {
        stt: '',
        name: '',
        material: '',
        unit: '',
        quantity: '',
        selected: false,
      },
    ]);
  };

  const handleItemChange = (index, field, value) => {
    const newItems = [...items];
    newItems[index][field] = value;
    setItems(newItems);
  };

  const handleToggleItemSelection = (index) => {
    const newItems = [...items];
    newItems[index].selected = !newItems[index].selected;
    setItems(newItems);
  };

  const handleGenerate = async () => {
    // Basic validation
    if (!customerName) {
      Alert.alert('Th√¥ng b√°o', 'Vui l√≤ng nh·∫≠p t√™n kh√°ch h√†ng');
      return;
    }

    // Check if any items are selected
    const selectedItems = items.filter((item) => item.selected);

    if (selectedItems.length === 0) {
      Alert.alert(
        'Th√¥ng b√°o',
        'Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt v·∫≠t t∆∞ ƒë·ªÉ ƒë∆∞a v√†o bi√™n b·∫£n giao h√†ng'
      );
      return;
    }

    // Check if selected items have name and quantity
    if (!selectedItems.some((item) => item.name && item.quantity)) {
      Alert.alert(
        'Th√¥ng b√°o',
        'Vui l√≤ng ƒë·∫£m b·∫£o c√°c v·∫≠t t∆∞ ƒë√£ ch·ªçn c√≥ t√™n v√† s·ªë l∆∞·ª£ng'
      );
      return;
    }

    const deliveryNoteData = {
      deliveryNoteNumber,
      deliveryDate: deliveryDate.toISOString(),
      customerName,
      customerTaxCode,
      customerAddress,
      customerRepresentative,
      customerRepresentativePosition,
      items: selectedItems, // Only include selected items
    };

    try {
      console.log('Generating delivery note with data:', deliveryNoteData);
      const url = await generateDeliveryNote(deliveryNoteData);
      if (url) {
        Alert.alert(
          'Th√†nh c√¥ng',
          'ƒê√£ t·∫°o bi√™n b·∫£n giao h√†ng th√†nh c√¥ng. B·∫°n c√≥ mu·ªën chia s·∫ª kh√¥ng?',
          [
            { text: 'ƒê·ªÉ sau', style: 'cancel' },
            { text: 'Chia s·∫ª', onPress: shareDeliveryNote },
          ]
        );
      }
    } catch (error) {
      console.error('Error in handleGenerate:', error);
      // Error is already handled in the hook
    }
  };

  if (loadingProject || isLoadingQuotation) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#007BFF" />
        <Text style={styles.loadingText}>
          {isLoadingQuotation
            ? 'ƒêang t·∫£i b√°o gi√° g·∫ßn nh·∫•t...'
            : 'ƒêang t·∫£i d·ªØ li·ªáu d·ª± √°n...'}
        </Text>
      </View>
    );
  }

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <View style={styles.header}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>T·∫°o Bi√™n B·∫£n Giao H√†ng</Text>
        <View style={{ width: 24 }} />
      </View>

      {latestQuotation && (
        <View style={styles.quotationInfo}>
          <Text style={styles.quotationInfoText}>
            S·ª≠ d·ª•ng d·ªØ li·ªáu t·ª´ b√°o gi√°:{' '}
            {latestQuotation.quotationNumber || 'Kh√¥ng c√≥ m√£'}
          </Text>
        </View>
      )}

      <ScrollView style={styles.content}>
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Th√¥ng tin chung</Text>
          <TextInput
            style={styles.input}
            placeholder="S·ªë bi√™n b·∫£n"
            value={deliveryNoteNumber}
            onChangeText={setDeliveryNoteNumber}
          />
          <Text style={styles.dateText}>
            Ng√†y: {deliveryDate.toLocaleDateString('vi-VN')}
          </Text>
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Th√¥ng tin kh√°ch h√†ng (B√™n B)</Text>
          <TextInput
            style={styles.input}
            placeholder="T√™n kh√°ch h√†ng"
            value={customerName}
            onChangeText={setCustomerName}
          />
          <TextInput
            style={styles.input}
            placeholder="M√£ s·ªë thu·∫ø"
            value={customerTaxCode}
            onChangeText={setCustomerTaxCode}
          />
          <TextInput
            style={styles.input}
            placeholder="ƒê·ªãa ch·ªâ"
            value={customerAddress}
            onChangeText={setCustomerAddress}
          />
          <TextInput
            style={styles.input}
            placeholder="Ng∆∞·ªùi ƒë·∫°i di·ªán"
            value={customerRepresentative}
            onChangeText={setCustomerRepresentative}
          />
          <TextInput
            style={styles.input}
            placeholder="Ch·ª©c v·ª•"
            value={customerRepresentativePosition}
            onChangeText={setCustomerRepresentativePosition}
          />
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Danh s√°ch v·∫≠t t∆∞</Text>
          <Text style={styles.selectionNote}>
            Ch·ªçn c√°c v·∫≠t t∆∞ c·∫ßn ƒë∆∞a v√†o bi√™n b·∫£n giao h√†ng
          </Text>
          {items.map((item, index) => (
            <View key={index} style={styles.itemRow}>
              <TouchableOpacity
                style={styles.checkbox}
                onPress={() => handleToggleItemSelection(index)}
              >
                <Ionicons
                  name={item.selected ? 'checkbox' : 'square-outline'}
                  size={24}
                  color={item.selected ? '#28A745' : '#999'}
                />
              </TouchableOpacity>
              <TextInput
                style={[styles.itemInput, { flex: 3 }]}
                placeholder="T√™n v·∫≠t t∆∞, h√†ng h√≥a"
                value={item.name}
                onChangeText={(value) => handleItemChange(index, 'name', value)}
              />
              <TextInput
                style={[styles.itemInput, { flex: 2 }]}
                placeholder="V·∫≠t li·ªáu"
                value={item.material}
                onChangeText={(value) =>
                  handleItemChange(index, 'material', value)
                }
              />
              <TextInput
                style={[styles.itemInput, { flex: 1 }]}
                placeholder="ƒêVT"
                value={item.unit}
                onChangeText={(value) => handleItemChange(index, 'unit', value)}
              />
              <TextInput
                style={[styles.itemInput, { flex: 1 }]}
                placeholder="S·ªë l∆∞·ª£ng"
                value={String(item.quantity)}
                onChangeText={(value) =>
                  handleItemChange(index, 'quantity', value)
                }
                keyboardType="numeric"
              />
            </View>
          ))}
          <TouchableOpacity style={styles.addButton} onPress={handleAddItem}>
            <Ionicons name="add-circle" size={24} color="#007BFF" />
            <Text style={styles.addButtonText}>Th√™m v·∫≠t t∆∞</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>

      <View style={styles.footer}>
        <TouchableOpacity
          style={styles.generateButton}
          onPress={handleGenerate}
          disabled={isLoading}
        >
          {isLoading ? (
            <ActivityIndicator color="#fff" />
          ) : (
            <Text style={styles.generateButtonText}>
              T·∫°o Bi√™n B·∫£n Giao H√†ng
            </Text>
          )}
        </TouchableOpacity>

        {excelUrl && (
          <TouchableOpacity
            style={styles.shareButton}
            onPress={shareDeliveryNote}
            disabled={isLoading}
          >
            <Text style={styles.shareButtonText}>Chia s·∫ª File</Text>
          </TouchableOpacity>
        )}
      </View>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F5F5',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 16,
    backgroundColor: '#FFF',
    borderBottomWidth: 1,
    borderBottomColor: '#EEE',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  content: {
    flex: 1,
  },
  section: {
    backgroundColor: '#FFF',
    padding: 16,
    marginVertical: 8,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  selectionNote: {
    fontSize: 14,
    fontStyle: 'italic',
    color: '#666',
    marginBottom: 8,
  },
  input: {
    borderWidth: 1,
    borderColor: '#DDD',
    borderRadius: 8,
    padding: 12,
    marginBottom: 12,
    fontSize: 16,
  },
  dateText: {
    fontSize: 16,
    color: '#333',
    marginBottom: 12,
  },
  itemRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  checkbox: {
    marginRight: 8,
  },
  itemInput: {
    borderWidth: 1,
    borderColor: '#DDD',
    borderRadius: 8,
    padding: 8,
    marginRight: 8,
    fontSize: 14,
  },
  addButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
  },
  addButtonText: {
    marginLeft: 8,
    color: '#007BFF',
    fontSize: 16,
  },
  footer: {
    padding: 16,
    backgroundColor: '#FFF',
    borderTopWidth: 1,
    borderTopColor: '#EEE',
  },
  generateButton: {
    backgroundColor: '#28A745',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
  },
  generateButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  shareButton: {
    backgroundColor: '#17A2B8',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 10,
  },
  shareButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#333',
  },
  quotationInfo: {
    backgroundColor: '#E3F2FD',
    padding: 10,
    alignItems: 'center',
  },
  quotationInfoText: {
    color: '#0D47A1',
    fontWeight: '500',
  },
});

export default CreateDeliveryNoteScreen;


--- END: src\screens\CreateDeliveryNoteScreen.js ---


--- START: src\screens\CreatePaymentRequestScreen.js ---
// src/screens/CreatePaymentRequestScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  TextInput,
  ScrollView,
  ActivityIndicator,
  SafeAreaView,
  Alert,
  KeyboardAvoidingView,
  Platform,
  Modal,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import { getProjectById } from '../api/projectService';
import { createPaymentRequest, logPayment } from '../api/paymentService';
import { getQuotationsByProject } from '../api/quotationService';
import DateTimePicker from '@react-native-community/datetimepicker';

const CreatePaymentRequestScreen = ({ route, navigation }) => {
  const { projectId } = route.params;
  const { theme } = useTheme();
  const { currentUser } = useAuth();
  const [project, setProject] = useState(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);

  // Form fields
  const [amount, setAmount] = useState('');
  const [description, setDescription] = useState('');
  const [dueDate, setDueDate] = useState(new Date());
  const [requestNumber, setRequestNumber] = useState('');
  const [showDatePicker, setShowDatePicker] = useState(false);

  // Payment modal
  const [showPaymentModal, setShowPaymentModal] = useState(false);
  const [paymentAmount, setPaymentAmount] = useState('');
  const [paymentMethod, setPaymentMethod] = useState('Chuy·ªÉn kho·∫£n');
  const [paymentNotes, setPaymentNotes] = useState('');
  const [paymentDate, setPaymentDate] = useState(new Date());
  const [showPaymentDatePicker, setShowPaymentDatePicker] = useState(false);
  const [addingPayment, setAddingPayment] = useState(false);

  // Quotation and payment info
  const [latestQuotation, setLatestQuotation] = useState(null);
  const [totalPaidAmount, setTotalPaidAmount] = useState(0);
  const [loadingQuotation, setLoadingQuotation] = useState(false);

  useEffect(() => {
    const loadProject = async () => {
      try {
        setLoading(true);
        const projectData = await getProjectById(projectId);
        if (!projectData) {
          Alert.alert('L·ªói', 'Kh√¥ng t√¨m th·∫•y th√¥ng tin d·ª± √°n');
          navigation.goBack();
          return;
        }
        setProject(projectData);

        // Generate a default request number
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const randomNum = Math.floor(Math.random() * 1000)
          .toString()
          .padStart(3, '0');
        setRequestNumber(`YCTT-${year}${month}${day}-${randomNum}`);
      } catch (error) {
        console.error('Error loading project:', error);
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i th√¥ng tin d·ª± √°n');
      } finally {
        setLoading(false);
      }
    };

    loadProject();
  }, [projectId, navigation]);

  // Load quotation and payment info
  const loadQuotationAndPaymentInfo = async () => {
    try {
      setLoadingQuotation(true);

      // Get latest quotation
      const quotations = await getQuotationsByProject(projectId);
      if (quotations && quotations.length > 0) {
        const latestQuote = quotations[0];
        setLatestQuotation(latestQuote);

        // Debug: log all fields of the quotation
        console.log('Latest quotation data:', latestQuote);
        console.log('Available fields:', Object.keys(latestQuote));

        // Check multiple possible field names for total amount
        const totalAmount =
          latestQuote.grandTotal ||
          latestQuote.totalAmount ||
          latestQuote.amount ||
          latestQuote.total ||
          latestQuote.quotationAmount ||
          latestQuote.finalAmount ||
          0;

        console.log('Found total amount:', totalAmount);
        console.log('Field values:', {
          grandTotal: latestQuote.grandTotal,
          totalAmount: latestQuote.totalAmount,
          amount: latestQuote.amount,
          total: latestQuote.total,
          quotationAmount: latestQuote.quotationAmount,
          finalAmount: latestQuote.finalAmount,
          afterDiscountTotal: latestQuote.afterDiscountTotal,
          subTotal: latestQuote.subTotal,
        });
      }

      // Get total paid amount from existing payment requests
      const { getPaymentRequestsByProject } = await import(
        '../api/paymentService'
      );
      const paymentRequests = await getPaymentRequestsByProject(projectId);

      const totalPaid = paymentRequests.reduce((sum, request) => {
        return sum + (request.totalPaid || 0);
      }, 0);

      setTotalPaidAmount(totalPaid);

      console.log('Total paid:', totalPaid);
    } catch (error) {
      console.error('Error loading quotation and payment info:', error);
    } finally {
      setLoadingQuotation(false);
    }
  };

  // Helper function to get quotation total amount
  const getQuotationTotalAmount = (quotation) => {
    if (!quotation) return 0;

    // Check multiple possible field names for total amount
    return (
      quotation.grandTotal ||
      quotation.totalAmount ||
      quotation.amount ||
      quotation.total ||
      quotation.quotationAmount ||
      quotation.finalAmount ||
      quotation.afterDiscountTotal ||
      quotation.subTotal ||
      0
    );
  };

  // Format currency
  const formatCurrency = (amount) => {
    if (!amount) return '0 ‚Ç´';
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
      minimumFractionDigits: 0,
    }).format(amount);
  };

  // Format date
  const formatDate = (date) => {
    return date.toLocaleDateString('vi-VN');
  };

  // Handle payment amount change
  const handlePaymentAmountChange = (text) => {
    // Remove all non-numeric characters
    const numberOnly = text.replace(/[^0-9]/g, '');

    if (numberOnly === '') {
      setPaymentAmount('');
      return;
    }

    // Format with commas
    const formatted = new Intl.NumberFormat('vi-VN').format(numberOnly);
    setPaymentAmount(formatted);
  };

  // Handle add manual payment
  const handleAddManualPayment = async () => {
    if (!paymentAmount) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p s·ªë ti·ªÅn thanh to√°n');
      return;
    }

    // Parse amount from formatted string
    const amountValue = parseFloat(paymentAmount.replace(/[^0-9]/g, ''));

    if (amountValue <= 0) {
      Alert.alert('L·ªói', 'S·ªë ti·ªÅn thanh to√°n ph·∫£i l·ªõn h∆°n 0');
      return;
    }

    try {
      setAddingPayment(true);

      // T·∫°o YCTT cho thanh to√°n th·ªß c√¥ng
      const manualPaymentRequestData = {
        projectId,
        requestNumber: `YCTT-MANUAL-${Date.now()}`,
        amount: amountValue,
        description: `Thanh to√°n th·ªß c√¥ng: ${
          paymentNotes || 'Kh√¥ng c√≥ ghi ch√∫'
        }`,
        issueDate: new Date(),
        dueDate: paymentDate,
        customerName: project?.customerName || 'Kh√¥ng x√°c ƒë·ªãnh',
        customerId: project?.customerId,
        status: 'paid', // ƒê√°nh d·∫•u l√† ƒë√£ thanh to√°n
        totalPaid: amountValue, // ƒê√£ thanh to√°n to√†n b·ªô
        misaInvoiceNumber: '',
        isManualPayment: true, // ƒê√°nh d·∫•u ƒë√¢y l√† thanh to√°n th·ªß c√¥ng
      };

      // T·∫°o YCTT
      const requestId = await createPaymentRequest(
        manualPaymentRequestData,
        currentUser?.uid
      );

      // T·∫°o payment record
      const paymentData = {
        amountPaid: amountValue,
        paymentMethod: paymentMethod,
        paymentDate: paymentDate,
        notes: paymentNotes || 'Thanh to√°n th·ªß c√¥ng',
        loggedBy: currentUser?.uid,
        loggedByName: currentUser?.displayName || currentUser?.email,
        isManualPayment: true,
      };

      // L∆∞u thanh to√°n v√†o database
      await logPayment(requestId, paymentData);

      Alert.alert(
        'Th√†nh c√¥ng',
        `ƒê√£ t·∫°o YCTT v√† th√™m thanh to√°n th·ªß c√¥ng: ${formatCurrency(
          amountValue
        )}`,
        [
          {
            text: 'Xem chi ti·∫øt',
            onPress: () =>
              navigation.navigate('PaymentRequestDetail', { requestId }),
          },
          {
            text: 'OK',
            onPress: () => {
              // Reset form
              setPaymentAmount('');
              setPaymentMethod('Chuy·ªÉn kho·∫£n');
              setPaymentNotes('');
              setPaymentDate(new Date());
              setShowPaymentModal(false);
            },
          },
        ]
      );
    } catch (error) {
      console.error('Error adding manual payment:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ th√™m thanh to√°n. Vui l√≤ng th·ª≠ l·∫°i.');
    } finally {
      setAddingPayment(false);
    }
  };

  const handleSave = async () => {
    // Validate form
    if (!amount) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p s·ªë ti·ªÅn');
      return;
    }

    if (!description) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p m√¥ t·∫£');
      return;
    }

    if (!requestNumber) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p s·ªë y√™u c·∫ßu thanh to√°n');
      return;
    }

    try {
      setSaving(true);

      const amountValue = parseFloat(amount.replace(/[^0-9]/g, ''));

      // Create payment request
      const paymentRequestData = {
        projectId,
        customerId: project.customerId,
        customerName: project.customerName,
        requestNumber,
        amount: amountValue,
        description,
        status: 'pending',
        issueDate: new Date(),
        dueDate,
        misaInvoiceNumber: '',
      };

      await createPaymentRequest(paymentRequestData, currentUser.uid);

      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ t·∫°o y√™u c·∫ßu thanh to√°n m·ªõi', [
        { text: 'OK', onPress: () => navigation.goBack() },
      ]);
    } catch (error) {
      console.error('Error creating payment request:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫°o y√™u c·∫ßu thanh to√°n');
    } finally {
      setSaving(false);
    }
  };

  // Format currency input
  const handleAmountChange = (text) => {
    // Remove non-digit characters
    const numberOnly = text.replace(/[^0-9]/g, '');
    if (numberOnly === '') {
      setAmount('');
      return;
    }

    // Format as currency
    const formatted = new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
      minimumFractionDigits: 0,
    }).format(numberOnly);

    setAmount(formatted);
  };

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={{ flex: 1 }}
      >
        <View style={[styles.header, { borderBottomColor: theme.border }]}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
          >
            <Ionicons name="arrow-back" size={24} color={theme.text} />
          </TouchableOpacity>
          <Text style={[styles.headerTitle, { color: theme.text }]}>
            T·∫°o Y√™u c·∫ßu Thanh to√°n
          </Text>
        </View>

        {loading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.primary} />
            <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
              ƒêang t·∫£i d·ªØ li·ªáu...
            </Text>
          </View>
        ) : (
          <ScrollView style={styles.content}>
            {/* Project Info */}
            <View
              style={[
                styles.projectInfo,
                { backgroundColor: theme.cardBackground },
              ]}
            >
              <Text style={[styles.projectName, { color: theme.text }]}>
                {project?.name || 'Kh√¥ng c√≥ t√™n'}
              </Text>
              <Text
                style={[styles.customerName, { color: theme.textSecondary }]}
              >
                {project?.customerName || 'Kh√¥ng c√≥ kh√°ch h√†ng'}
              </Text>
            </View>

            {/* Form Fields */}
            <View
              style={[
                styles.formContainer,
                { backgroundColor: theme.cardBackground },
              ]}
            >
              {/* Request Number */}
              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>
                  S·ªë y√™u c·∫ßu thanh to√°n
                </Text>
                <TextInput
                  style={[
                    styles.input,
                    {
                      backgroundColor: theme.inputBackground,
                      color: theme.text,
                      borderColor: theme.border,
                    },
                  ]}
                  value={requestNumber}
                  onChangeText={setRequestNumber}
                  placeholder="Nh·∫≠p s·ªë y√™u c·∫ßu thanh to√°n"
                  placeholderTextColor={theme.textMuted}
                />
              </View>

              {/* Amount */}
              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>
                  S·ªë ti·ªÅn
                </Text>
                <TextInput
                  style={[
                    styles.input,
                    {
                      backgroundColor: theme.inputBackground,
                      color: theme.text,
                      borderColor: theme.border,
                    },
                  ]}
                  value={amount}
                  onChangeText={handleAmountChange}
                  placeholder="Nh·∫≠p s·ªë ti·ªÅn"
                  placeholderTextColor={theme.textMuted}
                  keyboardType="numeric"
                />
              </View>

              {/* Description */}
              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>M√¥ t·∫£</Text>
                <TextInput
                  style={[
                    styles.input,
                    styles.textArea,
                    {
                      backgroundColor: theme.inputBackground,
                      color: theme.text,
                      borderColor: theme.border,
                    },
                  ]}
                  value={description}
                  onChangeText={setDescription}
                  placeholder="Nh·∫≠p m√¥ t·∫£ cho y√™u c·∫ßu thanh to√°n"
                  placeholderTextColor={theme.textMuted}
                  multiline
                  numberOfLines={3}
                />
              </View>

              {/* Due Date */}
              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>
                  H·∫°n thanh to√°n
                </Text>
                <TouchableOpacity
                  style={[
                    styles.input,
                    {
                      backgroundColor: theme.inputBackground,
                      borderColor: theme.border,
                    },
                  ]}
                  onPress={() => setShowDatePicker(true)}
                >
                  <Text style={{ color: theme.text }}>
                    {formatDate(dueDate)}
                  </Text>
                </TouchableOpacity>
              </View>

              {/* Manual Payment Button */}
              <View style={styles.formGroup}>
                <TouchableOpacity
                  style={[
                    styles.manualPaymentButton,
                    { backgroundColor: theme.primary },
                  ]}
                  onPress={async () => {
                    await loadQuotationAndPaymentInfo();
                    setShowPaymentModal(true);
                  }}
                >
                  <Ionicons
                    name="add-circle-outline"
                    size={20}
                    color="#FFFFFF"
                  />
                  <Text style={styles.manualPaymentButtonText}>
                    Th√™m thanh to√°n th·ªß c√¥ng
                  </Text>
                </TouchableOpacity>
              </View>
            </View>

            {/* Save Button */}
            <TouchableOpacity
              style={[
                styles.saveButton,
                { backgroundColor: theme.primary },
                saving && { opacity: 0.6 },
              ]}
              onPress={handleSave}
              disabled={saving}
            >
              {saving ? (
                <ActivityIndicator color="#FFFFFF" size="small" />
              ) : (
                <>
                  <Ionicons
                    name="document-text-outline"
                    size={20}
                    color="#FFFFFF"
                  />
                  <Text style={styles.saveButtonText}>
                    L∆∞u y√™u c·∫ßu thanh to√°n
                  </Text>
                </>
              )}
            </TouchableOpacity>
          </ScrollView>
        )}

        {/* Date Picker */}
        {showDatePicker && (
          <DateTimePicker
            value={dueDate}
            mode="date"
            display="default"
            onChange={handleDueDateChange}
          />
        )}

        {/* Payment Modal */}
        <Modal
          visible={showPaymentModal}
          animationType="slide"
          transparent={true}
          onRequestClose={() => setShowPaymentModal(false)}
        >
          <View style={styles.modalOverlay}>
            <View
              style={[
                styles.modalContent,
                { backgroundColor: theme.cardBackground },
              ]}
            >
              <View style={styles.modalHeader}>
                <Text style={[styles.modalTitle, { color: theme.text }]}>
                  Th√™m thanh to√°n th·ªß c√¥ng
                </Text>
                <TouchableOpacity
                  onPress={() => setShowPaymentModal(false)}
                  style={styles.closeButton}
                >
                  <Ionicons name="close" size={24} color={theme.text} />
                </TouchableOpacity>
              </View>

              <ScrollView style={styles.modalBody}>
                {/* Project Info */}
                <View
                  style={[
                    styles.modalInfoSection,
                    { borderBottomColor: theme.border },
                  ]}
                >
                  <Text
                    style={[
                      styles.modalInfoTitle,
                      { color: theme.textSecondary },
                    ]}
                  >
                    Th√¥ng tin d·ª± √°n
                  </Text>
                  <Text style={[styles.modalInfoText, { color: theme.text }]}>
                    {project?.name || 'Kh√¥ng c√≥ t√™n'}
                  </Text>
                  <Text style={[styles.modalInfoText, { color: theme.text }]}>
                    Kh√°ch h√†ng: {project?.customerName || 'Kh√¥ng x√°c ƒë·ªãnh'}
                  </Text>
                </View>

                {/* Quotation and Payment Summary */}
                {loadingQuotation ? (
                  <View style={styles.loadingSection}>
                    <ActivityIndicator size="small" color={theme.primary} />
                    <Text
                      style={[
                        styles.loadingText,
                        { color: theme.textSecondary },
                      ]}
                    >
                      ƒêang t·∫£i th√¥ng tin b√°o gi√°...
                    </Text>
                  </View>
                ) : latestQuotation ? (
                  <View
                    style={[
                      styles.quotationSection,
                      { borderBottomColor: theme.border },
                    ]}
                  >
                    <Text
                      style={[
                        styles.quotationTitle,
                        { color: theme.textSecondary },
                      ]}
                    >
                      B√°o gi√° g·∫ßn nh·∫•t
                    </Text>
                    <View style={styles.quotationInfo}>
                      <Text
                        style={[styles.quotationText, { color: theme.text }]}
                      >
                        T·ªïng b√°o gi√°:{' '}
                        {formatCurrency(
                          getQuotationTotalAmount(latestQuotation)
                        )}
                      </Text>
                      <Text
                        style={[styles.quotationText, { color: theme.text }]}
                      >
                        ƒê√£ thanh to√°n: {formatCurrency(totalPaidAmount)}
                      </Text>
                      <Text
                        style={[styles.quotationText, { color: '#FF9800' }]}
                      >
                        C√≤n l·∫°i:{' '}
                        {formatCurrency(
                          (getQuotationTotalAmount(latestQuotation) || 0) -
                            totalPaidAmount
                        )}
                      </Text>
                    </View>
                    <View style={styles.paymentProgress}>
                      <Text
                        style={[
                          styles.progressText,
                          { color: theme.textSecondary },
                        ]}
                      >
                        Ti·∫øn ƒë·ªô thanh to√°n: {formatCurrency(totalPaidAmount)} /{' '}
                        {formatCurrency(
                          getQuotationTotalAmount(latestQuotation) || 0
                        )}
                      </Text>
                      <View style={styles.progressBar}>
                        <View
                          style={[
                            styles.progressFill,
                            {
                              width: `${Math.min(
                                100,
                                (totalPaidAmount /
                                  (getQuotationTotalAmount(latestQuotation) ||
                                    1)) *
                                  100
                              )}%`,
                              backgroundColor:
                                totalPaidAmount >=
                                (getQuotationTotalAmount(latestQuotation) || 0)
                                  ? '#4CAF50'
                                  : theme.primary,
                            },
                          ]}
                        />
                      </View>
                    </View>
                  </View>
                ) : (
                  <View style={styles.noQuotationSection}>
                    <Ionicons
                      name="document-outline"
                      size={24}
                      color={theme.textMuted}
                    />
                    <Text
                      style={[
                        styles.noQuotationText,
                        { color: theme.textSecondary },
                      ]}
                    >
                      Ch∆∞a c√≥ b√°o gi√° cho d·ª± √°n n√†y
                    </Text>
                  </View>
                )}

                {/* Payment Form */}
                <View style={styles.modalFormSection}>
                  <Text style={[styles.modalFormTitle, { color: theme.text }]}>
                    Th√¥ng tin thanh to√°n
                  </Text>

                  <View style={styles.formGroup}>
                    <Text
                      style={[styles.formLabel, { color: theme.textSecondary }]}
                    >
                      S·ªë ti·ªÅn thanh to√°n *
                    </Text>
                    <TextInput
                      style={[
                        styles.formInput,
                        {
                          backgroundColor: theme.inputBackground,
                          color: theme.text,
                          borderColor: theme.border,
                        },
                      ]}
                      value={paymentAmount}
                      onChangeText={handlePaymentAmountChange}
                      placeholder="Nh·∫≠p s·ªë ti·ªÅn"
                      placeholderTextColor={theme.textMuted}
                      keyboardType="numeric"
                    />
                  </View>

                  <View style={styles.formGroup}>
                    <Text
                      style={[styles.formLabel, { color: theme.textSecondary }]}
                    >
                      Ph∆∞∆°ng th·ª©c thanh to√°n
                    </Text>
                    <View style={styles.paymentMethodContainer}>
                      {['Chuy·ªÉn kho·∫£n', 'Ti·ªÅn m·∫∑t', 'S√©c', 'Kh√°c'].map(
                        (method) => (
                          <TouchableOpacity
                            key={method}
                            style={[
                              styles.paymentMethodOption,
                              {
                                backgroundColor:
                                  paymentMethod === method
                                    ? theme.primary
                                    : theme.inputBackground,
                                borderColor: theme.border,
                              },
                            ]}
                            onPress={() => setPaymentMethod(method)}
                          >
                            <Text
                              style={[
                                styles.paymentMethodText,
                                {
                                  color:
                                    paymentMethod === method
                                      ? '#FFFFFF'
                                      : theme.text,
                                },
                              ]}
                            >
                              {method}
                            </Text>
                          </TouchableOpacity>
                        )
                      )}
                    </View>
                  </View>

                  <View style={styles.formGroup}>
                    <Text
                      style={[styles.formLabel, { color: theme.textSecondary }]}
                    >
                      Ng√†y thanh to√°n
                    </Text>
                    <TouchableOpacity
                      style={[
                        styles.datePickerButton,
                        {
                          backgroundColor: theme.inputBackground,
                          borderColor: theme.border,
                        },
                      ]}
                      onPress={() => setShowPaymentDatePicker(true)}
                    >
                      <Ionicons
                        name="calendar-outline"
                        size={20}
                        color={theme.text}
                      />
                      <Text
                        style={[styles.datePickerText, { color: theme.text }]}
                      >
                        {formatDate(paymentDate)}
                      </Text>
                    </TouchableOpacity>
                  </View>

                  <View style={styles.formGroup}>
                    <Text
                      style={[styles.formLabel, { color: theme.textSecondary }]}
                    >
                      Ghi ch√∫
                    </Text>
                    <TextInput
                      style={[
                        styles.formTextArea,
                        {
                          backgroundColor: theme.inputBackground,
                          color: theme.text,
                          borderColor: theme.border,
                        },
                      ]}
                      value={paymentNotes}
                      onChangeText={setPaymentNotes}
                      placeholder="Nh·∫≠p ghi ch√∫ (t√πy ch·ªçn)"
                      placeholderTextColor={theme.textMuted}
                      multiline
                      numberOfLines={3}
                    />
                  </View>
                </View>
              </ScrollView>

              <View style={styles.modalFooter}>
                <TouchableOpacity
                  style={[styles.modalButton, styles.cancelButton]}
                  onPress={() => setShowPaymentModal(false)}
                >
                  <Text style={styles.cancelButtonText}>H·ªßy</Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[
                    styles.modalButton,
                    styles.saveButton,
                    { backgroundColor: theme.primary },
                    addingPayment && { opacity: 0.6 },
                  ]}
                  onPress={handleAddManualPayment}
                  disabled={addingPayment}
                >
                  {addingPayment ? (
                    <ActivityIndicator size="small" color="#FFFFFF" />
                  ) : (
                    <Text style={styles.saveButtonText}>Th√™m thanh to√°n</Text>
                  )}
                </TouchableOpacity>
              </View>
            </View>
          </View>
        </Modal>

        {/* Payment Date Picker */}
        {showPaymentDatePicker && (
          <DateTimePicker
            value={paymentDate}
            mode="date"
            display="default"
            onChange={(event, selectedDate) => {
              setShowPaymentDatePicker(false);
              if (selectedDate) {
                setPaymentDate(selectedDate);
              }
            }}
          />
        )}
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
  },
  backButton: {
    marginRight: 16,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  projectInfo: {
    padding: 16,
    marginBottom: 16,
    borderRadius: 8,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  projectName: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  customerName: {
    fontSize: 14,
  },
  formContainer: {
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  formGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    marginBottom: 8,
  },
  input: {
    height: 48,
    borderWidth: 1,
    borderRadius: 8,
    paddingHorizontal: 12,
    fontSize: 16,
    justifyContent: 'center',
  },
  textArea: {
    minHeight: 80,
    textAlignVertical: 'top',
    paddingVertical: 10,
  },
  dateText: {
    fontSize: 16,
  },
  saveButton: {
    backgroundColor: '#0066cc',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 16,
    paddingHorizontal: 20,
    borderRadius: 8,
    marginHorizontal: 16,
    marginBottom: 20,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  saveButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
    textAlign: 'center',
  },
  manualPaymentButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 12,
    borderRadius: 8,
    marginTop: 10,
  },
  manualPaymentButtonText: {
    color: '#FFFFFF',
    fontSize: 14,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  modalContent: {
    width: '90%',
    maxHeight: '80%',
    borderRadius: 10,
    overflow: 'hidden',
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 4,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    backgroundColor: '#fff',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  closeButton: {
    padding: 5,
  },
  modalBody: {
    padding: 16,
    backgroundColor: '#fff',
  },
  modalInfoSection: {
    marginBottom: 16,
    paddingBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  modalInfoTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
    color: '#666',
  },
  modalInfoText: {
    fontSize: 14,
    marginBottom: 4,
    color: '#333',
  },
  modalFormSection: {
    marginTop: 16,
  },
  modalFormTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 12,
    color: '#333',
  },
  formLabel: {
    fontSize: 14,
    fontWeight: '500',
    marginBottom: 8,
  },
  formInput: {
    height: 48,
    borderWidth: 1,
    borderRadius: 8,
    paddingHorizontal: 12,
    fontSize: 16,
    backgroundColor: '#f9f9f9',
    borderColor: '#ddd',
    color: '#333',
  },
  paymentMethodContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-around',
    marginBottom: 16,
  },
  paymentMethodOption: {
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 20,
    marginVertical: 5,
    marginHorizontal: 5,
    borderWidth: 1,
    borderColor: '#ddd',
    backgroundColor: '#f9f9f9',
  },
  paymentMethodText: {
    fontSize: 14,
    fontWeight: '500',
    color: '#333',
  },
  datePickerButton: {
    flexDirection: 'row',
    alignItems: 'center',
    height: 48,
    borderWidth: 1,
    borderRadius: 8,
    paddingHorizontal: 12,
    borderColor: '#ddd',
    backgroundColor: '#f9f9f9',
  },
  datePickerText: {
    fontSize: 16,
    marginLeft: 10,
    color: '#333',
  },
  formTextArea: {
    minHeight: 80,
    textAlignVertical: 'top',
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderWidth: 1,
    borderRadius: 8,
    backgroundColor: '#f9f9f9',
    borderColor: '#ddd',
    color: '#333',
  },
  modalFooter: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
    backgroundColor: '#fff',
  },
  modalButton: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 8,
    alignItems: 'center',
    marginHorizontal: 5,
  },
  cancelButton: {
    backgroundColor: '#f5f5f5',
    borderWidth: 1,
    borderColor: '#ddd',
  },
  cancelButtonText: {
    color: '#666',
    fontSize: 16,
    fontWeight: 'bold',
  },
  saveButton: {
    backgroundColor: '#0066cc',
  },
  saveButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  loadingSection: {
    flexDirection: 'column',
    alignItems: 'center',
    paddingVertical: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 14,
  },
  quotationSection: {
    marginBottom: 16,
    paddingBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  quotationTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
    color: '#666',
  },
  quotationInfo: {
    marginBottom: 10,
  },
  quotationText: {
    fontSize: 14,
    marginBottom: 2,
  },
  paymentProgress: {
    marginTop: 10,
  },
  progressText: {
    fontSize: 14,
    marginBottom: 5,
    textAlign: 'center',
  },
  progressBar: {
    height: 8,
    backgroundColor: '#e0e0e0',
    borderRadius: 4,
    overflow: 'hidden',
  },
  progressFill: {
    height: '100%',
    borderRadius: 4,
  },
  noQuotationSection: {
    flexDirection: 'column',
    alignItems: 'center',
    paddingVertical: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  noQuotationText: {
    marginTop: 10,
    fontSize: 14,
    textAlign: 'center',
  },
});

export default CreatePaymentRequestScreen;


--- END: src\screens\CreatePaymentRequestScreen.js ---


--- START: src\screens\CreatePOScreen.js ---
import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  TextInput,
  Alert,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRoute, useNavigation } from '@react-navigation/native';
import SupplierPickerModal from '../components/SupplierPickerModal';
import usePurchaseOrderGenerator from '../hooks/usePurchaseOrderGenerator';

/**
 * CreatePOScreen
 * This is a simplified screen that pre-populates the material list coming
 * from route.params (passed from ProposalListScreen ‚Üí navigate('CreatePO', params)).
 * For now we only allow editing quantity / price; supplier info can be added later.
 */
const CreatePOScreen = () => {
  const route = useRoute();
  const navigation = useNavigation();

  // Supplier state & modal visibility
  const [showSupplierModal, setShowSupplierModal] = useState(false);
  const [supplier, setSupplier] = useState(null);

  // New state for PO info
  const [poNumber, setPoNumber] = useState('');
  const [proposalNumber, setProposalNumber] = useState('');
  const [deliveryTime, setDeliveryTime] = useState('');

  // VAT percentage
  const [vatPercentage, setVatPercentage] = useState(10);

  // Purchase order generator hook
  const { generatePurchaseOrder, loading } = usePurchaseOrderGenerator();

  const {
    projectName = '',
    projectId = '',
    materials: initMaterials = [],
  } = route.params || {};

  const [materials, setMaterials] = useState(
    initMaterials.length > 0
      ? initMaterials.map((m) => ({
          ...m,
          quantity: m.quantity?.toString() || '',
          unitPrice: m.unitPrice?.toString() || '',
        }))
      : [
          {
            name: '',
            specs: '',
            unit: '',
            quantity: '',
            unitPrice: '',
          },
        ]
  );

  const handleMaterialChange = (index, field, value) => {
    const updated = [...materials];
    updated[index] = { ...updated[index], [field]: value };
    setMaterials(updated);
  };

  const handleAddMaterial = () => {
    setMaterials([
      ...materials,
      { name: '', specs: '', unit: '', quantity: '', unitPrice: '' },
    ]);
  };

  const handleRemoveMaterial = (index) => {
    if (materials.length === 1) return;
    const updated = [...materials];
    updated.splice(index, 1);
    setMaterials(updated);
  };

  const subtotal = materials.reduce((sum, item) => {
    const qty = parseFloat(item.quantity) || 0;
    const price = parseFloat(item.unitPrice) || 0;
    return sum + qty * price;
  }, 0);

  const vatAmount = (subtotal * vatPercentage) / 100;
  const grandTotal = subtotal + vatAmount;

  const handleGeneratePO = async () => {
    if (!supplier) {
      Alert.alert('Thi·∫øu th√¥ng tin', 'Vui l√≤ng ch·ªçn Nh√† cung c·∫•p');
      return;
    }

    console.log('Starting PO generation for project ID:', projectId);

    const poData = {
      projectName,
      supplierName: supplier.name,
      supplierAddress: supplier.address || '',
      supplierPhone: supplier.phone || '',
      supplierEmail: supplier.email || '',
      supplierTaxCode: supplier.taxCode || '',
      materials,
      vatPercentage,
      // Add new fields
      poNumber,
      proposalNumber,
      deliveryTime,
    };

    try {
      console.log(
        'Calling generatePurchaseOrder with data:',
        JSON.stringify({
          projectId,
          supplierName: supplier.name,
          materialsCount: materials.length,
        })
      );

      const result = await generatePurchaseOrder(poData, projectId);
      console.log('PO generation successful, result:', result);
      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ t·∫°o ƒë∆°n ƒë·∫∑t h√†ng');
      navigation.goBack();
    } catch (err) {
      console.error('Error in handleGeneratePO:', err);
      // error is already handled in the hook
    }
  };

  return (
    <ScrollView style={styles.container}>
      <SupplierPickerModal
        visible={showSupplierModal}
        onClose={() => setShowSupplierModal(false)}
        onSelect={(sup) => {
          setSupplier(sup);
        }}
      />
      <Text style={styles.title}>T·∫°o PO cho d·ª± √°n: {projectName}</Text>

      {/* Supplier selection */}
      <View style={styles.supplierGroup}>
        <Text style={styles.label}>Nh√† cung c·∫•p</Text>
        <TouchableOpacity
          style={styles.selectButton}
          onPress={() => setShowSupplierModal(true)}
        >
          <Text style={styles.selectText}>
            {supplier ? supplier.name : 'Ch·ªçn nh√† cung c·∫•p'}
          </Text>
        </TouchableOpacity>
        {supplier && (
          <View style={{ marginTop: 4 }}>
            {supplier.address ? (
              <Text style={styles.supplierInfo}>{supplier.address}</Text>
            ) : null}
            {supplier.phone ? (
              <Text style={styles.supplierInfo}>ƒêT: {supplier.phone}</Text>
            ) : null}
          </View>
        )}
      </View>

      {/* PO Info Inputs */}
      <View style={styles.inputGroup}>
        <Text style={styles.label}>S·ªë ƒë∆°n ƒë·∫∑t h√†ng</Text>
        <TextInput
          style={styles.inputField}
          placeholder="Nh·∫≠p s·ªë ƒêƒêH (v√≠ d·ª•: PO-001)"
          value={poNumber}
          onChangeText={setPoNumber}
        />
      </View>
      <View style={styles.inputGroup}>
        <Text style={styles.label}>S·ªë ƒë·ªÅ xu·∫•t</Text>
        <TextInput
          style={styles.inputField}
          placeholder="Nh·∫≠p s·ªë ƒë·ªÅ xu·∫•t ƒë∆∞·ª£c duy·ªát"
          value={proposalNumber}
          onChangeText={setProposalNumber}
        />
      </View>
      <View style={styles.inputGroup}>
        <Text style={styles.label}>Th·ªùi gian giao h√†ng</Text>
        <TextInput
          style={styles.inputField}
          placeholder="Nh·∫≠p th·ªùi gian giao h√†ng (v√≠ d·ª•: 3-5 ng√†y)"
          value={deliveryTime}
          onChangeText={setDeliveryTime}
        />
      </View>

      {/* Materials list */}
      <View style={styles.sectionHeader}>
        <Text style={styles.sectionHeaderText}>Danh s√°ch v·∫≠t t∆∞</Text>
        <TouchableOpacity onPress={handleAddMaterial} style={styles.addBtn}>
          <Ionicons name="add-circle" size={22} color="#4CAF50" />
        </TouchableOpacity>
      </View>

      {materials.map((mat, idx) => {
        const total = (
          (parseFloat(mat.quantity) || 0) * (parseFloat(mat.unitPrice) || 0)
        ).toLocaleString('vi-VN');
        return (
          <View key={idx} style={styles.row}>
            <TextInput
              style={[styles.input, { flex: 3 }]}
              placeholder="T√™n v·∫≠t t∆∞"
              value={mat.name}
              onChangeText={(t) => handleMaterialChange(idx, 'name', t)}
            />
            <TextInput
              style={[styles.input, { flex: 1 }]}
              placeholder="SL"
              keyboardType="numeric"
              value={mat.quantity}
              onChangeText={(t) => handleMaterialChange(idx, 'quantity', t)}
            />
            <TextInput
              style={[styles.input, { flex: 2 }]}
              placeholder="ƒê∆°n gi√°"
              keyboardType="numeric"
              value={mat.unitPrice}
              onChangeText={(t) => handleMaterialChange(idx, 'unitPrice', t)}
            />
            <Text style={[styles.total, { flex: 2 }]}>{total}</Text>
            <TouchableOpacity onPress={() => handleRemoveMaterial(idx)}>
              <Ionicons name="trash-outline" size={18} color="red" />
            </TouchableOpacity>
          </View>
        );
      })}

      {/* Summary */}
      <View style={{ marginTop: 12 }}>
        <Text style={styles.summary}>
          T·∫°m t√≠nh: {subtotal.toLocaleString('vi-VN')} VND
        </Text>
        <View
          style={{ flexDirection: 'row', alignItems: 'center', marginTop: 6 }}
        >
          <Text style={styles.summary}>VAT (%) :</Text>
          <TextInput
            style={[styles.input, { width: 60, marginLeft: 6 }]}
            keyboardType="numeric"
            value={vatPercentage.toString()}
            onChangeText={(v) => setVatPercentage(parseFloat(v) || 0)}
          />
          <Text style={[styles.summary, { marginLeft: 6 }]}>
            {' '}
            = {vatAmount.toLocaleString('vi-VN')} VND
          </Text>
        </View>
        <Text style={styles.summary}>
          T·ªïng c·ªông: {grandTotal.toLocaleString('vi-VN')} VND
        </Text>
      </View>

      <TouchableOpacity
        style={styles.button}
        onPress={handleGeneratePO}
        disabled={loading}
      >
        <Ionicons name="document-text-outline" size={20} color="#fff" />
        <Text style={styles.buttonText}>T·∫°o ƒë∆°n ƒë·∫∑t h√†ng</Text>
      </TouchableOpacity>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, padding: 16, backgroundColor: '#fff' },
  title: { fontSize: 18, fontWeight: 'bold', marginBottom: 12 },
  sectionHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
    marginTop: 16,
  },
  sectionHeaderText: { fontSize: 16, fontWeight: '600', flex: 1 },
  addBtn: { padding: 4 },
  row: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
    paddingVertical: 2,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 6,
    borderRadius: 4,
    marginHorizontal: 2,
  },
  total: {
    textAlign: 'right',
    paddingHorizontal: 4,
    fontWeight: '500',
  },
  summary: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
  },
  button: {
    marginTop: 20,
    backgroundColor: '#4CAF50',
    padding: 14,
    borderRadius: 8,
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'center',
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    marginBottom: 4,
    color: '#444',
  },
  supplierGroup: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 12,
    borderRadius: 8,
    marginBottom: 12,
  },
  selectButton: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 12,
    borderRadius: 4,
  },
  selectText: { fontSize: 16 },
  supplierInfo: { fontSize: 13, color: '#666' },
  inputGroup: {
    marginBottom: 12,
  },
  inputField: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 12,
    borderRadius: 4,
    fontSize: 16,
  },
});

export default CreatePOScreen;


--- END: src\screens\CreatePOScreen.js ---


--- START: src\screens\CreateProposalScreen.js ---
// src/screens/CreateProposalScreen.js
import React, { useState } from 'react';
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
  Alert,
  StyleSheet,
  TextInput,
  ScrollView,
  Platform,
} from 'react-native';
import { createProposal, canCreateProposal } from '../api/proposalService';
import { useAuth } from '../contexts/AuthContext';
import DateTimePicker from '@react-native-community/datetimepicker';
import { Ionicons } from '@expo/vector-icons';

const CreateProposalScreen = ({ route, navigation }) => {
  const params = route?.params || {};
  const projectId = params.projectId;
  const projectName = params.projectName;
  const selectedItems = Array.isArray(params.selectedItems)
    ? params.selectedItems
    : [];
  const { currentUser } = useAuth();
  const [saving, setSaving] = useState(false);

  // C√°c tr∆∞·ªùng m·ªõi
  const [proposalNumber, setProposalNumber] = useState('');
  const [requiredDate, setRequiredDate] = useState(new Date());
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [priority, setPriority] = useState('normal'); // 'normal' ho·∫∑c 'urgent'
  const [purpose, setPurpose] = useState('');

  // Ki·ªÉm tra quy·ªÅn t·∫°o ƒë·ªÅ xu·∫•t
  if (!canCreateProposal(currentUser?.role)) {
    Alert.alert('Kh√¥ng c√≥ quy·ªÅn', 'B·∫°n kh√¥ng c√≥ quy·ªÅn t·∫°o ƒë·ªÅ xu·∫•t mua v·∫≠t t∆∞');
    navigation.goBack();
  }

  const handleDateChange = (event, selectedDate) => {
    setShowDatePicker(Platform.OS === 'ios');
    if (selectedDate) {
      setRequiredDate(selectedDate);
    }
  };

  const handleSubmit = async () => {
    // Validate
    if (!proposalNumber.trim()) {
      return Alert.alert('Thi·∫øu th√¥ng tin', 'Vui l√≤ng nh·∫≠p s·ªë ƒë·ªÅ xu·∫•t');
    }

    if (!purpose.trim()) {
      return Alert.alert('Thi·∫øu th√¥ng tin', 'Vui l√≤ng nh·∫≠p m·ª•c ƒë√≠ch s·ª≠ d·ª•ng');
    }

    const proposalCode = `THP/KT/25/${proposalNumber}`;

    setSaving(true);
    try {
      await createProposal({
        projectId,
        projectName,
        items: selectedItems,
        createdBy: currentUser.uid,
        createdByName: currentUser.displayName || currentUser.email,
        proposalCode,
        requiredDate,
        priority,
        purpose,
      });
      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ g·ª≠i ƒë·ªÅ xu·∫•t.');
      navigation.goBack();
    } catch (err) {
      Alert.alert('L·ªói', err.message);
    } finally {
      setSaving(false);
    }
  };

  const renderItem = ({ item }) => (
    <View style={styles.row}>
      <Text style={styles.name}>{item.name}</Text>
      <Text style={styles.qty}>{item.quantity}</Text>
      <Text style={styles.unit}>{item.unit}</Text>
    </View>
  );

  return (
    <ScrollView style={styles.container}>
      <Text style={styles.title}>ƒê·ªÅ xu·∫•t mua v·∫≠t t∆∞ - {projectName}</Text>

      {/* Form th√¥ng tin ƒë·ªÅ xu·∫•t */}
      <View style={styles.formSection}>
        <Text style={styles.sectionTitle}>Th√¥ng tin ƒë·ªÅ xu·∫•t</Text>

        <View style={styles.formGroup}>
          <Text style={styles.label}>M√£ ƒë·ªÅ xu·∫•t</Text>
          <View style={styles.codeInputContainer}>
            <Text style={styles.codePrefix}>THP/KT/25/</Text>
            <TextInput
              style={styles.codeInput}
              value={proposalNumber}
              onChangeText={setProposalNumber}
              placeholder="Nh·∫≠p s·ªë"
              keyboardType="numeric"
            />
          </View>
        </View>

        <View style={styles.formGroup}>
          <Text style={styles.label}>Ng√†y c·∫ßn cung c·∫•p</Text>
          <TouchableOpacity
            style={styles.dateButton}
            onPress={() => setShowDatePicker(true)}
          >
            <Text style={styles.dateText}>
              {requiredDate.toLocaleDateString('vi-VN')}
            </Text>
            <Ionicons name="calendar-outline" size={20} color="#666" />
          </TouchableOpacity>
          {showDatePicker && (
            <DateTimePicker
              value={requiredDate}
              mode="date"
              display={Platform.OS === 'ios' ? 'spinner' : 'default'}
              onChange={handleDateChange}
              minimumDate={new Date()}
            />
          )}
        </View>

        <View style={styles.formGroup}>
          <Text style={styles.label}>M·ª©c ƒë·ªô ∆∞u ti√™n</Text>
          <View style={styles.priorityContainer}>
            <TouchableOpacity
              style={[
                styles.priorityButton,
                priority === 'normal' && styles.priorityButtonActive,
              ]}
              onPress={() => setPriority('normal')}
            >
              <Text
                style={[
                  styles.priorityText,
                  priority === 'normal' && styles.priorityTextActive,
                ]}
              >
                B√¨nh th∆∞·ªùng
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.priorityButton,
                priority === 'urgent' && styles.priorityButtonActive,
                priority === 'urgent' && { backgroundColor: '#ffebee' },
              ]}
              onPress={() => setPriority('urgent')}
            >
              <Text
                style={[
                  styles.priorityText,
                  priority === 'urgent' && styles.priorityTextActive,
                  priority === 'urgent' && { color: '#d32f2f' },
                ]}
              >
                G·∫•p
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.formGroup}>
          <Text style={styles.label}>M·ª•c ƒë√≠ch s·ª≠ d·ª•ng</Text>
          <TextInput
            style={styles.purposeInput}
            value={purpose}
            onChangeText={setPurpose}
            placeholder="Nh·∫≠p m·ª•c ƒë√≠ch s·ª≠ d·ª•ng v·∫≠t t∆∞"
            multiline
            numberOfLines={3}
          />
        </View>
      </View>

      {/* Danh s√°ch v·∫≠t t∆∞ */}
      <View style={styles.materialsSection}>
        <Text style={styles.sectionTitle}>
          Danh s√°ch v·∫≠t t∆∞ ({selectedItems ? selectedItems.length : 0})
        </Text>
        <View style={styles.tableHeader}>
          <Text style={[styles.headerText, { flex: 3 }]}>T√™n v·∫≠t t∆∞</Text>
          <Text style={[styles.headerText, { flex: 1, textAlign: 'center' }]}>
            SL
          </Text>
          <Text style={[styles.headerText, { flex: 1, textAlign: 'center' }]}>
            ƒêVT
          </Text>
        </View>
        <FlatList
          data={selectedItems}
          keyExtractor={(i, idx) => idx.toString()}
          renderItem={renderItem}
          nestedScrollEnabled
          style={{ maxHeight: 300 }}
        />
      </View>

      <TouchableOpacity
        style={styles.submitBtn}
        onPress={handleSubmit}
        disabled={saving}
      >
        <Text style={styles.btnText}>
          {saving ? 'ƒêang g·ª≠i...' : 'G·ª≠i Duy·ªát'}
        </Text>
      </TouchableOpacity>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: '#f5f5f5',
  },
  title: {
    fontSize: 18,
    fontWeight: '700',
    marginBottom: 16,
  },
  formSection: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  materialsSection: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 12,
    color: '#333',
  },
  formGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    marginBottom: 8,
    color: '#555',
  },
  codeInputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 4,
    overflow: 'hidden',
  },
  codePrefix: {
    backgroundColor: '#f0f0f0',
    paddingHorizontal: 8,
    paddingVertical: 10,
    fontSize: 14,
  },
  codeInput: {
    flex: 1,
    paddingHorizontal: 8,
    paddingVertical: 8,
    fontSize: 14,
  },
  dateButton: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 4,
    padding: 10,
  },
  dateText: {
    fontSize: 14,
  },
  priorityContainer: {
    flexDirection: 'row',
    gap: 12,
  },
  priorityButton: {
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 4,
    borderWidth: 1,
    borderColor: '#ddd',
    backgroundColor: '#f9f9f9',
  },
  priorityButtonActive: {
    borderColor: '#0066cc',
    backgroundColor: '#e6f2ff',
  },
  priorityText: {
    color: '#666',
  },
  priorityTextActive: {
    color: '#0066cc',
    fontWeight: '500',
  },
  purposeInput: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 4,
    padding: 10,
    fontSize: 14,
    textAlignVertical: 'top',
    minHeight: 80,
  },
  tableHeader: {
    flexDirection: 'row',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    marginBottom: 4,
  },
  headerText: {
    fontWeight: '600',
    fontSize: 14,
    color: '#555',
  },
  row: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderColor: '#eee',
  },
  name: { flex: 3 },
  qty: { flex: 1, textAlign: 'center' },
  unit: { flex: 1, textAlign: 'center' },
  submitBtn: {
    backgroundColor: '#0066cc',
    padding: 14,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 8,
    marginBottom: 20,
  },
  btnText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 16,
  },
});

export default CreateProposalScreen;


--- END: src\screens\CreateProposalScreen.js ---


--- START: src\screens\CustomerDetailScreen.js ---
//src/screens/CustomerDetailScreen.js
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  Share,
  FlatList,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { getCustomerById, deleteCustomer } from '../api/customerService';
import { getProjects } from '../api/projectService';
import { useFocusEffect } from '@react-navigation/native';

const CustomerDetailScreen = ({ route, navigation }) => {
  const { customerId } = route.params;
  const [customer, setCustomer] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isDeleting, setIsDeleting] = useState(false);
  const [customerProjects, setCustomerProjects] = useState([]);
  const [loadingProjects, setLoadingProjects] = useState(false);

  // H√†m l·∫•y d·ªØ li·ªáu kh√°ch h√†ng
  const fetchCustomerData = async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await getCustomerById(customerId);

      if (data) {
        setCustomer(data);
      } else {
        setError('Kh√¥ng t√¨m th·∫•y th√¥ng tin kh√°ch h√†ng');
      }
    } catch (err) {
      console.error('L·ªói khi t·∫£i th√¥ng tin kh√°ch h√†ng:', err);
      setError('Kh√¥ng th·ªÉ t·∫£i th√¥ng tin kh√°ch h√†ng. Vui l√≤ng th·ª≠ l·∫°i sau.');
    } finally {
      setLoading(false);
    }
  };

  // H√†m l·∫•y danh s√°ch d·ª± √°n c·ªßa kh√°ch h√†ng
  const fetchCustomerProjects = async () => {
    try {
      setLoadingProjects(true);
      const allProjects = await getProjects();

      // L·ªçc d·ª± √°n theo customerId
      const projects = allProjects.filter(
        (project) =>
          project.customerId === customerId ||
          project.customerName === customer?.name
      );

      setCustomerProjects(projects);
      console.log(
        `T√¨m th·∫•y ${projects.length} d·ª± √°n cho kh√°ch h√†ng ${customer?.name}`
      );
    } catch (err) {
      console.error('L·ªói khi t·∫£i d·ª± √°n c·ªßa kh√°ch h√†ng:', err);
    } finally {
      setLoadingProjects(false);
    }
  };

  // L·∫•y d·ªØ li·ªáu kh√°ch h√†ng khi m√†n h√¨nh ƒë∆∞·ª£c t·∫£i
  useEffect(() => {
    fetchCustomerData();
  }, [customerId]);

  // L·∫•y d·ª± √°n khi c√≥ th√¥ng tin kh√°ch h√†ng
  useEffect(() => {
    if (customer) {
      fetchCustomerProjects();
    }
  }, [customer]);

  // L√†m m·ªõi d·ªØ li·ªáu khi m√†n h√¨nh ƒë∆∞·ª£c focus (quay l·∫°i sau khi ch·ªânh s·ª≠a)
  useFocusEffect(
    useCallback(() => {
      fetchCustomerData();
    }, [customerId])
  );

  // L·∫•y nh√£n hi·ªÉn th·ªã cho lo·∫°i kh√°ch h√†ng
  const getTypeLabel = (type) => {
    switch (type) {
      case 'vip':
        return 'VIP';
      case 'potential':
        return 'Ti·ªÅm nƒÉng';
      case 'regular':
        return 'Th∆∞·ªùng xuy√™n';
      default:
        return type || 'Ch∆∞a ph√¢n lo·∫°i';
    }
  };

  // L·∫•y m√†u cho lo·∫°i kh√°ch h√†ng
  const getTypeColor = (type) => {
    switch (type) {
      case 'vip':
        return '#4CAF50'; // xanh l√°
      case 'potential':
        return '#FF9800'; // cam
      default:
        return '#9E9E9E'; // x√°m
    }
  };

  // L·∫•y m√†u cho tr·∫°ng th√°i d·ª± √°n
  const getStatusColor = (status) => {
    switch (status?.toLowerCase()) {
      case 'completed':
        return '#4CAF50'; // xanh l√°
      case 'in_progress':
        return '#FF9800'; // cam
      case 'pending':
        return '#2196F3'; // xanh d∆∞∆°ng
      case 'cancelled':
        return '#F44336'; // ƒë·ªè
      default:
        return '#9E9E9E'; // x√°m
    }
  };

  // L·∫•y nh√£n tr·∫°ng th√°i d·ª± √°n
  const getStatusLabel = (status) => {
    switch (status?.toLowerCase()) {
      case 'completed':
        return 'Ho√†n th√†nh';
      case 'in_progress':
        return 'ƒêang th·ª±c hi·ªán';
      case 'pending':
        return 'Ch·ªù x·ª≠ l√Ω';
      case 'cancelled':
        return 'ƒê√£ h·ªßy';
      default:
        return status || 'Ch∆∞a x√°c ƒë·ªãnh';
    }
  };

  // Format currency
  const formatCurrency = (amount) => {
    if (!amount) return '0 ‚Ç´';
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
      minimumFractionDigits: 0,
    }).format(amount);
  };

  // Format date
  const formatDate = (timestamp) => {
    if (!timestamp) return 'Ch∆∞a c√≥';
    if (timestamp.seconds) {
      const date = new Date(timestamp.seconds * 1000);
      return date.toLocaleDateString('vi-VN', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
      });
    }
    return new Date(timestamp).toLocaleDateString('vi-VN');
  };

  // Render project item
  const renderProjectItem = ({ item }) => (
    <TouchableOpacity
      style={styles.projectCard}
      onPress={() =>
        navigation.navigate('ProjectDetail', { projectId: item.id })
      }
    >
      <View style={styles.projectHeader}>
        <Text style={styles.projectName} numberOfLines={2}>
          {item.name || 'D·ª± √°n kh√¥ng t√™n'}
        </Text>
        <View
          style={[
            styles.statusBadge,
            { backgroundColor: getStatusColor(item.status) },
          ]}
        >
          <Text style={styles.statusText}>{getStatusLabel(item.status)}</Text>
        </View>
      </View>

      <View style={styles.projectDetails}>
        <View style={styles.projectDetailRow}>
          <Ionicons name="calendar-outline" size={16} color="#666" />
          <Text style={styles.projectDetailText}>
            {formatDate(item.createdAt)}
          </Text>
        </View>

        {item.budget && (
          <View style={styles.projectDetailRow}>
            <Ionicons name="cash-outline" size={16} color="#666" />
            <Text style={styles.projectDetailText}>
              Ng√¢n s√°ch: {formatCurrency(item.budget)}
            </Text>
          </View>
        )}

        {item.description && (
          <View style={styles.projectDetailRow}>
            <Ionicons name="document-text-outline" size={16} color="#666" />
            <Text style={styles.projectDetailText} numberOfLines={2}>
              {item.description}
            </Text>
          </View>
        )}
      </View>

      <View style={styles.projectFooter}>
        <Ionicons name="chevron-forward" size={20} color="#666" />
      </View>
    </TouchableOpacity>
  );

  // X·ª≠ l√Ω chia s·∫ª th√¥ng tin kh√°ch h√†ng
  const handleShare = async () => {
    if (!customer) return;

    try {
      const message = `
Th√¥ng tin kh√°ch h√†ng:
T√™n: ${customer.name || 'Kh√¥ng c√≥'}
Ng∆∞·ªùi li√™n h·ªá: ${customer.contactPerson || 'Kh√¥ng c√≥'}
ƒêi·ªán tho·∫°i: ${customer.phone || 'Kh√¥ng c√≥'}
Email: ${customer.email || 'Kh√¥ng c√≥'}
ƒê·ªãa ch·ªâ: ${customer.address || 'Kh√¥ng c√≥'}
Lo·∫°i kh√°ch h√†ng: ${getTypeLabel(customer.type)}
S·ªë d·ª± √°n: ${customerProjects.length}
      `;

      await Share.share({
        message,
        title: `Th√¥ng tin kh√°ch h√†ng: ${customer.name}`,
      });
    } catch (error) {
      console.error('L·ªói khi chia s·∫ª:', error);
    }
  };

  // X·ª≠ l√Ω ch·ªânh s·ª≠a kh√°ch h√†ng
  const handleEdit = () => {
    navigation.navigate('EditCustomer', { customer });
  };

  // X·ª≠ l√Ω x√≥a kh√°ch h√†ng
  const handleDelete = () => {
    Alert.alert(
      'X√°c nh·∫≠n x√≥a',
      'B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a kh√°ch h√†ng n√†y kh√¥ng?',
      [
        { text: 'H·ªßy', style: 'cancel' },
        {
          text: 'X√≥a',
          style: 'destructive',
          onPress: async () => {
            try {
              setIsDeleting(true);
              await deleteCustomer(customer.id);
              Alert.alert('Th√†nh c√¥ng', 'ƒê√£ x√≥a kh√°ch h√†ng th√†nh c√¥ng', [
                {
                  text: 'OK',
                  onPress: () => navigation.goBack(),
                },
              ]);
            } catch (error) {
              if (error.code === 'permission-denied') {
                Alert.alert(
                  'L·ªói quy·ªÅn',
                  'B·∫°n kh√¥ng c√≥ ƒë·ªß quy·ªÅn ƒë·ªÉ th·ª±c hi·ªán h√†nh ƒë·ªông n√†y.'
                );
              } else {
                console.error('L·ªói khi x√≥a kh√°ch h√†ng:', error);
                Alert.alert(
                  'L·ªói',
                  'Kh√¥ng th·ªÉ x√≥a kh√°ch h√†ng. Vui l√≤ng th·ª≠ l·∫°i sau.'
                );
              }
              setIsDeleting(false);
            }
          },
        },
      ]
    );
  };

  // Hi·ªÉn th·ªã khi ƒëang t·∫£i d·ªØ li·ªáu
  if (loading) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color="#0066cc" />
        <Text style={styles.loadingText}>ƒêang t·∫£i th√¥ng tin kh√°ch h√†ng...</Text>
      </View>
    );
  }

  // Hi·ªÉn th·ªã khi c√≥ l·ªói
  if (error) {
    return (
      <View style={styles.centerContainer}>
        <Ionicons name="alert-circle-outline" size={50} color="#FF3B30" />
        <Text style={styles.errorText}>{error}</Text>
        <TouchableOpacity
          style={styles.retryButton}
          onPress={() => navigation.goBack()}
        >
          <Text style={styles.retryButtonText}>Quay l·∫°i</Text>
        </TouchableOpacity>
      </View>
    );
  }

  // Hi·ªÉn th·ªã khi kh√¥ng t√¨m th·∫•y kh√°ch h√†ng
  if (!customer) {
    return (
      <View style={styles.centerContainer}>
        <Ionicons name="person-outline" size={50} color="#999" />
        <Text style={styles.errorText}>
          Kh√¥ng t√¨m th·∫•y th√¥ng tin kh√°ch h√†ng
        </Text>
        <TouchableOpacity
          style={styles.retryButton}
          onPress={() => navigation.goBack()}
        >
          <Text style={styles.retryButtonText}>Quay l·∫°i</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Chi ti·∫øt kh√°ch h√†ng</Text>
        <TouchableOpacity style={styles.shareButton} onPress={handleShare}>
          <Ionicons name="share-outline" size={24} color="#333" />
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.contentContainer}>
        <View style={styles.customerHeader}>
          <View style={styles.customerNameContainer}>
            <Text style={styles.customerName}>
              {customer.name || 'Ch∆∞a c√≥ t√™n'}
            </Text>
            <View
              style={[
                styles.customerTypeTag,
                { borderColor: getTypeColor(customer.type) },
              ]}
            >
              <Text
                style={[
                  styles.customerTypeText,
                  { color: getTypeColor(customer.type) },
                ]}
              >
                {getTypeLabel(customer.type)}
              </Text>
            </View>
          </View>
        </View>

        <View style={styles.infoSection}>
          <View style={styles.infoItem}>
            <Text style={styles.infoLabel}>Ng∆∞·ªùi li√™n h·ªá</Text>
            <Text style={styles.infoValue}>
              {customer.contactPerson || 'Ch∆∞a c√≥ th√¥ng tin'}
            </Text>
          </View>

          <View style={styles.infoItem}>
            <Text style={styles.infoLabel}>S·ªë ƒëi·ªán tho·∫°i</Text>
            <View style={styles.infoValueWithIcon}>
              <Text style={styles.infoValue}>
                {customer.phone || 'Ch∆∞a c√≥ th√¥ng tin'}
              </Text>
              {customer.phone && (
                <TouchableOpacity style={styles.actionIcon}>
                  <Ionicons name="call-outline" size={20} color="#0066cc" />
                </TouchableOpacity>
              )}
            </View>
          </View>

          <View style={styles.infoItem}>
            <Text style={styles.infoLabel}>Email</Text>
            <View style={styles.infoValueWithIcon}>
              <Text style={styles.infoValue}>
                {customer.email || 'Ch∆∞a c√≥ th√¥ng tin'}
              </Text>
              {customer.email && (
                <TouchableOpacity style={styles.actionIcon}>
                  <Ionicons name="mail-outline" size={20} color="#0066cc" />
                </TouchableOpacity>
              )}
            </View>
          </View>

          <View style={styles.infoItem}>
            <Text style={styles.infoLabel}>ƒê·ªãa ch·ªâ</Text>
            <Text style={styles.infoValue}>
              {customer.address || 'Ch∆∞a c√≥ th√¥ng tin'}
            </Text>
          </View>

          <View style={styles.infoItem}>
            <Text style={styles.infoLabel}>M√£ s·ªë thu·∫ø</Text>
            <Text style={styles.infoValue}>
              {customer.taxCode || 'Ch∆∞a c√≥ th√¥ng tin'}
            </Text>
          </View>
        </View>

        <View style={styles.metaSection}>
          <Text style={styles.metaSectionTitle}>Th√¥ng tin b·ªï sung</Text>

          <View style={styles.metaItem}>
            <Text style={styles.metaLabel}>Ng√†y t·∫°o</Text>
            <Text style={styles.metaValue}>
              {formatDate(customer.createdAt)}
            </Text>
          </View>

          <View style={styles.metaItem}>
            <Text style={styles.metaLabel}>C·∫≠p nh·∫≠t l·∫ßn cu·ªëi</Text>
            <Text style={styles.metaValue}>
              {formatDate(customer.updatedAt)}
            </Text>
          </View>
        </View>

        {/* Section d·ª± √°n c·ªßa kh√°ch h√†ng */}
        <View style={styles.projectSection}>
          <View style={styles.projectSectionHeader}>
            <Text style={styles.projectSectionTitle}>
              D·ª± √°n ƒë√£ gia c√¥ng ({customerProjects.length})
            </Text>
            {loadingProjects && (
              <ActivityIndicator size="small" color="#0066cc" />
            )}
          </View>

          {customerProjects.length > 0 ? (
            <FlatList
              data={customerProjects}
              renderItem={renderProjectItem}
              keyExtractor={(item) => item.id}
              contentContainerStyle={styles.projectList}
              showsVerticalScrollIndicator={false}
              scrollEnabled={false} // Disable scroll for nested FlatList
            />
          ) : !loadingProjects ? (
            <View style={styles.emptyProjects}>
              <Ionicons name="folder-open-outline" size={48} color="#ccc" />
              <Text style={styles.emptyProjectsText}>
                Ch∆∞a c√≥ d·ª± √°n n√†o ƒë∆∞·ª£c gia c√¥ng
              </Text>
            </View>
          ) : null}
        </View>
      </ScrollView>

      <View style={styles.footer}>
        <View style={styles.buttonContainer}>
          <TouchableOpacity
            style={styles.deleteButton}
            onPress={handleDelete}
            disabled={isDeleting}
          >
            {isDeleting ? (
              <ActivityIndicator color="#fff" size="small" />
            ) : (
              <>
                <Ionicons name="trash-outline" size={20} color="#fff" />
                <Text style={styles.deleteButtonText}>X√≥a</Text>
              </>
            )}
          </TouchableOpacity>

          <TouchableOpacity style={styles.editButton} onPress={handleEdit}>
            <Ionicons name="create-outline" size={20} color="#fff" />
            <Text style={styles.editButtonText}>Ch·ªânh s·ª≠a</Text>
          </TouchableOpacity>
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
  },
  errorText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  retryButton: {
    marginTop: 16,
    backgroundColor: '#0066cc',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 6,
  },
  retryButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '500',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  shareButton: {
    padding: 4,
  },
  contentContainer: {
    flex: 1,
  },
  customerHeader: {
    backgroundColor: '#fff',
    padding: 16,
    marginBottom: 12,
  },
  customerNameContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  customerName: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#333',
    flex: 1,
  },
  customerTypeTag: {
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 10,
    paddingVertical: 3,
  },
  customerTypeText: {
    fontSize: 12,
    fontWeight: '500',
  },
  infoSection: {
    backgroundColor: '#fff',
    padding: 16,
    marginBottom: 12,
  },
  infoItem: {
    marginBottom: 16,
  },
  infoLabel: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
  },
  infoValue: {
    fontSize: 16,
    color: '#333',
  },
  infoValueWithIcon: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  actionIcon: {
    padding: 4,
  },
  metaSection: {
    backgroundColor: '#fff',
    padding: 16,
    marginBottom: 20,
  },
  metaSectionTitle: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    marginBottom: 12,
  },
  metaItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  metaLabel: {
    fontSize: 14,
    color: '#666',
  },
  metaValue: {
    fontSize: 14,
    color: '#333',
  },
  projectSection: {
    backgroundColor: '#fff',
    padding: 16,
    marginBottom: 20,
  },
  projectSectionTitle: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    marginBottom: 12,
  },
  projectList: {
    paddingBottom: 20,
  },
  projectCard: {
    backgroundColor: '#f0f0f0',
    borderRadius: 8,
    marginBottom: 10,
    overflow: 'hidden',
  },
  projectHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 12,
    backgroundColor: '#e0e0e0',
  },
  projectName: {
    flex: 1,
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    marginRight: 10,
  },
  statusBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 5,
  },
  statusText: {
    color: 'white',
    fontSize: 12,
    fontWeight: '500',
  },
  projectDetails: {
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  projectDetailRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
  },
  projectDetailText: {
    fontSize: 14,
    color: '#666',
    marginLeft: 5,
  },
  projectFooter: {
    padding: 12,
    alignItems: 'flex-end',
  },
  footer: {
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  editButton: {
    backgroundColor: '#0066cc',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    borderRadius: 8,
    flex: 3,
    marginLeft: 10,
  },
  editButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  deleteButton: {
    backgroundColor: '#e74c3c',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    borderRadius: 8,
    flex: 1,
  },
  deleteButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  projectSectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 10,
  },
  emptyProjects: {
    alignItems: 'center',
    paddingVertical: 20,
  },
  emptyProjectsText: {
    marginTop: 10,
    fontSize: 16,
    color: '#666',
  },
});

export default CustomerDetailScreen;


--- END: src\screens\CustomerDetailScreen.js ---


--- START: src\screens\CustomerImportScreen.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  FlatList,
  Alert,
  ActivityIndicator,
  SafeAreaView,
  StatusBar,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useCustomerImport } from '../hooks/useCustomerImport';

const CustomerImportScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const {
    driveFiles: files,
    isLoadingFiles: loading,
    isProcessingFile: importing,
    fetchCustomerFiles,
    importCustomersFromFile,
  } = useCustomerImport();
  const [selectedFile, setSelectedFile] = useState(null);

  // T·∫£i danh s√°ch file khi component mount
  useEffect(() => {
    fetchCustomerFiles();
  }, [fetchCustomerFiles]);

  const handleFileSelect = (file) => {
    setSelectedFile(file);
  };

  const handleImport = async () => {
    if (!selectedFile) {
      Alert.alert('L·ªói', 'Vui l√≤ng ch·ªçn file ƒë·ªÉ import');
      return;
    }

    Alert.alert(
      'X√°c nh·∫≠n Import',
      `B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën import kh√°ch h√†ng t·ª´ file "${selectedFile.name}"?`,
      [
        { text: 'H·ªßy', style: 'cancel' },
        {
          text: 'Import',
          style: 'destructive',
          onPress: async () => {
            try {
              const result = await importCustomersFromFile(
                selectedFile.id,
                selectedFile.name
              );

              if (result) {
                // Import th√†nh c√¥ng, quay l·∫°i m√†n h√¨nh tr∆∞·ªõc
                navigation.goBack();
              }
            } catch (error) {
              console.error('L·ªói khi import:', error);
              // Error ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω trong hook
            }
          },
        },
      ]
    );
  };

  const formatFileSize = (bytes) => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('vi-VN');
  };

  const renderFileItem = ({ item }) => (
    <TouchableOpacity
      style={[
        styles.fileItem,
        {
          backgroundColor: theme.card,
          borderColor:
            selectedFile?.id === item.id ? theme.primary : theme.border,
        },
      ]}
      onPress={() => handleFileSelect(item)}
    >
      <View style={styles.fileInfo}>
        <Ionicons name="document-outline" size={24} color={theme.primary} />
        <View style={styles.fileDetails}>
          <Text
            style={[styles.fileName, { color: theme.text }]}
            numberOfLines={2}
          >
            {item.name}
          </Text>
          <Text style={[styles.fileMeta, { color: theme.textSecondary }]}>
            {formatFileSize(item.size)} ‚Ä¢ {formatDate(item.modifiedTime)}
          </Text>
        </View>
      </View>
      {selectedFile?.id === item.id && (
        <Ionicons name="checkmark-circle" size={24} color={theme.primary} />
      )}
    </TouchableOpacity>
  );

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <StatusBar
        barStyle={theme.dark ? 'light-content' : 'dark-content'}
        backgroundColor={theme.background}
      />

      {/* Header */}
      <View style={[styles.header, { borderBottomColor: theme.border }]}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back" size={24} color={theme.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Import Kh√°ch H√†ng
        </Text>
        <TouchableOpacity onPress={fetchCustomerFiles} disabled={loading}>
          <Ionicons
            name="refresh"
            size={24}
            color={loading ? theme.textMuted : theme.text}
          />
        </TouchableOpacity>
      </View>

      {/* Instructions */}
      <View
        style={[
          styles.instructions,
          { backgroundColor: theme.card, borderColor: theme.border },
        ]}
      >
        <Text style={[styles.instructionsTitle, { color: theme.text }]}>
          H∆∞·ªõng d·∫´n Import
        </Text>
        <Text style={[styles.instructionsText, { color: theme.textSecondary }]}>
          ‚Ä¢ C·ªôt A: T√™n c√¥ng ty{'\n'}‚Ä¢ C·ªôt B: M√£ s·ªë thu·∫ø{'\n'}‚Ä¢ C·ªôt C: ƒê·ªãa ch·ªâ
          {'\n'}‚Ä¢ C·ªôt D: Email{'\n'}‚Ä¢ File Excel ph·∫£i c√≥ t√™n ch·ª©a t·ª´ "customer"
        </Text>
      </View>

      {/* File List */}
      <View style={styles.content}>
        <Text style={[styles.sectionTitle, { color: theme.text }]}>
          Ch·ªçn File Excel
        </Text>

        {loading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.primary} />
            <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
              ƒêang t·∫£i danh s√°ch file...
            </Text>
          </View>
        ) : files.length === 0 ? (
          <View style={styles.emptyContainer}>
            <Ionicons
              name="folder-open-outline"
              size={60}
              color={theme.textMuted}
            />
            <Text style={[styles.emptyText, { color: theme.textSecondary }]}>
              Kh√¥ng t√¨m th·∫•y file customer n√†o
            </Text>
            <TouchableOpacity
              style={[styles.refreshButton, { borderColor: theme.border }]}
              onPress={fetchCustomerFiles}
            >
              <Ionicons name="refresh" size={16} color={theme.primary} />
              <Text style={[styles.refreshText, { color: theme.primary }]}>
                Th·ª≠ l·∫°i
              </Text>
            </TouchableOpacity>
          </View>
        ) : (
          <FlatList
            data={files}
            renderItem={renderFileItem}
            keyExtractor={(item) => item.id}
            showsVerticalScrollIndicator={false}
            contentContainerStyle={styles.fileList}
          />
        )}
      </View>

      {/* Import Button */}
      {selectedFile && (
        <View style={[styles.footer, { borderTopColor: theme.border }]}>
          <TouchableOpacity
            style={[
              styles.importButton,
              { backgroundColor: theme.primary },
              importing && styles.importButtonDisabled,
            ]}
            onPress={handleImport}
            disabled={importing}
          >
            {importing ? (
              <ActivityIndicator size="small" color="white" />
            ) : (
              <Ionicons name="cloud-upload-outline" size={20} color="white" />
            )}
            <Text style={styles.importButtonText}>
              {importing ? 'ƒêang Import...' : 'Import Kh√°ch H√†ng'}
            </Text>
          </TouchableOpacity>
        </View>
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  instructions: {
    margin: 16,
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
  },
  instructionsTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  instructionsText: {
    fontSize: 14,
    lineHeight: 20,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 32,
  },
  emptyText: {
    marginTop: 16,
    fontSize: 16,
    textAlign: 'center',
    marginBottom: 20,
  },
  refreshButton: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    borderWidth: 1,
    borderRadius: 8,
  },
  refreshText: {
    marginLeft: 8,
    fontSize: 14,
    fontWeight: '500',
  },
  fileList: {
    gap: 12,
  },
  fileItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 16,
    borderRadius: 8,
    borderWidth: 2,
  },
  fileInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  fileDetails: {
    marginLeft: 12,
    flex: 1,
  },
  fileName: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 4,
  },
  fileMeta: {
    fontSize: 12,
  },
  footer: {
    padding: 16,
    borderTopWidth: 1,
  },
  importButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 16,
    borderRadius: 8,
  },
  importButtonDisabled: {
    opacity: 0.6,
  },
  importButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
});

export default CustomerImportScreen;


--- END: src\screens\CustomerImportScreen.js ---


--- START: src\screens\CustomerManagementScreen.js ---
//src/screens/CustomerManagementScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  FlatList,
  StyleSheet,
  ActivityIndicator,
  Pressable,
  TouchableOpacity,
  SafeAreaView,
  StatusBar,
  TextInput,
  LayoutAnimation,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { getCustomers } from '../api/customerService';
import { useTheme } from '../contexts/ThemeContext';
import CustomerAddModal from '../components/CustomerAddModal';

// Component hi·ªÉn th·ªã t·ª´ng kh√°ch h√†ng trong danh s√°ch
const CustomerListItem = ({ customer, onPress }) => {
  const { theme } = useTheme();
  // X√°c ƒë·ªãnh lo·∫°i kh√°ch h√†ng ƒë·ªÉ hi·ªÉn th·ªã m√†u s·∫Øc ph√π h·ª£p
  const getTypeColor = (type) => {
    switch (type) {
      case 'vip':
        return '#4CAF50'; // xanh l√°
      case 'potential':
        return '#FF9800'; // cam
      default:
        return theme.textMuted; // S·ª≠ d·ª•ng m√†u t·ª´ theme
    }
  };

  // L·∫•y nh√£n hi·ªÉn th·ªã cho lo·∫°i kh√°ch h√†ng
  const getTypeLabel = (type) => {
    switch (type) {
      case 'vip':
        return 'VIP';
      case 'potential':
        return 'Ti·ªÅm nƒÉng';
      case 'regular':
        return 'Th∆∞·ªùng xuy√™n';
      default:
        return type || 'Ch∆∞a ph√¢n lo·∫°i';
    }
  };

  return (
    <Pressable
      style={({ pressed }) => [
        styles.customerCard,
        { backgroundColor: theme.card },
        pressed && styles.cardPressed,
      ]}
      onPress={() => onPress(customer)}
    >
      <View style={styles.customerInfo}>
        <Text style={[styles.customerName, { color: theme.text }]}>
          {customer.name || 'Ch∆∞a c√≥ t√™n'}
        </Text>

        <View style={styles.contactRow}>
          <Ionicons
            name="person-outline"
            size={14}
            color={theme.textSecondary}
          />
          <Text style={[styles.contactText, { color: theme.textSecondary }]}>
            {customer.contactPerson || 'Ch∆∞a c√≥ ng∆∞·ªùi li√™n h·ªá'}
          </Text>
        </View>

        {customer.email && (
          <View style={styles.contactRow}>
            <Ionicons
              name="mail-outline"
              size={14}
              color={theme.textSecondary}
            />
            <Text style={[styles.contactText, { color: theme.textSecondary }]}>
              {customer.email}
            </Text>
          </View>
        )}

        {customer.phone && (
          <View style={styles.contactRow}>
            <Ionicons
              name="call-outline"
              size={14}
              color={theme.textSecondary}
            />
            <Text style={[styles.contactText, { color: theme.textSecondary }]}>
              {customer.phone}
            </Text>
          </View>
        )}
      </View>

      <View style={styles.customerTypeContainer}>
        <View
          style={[
            styles.customerTypeTag,
            { borderColor: getTypeColor(customer.type) },
          ]}
        >
          <Text
            style={[
              styles.customerTypeText,
              { color: getTypeColor(customer.type) },
            ]}
          >
            {getTypeLabel(customer.type)}
          </Text>
        </View>
      </View>
    </Pressable>
  );
};

const CustomerManagementScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const [customers, setCustomers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [refreshing, setRefreshing] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [filteredCustomers, setFilteredCustomers] = useState([]);
  const [showAddModal, setShowAddModal] = useState(false);

  // H√†m t·∫£i danh s√°ch kh√°ch h√†ng
  const loadCustomers = async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await getCustomers();

      // Th√™m animation khi c·∫≠p nh·∫≠t danh s√°ch
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);

      setCustomers(data);
      setFilteredCustomers(data); // Kh·ªüi t·∫°o danh s√°ch l·ªçc ban ƒë·∫ßu
    } catch (err) {
      console.error('L·ªói khi t·∫£i danh s√°ch kh√°ch h√†ng:', err);
      setError('Kh√¥ng th·ªÉ t·∫£i danh s√°ch kh√°ch h√†ng. Vui l√≤ng th·ª≠ l·∫°i sau.');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  // T·∫£i d·ªØ li·ªáu khi m√†n h√¨nh ƒë∆∞·ª£c m·ªü
  useEffect(() => {
    loadCustomers();

    // Th√™m listener ƒë·ªÉ l√†m m·ªõi danh s√°ch khi quay l·∫°i t·ª´ m√†n h√¨nh kh√°c
    const unsubscribe = navigation.addListener('focus', () => {
      loadCustomers();
    });

    return unsubscribe;
  }, [navigation]);

  // L·ªçc danh s√°ch kh√°ch h√†ng theo t·ª´ kh√≥a t√¨m ki·∫øm
  useEffect(() => {
    if (!searchQuery.trim()) {
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
      setFilteredCustomers(customers);
      return;
    }

    const query = searchQuery.toLowerCase().trim();
    const filtered = customers.filter((customer) => {
      const name = (customer.name || '').toLowerCase();
      const contactPerson = (customer.contactPerson || '').toLowerCase();
      const email = (customer.email || '').toLowerCase();
      const phone = (customer.phone || '').toLowerCase();

      return (
        name.includes(query) ||
        contactPerson.includes(query) ||
        email.includes(query) ||
        phone.includes(query)
      );
    });

    // Th√™m animation khi c·∫≠p nh·∫≠t k·∫øt qu·∫£ t√¨m ki·∫øm
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);

    setFilteredCustomers(filtered);
  }, [searchQuery, customers]);

  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng k√©o ƒë·ªÉ l√†m m·ªõi
  const handleRefresh = () => {
    setRefreshing(true);
    loadCustomers();
  };

  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng nh·∫•n v√†o m·ªôt kh√°ch h√†ng
  const handleCustomerPress = (customer) => {
    navigation.navigate('CustomerDetail', { customerId: customer.id });
  };

  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng mu·ªën th√™m kh√°ch h√†ng m·ªõi
  const handleAddCustomer = () => {
    setShowAddModal(true);
  };

  const handleManualAdd = () => {
    navigation.navigate('AddCustomer');
  };

  const handleImportExcel = () => {
    navigation.navigate('CustomerImport');
  };

  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng nh·∫≠p t·ª´ kh√≥a t√¨m ki·∫øm
  const handleSearch = (text) => {
    setSearchQuery(text);
  };

  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng mu·ªën x√≥a t·ª´ kh√≥a t√¨m ki·∫øm
  const handleClearSearch = () => {
    setSearchQuery('');
  };

  // Hi·ªÉn th·ªã khi ƒëang t·∫£i d·ªØ li·ªáu
  if (loading && !refreshing) {
    return (
      <View
        style={[styles.centerContainer, { backgroundColor: theme.background }]}
      >
        <ActivityIndicator size="large" color={theme.primary} />
        <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
          ƒêang t·∫£i danh s√°ch kh√°ch h√†ng...
        </Text>
      </View>
    );
  }

  // Hi·ªÉn th·ªã khi c√≥ l·ªói
  if (error) {
    return (
      <View
        style={[styles.centerContainer, { backgroundColor: theme.background }]}
      >
        <Ionicons name="alert-circle-outline" size={50} color={theme.danger} />
        <Text style={[styles.errorText, { color: theme.text }]}>{error}</Text>
        <TouchableOpacity
          style={[styles.retryButton, { backgroundColor: theme.primary }]}
          onPress={loadCustomers}
        >
          <Text style={styles.retryButtonText}>Th·ª≠ l·∫°i</Text>
        </TouchableOpacity>
      </View>
    );
  }

  // Hi·ªÉn th·ªã khi kh√¥ng c√≥ kh√°ch h√†ng
  if (customers.length === 0) {
    return (
      <SafeAreaView
        style={[styles.container, { backgroundColor: theme.background }]}
      >
        <View style={[styles.header, { borderBottomColor: theme.border }]}>
          <Text style={[styles.headerTitle, { color: theme.text }]}>
            Qu·∫£n l√Ω Kh√°ch h√†ng
          </Text>
          <TouchableOpacity
            style={[styles.addButton, { backgroundColor: theme.primary }]}
            onPress={handleAddCustomer}
          >
            <Ionicons name="add" size={24} color="#fff" />
          </TouchableOpacity>
        </View>

        <View
          style={[
            styles.centerContainer,
            { backgroundColor: theme.background },
          ]}
        >
          <Ionicons name="people-outline" size={60} color={theme.textMuted} />
          <Text style={[styles.emptyText, { color: theme.textSecondary }]}>
            Ch∆∞a c√≥ kh√°ch h√†ng n√†o
          </Text>
          <TouchableOpacity
            style={[
              styles.addCustomerButton,
              { backgroundColor: theme.primary },
            ]}
            onPress={handleAddCustomer}
          >
            <Text style={styles.addCustomerButtonText}>
              Th√™m kh√°ch h√†ng m·ªõi
            </Text>
          </TouchableOpacity>
        </View>
      </SafeAreaView>
    );
  }

  // Hi·ªÉn th·ªã danh s√°ch kh√°ch h√†ng
  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <StatusBar
        barStyle={theme.dark ? 'light-content' : 'dark-content'}
        backgroundColor={theme.background}
      />

      <View style={[styles.header, { borderBottomColor: theme.border }]}>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Qu·∫£n l√Ω Kh√°ch h√†ng
        </Text>
        <View style={styles.headerButtons}>
          <TouchableOpacity
            style={[styles.importButton, { borderColor: theme.border }]}
            onPress={() => navigation.navigate('CustomerImport')}
          >
            <Ionicons
              name="cloud-upload-outline"
              size={20}
              color={theme.primary}
            />
          </TouchableOpacity>
          <TouchableOpacity
            style={[styles.addButton, { backgroundColor: theme.primary }]}
            onPress={handleAddCustomer}
          >
            <Ionicons name="add" size={24} color="#fff" />
          </TouchableOpacity>
        </View>
      </View>

      <View
        style={[
          styles.searchContainer,
          { backgroundColor: theme.card, borderColor: theme.border },
        ]}
      >
        <Ionicons
          name="search"
          size={20}
          color={theme.textMuted}
          style={styles.searchIcon}
        />
        <TextInput
          style={[styles.searchInput, { color: theme.text }]}
          placeholder="T√¨m ki·∫øm kh√°ch h√†ng..."
          placeholderTextColor={theme.textMuted}
          value={searchQuery}
          onChangeText={handleSearch}
        />
        {searchQuery.length > 0 && (
          <TouchableOpacity onPress={handleClearSearch}>
            <Ionicons name="close-circle" size={20} color={theme.textMuted} />
          </TouchableOpacity>
        )}
      </View>

      {filteredCustomers.length === 0 && searchQuery ? (
        <View style={styles.emptyResultContainer}>
          <Ionicons name="search-outline" size={50} color="#CCCCCC" />
          <Text style={styles.emptyResultText}>
            Kh√¥ng t√¨m th·∫•y kh√°ch h√†ng ph√π h·ª£p
          </Text>
          <TouchableOpacity
            onPress={handleClearSearch}
            style={styles.tryAgainButton}
          >
            <Text style={styles.tryAgainButtonText}>X√≥a t√¨m ki·∫øm</Text>
          </TouchableOpacity>
        </View>
      ) : (
        <FlatList
          data={filteredCustomers}
          keyExtractor={(item) => item.id}
          renderItem={({ item }) => (
            <CustomerListItem customer={item} onPress={handleCustomerPress} />
          )}
          contentContainerStyle={styles.listContainer}
          showsVerticalScrollIndicator={false}
          refreshing={refreshing}
          onRefresh={handleRefresh}
          initialNumToRender={10}
          maxToRenderPerBatch={10}
          windowSize={10}
          ListEmptyComponent={
            !searchQuery ? (
              <View style={styles.emptyContainer}>
                <Ionicons name="people-outline" size={60} color="#CCCCCC" />
                <Text style={styles.emptyText}>Ch∆∞a c√≥ kh√°ch h√†ng n√†o</Text>
                <TouchableOpacity
                  style={styles.addCustomerButton}
                  onPress={handleAddCustomer}
                >
                  <Text style={styles.addCustomerButtonText}>
                    Th√™m kh√°ch h√†ng m·ªõi
                  </Text>
                </TouchableOpacity>
              </View>
            ) : null
          }
        />
      )}

      {/* Add Customer Modal */}
      <CustomerAddModal
        visible={showAddModal}
        onClose={() => setShowAddModal(false)}
        onManualAdd={handleManualAdd}
        onImportExcel={handleImportExcel}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
    backgroundColor: '#fff',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: 'bold',
  },
  headerButtons: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  importButton: {
    width: 36,
    height: 36,
    borderRadius: 18,
    borderWidth: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  addButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginHorizontal: 16,
    marginTop: 16,
    marginBottom: 8,
    paddingHorizontal: 12,
    borderWidth: 1,
    borderRadius: 12,
    backgroundColor: '#fff',
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    height: 44,
    fontSize: 16,
  },
  listContainer: {
    paddingHorizontal: 16,
  },
  customerCard: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    padding: 16,
    marginVertical: 8,
    borderRadius: 12,
    backgroundColor: '#ffffff',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
  },
  cardPressed: {
    transform: [{ scale: 0.98 }],
    opacity: 0.9,
  },
  customerInfo: {
    flex: 1,
    marginRight: 10,
  },
  customerName: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  contactRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
  },
  contactText: {
    marginLeft: 6,
    fontSize: 14,
  },
  customerTypeContainer: {
    marginLeft: 12,
  },
  customerTypeTag: {
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  customerTypeText: {
    fontSize: 12,
    fontWeight: '500',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
    color: '#666',
  },
  errorText: {
    marginTop: 10,
    fontSize: 16,
    color: '#333',
    textAlign: 'center',
    marginBottom: 20,
  },
  retryButton: {
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 8,
  },
  retryButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
    minHeight: 300,
  },
  emptyText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  addCustomerButton: {
    marginTop: 16,
    backgroundColor: '#0066cc',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 6,
  },
  addCustomerButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '500',
  },
  emptyResultContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  emptyResultText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  tryAgainButton: {
    marginTop: 16,
    backgroundColor: '#f0f0f0',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 6,
  },
  tryAgainButtonText: {
    color: '#333',
    fontSize: 16,
    fontWeight: '500',
  },
});

export default CustomerManagementScreen;


--- END: src\screens\CustomerManagementScreen.js ---


--- START: src\screens\DebtDashboard.js ---
import React, { useState, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Dimensions,
  RefreshControl,
  Alert,
} from 'react-native';
import { useFocusEffect } from '@react-navigation/native';
import { doc, getDoc } from 'firebase/firestore';
import { db } from '../config/firebaseConfig';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import { Ionicons } from '@expo/vector-icons';
import { BarChart } from 'react-native-chart-kit';
import { getFunctions, httpsCallable } from 'firebase/functions';

// ID th∆∞ m·ª•c Google Drive ch·ª©a file Excel c√¥ng n·ª£
const DEBT_FOLDER_ID = '1Ci_BHZx0-Uhv2xg5IzwLPn05yPAUXOOU';

const screenWidth = Dimensions.get('window').width;

const DebtDashboard = ({ navigation }) => {
  const { theme } = useTheme();
  const { currentUser } = useAuth();
  const [dashboardData, setDashboardData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [error, setError] = useState(null);
  const [processingExcel, setProcessingExcel] = useState(false);

  // H√†m l·∫•y d·ªØ li·ªáu t·ªïng quan t·ª´ Firestore
  const fetchDashboardData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const dashboardRef = doc(db, 'summaries', 'directorDashboard');
      const dashboardSnap = await getDoc(dashboardRef);

      if (dashboardSnap.exists()) {
        const data = dashboardSnap.data();
        setDashboardData(data);
      } else {
        // N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu, th·ª≠ g·ªçi cloud function ƒë·ªÉ x·ª≠ l√Ω
        await fetchLatestExcelData();
      }
    } catch (err) {
      console.error('Error fetching dashboard data:', err);
      setError('L·ªói khi t·∫£i d·ªØ li·ªáu t·ªïng quan.');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  }, []);

  // H√†m g·ªçi Cloud Function ƒë·ªÉ x·ª≠ l√Ω file Excel m·ªõi nh·∫•t
  const fetchLatestExcelData = async () => {
    try {
      setProcessingExcel(true);
      setError(null);

      // G·ªçi cloud function triggerExcelProcessing
      const functions = getFunctions(undefined, 'asia-southeast1');
      const triggerExcel = httpsCallable(functions, 'triggerExcelProcessing');

      const result = await triggerExcel();
      console.log('K·∫øt qu·∫£ x·ª≠ l√Ω Excel:', result.data);

      if (result.data && result.data.success) {
        // L·∫•y d·ªØ li·ªáu m·ªõi t·ª´ Firestore
        const dashboardRef = doc(db, 'summaries', 'directorDashboard');
        const dashboardSnap = await getDoc(dashboardRef);

        if (dashboardSnap.exists()) {
          const data = dashboardSnap.data();
          setDashboardData(data);
        }

        Alert.alert(
          'C·∫≠p nh·∫≠t th√†nh c√¥ng',
          `ƒê√£ c·∫≠p nh·∫≠t d·ªØ li·ªáu t·ª´ file: ${result.data.fileName}`
        );
      } else {
        throw new Error('Kh√¥ng nh·∫≠n ƒë∆∞·ª£c d·ªØ li·ªáu t·ª´ cloud function');
      }
    } catch (err) {
      console.error('L·ªói khi x·ª≠ l√Ω file Excel:', err);
      setError(`L·ªói khi x·ª≠ l√Ω file Excel: ${err.message}`);
      Alert.alert('L·ªói', `Kh√¥ng th·ªÉ x·ª≠ l√Ω file Excel: ${err.message}`);
    } finally {
      setProcessingExcel(false);
      setRefreshing(false);
    }
  };

  const onRefresh = useCallback(() => {
    setRefreshing(true);
    fetchLatestExcelData();
  }, []);

  useFocusEffect(
    useCallback(() => {
      fetchDashboardData();
    }, [fetchDashboardData])
  );

  const formatDate = (timestamp) => {
    if (!timestamp) return 'Kh√¥ng c√≥ d·ªØ li·ªáu';

    const date = timestamp.toDate ? timestamp.toDate() : timestamp;
    return new Intl.DateTimeFormat('vi-VN', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    }).format(date);
  };

  const formatCurrency = (amount) => {
    if (amount === undefined || amount === null) return '0 ‚Ç´';

    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(amount);
  };

  if (loading && !refreshing) {
    return (
      <View style={[styles.container, { backgroundColor: theme.background }]}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.text }]}>
            ƒêang t·∫£i d·ªØ li·ªáu c√¥ng n·ª£...
          </Text>
        </View>
      </View>
    );
  }

  const chartConfig = {
    backgroundGradientFrom: theme.card,
    backgroundGradientTo: theme.card,
    color: (opacity = 1) => `rgba(26, 255, 146, ${opacity})`,
    strokeWidth: 2,
    barPercentage: 0.7,
    useShadowColorFromDataset: false,
    decimalPlaces: 1,
  };

  const getPayableChartData = () => {
    // D·ªØ li·ªáu m·ªõi kh√¥ng c√≥ top5Payable, n√™n tr·∫£ v·ªÅ d·ªØ li·ªáu m·∫´u
    return {
      labels: ['Kh√¥ng c√≥ d·ªØ li·ªáu chi ti·∫øt'],
      datasets: [
        {
          data: [
            dashboardData?.totalPayable
              ? dashboardData.totalPayable / 1000000
              : 0,
          ],
        },
      ],
    };
  };

  const getReceivableChartData = () => {
    // D·ªØ li·ªáu m·ªõi kh√¥ng c√≥ top5Receivable, n√™n tr·∫£ v·ªÅ d·ªØ li·ªáu m·∫´u
    return {
      labels: ['Kh√¥ng c√≥ d·ªØ li·ªáu chi ti·∫øt'],
      datasets: [
        {
          data: [
            dashboardData?.totalReceivable
              ? dashboardData.totalReceivable / 1000000
              : 0,
          ],
        },
      ],
    };
  };

  return (
    <ScrollView
      style={[styles.container, { backgroundColor: theme.background }]}
      refreshControl={
        <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
      }
    >
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={theme.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          B√°o C√°o C√¥ng N·ª£
        </Text>
        <TouchableOpacity
          style={styles.refreshButton}
          onPress={fetchLatestExcelData}
          disabled={processingExcel || refreshing}
        >
          {processingExcel ? (
            <ActivityIndicator size="small" color={theme.primary} />
          ) : (
            <Ionicons name="refresh-outline" size={24} color={theme.text} />
          )}
        </TouchableOpacity>
      </View>

      {error ? (
        <View style={styles.errorContainer}>
          <Ionicons name="alert-circle-outline" size={48} color={theme.error} />
          <Text style={[styles.errorText, { color: theme.error }]}>
            {error}
          </Text>
          <TouchableOpacity
            style={[styles.retryButton, { backgroundColor: theme.primary }]}
            onPress={fetchLatestExcelData}
          >
            <Text style={styles.retryButtonText}>Th·ª≠ l·∫°i</Text>
          </TouchableOpacity>
        </View>
      ) : (
        <>
          <View style={styles.kpiContainer}>
            <View
              style={[
                styles.kpiCard,
                { backgroundColor: '#d9534f' }, // Red for payables
              ]}
            >
              <Text style={styles.kpiLabel}>T·ªïng N·ª£ Ph·∫£i Tr·∫£</Text>
              <Text style={styles.kpiValue}>
                {dashboardData?.formattedTotals?.totalPayable ||
                  formatCurrency(dashboardData?.totalPayable)}
              </Text>
            </View>

            <View
              style={[
                styles.kpiCard,
                { backgroundColor: '#5cb85c' }, // Green for receivables
              ]}
            >
              <Text style={styles.kpiLabel}>T·ªïng N·ª£ Ph·∫£i Thu</Text>
              <Text style={styles.kpiValue}>
                {dashboardData?.formattedTotals?.totalReceivable ||
                  formatCurrency(dashboardData?.totalReceivable)}
              </Text>
            </View>

            <View
              style={[
                styles.kpiCard,
                {
                  backgroundColor:
                    (dashboardData?.netPosition || 0) >= 0
                      ? '#5cb85c' // Green for positive
                      : '#d9534f', // Red for negative
                },
              ]}
            >
              <Text style={styles.kpiLabel}>V·ªã Th·∫ø C√¥ng N·ª£ R√≤ng</Text>
              <Text style={styles.kpiValue}>
                {dashboardData?.formattedTotals?.netPosition ||
                  formatCurrency(dashboardData?.netPosition)}
              </Text>
            </View>

            <View style={[styles.kpiCard, { backgroundColor: theme.card }]}>
              <Text style={[styles.kpiLabel, { color: theme.textSecondary }]}>
                C·∫≠p nh·∫≠t l·∫ßn cu·ªëi
              </Text>
              <Text style={[styles.lastUpdatedValue, { color: theme.text }]}>
                {dashboardData?.lastUpdated
                  ? formatDate(dashboardData.lastUpdated)
                  : 'Ch∆∞a c√≥ d·ªØ li·ªáu'}
              </Text>
              {dashboardData?.fileName && (
                <Text style={[styles.fileNameText, { color: theme.textMuted }]}>
                  {dashboardData.fileName}
                </Text>
              )}
            </View>
          </View>

          <View style={styles.chartSection}>
            <Text style={[styles.chartTitle, { color: theme.text }]}>
              Top 5 C√¥ng N·ª£ Ph·∫£i Tr·∫£ (Tri·ªáu VNƒê)
            </Text>
            <View style={styles.chartContainer}>
              <BarChart
                data={getPayableChartData()}
                width={screenWidth - 32}
                height={220}
                chartConfig={chartConfig}
                verticalLabelRotation={30}
                showValuesOnTopOfBars={true}
                fromZero={true}
                style={styles.chart}
              />
            </View>
          </View>

          <View style={styles.chartSection}>
            <Text style={[styles.chartTitle, { color: theme.text }]}>
              Top 5 Kh√°ch H√†ng N·ª£ Nhi·ªÅu Nh·∫•t (Tri·ªáu VNƒê)
            </Text>
            <View style={styles.chartContainer}>
              <BarChart
                data={getReceivableChartData()}
                width={screenWidth - 32}
                height={220}
                chartConfig={{
                  ...chartConfig,
                  color: (opacity = 1) => `rgba(54, 162, 235, ${opacity})`,
                }}
                verticalLabelRotation={30}
                showValuesOnTopOfBars={true}
                fromZero={true}
                style={styles.chart}
              />
            </View>
          </View>
        </>
      )}
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 16,
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    flex: 1,
    textAlign: 'center',
  },
  backButton: {
    padding: 8,
  },
  refreshButton: {
    padding: 8,
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
    marginTop: 50,
  },
  errorText: {
    fontSize: 16,
    textAlign: 'center',
    marginVertical: 20,
  },
  retryButton: {
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 8,
  },
  retryButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
  kpiContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    marginBottom: 16,
  },
  kpiCard: {
    width: '48%',
    padding: 16,
    borderRadius: 12,
    marginBottom: 16,
    alignItems: 'center',
    justifyContent: 'center',
  },
  kpiLabel: {
    color: 'white',
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 8,
    textAlign: 'center',
  },
  kpiValue: {
    color: 'white',
    fontSize: 20,
    fontWeight: 'bold',
    textAlign: 'center',
  },
  lastUpdatedValue: {
    fontSize: 14,
    fontWeight: '500',
    textAlign: 'center',
  },
  chartSection: {
    marginVertical: 16,
    paddingHorizontal: 16,
  },
  chartTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  chartContainer: {
    alignItems: 'center',
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 8,
  },
  chart: {
    borderRadius: 12,
    marginVertical: 8,
  },
  fileNameText: {
    fontSize: 12,
    marginTop: 4,
    textAlign: 'center',
  },
});

export default DebtDashboard;


--- END: src\screens\DebtDashboard.js ---


--- START: src\screens\DirectorDashboardScreen.js ---
import React, { useState, useEffect, useLayoutEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  FlatList,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useNavigation, useFocusEffect } from '@react-navigation/native';
import { useAuth } from '../contexts/AuthContext';
import { useTheme } from '../contexts/ThemeContext';
import {
  getProposalsByStatus,
  canApproveProposal,
} from '../api/proposalService';

const DirectorDashboardScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const { currentUser } = useAuth();
  const [loading, setLoading] = useState(true);
  const [pendingProposals, setPendingProposals] = useState([]);
  const [canApprove, setCanApprove] = useState(false);

  useLayoutEffect(() => {
    navigation.setOptions({
      headerRight: () => (
        <TouchableOpacity
          onPress={() => navigation.navigate('Notifications')}
          style={{ marginRight: 16 }}
        >
          <Ionicons name="notifications-outline" size={24} color="#333" />
        </TouchableOpacity>
      ),
    });
  }, [navigation]);

  // Th√™m useFocusEffect ƒë·ªÉ t·∫£i l·∫°i d·ªØ li·ªáu khi m√†n h√¨nh ƒë∆∞·ª£c focus
  useFocusEffect(
    React.useCallback(() => {
      loadData();
    }, [])
  );

  const loadData = async () => {
    setLoading(true);
    try {
      // Ki·ªÉm tra quy·ªÅn duy·ªát ƒë·ªÅ xu·∫•t
      const hasApprovalPermission = canApproveProposal(currentUser?.role);
      setCanApprove(hasApprovalPermission);

      // N·∫øu c√≥ quy·ªÅn duy·ªát, t·∫£i danh s√°ch ƒë·ªÅ xu·∫•t ch·ªù duy·ªát
      if (hasApprovalPermission) {
        try {
          const proposals = await getProposalsByStatus('pending');
          console.log('Loaded pending proposals:', proposals.length);
          setPendingProposals(proposals);
        } catch (error) {
          console.error('Error loading proposals:', error);
          // V·∫´n set canApprove ƒë·ªÉ hi·ªÉn th·ªã UI
        }
      }
    } catch (error) {
      console.error('Error loading data:', error);
    } finally {
      setLoading(false);
    }
  };

  const formatDate = (timestamp) => {
    if (!timestamp) return 'N/A';
    try {
      if (timestamp.toDate) {
        return timestamp.toDate().toLocaleDateString('vi-VN');
      } else if (timestamp instanceof Date) {
        return timestamp.toLocaleDateString('vi-VN');
      }
      return 'N/A';
    } catch (e) {
      return 'N/A';
    }
  };

  const getPriorityColor = (priority) => {
    switch (priority) {
      case 'urgent':
        return '#FF3B30';
      case 'normal':
        return '#007AFF';
      default:
        return '#007AFF';
    }
  };

  const renderProposalItem = ({ item }) => {
    // Choose icon and color based on priority
    let iconName = 'document-text';
    let iconColor = '#4E8AF4'; // New color for default items

    if (item.priority === 'urgent') {
      iconName = 'alert-circle';
      iconColor = '#FF3B30';
    }

    return (
      <TouchableOpacity
        style={[styles.proposalItem, { backgroundColor: theme.card }]}
        onPress={() => navigation.navigate('ProposalList')}
      >
        <View style={styles.proposalIconContainer}>
          <Ionicons name={iconName} size={24} color={iconColor} />
        </View>
        <View style={styles.proposalContent}>
          <Text
            style={[styles.proposalCode, { color: theme.text }]}
            numberOfLines={1}
          >
            {item.proposalCode}
          </Text>
          <Text
            style={[styles.projectName, { color: theme.textSecondary }]}
            numberOfLines={1}
          >
            {item.projectName}
          </Text>
          <Text
            style={[
              styles.requiredDate,
              {
                color:
                  item.priority === 'urgent' ? '#FF3B30' : theme.textSecondary,
              },
            ]}
          >
            C·∫ßn: {formatDate(item.requiredDate)} ‚Ä¢ {item.items?.length || 0} v·∫≠t
            t∆∞
          </Text>
        </View>
        <Ionicons name="chevron-forward" size={20} color={theme.textMuted} />
      </TouchableOpacity>
    );
  };

  // Helper functions for status and priority
  const getStatusColor = (status) => {
    switch (status) {
      case 'approved':
        return '#34C759';
      case 'rejected':
        return '#FF3B30';
      case 'pending':
      default:
        return '#FF9500';
    }
  };

  const getStatusLabel = (status) => {
    switch (status) {
      case 'approved':
        return 'ƒê√£ duy·ªát';
      case 'rejected':
        return 'T·ª´ ch·ªëi';
      case 'pending':
      default:
        return 'Ch·ªù duy·ªát';
    }
  };

  return (
    <ScrollView
      style={[styles.container, { backgroundColor: theme.background }]}
      contentContainerStyle={styles.contentContainer}
    >
      <Text style={[styles.screenTitle, { color: theme.text }]}>
        B·∫£ng ƒëi·ªÅu khi·ªÉn Gi√°m ƒë·ªëc
      </Text>

      {/* N√∫t truy c·∫≠p m√†n h√¨nh c√¥ng n·ª£ */}
      <TouchableOpacity
        style={[styles.debtButton, { backgroundColor: theme.primary }]}
        onPress={() => navigation.navigate('DebtDashboard')}
      >
        <Ionicons name="cash-outline" size={24} color="white" />
        <Text style={styles.debtButtonText}>Xem b√°o c√°o c√¥ng n·ª£</Text>
      </TouchableOpacity>

      {/* Ph·∫ßn ƒë·ªÅ xu·∫•t ch·ªù duy·ªát */}
      {canApprove && (
        <View style={styles.section}>
          <View style={styles.sectionHeader}>
            <View style={styles.sectionTitleContainer}>
              <Ionicons
                name="file-tray-stacked-outline"
                size={22}
                color={theme.primary}
                style={styles.sectionIcon}
              />
              <Text style={[styles.sectionTitle, { color: theme.text }]}>
                ƒê·ªÅ xu·∫•t ch·ªù duy·ªát
              </Text>
            </View>
            <TouchableOpacity
              style={styles.viewAllButton}
              onPress={() => navigation.navigate('ProposalList')}
            >
              <Text style={[styles.viewAllText, { color: theme.primary }]}>
                Xem t·∫•t c·∫£
              </Text>
              <Ionicons
                name="chevron-forward"
                size={16}
                color={theme.primary}
              />
            </TouchableOpacity>
          </View>

          {loading ? (
            <ActivityIndicator
              size="large"
              color={theme.primary}
              style={styles.loader}
            />
          ) : pendingProposals.length > 0 ? (
            <View
              style={[styles.proposalsContainer, { borderColor: theme.border }]}
            >
              <FlatList
                data={pendingProposals}
                renderItem={renderProposalItem}
                keyExtractor={(item) => item.id}
                style={styles.proposalsList}
                scrollEnabled={true}
                nestedScrollEnabled={true}
                showsVerticalScrollIndicator={true}
                ListFooterComponent={
                  pendingProposals.length > 3 ? (
                    <TouchableOpacity
                      style={[
                        styles.moreButton,
                        { backgroundColor: theme.backgroundLight },
                      ]}
                      onPress={() => navigation.navigate('ProposalList')}
                    >
                      <Text
                        style={[
                          styles.moreButtonText,
                          { color: theme.primary },
                        ]}
                      >
                        Xem th√™m {pendingProposals.length - 3} ƒë·ªÅ xu·∫•t
                      </Text>
                    </TouchableOpacity>
                  ) : null
                }
              />
            </View>
          ) : (
            <View style={[styles.emptyState, { backgroundColor: theme.card }]}>
              <Ionicons
                name="checkmark-circle"
                size={40}
                color={theme.success || '#4CAF50'}
              />
              <Text style={[styles.emptyText, { color: theme.textSecondary }]}>
                Kh√¥ng c√≥ ƒë·ªÅ xu·∫•t n√†o ch·ªù duy·ªát
              </Text>
            </View>
          )}
        </View>
      )}

      {/* C√°c ph·∫ßn kh√°c c·ªßa dashboard */}
      <View style={styles.section}>
        <View style={styles.sectionTitleContainer}>
          <Ionicons
            name="stats-chart"
            size={22}
            color="#0066cc"
            style={styles.sectionIcon}
          />
          <Text style={[styles.sectionTitle, { color: theme.text }]}>
            B√°o c√°o d·ª± √°n
          </Text>
        </View>

        <TouchableOpacity
          style={[styles.dashboardCard, { backgroundColor: theme.card }]}
          onPress={() => navigation.navigate('FinancialDashboard')}
        >
          <Ionicons
            name="stats-chart"
            size={24}
            color="#4CAF50"
            style={styles.cardIcon}
          />
          <View style={styles.cardContent}>
            <Text style={[styles.cardTitle, { color: theme.text }]}>
              B√°o c√°o T√†i ch√≠nh
            </Text>
            <Text
              style={[styles.cardDescription, { color: theme.textSecondary }]}
            >
              Xem doanh thu, chi ph√≠ v√† l·ª£i nhu·∫≠n
            </Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color={theme.textMuted} />
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.dashboardCard, { backgroundColor: theme.card }]}
          onPress={() => navigation.navigate('TotalSalaryReport')}
        >
          <Ionicons
            name="wallet-outline"
            size={24}
            color="#FF9500"
            style={styles.cardIcon}
          />
          <View style={styles.cardContent}>
            <Text style={[styles.cardTitle, { color: theme.text }]}>
              B√°o c√°o t·ªïng l∆∞∆°ng
            </Text>
            <Text
              style={[styles.cardDescription, { color: theme.textSecondary }]}
            >
              Xem t·ªïng l∆∞∆°ng ph·∫£i tr·∫£ cho nh√¢n vi√™n
            </Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color={theme.textMuted} />
        </TouchableOpacity>
      </View>

      <View style={styles.section}>
        <View style={styles.sectionTitleContainer}>
          <Ionicons
            name="people"
            size={22}
            color="#FF9500"
            style={styles.sectionIcon}
          />
          <Text style={[styles.sectionTitle, { color: theme.text }]}>
            Qu·∫£n l√Ω nh√¢n s·ª±
          </Text>
        </View>
        <TouchableOpacity
          style={[styles.dashboardCard, { backgroundColor: theme.card }]}
          onPress={() => navigation.navigate('Attendance')}
        >
          <Ionicons
            name="people"
            size={24}
            color="#FF9500"
            style={styles.cardIcon}
          />
          <View style={styles.cardContent}>
            <Text style={[styles.cardTitle, { color: theme.text }]}>
              Ch·∫•m c√¥ng
            </Text>
            <Text
              style={[styles.cardDescription, { color: theme.textSecondary }]}
            >
              Qu·∫£n l√Ω ch·∫•m c√¥ng v√† tƒÉng ca
            </Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color={theme.textMuted} />
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.dashboardCard, { backgroundColor: theme.card }]}
          onPress={() => navigation.navigate('UserManagement')}
        >
          <Ionicons
            name="person-add"
            size={24}
            color="#FF2D55"
            style={styles.cardIcon}
          />
          <View style={styles.cardContent}>
            <Text style={[styles.cardTitle, { color: theme.text }]}>
              Qu·∫£n l√Ω ng∆∞·ªùi d√πng
            </Text>
            <Text
              style={[styles.cardDescription, { color: theme.textSecondary }]}
            >
              Th√™m v√† ph√¢n quy·ªÅn ng∆∞·ªùi d√πng
            </Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color={theme.textMuted} />
        </TouchableOpacity>
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  contentContainer: {
    padding: 16,
    paddingBottom: 32,
  },
  screenTitle: {
    fontSize: 22,
    fontWeight: 'bold',
    marginBottom: 20,
  },
  debtButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 12,
    borderRadius: 8,
    marginBottom: 20,
  },
  debtButtonText: {
    color: 'white',
    fontWeight: 'bold',
    fontSize: 16,
    marginLeft: 8,
  },
  section: {
    marginBottom: 24,
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  sectionTitleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  sectionIcon: {
    marginRight: 8,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  viewAllButton: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  viewAllText: {
    fontSize: 14,
    fontWeight: '500',
    marginRight: 4,
  },
  proposalsContainer: {
    borderWidth: 1,
    borderRadius: 8,
    height: 220, // Chi·ªÅu cao c·ªë ƒë·ªãnh
    marginBottom: 8,
  },
  proposalsList: {
    flex: 1,
  },
  proposalItem: {
    flexDirection: 'row',
    alignItems: 'center', // Changed from flex-start to center
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  proposalIconContainer: {
    marginRight: 12,
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: '#f0f0f0',
    justifyContent: 'center',
    alignItems: 'center',
  },
  proposalContent: {
    flex: 1,
    marginRight: 8, // Add margin to prevent text touching the arrow
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 2,
  },
  proposalCode: {
    fontWeight: 'bold',
    fontSize: 15,
  },
  projectName: {
    fontSize: 13,
    marginTop: 2,
  },
  requiredDate: {
    fontSize: 12,
    marginTop: 2,
  },
  statusBadge: {
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 4,
  },
  statusText: {
    color: '#fff',
    fontSize: 10,
    fontWeight: '500',
  },
  moreButton: {
    padding: 12,
    alignItems: 'center',
    borderBottomLeftRadius: 8,
    borderBottomRightRadius: 8,
  },
  moreButtonText: {
    fontWeight: '500',
  },
  emptyState: {
    padding: 24,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  emptyText: {
    marginTop: 12,
    fontSize: 16,
    textAlign: 'center',
  },
  loader: {
    padding: 24,
  },
  dashboardCard: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderRadius: 8,
    marginBottom: 12,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  cardIcon: {
    marginRight: 16,
  },
  cardContent: {
    flex: 1,
  },
  cardTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 4,
  },
  cardDescription: {
    fontSize: 14,
  },
});

export default DirectorDashboardScreen;


--- END: src\screens\DirectorDashboardScreen.js ---


--- START: src\screens\EditCustomerScreen.js ---
//src/screens/EditCustomerScreen.js
import React, { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { updateCustomer } from '../api/customerService';
import { useAuth } from '../contexts/AuthContext';

const EditCustomerScreen = ({ route, navigation }) => {
  const { customer } = route.params;
  const { currentUser } = useAuth();
  const [isLoading, setIsLoading] = useState(false);
  const [formData, setFormData] = useState({
    name: customer.name || '',
    contactPerson: customer.contactPerson || '',
    phone: customer.phone || '',
    email: customer.email || '',
    address: customer.address || '',
    type: customer.type || 'regular',
    taxCode: customer.taxCode || '',
  });

  // C·∫≠p nh·∫≠t gi√° tr·ªã form
  const handleChange = (field, value) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));
  };

  // Ki·ªÉm tra form h·ª£p l·ªá
  const validateForm = () => {
    if (!formData.name.trim()) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p t√™n kh√°ch h√†ng');
      return false;
    }

    if (!formData.contactPerson.trim()) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p t√™n ng∆∞·ªùi li√™n h·ªá');
      return false;
    }

    if (formData.email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
      Alert.alert('L·ªói', 'Email kh√¥ng h·ª£p l·ªá');
      return false;
    }

    return true;
  };

  // X·ª≠ l√Ω c·∫≠p nh·∫≠t kh√°ch h√†ng
  const handleUpdate = async () => {
    if (!validateForm()) {
      return;
    }

    setIsLoading(true);

    try {
      // G·ªçi API c·∫≠p nh·∫≠t th√¥ng tin kh√°ch h√†ng
      await updateCustomer(customer.id, formData, currentUser?.uid);

      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ c·∫≠p nh·∫≠t th√¥ng tin kh√°ch h√†ng th√†nh c√¥ng', [
        {
          text: 'OK',
          onPress: () => navigation.goBack(),
        },
      ]);
    } catch (error) {
      if (error.code === 'permission-denied') {
        Alert.alert(
          'L·ªói quy·ªÅn',
          'B·∫°n kh√¥ng c√≥ ƒë·ªß quy·ªÅn ƒë·ªÉ th·ª±c hi·ªán h√†nh ƒë·ªông n√†y.'
        );
      } else {
        console.error('L·ªói khi c·∫≠p nh·∫≠t kh√°ch h√†ng:', error);
        Alert.alert(
          'L·ªói',
          'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t th√¥ng tin kh√°ch h√†ng. Vui l√≤ng th·ª≠ l·∫°i sau.'
        );
      }
    } finally {
      setIsLoading(false);
    }
  };

  // X·ª≠ l√Ω thay ƒë·ªïi lo·∫°i kh√°ch h√†ng
  const handleSelectType = (type) => {
    handleChange('type', type);
  };

  return (
    <KeyboardAvoidingView
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      style={styles.container}
    >
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Ch·ªânh s·ª≠a th√¥ng tin kh√°ch h√†ng</Text>
        <View style={styles.placeholder} />
      </View>

      <ScrollView
        style={styles.formContainer}
        contentContainerStyle={styles.formContent}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.inputGroup}>
          <Text style={styles.label}>
            T√™n c√¥ng ty / T·ªï ch·ª©c <Text style={styles.required}>*</Text>
          </Text>
          <TextInput
            style={styles.input}
            value={formData.name}
            onChangeText={(text) => handleChange('name', text)}
            placeholder="Nh·∫≠p t√™n c√¥ng ty ho·∫∑c t·ªï ch·ª©c"
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>
            Ng∆∞·ªùi li√™n h·ªá <Text style={styles.required}>*</Text>
          </Text>
          <TextInput
            style={styles.input}
            value={formData.contactPerson}
            onChangeText={(text) => handleChange('contactPerson', text)}
            placeholder="Nh·∫≠p t√™n ng∆∞·ªùi li√™n h·ªá"
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>S·ªë ƒëi·ªán tho·∫°i</Text>
          <TextInput
            style={styles.input}
            value={formData.phone}
            onChangeText={(text) => handleChange('phone', text)}
            placeholder="Nh·∫≠p s·ªë ƒëi·ªán tho·∫°i"
            keyboardType="phone-pad"
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>Email</Text>
          <TextInput
            style={styles.input}
            value={formData.email}
            onChangeText={(text) => handleChange('email', text)}
            placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ email"
            keyboardType="email-address"
            autoCapitalize="none"
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>ƒê·ªãa ch·ªâ</Text>
          <TextInput
            style={[styles.input, styles.textArea]}
            value={formData.address}
            onChangeText={(text) => handleChange('address', text)}
            placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ"
            multiline
            numberOfLines={3}
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>M√£ s·ªë thu·∫ø</Text>
          <TextInput
            style={styles.input}
            value={formData.taxCode}
            onChangeText={(text) => handleChange('taxCode', text)}
            placeholder="Nh·∫≠p m√£ s·ªë thu·∫ø"
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>Lo·∫°i kh√°ch h√†ng</Text>
          <View style={styles.typeButtonsContainer}>
            <TouchableOpacity
              style={[
                styles.typeButton,
                formData.type === 'potential' && styles.selectedTypeButton,
              ]}
              onPress={() => handleSelectType('potential')}
            >
              <Text
                style={[
                  styles.typeButtonText,
                  formData.type === 'potential' &&
                    styles.selectedTypeButtonText,
                ]}
              >
                Ti·ªÅm nƒÉng
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.typeButton,
                formData.type === 'regular' && styles.selectedTypeButton,
              ]}
              onPress={() => handleSelectType('regular')}
            >
              <Text
                style={[
                  styles.typeButtonText,
                  formData.type === 'regular' && styles.selectedTypeButtonText,
                ]}
              >
                Th∆∞·ªùng xuy√™n
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.typeButton,
                formData.type === 'vip' && styles.selectedTypeButton,
              ]}
              onPress={() => handleSelectType('vip')}
            >
              <Text
                style={[
                  styles.typeButtonText,
                  formData.type === 'vip' && styles.selectedTypeButtonText,
                ]}
              >
                VIP
              </Text>
            </TouchableOpacity>
          </View>
        </View>
      </ScrollView>

      <View style={styles.footer}>
        <TouchableOpacity
          style={styles.saveButton}
          onPress={handleUpdate}
          disabled={isLoading}
        >
          {isLoading ? (
            <ActivityIndicator color="#fff" size="small" />
          ) : (
            <>
              <Ionicons name="save-outline" size={20} color="#fff" />
              <Text style={styles.saveButtonText}>L∆∞u thay ƒë·ªïi</Text>
            </>
          )}
        </TouchableOpacity>
      </View>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  placeholder: {
    width: 24,
  },
  formContainer: {
    flex: 1,
  },
  formContent: {
    padding: 16,
  },
  inputGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    marginBottom: 6,
    color: '#333',
  },
  required: {
    color: '#e74c3c',
  },
  input: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    color: '#333',
  },
  textArea: {
    minHeight: 80,
    textAlignVertical: 'top',
  },
  typeButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  typeButton: {
    flex: 1,
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 8,
    borderRadius: 8,
    marginHorizontal: 4,
    alignItems: 'center',
  },
  selectedTypeButton: {
    backgroundColor: '#0066cc',
  },
  typeButtonText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '500',
  },
  selectedTypeButtonText: {
    color: '#fff',
  },
  footer: {
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  saveButton: {
    backgroundColor: '#0066cc',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    borderRadius: 8,
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
});

export default EditCustomerScreen;


--- END: src\screens\EditCustomerScreen.js ---


--- START: src\screens\EditInventoryItemScreen.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  Image,
  Alert,
  Platform,
} from 'react-native';
import {
  TextInput,
  Button,
  Text,
  Appbar,
  HelperText,
  Divider,
  Dialog,
  Portal,
  List,
  ActivityIndicator,
} from 'react-native-paper';
import { useNavigation, useRoute } from '@react-navigation/native';
import * as ImagePicker from 'expo-image-picker';
import InventoryService from '../api/inventoryService';
import { firebase } from '../config/firebaseConfig';
import useInventory from '../hooks/useInventory';

const EditInventoryItemScreen = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { itemId } = route.params || {};
  const { updateInventoryItem, getInventoryItemDetail } = useInventory();

  // State cho form ch·ªânh s·ª≠a v·∫≠t t∆∞
  const [formData, setFormData] = useState({
    name: '',
    code: '',
    description: '',
    categoryId: '',
    unit: '',
    stockQuantity: 0,
    minQuantity: 0,
    price: 0,
    weight: 0,
    material: '',
    totalPrice: 0,
  });
  const [image, setImage] = useState(null);
  const [imageBlob, setImageBlob] = useState(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [errors, setErrors] = useState({});
  const [categories, setCategories] = useState([]);
  const [selectedCategory, setSelectedCategory] = useState(null);
  const [categoryDialogVisible, setCategoryDialogVisible] = useState(false);
  const [units] = useState([
    'c√°i',
    'b·ªô',
    't·∫•m',
    'kg',
    'm√©t',
    'm2',
    'cu·ªôn',
    'l√≠t',
    'lon',
  ]);
  const [unitDialogVisible, setUnitDialogVisible] = useState(false);

  // Load d·ªØ li·ªáu v·∫≠t t∆∞ v√† danh s√°ch danh m·ª•c khi m√†n h√¨nh ƒë∆∞·ª£c mount
  useEffect(() => {
    fetchCategories();
    requestPermissions();

    // N·∫øu c√≥ itemId th√¨ load th√¥ng tin v·∫≠t t∆∞
    if (itemId) {
      fetchItemDetails();
    } else {
      // N·∫øu kh√¥ng c√≥ itemId, quay v·ªÅ m√†n h√¨nh tr∆∞·ªõc
      Alert.alert('L·ªói', 'Kh√¥ng t√¨m th·∫•y th√¥ng tin v·∫≠t t∆∞');
      navigation.goBack();
      setLoading(false);
    }
  }, [itemId]);

  // H√†m l·∫•y chi ti·∫øt v·∫≠t t∆∞
  const fetchItemDetails = async () => {
    try {
      const itemDetails = await getInventoryItemDetail(itemId);

      // C·∫≠p nh·∫≠t formData t·ª´ th√¥ng tin v·∫≠t t∆∞
      setFormData({
        name: itemDetails.name || '',
        code: itemDetails.code || '',
        description: itemDetails.description || '',
        categoryId: itemDetails.categoryId || '',
        unit: itemDetails.unit || '',
        stockQuantity: itemDetails.stockQuantity || 0,
        minQuantity: itemDetails.minQuantity || 0,
        price: itemDetails.price || 0,
        weight: itemDetails.weight || 0,
        material: itemDetails.material || '',
        totalPrice: itemDetails.totalPrice || 0,
      });

      // C·∫≠p nh·∫≠t category ƒë√£ ch·ªçn
      if (itemDetails.categoryId && categories.length > 0) {
        const category = categories.find(
          (c) => c.id === itemDetails.categoryId
        );
        if (category) {
          setSelectedCategory(category);
        }
      } else if (itemDetails.category) {
        setSelectedCategory(itemDetails.category);
      }

      // C·∫≠p nh·∫≠t h√¨nh ·∫£nh n·∫øu c√≥
      if (itemDetails.imageUrl) {
        setImage(itemDetails.imageUrl);
      }

      setLoading(false);
    } catch (error) {
      console.error('L·ªói khi l·∫•y chi ti·∫øt v·∫≠t t∆∞:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ l·∫•y th√¥ng tin v·∫≠t t∆∞');
      navigation.goBack();
    }
  };

  // H√†m l·∫•y danh s√°ch danh m·ª•c t·ª´ Firestore
  const fetchCategories = async () => {
    try {
      const snapshot = await firebase
        .firestore()
        .collection('inventory_categories')
        .get();
      const fetchedCategories = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));
      setCategories(fetchedCategories);
    } catch (error) {
      console.error('L·ªói khi l·∫•y danh m·ª•c:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ l·∫•y danh s√°ch danh m·ª•c');
    }
  };

  // Y√™u c·∫ßu quy·ªÅn truy c·∫≠p camera v√† th∆∞ vi·ªán ·∫£nh
  const requestPermissions = async () => {
    if (Platform.OS !== 'web') {
      const { status: cameraStatus } =
        await ImagePicker.requestCameraPermissionsAsync();
      const { status: libraryStatus } =
        await ImagePicker.requestMediaLibraryPermissionsAsync();

      if (cameraStatus !== 'granted' || libraryStatus !== 'granted') {
        Alert.alert(
          'C·∫ßn quy·ªÅn truy c·∫≠p',
          'B·∫°n c·∫ßn c·∫•p quy·ªÅn ƒë·ªÉ s·ª≠ d·ª•ng camera v√† th∆∞ vi·ªán ·∫£nh.'
        );
      }
    }
  };

  // X·ª≠ l√Ω thay ƒë·ªïi gi√° tr·ªã c√°c tr∆∞·ªùng
  const handleChange = (field, value) => {
    // X·ª≠ l√Ω cho tr∆∞·ªùng s·ªë
    if (['stockQuantity', 'minQuantity', 'price', 'weight'].includes(field)) {
      const numericValue = parseFloat(value.replace(/[^0-9.]/g, ''));
      const updatedValue = isNaN(numericValue) ? 0 : numericValue;

      const updatedFormData = {
        ...formData,
        [field]: updatedValue,
      };

      // T√≠nh to√°n l·∫°i gi√° tr·ªã totalPrice n·∫øu thay ƒë·ªïi s·ªë l∆∞·ª£ng ho·∫∑c ƒë∆°n gi√°
      if (field === 'stockQuantity' || field === 'price') {
        updatedFormData.totalPrice =
          updatedFormData.stockQuantity * updatedFormData.price;
      }

      setFormData(updatedFormData);
    } else {
      setFormData({
        ...formData,
        [field]: value,
      });
    }

    // X√≥a l·ªói khi ng∆∞·ªùi d√πng ƒëi·ªÅn l·∫°i
    if (errors[field]) {
      setErrors({
        ...errors,
        [field]: null,
      });
    }
  };

  // Ch·ªçn danh m·ª•c
  const handleCategorySelect = (category) => {
    setSelectedCategory(category);
    setFormData({
      ...formData,
      categoryId: category.id,
    });
    setCategoryDialogVisible(false);

    // X√≥a l·ªói danh m·ª•c n·∫øu c√≥
    if (errors.categoryId) {
      setErrors({
        ...errors,
        categoryId: null,
      });
    }
  };

  // Ch·ªçn ƒë∆°n v·ªã t√≠nh
  const handleUnitSelect = (unit) => {
    setFormData({
      ...formData,
      unit,
    });
    setUnitDialogVisible(false);

    // X√≥a l·ªói ƒë∆°n v·ªã n·∫øu c√≥
    if (errors.unit) {
      setErrors({
        ...errors,
        unit: null,
      });
    }
  };

  // Ch·ªçn ·∫£nh t·ª´ th∆∞ vi·ªán
  const pickImage = async () => {
    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        aspect: [4, 3],
        quality: 0.8,
      });

      if (!result.canceled && result.assets && result.assets[0]) {
        const imageUri = result.assets[0].uri;
        setImage(imageUri);

        // Chuy·ªÉn ·∫£nh th√†nh blob ƒë·ªÉ upload
        const response = await fetch(imageUri);
        const blob = await response.blob();
        setImageBlob(blob);
      }
    } catch (error) {
      console.error('L·ªói khi ch·ªçn ·∫£nh:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ch·ªçn ·∫£nh');
    }
  };

  // Ch·ª•p ·∫£nh t·ª´ camera
  const takePhoto = async () => {
    try {
      const result = await ImagePicker.launchCameraAsync({
        allowsEditing: true,
        aspect: [4, 3],
        quality: 0.8,
      });

      if (!result.canceled && result.assets && result.assets[0]) {
        const imageUri = result.assets[0].uri;
        setImage(imageUri);

        // Chuy·ªÉn ·∫£nh th√†nh blob ƒë·ªÉ upload
        const response = await fetch(imageUri);
        const blob = await response.blob();
        setImageBlob(blob);
      }
    } catch (error) {
      console.error('L·ªói khi ch·ª•p ·∫£nh:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ch·ª•p ·∫£nh');
    }
  };

  // Ki·ªÉm tra form tr∆∞·ªõc khi l∆∞u
  const validateForm = () => {
    const newErrors = {};

    if (!formData.name.trim()) {
      newErrors.name = 'Vui l√≤ng nh·∫≠p t√™n v·∫≠t t∆∞';
    }

    if (!formData.code.trim()) {
      newErrors.code = 'Vui l√≤ng nh·∫≠p m√£ v·∫≠t t∆∞';
    }

    if (!formData.categoryId) {
      newErrors.categoryId = 'Vui l√≤ng ch·ªçn danh m·ª•c';
    }

    if (!formData.unit.trim()) {
      newErrors.unit = 'Vui l√≤ng ch·ªçn ƒë∆°n v·ªã t√≠nh';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // C·∫≠p nh·∫≠t v·∫≠t t∆∞
  const handleSave = async () => {
    if (!validateForm()) return;

    setSaving(true);

    try {
      // C·∫≠p nh·∫≠t v·∫≠t t∆∞
      const result = await updateInventoryItem(itemId, formData);

      // N·∫øu c√≥ h√¨nh ·∫£nh m·ªõi, upload v√† c·∫≠p nh·∫≠t URL
      if (imageBlob) {
        await InventoryService.uploadItemImage(itemId, imageBlob);
      }

      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ c·∫≠p nh·∫≠t th√¥ng tin v·∫≠t t∆∞', [
        { text: 'OK', onPress: () => navigation.goBack() },
      ]);
    } catch (error) {
      console.error('L·ªói khi c·∫≠p nh·∫≠t v·∫≠t t∆∞:', error);
      Alert.alert('L·ªói', error.message || 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t v·∫≠t t∆∞');
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0066cc" />
        <Text style={styles.loadingText}>ƒêang t·∫£i th√¥ng tin v·∫≠t t∆∞...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Appbar.Header>
        <Appbar.BackAction onPress={() => navigation.goBack()} />
        <Appbar.Content title="Ch·ªânh s·ª≠a v·∫≠t t∆∞" />
      </Appbar.Header>

      <ScrollView style={styles.scrollView}>
        {/* Th√¥ng tin c∆° b·∫£n */}
        <Text style={styles.sectionTitle}>Th√¥ng tin c∆° b·∫£n</Text>

        <TextInput
          label="T√™n v·∫≠t t∆∞ *"
          value={formData.name}
          onChangeText={(text) => handleChange('name', text)}
          style={styles.input}
          error={!!errors.name}
        />
        {errors.name && <HelperText type="error">{errors.name}</HelperText>}

        <TextInput
          label="M√£ v·∫≠t t∆∞ *"
          value={formData.code}
          onChangeText={(text) => handleChange('code', text)}
          style={styles.input}
          error={!!errors.code}
        />
        {errors.code && <HelperText type="error">{errors.code}</HelperText>}

        <TouchableOpacity
          onPress={() => setCategoryDialogVisible(true)}
          style={styles.input}
        >
          <TextInput
            label="Danh m·ª•c *"
            value={selectedCategory ? selectedCategory.name : ''}
            editable={false}
            right={<TextInput.Icon icon="menu-down" />}
            error={!!errors.categoryId}
          />
        </TouchableOpacity>
        {errors.categoryId && (
          <HelperText type="error">{errors.categoryId}</HelperText>
        )}

        <TouchableOpacity
          onPress={() => setUnitDialogVisible(true)}
          style={styles.input}
        >
          <TextInput
            label="ƒê∆°n v·ªã t√≠nh *"
            value={formData.unit}
            editable={false}
            right={<TextInput.Icon icon="menu-down" />}
            error={!!errors.unit}
          />
        </TouchableOpacity>
        {errors.unit && <HelperText type="error">{errors.unit}</HelperText>}

        <TextInput
          label="M√¥ t·∫£"
          value={formData.description}
          onChangeText={(text) => handleChange('description', text)}
          multiline
          numberOfLines={3}
          style={styles.input}
        />

        <Divider style={styles.divider} />

        {/* Th√¥ng tin s·ªë l∆∞·ª£ng v√† ƒë∆°n gi√° */}
        <Text style={styles.sectionTitle}>Th√¥ng tin s·ªë l∆∞·ª£ng v√† ƒë∆°n gi√°</Text>

        <TextInput
          label="S·ªë l∆∞·ª£ng t·ªìn kho"
          value={formData.stockQuantity.toString()}
          onChangeText={(text) => handleChange('stockQuantity', text)}
          keyboardType="numeric"
          style={styles.input}
        />

        <TextInput
          label="S·ªë l∆∞·ª£ng t·ªìn t·ªëi thi·ªÉu"
          value={formData.minQuantity.toString()}
          onChangeText={(text) => handleChange('minQuantity', text)}
          keyboardType="numeric"
          style={styles.input}
        />

        <TextInput
          label={`ƒê∆°n gi√° (VNƒê/${formData.unit || 'ƒë∆°n v·ªã'})`}
          value={formData.price.toString()}
          onChangeText={(text) => handleChange('price', text)}
          keyboardType="numeric"
          style={styles.input}
        />

        <View style={styles.totalPriceContainer}>
          <Text style={styles.totalPriceLabel}>T·ªïng gi√° tr·ªã:</Text>
          <Text style={styles.totalPriceValue}>
            {(formData.totalPrice || 0).toLocaleString('vi-VN')} VNƒê
          </Text>
        </View>

        <Divider style={styles.divider} />

        {/* Th√¥ng tin b·ªï sung */}
        <Text style={styles.sectionTitle}>Th√¥ng tin b·ªï sung</Text>

        <TextInput
          label="V·∫≠t li·ªáu"
          value={formData.material}
          onChangeText={(text) => handleChange('material', text)}
          style={styles.input}
        />

        <TextInput
          label="Kh·ªëi l∆∞·ª£ng (kg)"
          value={formData.weight.toString()}
          onChangeText={(text) => handleChange('weight', text)}
          keyboardType="numeric"
          style={styles.input}
        />

        {/* Ph·∫ßn upload h√¨nh ·∫£nh */}
        <Text style={styles.sectionTitle}>H√¨nh ·∫£nh v·∫≠t t∆∞</Text>

        <View style={styles.imageContainer}>
          {image ? (
            <Image source={{ uri: image }} style={styles.image} />
          ) : (
            <View style={styles.imagePlaceholder}>
              <Text style={styles.placeholderText}>Ch∆∞a c√≥ ·∫£nh</Text>
            </View>
          )}

          <View style={styles.imageButtons}>
            <Button
              mode="contained"
              onPress={pickImage}
              style={styles.imageButton}
            >
              Ch·ªçn ·∫£nh
            </Button>
            <Button
              mode="outlined"
              onPress={takePhoto}
              style={styles.imageButton}
            >
              Ch·ª•p ·∫£nh
            </Button>
          </View>
        </View>

        {/* N√∫t l∆∞u */}
        <Button
          mode="contained"
          onPress={handleSave}
          style={styles.saveButton}
          loading={saving}
          disabled={saving}
        >
          C·∫≠p nh·∫≠t v·∫≠t t∆∞
        </Button>
      </ScrollView>

      {/* Dialog ch·ªçn danh m·ª•c */}
      <Portal>
        <Dialog
          visible={categoryDialogVisible}
          onDismiss={() => setCategoryDialogVisible(false)}
        >
          <Dialog.Title>Ch·ªçn danh m·ª•c</Dialog.Title>
          <Dialog.Content>
            <ScrollView style={{ maxHeight: 300 }}>
              {categories.map((category) => (
                <List.Item
                  key={category.id}
                  title={category.name}
                  description={category.description}
                  onPress={() => handleCategorySelect(category)}
                />
              ))}
            </ScrollView>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setCategoryDialogVisible(false)}>
              ƒê√≥ng
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* Dialog ch·ªçn ƒë∆°n v·ªã t√≠nh */}
      <Portal>
        <Dialog
          visible={unitDialogVisible}
          onDismiss={() => setUnitDialogVisible(false)}
        >
          <Dialog.Title>Ch·ªçn ƒë∆°n v·ªã t√≠nh</Dialog.Title>
          <Dialog.Content>
            <ScrollView style={{ maxHeight: 300 }}>
              {units.map((unit) => (
                <List.Item
                  key={unit}
                  title={unit}
                  onPress={() => handleUnitSelect(unit)}
                />
              ))}
            </ScrollView>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setUnitDialogVisible(false)}>ƒê√≥ng</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  loadingText: {
    marginTop: 10,
    color: '#666',
  },
  scrollView: {
    flex: 1,
    padding: 16,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginVertical: 12,
  },
  input: {
    marginBottom: 8,
    backgroundColor: 'white',
  },
  divider: {
    marginVertical: 16,
  },
  imageContainer: {
    marginVertical: 10,
    alignItems: 'center',
  },
  image: {
    width: '100%',
    height: 200,
    borderRadius: 8,
    marginBottom: 10,
  },
  imagePlaceholder: {
    width: '100%',
    height: 200,
    borderRadius: 8,
    backgroundColor: '#e0e0e0',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 10,
  },
  placeholderText: {
    color: '#757575',
  },
  imageButtons: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    width: '100%',
  },
  imageButton: {
    flex: 1,
    marginHorizontal: 5,
  },
  saveButton: {
    marginVertical: 24,
    paddingVertical: 6,
    backgroundColor: '#3f51b5',
  },
  totalPriceContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    backgroundColor: '#f0f0f0',
    borderRadius: 8,
    marginBottom: 16,
  },
  totalPriceLabel: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  totalPriceValue: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#3f51b5',
  },
});

export default EditInventoryItemScreen;


--- END: src\screens\EditInventoryItemScreen.js ---


--- START: src\screens\EditProjectScreen.js ---
//src/screens/EditProjectScreen.js
import React, { useState, useEffect, useLayoutEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
  Modal,
  FlatList,
  LogBox,
  ActionSheetIOS,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import DateTimePicker from '@react-native-community/datetimepicker';
import { updateProject } from '../api/projectService';
import { getCustomers } from '../api/customerService';
import { useAuth } from '../contexts/AuthContext';
import DraggableFlatList from 'react-native-draggable-flatlist';
import ProcessPickerModal from '../components/ProcessPickerModal';
import uuid from 'react-native-uuid';
import { GestureHandlerRootView } from 'react-native-gesture-handler';

// Ignore the VirtualizedLists nested warning (we purposely nest one non-scrollable list inside a ScrollView)
LogBox.ignoreLogs(['VirtualizedLists should never be nested']);

const EditProjectScreen = ({ route, navigation }) => {
  // L·∫•y th√¥ng tin d·ª± √°n t·ª´ route params
  const { project } = route.params;
  const { currentUser } = useAuth();
  const [isLoading, setIsLoading] = useState(false);
  const [customers, setCustomers] = useState([]);
  const [loadingCustomers, setLoadingCustomers] = useState(true);
  const [customerModalVisible, setCustomerModalVisible] = useState(false);
  const [customerSearchQuery, setCustomerSearchQuery] = useState('');
  const [filteredCustomers, setFilteredCustomers] = useState([]);

  // Th√™m state cho date picker
  const [showStartDatePicker, setShowStartDatePicker] = useState(false);
  const [showEndDatePicker, setShowEndDatePicker] = useState(false);

  // Kh·ªüi t·∫°o formData v·ªõi d·ªØ li·ªáu d·ª± √°n hi·ªán t·∫°i
  const [formData, setFormData] = useState({
    name: project?.name || '',
    description: project?.description || '',
    customerId: project?.customerId || '',
    customerName: project?.customerName || '',
    status: project?.status || 'pending',
    startDate: project?.startDate
      ? new Date(project.startDate.seconds * 1000)
      : null,
    endDate: project?.endDate ? new Date(project.endDate.seconds * 1000) : null,
    durationInDays: project?.durationInDays
      ? String(project.durationInDays)
      : '',
    location: project?.location || 'workshop', // 'workshop' (t·∫°i x∆∞·ªüng) ho·∫∑c 'site' (t·∫°i c√¥ng tr√¨nh)
    budget: project?.budget ? String(project.budget) : '',
    notes: project?.notes || '',
  });

  // L·∫•y danh s√°ch kh√°ch h√†ng khi m√†n h√¨nh ƒë∆∞·ª£c t·∫£i
  useEffect(() => {
    const fetchCustomers = async () => {
      try {
        setLoadingCustomers(true);
        const data = await getCustomers();
        setCustomers(data);
        setFilteredCustomers(data);
      } catch (error) {
        console.error('L·ªói khi l·∫•y danh s√°ch kh√°ch h√†ng:', error);
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch kh√°ch h√†ng');
      } finally {
        setLoadingCustomers(false);
      }
    };

    fetchCustomers();
  }, []);

  // L·ªçc danh s√°ch kh√°ch h√†ng khi t·ª´ kh√≥a t√¨m ki·∫øm thay ƒë·ªïi
  useEffect(() => {
    if (!customerSearchQuery.trim()) {
      setFilteredCustomers(customers);
      return;
    }

    const query = customerSearchQuery.toLowerCase().trim();
    const filtered = customers.filter((customer) => {
      const name = (customer.name || '').toLowerCase();
      const contact = (customer.contactPerson || '').toLowerCase();
      const email = (customer.email || '').toLowerCase();

      return (
        name.includes(query) || contact.includes(query) || email.includes(query)
      );
    });

    setFilteredCustomers(filtered);
  }, [customerSearchQuery, customers]);

  // C·∫≠p nh·∫≠t gi√° tr·ªã form
  const handleChange = (field, value) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));
  };

  // X·ª≠ l√Ω khi ch·ªçn ng√†y b·∫Øt ƒë·∫ßu
  const handleStartDateChange = (event, selectedDate) => {
    setShowStartDatePicker(false);
    if (selectedDate) {
      handleChange('startDate', selectedDate);

      // T·ª± ƒë·ªông t√≠nh ng√†y k·∫øt th√∫c n·∫øu c√≥ s·ªë ng√†y thi c√¥ng
      if (formData.durationInDays) {
        const endDate = new Date(selectedDate);
        endDate.setDate(endDate.getDate() + Number(formData.durationInDays));
        handleChange('endDate', endDate);
      }
    }
  };

  // X·ª≠ l√Ω khi nh·∫≠p s·ªë ng√†y thi c√¥ng
  const handleDurationChange = (text) => {
    handleChange('durationInDays', text);

    // T·ª± ƒë·ªông t√≠nh ng√†y k·∫øt th√∫c n·∫øu c√≥ ng√†y b·∫Øt ƒë·∫ßu
    if (formData.startDate && text) {
      const endDate = new Date(formData.startDate);
      endDate.setDate(endDate.getDate() + Number(text));
      handleChange('endDate', endDate);
    }
  };

  // X·ª≠ l√Ω khi ch·ªçn v·ªã tr√≠
  const handleLocationChange = (location) => {
    handleChange('location', location);
  };

  // ƒê·ªãnh d·∫°ng ng√†y ƒë·ªÉ hi·ªÉn th·ªã
  const formatDate = (date) => {
    if (!date) return '';
    return date.toLocaleDateString('vi-VN');
  };

  // Ki·ªÉm tra form h·ª£p l·ªá
  const validateForm = () => {
    if (!formData.name.trim()) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p t√™n d·ª± √°n');
      return false;
    }

    return true;
  };

  // X·ª≠ l√Ω c·∫≠p nh·∫≠t d·ª± √°n
  const handleUpdate = async () => {
    if (!validateForm()) {
      return;
    }

    setIsLoading(true);

    try {
      // Chu·∫©n b·ªã d·ªØ li·ªáu ƒë·ªÉ l∆∞u
      const projectData = {
        ...formData,
        tasks: formData.tasks, // **QUAN TR·ªåNG: ƒê·∫£m b·∫£o d√≤ng n√†y t·ªìn t·∫°i**
        budget: formData.budget ? Number(formData.budget) : null,
        durationInDays: formData.durationInDays
          ? Number(formData.durationInDays)
          : null,
        workflowStages: workflowStages.map((s, index) => ({
          ...s,
          order: index,
        })),
      };

      // G·ªçi API c·∫≠p nh·∫≠t d·ª± √°n
      await updateProject(project.id, projectData, currentUser?.uid);

      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ c·∫≠p nh·∫≠t d·ª± √°n th√†nh c√¥ng', [
        {
          text: 'OK',
          onPress: () => navigation.goBack(),
        },
      ]);
    } catch (error) {
      if (error.code === 'permission-denied') {
        Alert.alert(
          'L·ªói quy·ªÅn',
          'B·∫°n kh√¥ng c√≥ ƒë·ªß quy·ªÅn ƒë·ªÉ th·ª±c hi·ªán h√†nh ƒë·ªông n√†y.'
        );
      } else {
        console.error('L·ªói khi c·∫≠p nh·∫≠t d·ª± √°n:', error);
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t d·ª± √°n. Vui l√≤ng th·ª≠ l·∫°i sau.');
      }
    } finally {
      setIsLoading(false);
    }
  };

  // X·ª≠ l√Ω thay ƒë·ªïi tr·∫°ng th√°i d·ª± √°n
  const handleSelectStatus = (status) => {
    handleChange('status', status);
  };

  // X·ª≠ l√Ω m·ªü modal ch·ªçn kh√°ch h√†ng
  const handleOpenCustomerModal = () => {
    setCustomerModalVisible(true);
  };

  // X·ª≠ l√Ω ƒë√≥ng modal ch·ªçn kh√°ch h√†ng
  const handleCloseCustomerModal = () => {
    setCustomerModalVisible(false);
    setCustomerSearchQuery('');
  };

  // X·ª≠ l√Ω khi ch·ªçn kh√°ch h√†ng
  const handleSelectCustomer = (customer) => {
    setFormData((prev) => ({
      ...prev,
      customerId: customer.id,
      customerName: customer.name,
    }));
    handleCloseCustomerModal();
  };

  // X·ª≠ l√Ω khi t√¨m ki·∫øm kh√°ch h√†ng
  const handleSearchCustomer = (text) => {
    setCustomerSearchQuery(text);
  };

  // X·ª≠ l√Ω khi x√≥a kh√°ch h√†ng ƒë√£ ch·ªçn
  const handleClearCustomer = () => {
    setFormData((prev) => ({
      ...prev,
      customerId: '',
      customerName: '',
    }));
  };

  // Render m·ªôt item trong danh s√°ch kh√°ch h√†ng
  const renderCustomerItem = ({ item }) => (
    <TouchableOpacity
      style={[
        styles.customerItem,
        item.id === formData.customerId && styles.selectedCustomerItem,
      ]}
      onPress={() => handleSelectCustomer(item)}
    >
      <View>
        <Text style={styles.customerName}>
          {item.name}
          {item.id === formData.customerId && ' (ƒê√£ ch·ªçn)'}
        </Text>
        {item.contactPerson && (
          <Text style={styles.customerDetail}>
            Ng∆∞·ªùi li√™n h·ªá: {item.contactPerson}
          </Text>
        )}
        {item.email && (
          <Text style={styles.customerDetail}>Email: {item.email}</Text>
        )}
      </View>
      {item.id === formData.customerId && (
        <Ionicons name="checkmark-circle" size={20} color="#0066cc" />
      )}
      {item.id !== formData.customerId && (
        <Ionicons name="chevron-forward" size={20} color="#999" />
      )}
    </TouchableOpacity>
  );

  // ·∫®n header m·∫∑c ƒë·ªãnh ƒë·ªÉ tr√°nh tr√πng l·∫∑p
  useLayoutEffect(() => {
    navigation.setOptions({ headerShown: false });
  }, [navigation]);

  const [workflowStages, setWorkflowStages] = useState(
    project?.workflowStages || []
  );
  const [pickerVisible, setPickerVisible] = useState(false);

  // Remove stage
  const handleRemoveStage = (stageId) => {
    Alert.alert('X√°c nh·∫≠n', 'X√≥a c√¥ng ƒëo·∫°n n√†y?', [
      { text: 'H·ªßy', style: 'cancel' },
      {
        text: 'X√≥a',
        style: 'destructive',
        onPress: () =>
          setWorkflowStages((prev) =>
            prev.filter((s) => s.stageId !== stageId)
          ),
      },
    ]);
  };

  const STATUS_OPTIONS = [
    { value: 'pending', label: 'Ch·ªù x·ª≠ l√Ω' },
    { value: 'in_progress', label: 'ƒêang l√†m' },
    { value: 'completed', label: 'Ho√†n th√†nh' },
  ];

  const changeStageStatusLocal = (stageId, newStatus) => {
    setWorkflowStages((prev) =>
      prev.map((s) => (s.stageId === stageId ? { ...s, status: newStatus } : s))
    );
  };

  const quickChangeStatus = (stage) => {
    if (Platform.OS === 'ios') {
      ActionSheetIOS.showActionSheetWithOptions(
        {
          options: [...STATUS_OPTIONS.map((s) => s.label), 'H·ªßy'],
          cancelButtonIndex: STATUS_OPTIONS.length,
        },
        (idx) => {
          if (idx < STATUS_OPTIONS.length) {
            changeStageStatusLocal(stage.stageId, STATUS_OPTIONS[idx].value);
          }
        }
      );
    } else {
      Alert.alert('Ch·ªçn tr·∫°ng th√°i', null, [
        ...STATUS_OPTIONS.map((opt) => ({
          text: opt.label,
          onPress: () => changeStageStatusLocal(stage.stageId, opt.value),
        })),
        { text: 'H·ªßy', style: 'cancel' },
      ]);
    }
  };

  /* -------------------- WORKFLOW BUILDER ------------------- */
  const renderStageItem = ({ item, drag, isActive }) => {
    const statusColor =
      item.status === 'completed'
        ? '#4CAF50'
        : item.status === 'in_progress'
        ? '#FFD54F'
        : '#9E9E9E';

    return (
      <View style={[styles.stageRow, isActive && { opacity: 0.8 }]}>
        <TouchableOpacity onLongPress={drag} style={styles.dragHandle}>
          <Ionicons name="reorder-two-outline" size={20} color="#666" />
        </TouchableOpacity>

        <View style={styles.stageInfo}>
          <Text style={styles.stageName}>{item.processName}</Text>
          <TouchableOpacity
            style={[
              styles.statusBadge,
              { backgroundColor: statusColor + '22' },
            ]}
            onPress={() => quickChangeStatus(item)}
          >
            <Text style={[styles.statusBadgeText, { color: statusColor }]}>
              {
                {
                  pending: 'Ch·ªù x·ª≠ l√Ω',
                  in_progress: 'ƒêang l√†m',
                  completed: 'Ho√†n th√†nh',
                }[item.status]
              }
            </Text>
          </TouchableOpacity>
        </View>

        <TouchableOpacity
          style={styles.deleteStageBtn}
          onPress={() => handleRemoveStage(item.stageId)}
        >
          <Ionicons name="trash-outline" size={20} color="#d11a2a" />
        </TouchableOpacity>
      </View>
    );
  };

  const handleAddStages = (selectedTemplates) => {
    const newStages = [...workflowStages];
    let newTasks = formData.tasks ? { ...formData.tasks } : {}; // L·∫•y c√°c task hi·ªán c√≥ ho·∫∑c t·∫°o object r·ªóng n·∫øu ch∆∞a c√≥

    selectedTemplates.forEach((tpl) => {
      // T·∫°o m·ªôt ID duy nh·∫•t cho GIAI ƒêO·∫†N m·ªõi
      const newStageId = uuid.v4();

      // Th√™m giai ƒëo·∫°n m·ªõi v√†o m·∫£ng workflowStages
      newStages.push({
        stageId: newStageId, // ID duy nh·∫•t cho stage
        processKey: tpl.processKey,
        processName: tpl.processName,
        order: newStages.length,
        status: 'pending',
      });

      // T·∫°o m·ªôt ID duy nh·∫•t cho TASK m·ªõi
      const newTaskId = `task_${newStageId}`;

      // Th√™m task m·∫∑c ƒë·ªãnh v√†o object tasks
      newTasks[newTaskId] = {
        name: tpl.processName, // L·∫•y tr·ª±c ti·∫øp t√™n c√¥ng ƒëo·∫°n l√†m t√™n c√¥ng vi·ªác
        status: 'pending',
        stageId: newStageId, // Li√™n k·∫øt task n√†y v·ªõi stage v·ª´a t·∫°o
      };
    });

    setWorkflowStages(newStages);

    // C·∫≠p nh·∫≠t formData v·ªõi tasks m·ªõi
    setFormData((prev) => ({
      ...prev,
      tasks: newTasks,
    }));

    setPickerVisible(false);
  };

  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.container}
      >
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
          >
            <Ionicons name="arrow-back" size={24} color="#333" />
          </TouchableOpacity>
          <Text style={styles.headerTitle}>Ch·ªânh s·ª≠a d·ª± √°n</Text>
          <View style={styles.placeholder} />
        </View>

        <ScrollView
          style={styles.formContainer}
          contentContainerStyle={styles.formContent}
          keyboardShouldPersistTaps="handled"
        >
          <View style={styles.inputGroup}>
            <Text style={styles.label}>
              T√™n d·ª± √°n <Text style={styles.required}>*</Text>
            </Text>
            <TextInput
              style={styles.input}
              value={formData.name}
              onChangeText={(text) => handleChange('name', text)}
              placeholder="Nh·∫≠p t√™n d·ª± √°n"
            />
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>M√¥ t·∫£</Text>
            <TextInput
              style={[styles.input, styles.textArea]}
              value={formData.description}
              onChangeText={(text) => handleChange('description', text)}
              placeholder="Nh·∫≠p m√¥ t·∫£ d·ª± √°n"
              multiline
              numberOfLines={3}
            />
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Kh√°ch h√†ng</Text>
            {formData.customerName ? (
              <View style={styles.selectedCustomerContainer}>
                <View style={styles.selectedCustomer}>
                  <Ionicons name="business-outline" size={20} color="#0066cc" />
                  <Text style={styles.selectedCustomerText}>
                    {formData.customerName}
                  </Text>
                </View>
                <TouchableOpacity
                  style={styles.clearCustomerButton}
                  onPress={handleClearCustomer}
                >
                  <Ionicons name="close-circle" size={20} color="#999" />
                </TouchableOpacity>
              </View>
            ) : (
              <TouchableOpacity
                style={styles.customerSelectButton}
                onPress={handleOpenCustomerModal}
              >
                <Ionicons name="add-circle-outline" size={20} color="#0066cc" />
                <Text style={styles.customerSelectButtonText}>
                  Ch·ªçn kh√°ch h√†ng
                </Text>
              </TouchableOpacity>
            )}
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Tr·∫°ng th√°i</Text>
            <View style={styles.statusButtonsContainer}>
              <TouchableOpacity
                style={[
                  styles.statusButton,
                  formData.status === 'pending' && styles.selectedStatusButton,
                ]}
                onPress={() => handleSelectStatus('pending')}
              >
                <Text
                  style={[
                    styles.statusButtonText,
                    formData.status === 'pending' &&
                      styles.selectedStatusButtonText,
                  ]}
                >
                  Ch·ªù x·ª≠ l√Ω
                </Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.statusButton,
                  formData.status === 'in-progress' &&
                    styles.selectedStatusButton,
                ]}
                onPress={() => handleSelectStatus('in-progress')}
              >
                <Text
                  style={[
                    styles.statusButtonText,
                    formData.status === 'in-progress' &&
                      styles.selectedStatusButtonText,
                  ]}
                >
                  ƒêang th·ª±c hi·ªán
                </Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.statusButton,
                  formData.status === 'completed' &&
                    styles.selectedStatusButton,
                ]}
                onPress={() => handleSelectStatus('completed')}
              >
                <Text
                  style={[
                    styles.statusButtonText,
                    formData.status === 'completed' &&
                      styles.selectedStatusButtonText,
                  ]}
                >
                  Ho√†n th√†nh
                </Text>
              </TouchableOpacity>
            </View>

            <View style={[styles.statusButtonsContainer, { marginTop: 8 }]}>
              <TouchableOpacity
                style={[
                  styles.statusButton,
                  formData.status === 'cancelled' &&
                    styles.selectedStatusButton,
                ]}
                onPress={() => handleSelectStatus('cancelled')}
              >
                <Text
                  style={[
                    styles.statusButtonText,
                    formData.status === 'cancelled' &&
                      styles.selectedStatusButtonText,
                  ]}
                >
                  ƒê√£ h·ªßy
                </Text>
              </TouchableOpacity>
            </View>
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Ng√†y b·∫Øt ƒë·∫ßu</Text>
            <TouchableOpacity
              style={styles.dateButton}
              onPress={() => setShowStartDatePicker(true)}
            >
              <Ionicons name="calendar-outline" size={20} color="#0066cc" />
              <Text style={styles.dateButtonText}>
                {formData.startDate
                  ? formatDate(formData.startDate)
                  : 'Ch·ªçn ng√†y b·∫Øt ƒë·∫ßu'}
              </Text>
            </TouchableOpacity>
            {showStartDatePicker && (
              <DateTimePicker
                value={formData.startDate || new Date()}
                mode="date"
                display="default"
                onChange={handleStartDateChange}
              />
            )}
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>S·ªë ng√†y thi c√¥ng</Text>
            <TextInput
              style={styles.input}
              value={formData.durationInDays}
              onChangeText={handleDurationChange}
              placeholder="Nh·∫≠p s·ªë ng√†y thi c√¥ng"
              keyboardType="numeric"
            />
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Ng√†y k·∫øt th√∫c (t·ª± ƒë·ªông t√≠nh)</Text>
            <View style={styles.readOnlyField}>
              <Ionicons name="calendar-outline" size={20} color="#666" />
              <Text style={styles.readOnlyText}>
                {formData.endDate
                  ? formatDate(formData.endDate)
                  : 'Ch∆∞a x√°c ƒë·ªãnh'}
              </Text>
            </View>
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>V·ªã tr√≠ thi c√¥ng</Text>
            <View style={styles.locationButtonsContainer}>
              <TouchableOpacity
                style={[
                  styles.locationButton,
                  formData.location === 'workshop' &&
                    styles.selectedLocationButton,
                ]}
                onPress={() => handleLocationChange('workshop')}
              >
                <Text
                  style={[
                    styles.locationButtonText,
                    formData.location === 'workshop' &&
                      styles.selectedLocationButtonText,
                  ]}
                >
                  T·∫°i x∆∞·ªüng
                </Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.locationButton,
                  formData.location === 'site' && styles.selectedLocationButton,
                ]}
                onPress={() => handleLocationChange('site')}
              >
                <Text
                  style={[
                    styles.locationButtonText,
                    formData.location === 'site' &&
                      styles.selectedLocationButtonText,
                  ]}
                >
                  T·∫°i c√¥ng tr√¨nh
                </Text>
              </TouchableOpacity>
            </View>
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Ng√¢n s√°ch</Text>
            <TextInput
              style={styles.input}
              value={formData.budget}
              onChangeText={(text) => handleChange('budget', text)}
              placeholder="Nh·∫≠p ng√¢n s√°ch d·ª± √°n"
              keyboardType="numeric"
            />
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Ghi ch√∫</Text>
            <TextInput
              style={[styles.input, styles.textArea]}
              value={formData.notes}
              onChangeText={(text) => handleChange('notes', text)}
              placeholder="Nh·∫≠p ghi ch√∫"
              multiline
              numberOfLines={3}
            />
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Quy tr√¨nh S·∫£n xu·∫•t</Text>
            <DraggableFlatList
              data={workflowStages}
              keyExtractor={(item) => item.stageId}
              onDragEnd={({ data }) => setWorkflowStages(data)}
              renderItem={renderStageItem}
              scrollEnabled={false}
            />
            <TouchableOpacity
              style={styles.addStageBtn}
              onPress={() => setPickerVisible(true)}
            >
              <Ionicons name="add-circle-outline" size={20} color="#0066cc" />
              <Text style={styles.addStageText}>Th√™m C√¥ng ƒëo·∫°n</Text>
            </TouchableOpacity>
          </View>
        </ScrollView>

        <View style={styles.footer}>
          <TouchableOpacity
            style={styles.saveButton}
            onPress={handleUpdate}
            disabled={isLoading}
          >
            {isLoading ? (
              <ActivityIndicator color="#fff" size="small" />
            ) : (
              <>
                <Ionicons name="save-outline" size={20} color="#fff" />
                <Text style={styles.saveButtonText}>L∆∞u thay ƒë·ªïi</Text>
              </>
            )}
          </TouchableOpacity>
        </View>

        {/* Modal ch·ªçn kh√°ch h√†ng */}
        <Modal
          visible={customerModalVisible}
          animationType="slide"
          transparent={true}
          onRequestClose={handleCloseCustomerModal}
        >
          <View style={styles.modalContainer}>
            <View style={styles.modalContent}>
              <View style={styles.modalHeader}>
                <Text style={styles.modalTitle}>Ch·ªçn kh√°ch h√†ng</Text>
                <TouchableOpacity
                  style={styles.closeButton}
                  onPress={handleCloseCustomerModal}
                >
                  <Ionicons name="close" size={24} color="#333" />
                </TouchableOpacity>
              </View>

              <View style={styles.searchContainer}>
                <Ionicons
                  name="search"
                  size={20}
                  color="#999"
                  style={styles.searchIcon}
                />
                <TextInput
                  style={styles.searchInput}
                  placeholder="T√¨m ki·∫øm kh√°ch h√†ng..."
                  value={customerSearchQuery}
                  onChangeText={handleSearchCustomer}
                />
                {customerSearchQuery.length > 0 && (
                  <TouchableOpacity
                    onPress={() => setCustomerSearchQuery('')}
                    style={styles.clearSearchButton}
                  >
                    <Ionicons name="close-circle" size={18} color="#999" />
                  </TouchableOpacity>
                )}
              </View>

              {loadingCustomers ? (
                <View style={styles.loadingContainer}>
                  <ActivityIndicator size="large" color="#0066cc" />
                  <Text style={styles.loadingText}>
                    ƒêang t·∫£i danh s√°ch kh√°ch h√†ng...
                  </Text>
                </View>
              ) : (
                <FlatList
                  data={filteredCustomers}
                  keyExtractor={(item) => item.id}
                  renderItem={renderCustomerItem}
                  contentContainerStyle={styles.customersList}
                  ListEmptyComponent={() => (
                    <View style={styles.emptyListContainer}>
                      <Ionicons name="search-outline" size={40} color="#ccc" />
                      <Text style={styles.emptyListText}>
                        Kh√¥ng t√¨m th·∫•y kh√°ch h√†ng ph√π h·ª£p
                      </Text>
                    </View>
                  )}
                />
              )}
            </View>
          </View>
        </Modal>

        <ProcessPickerModal
          visible={pickerVisible}
          onClose={() => setPickerVisible(false)}
          onConfirm={handleAddStages}
          existingStageKeys={workflowStages.map((s) => s.processKey)}
        />
      </KeyboardAvoidingView>
    </GestureHandlerRootView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  placeholder: {
    width: 24,
  },
  formContainer: {
    flex: 1,
  },
  formContent: {
    padding: 16,
  },
  inputGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    marginBottom: 6,
    color: '#333',
  },
  required: {
    color: '#e74c3c',
  },
  input: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    color: '#333',
  },
  textArea: {
    minHeight: 80,
    textAlignVertical: 'top',
  },
  statusButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  statusButton: {
    flex: 1,
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 8,
    borderRadius: 8,
    marginHorizontal: 4,
    alignItems: 'center',
  },
  selectedStatusButton: {
    backgroundColor: '#0066cc',
  },
  statusButtonText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '500',
  },
  selectedStatusButtonText: {
    color: '#fff',
  },
  // Th√™m style cho c√°c tr∆∞·ªùng m·ªõi
  dateButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
  },
  dateButtonText: {
    fontSize: 16,
    color: '#333',
    marginLeft: 8,
  },
  locationButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  locationButton: {
    flex: 1,
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 8,
    borderRadius: 8,
    marginHorizontal: 4,
    alignItems: 'center',
  },
  selectedLocationButton: {
    backgroundColor: '#0066cc',
  },
  locationButtonText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '500',
  },
  selectedLocationButtonText: {
    color: '#fff',
  },
  customerSelectButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
  },
  customerSelectButtonText: {
    fontSize: 16,
    color: '#0066cc',
    marginLeft: 8,
  },
  selectedCustomerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
  },
  selectedCustomer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  selectedCustomerText: {
    fontSize: 16,
    color: '#333',
    marginLeft: 8,
  },
  clearCustomerButton: {
    padding: 4,
  },
  footer: {
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  saveButton: {
    backgroundColor: '#0066cc',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    borderRadius: 8,
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  modalContainer: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: '#fff',
    borderTopLeftRadius: 16,
    borderTopRightRadius: 16,
    height: '80%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  closeButton: {
    padding: 4,
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    margin: 16,
    borderRadius: 8,
    paddingHorizontal: 12,
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    height: 40,
    fontSize: 16,
  },
  clearSearchButton: {
    padding: 4,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
  },
  customersList: {
    padding: 16,
    paddingTop: 0,
  },
  customerItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#f9f9f9',
    padding: 12,
    borderRadius: 8,
    marginBottom: 8,
  },
  selectedCustomerItem: {
    borderWidth: 1,
    borderColor: '#0066cc',
    backgroundColor: '#f0f7ff',
  },
  customerName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 2,
  },
  customerDetail: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  emptyListContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 40,
  },
  emptyListText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  readOnlyField: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
  },
  readOnlyText: {
    fontSize: 16,
    color: '#666',
    marginLeft: 8,
  },
  stageRow: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    marginBottom: 8,
    backgroundColor: '#fff',
  },
  dragHandle: {
    padding: 4,
    marginRight: 8,
  },
  stageInfo: { flex: 1 },
  statusBadge: {
    alignSelf: 'flex-start',
    marginTop: 4,
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  statusBadgeText: { fontSize: 12, fontWeight: '500' },
  deleteStageBtn: { padding: 4, marginLeft: 8 },
  addStageBtn: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f1f1',
    paddingVertical: 12,
    paddingHorizontal: 12,
    borderRadius: 8,
    marginTop: 16,
  },
  addStageText: {
    fontSize: 16,
    color: '#0066cc',
    marginLeft: 8,
  },
});

export default EditProjectScreen;


--- END: src\screens\EditProjectScreen.js ---


--- START: src\screens\EditSupplierScreen.js ---
// src/screens/EditSupplierScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  ScrollView,
  Alert,
  ActivityIndicator,
  SafeAreaView,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { getSupplierById, updateSupplier } from '../api/supplierService';
import { useAuth } from '../contexts/AuthContext';

const MATERIAL_CATEGORIES = [
  'Th√©p',
  'G·ªó',
  'K√≠nh',
  'Nh√¥m',
  'ƒêi·ªán',
  'N∆∞·ªõc',
  'S∆°n',
  'G·∫°ch',
  'Xi mƒÉng',
  'Thi·∫øt b·ªã v·ªá sinh',
  'Thi·∫øt b·ªã ƒëi·ªán',
  'V·∫≠t li·ªáu ho√†n thi·ªán',
  'S·∫Øt',
  'Inox',
  'Ph·ª• ki·ªán',
  'MƒÉng s√¥ng',
  'Thi·∫øt b·ªã h√†n',
  'Kh√≠ h√†n',
  'Kh√°c',
];

const EditSupplierScreen = ({ route, navigation }) => {
  const { supplier: initialSupplier } = route.params;
  const { currentUser } = useAuth();
  const [formData, setFormData] = useState({
    name: '',
    contactName: '',
    phone: '',
    email: '',
    address: '',
    taxCode: '',
    bankAccount: '',
    bankName: '',
    description: '',
    categories: [],
    verified: false,
  });
  const [errors, setErrors] = useState({});
  const [saving, setSaving] = useState(false);
  const [loading, setLoading] = useState(true);

  // T·∫£i d·ªØ li·ªáu nh√† cung c·∫•p
  useEffect(() => {
    const loadSupplierData = async () => {
      try {
        if (initialSupplier) {
          // N·∫øu ƒë√£ c√≥ d·ªØ li·ªáu t·ª´ route params, s·ª≠ d·ª•ng n√≥
          setFormData({
            ...initialSupplier,
            categories: initialSupplier.categories || [],
          });
          setLoading(false);
        } else if (route.params?.supplierId) {
          // N·∫øu ch·ªâ c√≥ ID, t·∫£i d·ªØ li·ªáu t·ª´ Firestore
          const supplierData = await getSupplierById(route.params.supplierId);
          setFormData({
            ...supplierData,
            categories: supplierData.categories || [],
          });
          setLoading(false);
        } else {
          // Kh√¥ng c√≥ d·ªØ li·ªáu
          Alert.alert('L·ªói', 'Kh√¥ng t√¨m th·∫•y th√¥ng tin nh√† cung c·∫•p');
          navigation.goBack();
        }
      } catch (error) {
        console.error('L·ªói khi t·∫£i d·ªØ li·ªáu nh√† cung c·∫•p:', error);
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i th√¥ng tin nh√† cung c·∫•p');
        navigation.goBack();
      }
    };

    loadSupplierData();
  }, [route.params, initialSupplier, navigation]);

  const handleChange = (field, value) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));

    // Clear error when field is edited
    if (errors[field]) {
      setErrors((prev) => ({
        ...prev,
        [field]: null,
      }));
    }
  };

  const toggleCategory = (category) => {
    setFormData((prev) => {
      const updatedCategories = [...prev.categories];

      if (updatedCategories.includes(category)) {
        // Remove category if already selected
        return {
          ...prev,
          categories: updatedCategories.filter((c) => c !== category),
        };
      } else {
        // Add category if not selected
        return {
          ...prev,
          categories: [...updatedCategories, category],
        };
      }
    });
  };

  const validateForm = () => {
    const newErrors = {};

    if (!formData.name.trim()) {
      newErrors.name = 'Vui l√≤ng nh·∫≠p t√™n nh√† cung c·∫•p';
    }

    if (formData.phone && !/^[0-9]{10,11}$/.test(formData.phone.trim())) {
      newErrors.phone = 'S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá';
    }

    if (formData.email && !/\S+@\S+\.\S+/.test(formData.email.trim())) {
      newErrors.email = 'Email kh√¥ng h·ª£p l·ªá';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async () => {
    if (!validateForm()) {
      Alert.alert('L·ªói', 'Vui l√≤ng ki·ªÉm tra l·∫°i th√¥ng tin nh·∫≠p');
      return;
    }

    setSaving(true);
    try {
      // Th√™m th√¥ng tin ng∆∞·ªùi c·∫≠p nh·∫≠t
      const updatedData = {
        ...formData,
        updatedBy: currentUser?.uid || 'unknown',
        updatedByName:
          currentUser?.displayName || currentUser?.email || 'Ng∆∞·ªùi d√πng',
      };

      await updateSupplier(formData.id, updatedData);
      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ c·∫≠p nh·∫≠t th√¥ng tin nh√† cung c·∫•p', [
        { text: 'OK', onPress: () => navigation.goBack() },
      ]);
    } catch (error) {
      console.error('L·ªói khi c·∫≠p nh·∫≠t nh√† cung c·∫•p:', error);
      Alert.alert(
        'L·ªói',
        'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t th√¥ng tin nh√† cung c·∫•p. Vui l√≤ng th·ª≠ l·∫°i sau.'
      );
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return (
      <SafeAreaView style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0066cc" />
        <Text style={styles.loadingText}>ƒêang t·∫£i d·ªØ li·ªáu...</Text>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={{ flex: 1 }}
      >
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
          >
            <Ionicons name="arrow-back" size={24} color="#333" />
          </TouchableOpacity>
          <Text style={styles.headerTitle}>Ch·ªânh s·ª≠a nh√† cung c·∫•p</Text>
          <View style={{ width: 24 }} />
        </View>

        <ScrollView style={styles.content}>
          <View style={styles.formGroup}>
            <Text style={styles.label}>
              T√™n nh√† cung c·∫•p <Text style={styles.required}>*</Text>
            </Text>
            <TextInput
              style={[styles.input, errors.name && styles.inputError]}
              value={formData.name}
              onChangeText={(text) => handleChange('name', text)}
              placeholder="Nh·∫≠p t√™n nh√† cung c·∫•p"
            />
            {errors.name && <Text style={styles.errorText}>{errors.name}</Text>}
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Ng∆∞·ªùi li√™n h·ªá</Text>
            <TextInput
              style={styles.input}
              value={formData.contactName}
              onChangeText={(text) => handleChange('contactName', text)}
              placeholder="Nh·∫≠p t√™n ng∆∞·ªùi li√™n h·ªá"
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>S·ªë ƒëi·ªán tho·∫°i</Text>
            <TextInput
              style={[styles.input, errors.phone && styles.inputError]}
              value={formData.phone}
              onChangeText={(text) => handleChange('phone', text)}
              placeholder="Nh·∫≠p s·ªë ƒëi·ªán tho·∫°i"
              keyboardType="phone-pad"
            />
            {errors.phone && (
              <Text style={styles.errorText}>{errors.phone}</Text>
            )}
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Email</Text>
            <TextInput
              style={[styles.input, errors.email && styles.inputError]}
              value={formData.email}
              onChangeText={(text) => handleChange('email', text)}
              placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ email"
              keyboardType="email-address"
              autoCapitalize="none"
            />
            {errors.email && (
              <Text style={styles.errorText}>{errors.email}</Text>
            )}
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>ƒê·ªãa ch·ªâ</Text>
            <TextInput
              style={styles.input}
              value={formData.address}
              onChangeText={(text) => handleChange('address', text)}
              placeholder="Nh·∫≠p ƒë·ªãa ch·ªâ"
              multiline
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>M√£ s·ªë thu·∫ø</Text>
            <TextInput
              style={styles.input}
              value={formData.taxCode}
              onChangeText={(text) => handleChange('taxCode', text)}
              placeholder="Nh·∫≠p m√£ s·ªë thu·∫ø"
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>T√†i kho·∫£n ng√¢n h√†ng</Text>
            <TextInput
              style={styles.input}
              value={formData.bankAccount}
              onChangeText={(text) => handleChange('bankAccount', text)}
              placeholder="Nh·∫≠p s·ªë t√†i kho·∫£n"
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>T√™n ng√¢n h√†ng</Text>
            <TextInput
              style={styles.input}
              value={formData.bankName}
              onChangeText={(text) => handleChange('bankName', text)}
              placeholder="Nh·∫≠p t√™n ng√¢n h√†ng"
            />
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>Danh m·ª•c v·∫≠t t∆∞ cung c·∫•p</Text>
            <View style={styles.categoriesContainer}>
              {MATERIAL_CATEGORIES.map((category, index) => (
                <TouchableOpacity
                  key={index}
                  style={[
                    styles.categoryTag,
                    formData.categories.includes(category) &&
                      styles.categoryTagSelected,
                  ]}
                  onPress={() => toggleCategory(category)}
                >
                  <Text
                    style={[
                      styles.categoryText,
                      formData.categories.includes(category) &&
                        styles.categoryTextSelected,
                    ]}
                  >
                    {category}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          </View>

          <View style={styles.formGroup}>
            <Text style={styles.label}>M√¥ t·∫£</Text>
            <TextInput
              style={[styles.input, styles.textArea]}
              value={formData.description}
              onChangeText={(text) => handleChange('description', text)}
              placeholder="Nh·∫≠p m√¥ t·∫£ v·ªÅ nh√† cung c·∫•p"
              multiline
              numberOfLines={4}
              textAlignVertical="top"
            />
          </View>

          <View style={styles.verifiedContainer}>
            <TouchableOpacity
              style={styles.checkboxContainer}
              onPress={() => handleChange('verified', !formData.verified)}
            >
              <View
                style={[
                  styles.checkbox,
                  formData.verified && styles.checkboxChecked,
                ]}
              >
                {formData.verified && (
                  <Ionicons name="checkmark" size={16} color="#fff" />
                )}
              </View>
              <Text style={styles.checkboxLabel}>ƒê√£ x√°c minh</Text>
            </TouchableOpacity>
          </View>

          <TouchableOpacity
            style={styles.saveButton}
            onPress={handleSubmit}
            disabled={saving}
          >
            {saving ? (
              <ActivityIndicator color="#fff" size="small" />
            ) : (
              <Text style={styles.saveButtonText}>C·∫≠p nh·∫≠t</Text>
            )}
          </TouchableOpacity>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  loadingText: {
    marginTop: 12,
    color: '#666',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  content: {
    flex: 1,
    padding: 16,
  },
  formGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    color: '#333',
    marginBottom: 6,
  },
  required: {
    color: 'red',
  },
  input: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    fontSize: 16,
  },
  inputError: {
    borderColor: 'red',
  },
  errorText: {
    color: 'red',
    fontSize: 12,
    marginTop: 4,
  },
  textArea: {
    minHeight: 100,
    textAlignVertical: 'top',
  },
  categoriesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginTop: 8,
  },
  categoryTag: {
    backgroundColor: '#f0f0f0',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 16,
    marginRight: 8,
    marginBottom: 8,
  },
  categoryTagSelected: {
    backgroundColor: '#e6f2ff',
    borderWidth: 1,
    borderColor: '#0066cc',
  },
  categoryText: {
    fontSize: 14,
    color: '#666',
  },
  categoryTextSelected: {
    color: '#0066cc',
    fontWeight: '500',
  },
  verifiedContainer: {
    marginBottom: 24,
  },
  checkboxContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  checkbox: {
    width: 20,
    height: 20,
    borderRadius: 4,
    borderWidth: 1,
    borderColor: '#999',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 8,
  },
  checkboxChecked: {
    backgroundColor: '#0066cc',
    borderColor: '#0066cc',
  },
  checkboxLabel: {
    fontSize: 16,
    color: '#333',
  },
  saveButton: {
    backgroundColor: '#0066cc',
    paddingVertical: 14,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 30,
  },
  saveButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
});

export default EditSupplierScreen;


--- END: src\screens\EditSupplierScreen.js ---


--- START: src\screens\ExpenseListScreen.js ---
// src/screens/ExpenseListScreen.js
import React, { useEffect, useMemo, useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  SafeAreaView,
  StatusBar,
  TextInput,
  ScrollView,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import { getQuotationsByProject } from '../api/quotationService';
import { db } from '../config/firebaseConfig';
import { collection, getDocs, query, where } from 'firebase/firestore';
import { getUserById } from '../api/userService';
import { upsertProjectExpense } from '../api/expenseService';

const MATERIAL_RATE_PER_KG = {
  SUS304: 55000,
  SS400: 17000,
  OTHER: 0,
};

const getMaterialKey = (item) => {
  const fromField = (item.material || item.name || '').toString().toLowerCase();
  if (fromField.includes('sus304') || fromField.includes('304'))
    return 'SUS304';
  if (fromField.includes('ss400') || fromField.includes('400')) return 'SS400';
  return 'OTHER';
};

const getRateByMaterial = (key) => MATERIAL_RATE_PER_KG[key] ?? 0;

const toCurrency = (amount) =>
  new Intl.NumberFormat('vi-VN', {
    style: 'currency',
    currency: 'VND',
    minimumFractionDigits: 0,
  }).format(Math.round(amount || 0));

const formatMinutesToHM = (minutes) => {
  const h = Math.floor((minutes || 0) / 60);
  const m = Math.round((minutes || 0) % 60);
  return `${h}h ${m}p`;
};

const ExpenseListScreen = ({ navigation, route }) => {
  const { theme } = useTheme();
  const { user: currentUser } = useAuth();
  const { projectId, projectName } = route.params || {};

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  // Material summary
  const [weightByType, setWeightByType] = useState({
    SUS304: 0,
    SS400: 0,
    OTHER: 0,
  });
  const weightLabel = useMemo(() => {
    const parts = [];
    if (weightByType.SUS304 > 0)
      parts.push(`SUS304: ${Math.round(weightByType.SUS304)} kg`);
    if (weightByType.SS400 > 0)
      parts.push(`SS400: ${Math.round(weightByType.SS400)} kg`);
    return parts.join(' ¬∑ ');
  }, [weightByType]);

  const [materialsCost, setMaterialsCost] = useState(0);
  const [laborCost, setLaborCost] = useState(0);
  const [accessoryPrice, setAccessoryPrice] = useState('0');
  const [hasAccessories, setHasAccessories] = useState(false);

  const [workerBreakdown, setWorkerBreakdown] = useState([]); // [{ workerId, workerName, minutes, stages:[], cost }]

  const totalCost = useMemo(() => {
    const accessories =
      parseInt((accessoryPrice || '0').replace(/[^0-9]/g, ''), 10) || 0;
    return (materialsCost || 0) + (laborCost || 0) + accessories;
  }, [materialsCost, laborCost, accessoryPrice]);

  useEffect(() => {
    let isMounted = true;
    const run = async () => {
      if (!projectId) {
        setError('Thi·∫øu projectId');
        setLoading(false);
        return;
      }
      try {
        setLoading(true);

        // 1) L·∫•y b√°o gi√° m·ªõi nh·∫•t c·ªßa d·ª± √°n
        const quotations = await getQuotationsByProject(projectId);
        const latest =
          Array.isArray(quotations) && quotations.length > 0
            ? quotations[0]
            : null;

        // 1a) T√≠nh v·∫≠t li·ªáu theo kg v√† nh√£n kh·ªëi l∆∞·ª£ng
        let computedWeights = { SUS304: 0, SS400: 0, OTHER: 0 };
        let computedMaterialCost = 0;
        if (latest && Array.isArray(latest.materials)) {
          const weights = { SUS304: 0, SS400: 0, OTHER: 0 };
          for (const it of latest.materials) {
            const key = getMaterialKey(it);
            const quantity = Number(it.quantity || 0);
            const weightPerUnit = Number(it.weight || 0); // t·ª´ import v·∫≠t t∆∞
            const totalWeight = quantity * weightPerUnit; // kg
            weights[key] += totalWeight;
          }
          computedWeights = weights;
          if (isMounted) setWeightByType(weights);

          const cost =
            weights.SUS304 * getRateByMaterial('SUS304') +
            weights.SS400 * getRateByMaterial('SS400');
          computedMaterialCost = cost;
          if (isMounted) setMaterialsCost(cost);

          // 1b) Ph·ª• ki·ªán?
          const foundAccessories = latest.materials.some((m) => {
            const name = (m.name || '').toString().toLowerCase();
            return (
              name.includes('ph·ª• ki·ªán') ||
              name.includes('phu kien') ||
              name.includes('ph·ª• ki·ªán ƒëi k√®m')
            );
          });
          if (isMounted) setHasAccessories(foundAccessories);
        } else {
          if (isMounted) {
            setWeightByType({ SUS304: 0, SS400: 0, OTHER: 0 });
            setMaterialsCost(0);
            setHasAccessories(false);
          }
        }

        // 2) T√≠nh chi ph√≠ nh√¢n c√¥ng t·ª´ work_sessions c·ªßa d·ª± √°n n√†y
        const sessionsSnap = await getDocs(
          query(
            collection(db, 'work_sessions'),
            where('projectId', '==', projectId),
            where('endTime', '!=', null)
          )
        );

        // Gom theo workerId
        const sessions = [];
        sessionsSnap.forEach((d) => sessions.push({ id: d.id, ...d.data() }));
        const byWorker = new Map();
        for (const s of sessions) {
          const wid = s.workerId;
          if (!wid) continue;
          const durationHours = Number(s.durationInHours || 0);
          const minutes = Math.round(durationHours * 60);
          const curr = byWorker.get(wid) || {
            workerId: wid,
            workerName: s.workerName || 'Kh√¥ng t√™n',
            minutes: 0,
            stages: new Set(),
          };
          curr.minutes += minutes;
          if (s.stageName) curr.stages.add(s.stageName);
          byWorker.set(wid, curr);
        }

        // L·∫•y l∆∞∆°ng c·ªßa t·ª´ng worker v√† t√≠nh cost
        let totalLabor = 0;
        const breakdown = [];
        for (const [wid, info] of byWorker.entries()) {
          const userDoc = await getUserById(wid);
          const dailySalary = Number(userDoc?.dailySalary || 0);
          const monthlySalary = Number(userDoc?.monthlySalary || 0);
          // Quy ƒë·ªïi l∆∞∆°ng theo gi·ªù
          let hourlyRate = 0;
          if (dailySalary > 0) hourlyRate = dailySalary / 8;
          else if (monthlySalary > 0) hourlyRate = monthlySalary / 30 / 8; // 30 ng√†y ~ v√≠ d·ª• c·ªßa b·∫°n

          const cost = (hourlyRate * info.minutes) / 60;
          totalLabor += cost;
          breakdown.push({
            workerId: wid,
            workerName: info.workerName,
            minutes: info.minutes,
            stages: Array.from(info.stages),
            cost,
          });
        }

        if (isMounted) {
          setWorkerBreakdown(breakdown);
          setLaborCost(totalLabor);
        }

        // L∆∞u chi ph√≠ v√†o collection expenses
        try {
          const expenseData = {
            projectName: projectName || 'D·ª± √°n kh√¥ng t√™n',
            materialCost: computedMaterialCost,
            laborCost: totalLabor,
            accessoryCost:
              parseInt((accessoryPrice || '0').replace(/[^0-9]/g, ''), 10) || 0,
            totalCost:
              computedMaterialCost +
              totalLabor +
              (parseInt((accessoryPrice || '0').replace(/[^0-9]/g, ''), 10) ||
                0),
            materialBreakdown: computedWeights,
            laborBreakdown: breakdown,
          };

          console.log('üíæ L∆∞u chi ph√≠ d·ª± √°n (upsert):', projectId, expenseData);
          await upsertProjectExpense(projectId, expenseData);
        } catch (expenseError) {
          console.error('‚ùå L·ªói khi l∆∞u chi ph√≠:', expenseError);
        }
      } catch (e) {
        console.error('Expense calc error:', e);
        if (isMounted) setError(e.message || 'C√≥ l·ªói x·∫£y ra');
      } finally {
        if (isMounted) setLoading(false);
      }
    };
    run();
    return () => {
      isMounted = false;
    };
  }, [projectId]);

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <StatusBar
        barStyle={theme.dark ? 'light-content' : 'dark-content'}
        backgroundColor={theme.background}
      />

      {/* Header */}
      <View style={[styles.header, { borderBottomColor: theme.border }]}>
        <TouchableOpacity
          onPress={() => navigation.goBack()}
          style={{ padding: 4 }}
        >
          <Ionicons name="arrow-back" size={22} color={theme.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Chi ph√≠ d·ª± √°n
        </Text>
        <View style={{ width: 26 }} />
      </View>

      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
            ƒêang t√≠nh to√°n...
          </Text>
        </View>
      ) : error ? (
        <View style={styles.emptyContainer}>
          <Ionicons
            name="alert-circle-outline"
            size={60}
            color={theme.textMuted}
          />
          <Text style={[styles.emptyText, { color: theme.textSecondary }]}>
            {error}
          </Text>
        </View>
      ) : (
        <ScrollView contentContainerStyle={styles.content}>
          {/* Project */}
          <View
            style={[
              styles.card,
              { backgroundColor: theme.card, borderColor: theme.border },
            ]}
          >
            <Text style={[styles.cardTitle, { color: theme.text }]}>
              {projectName ? `D·ª± √°n: ${projectName}` : 'D·ª± √°n hi·ªán t·∫°i'}
            </Text>
            {weightLabel ? (
              <Text style={[styles.subtle, { color: theme.textSecondary }]}>
                Kh·ªëi l∆∞·ª£ng: {weightLabel}
              </Text>
            ) : null}
          </View>

          {/* Materials summary */}
          <View
            style={[
              styles.card,
              { backgroundColor: theme.card, borderColor: theme.border },
            ]}
          >
            <Text style={[styles.sectionTitle, { color: theme.text }]}>
              V·∫≠t li·ªáu
            </Text>
            <View style={styles.rowJustify}>
              <Text style={{ color: theme.textSecondary }}>SUS304</Text>
              <Text style={{ color: theme.text }}>
                {toCurrency(weightByType.SUS304 * getRateByMaterial('SUS304'))}
              </Text>
            </View>
            <View style={styles.rowJustify}>
              <Text style={{ color: theme.textSecondary }}>SS400</Text>
              <Text style={{ color: theme.text }}>
                {toCurrency(weightByType.SS400 * getRateByMaterial('SS400'))}
              </Text>
            </View>
            <View style={styles.divider} />
            <View style={styles.rowJustify}>
              <Text style={[styles.bold, { color: theme.text }]}>
                T·ªïng v·∫≠t li·ªáu
              </Text>
              <Text style={[styles.bold, { color: theme.text }]}>
                {toCurrency(materialsCost)}
              </Text>
            </View>
          </View>

          {/* Accessories */}
          {hasAccessories && (
            <View
              style={[
                styles.card,
                { backgroundColor: theme.card, borderColor: theme.border },
              ]}
            >
              <Text style={[styles.sectionTitle, { color: theme.text }]}>
                Ph·ª• ki·ªán
              </Text>
              <View style={[styles.row, { alignItems: 'center' }]}>
                <Text style={{ color: theme.textSecondary, marginRight: 10 }}>
                  Gi√° ph·ª• ki·ªán:
                </Text>
                <View style={[styles.inputBox, { borderColor: theme.border }]}>
                  <TextInput
                    value={accessoryPrice}
                    onChangeText={(t) =>
                      setAccessoryPrice(t.replace(/[^0-9]/g, ''))
                    }
                    keyboardType="numeric"
                    placeholder="0"
                    placeholderTextColor={theme.textMuted}
                    style={{ color: theme.text, paddingVertical: 6 }}
                  />
                </View>
              </View>
            </View>
          )}

          {/* Labor breakdown */}
          <View
            style={[
              styles.card,
              { backgroundColor: theme.card, borderColor: theme.border },
            ]}
          >
            <Text style={[styles.sectionTitle, { color: theme.text }]}>
              Nh√¢n c√¥ng
            </Text>
            {workerBreakdown.length === 0 ? (
              <Text style={{ color: theme.textSecondary }}>
                Ch∆∞a c√≥ d·ªØ li·ªáu nh√¢n c√¥ng.
              </Text>
            ) : (
              <View>
                {workerBreakdown.map((w) => (
                  <View key={w.workerId} style={styles.workerRow}>
                    <View style={{ flex: 1 }}>
                      <Text style={[styles.bold, { color: theme.text }]}>
                        {w.workerName} ({formatMinutesToHM(w.minutes)})
                      </Text>
                      {w.stages && w.stages.length > 0 && (
                        <Text style={{ color: theme.textSecondary }}>
                          {w.stages.join(', ')}
                        </Text>
                      )}
                    </View>
                    <Text style={[styles.bold, { color: theme.text }]}>
                      {toCurrency(w.cost)}
                    </Text>
                  </View>
                ))}
                <View style={styles.divider} />
                <View style={styles.rowJustify}>
                  <Text style={[styles.bold, { color: theme.text }]}>
                    T·ªïng nh√¢n c√¥ng
                  </Text>
                  <Text style={[styles.bold, { color: theme.text }]}>
                    {toCurrency(laborCost)}
                  </Text>
                </View>
              </View>
            )}
          </View>

          {/* Summary table */}
          <View
            style={[
              styles.card,
              { backgroundColor: theme.card, borderColor: theme.border },
            ]}
          >
            <Text style={[styles.sectionTitle, { color: theme.text }]}>
              T·ªïng h·ª£p chi ph√≠
            </Text>
            <View style={styles.rowJustify}>
              <Text style={{ color: theme.textSecondary }}>V·∫≠t li·ªáu</Text>
              <Text style={{ color: theme.text }}>
                {toCurrency(materialsCost)}
              </Text>
            </View>
            <View style={styles.rowJustify}>
              <Text style={{ color: theme.textSecondary }}>Nh√¢n c√¥ng</Text>
              <Text style={{ color: theme.text }}>{toCurrency(laborCost)}</Text>
            </View>
            <View style={styles.rowJustify}>
              <Text style={{ color: theme.textSecondary }}>Ph·ª• ki·ªán</Text>
              <Text style={{ color: theme.text }}>
                {toCurrency(
                  parseInt(
                    (accessoryPrice || '0').replace(/[^0-9]/g, ''),
                    10
                  ) || 0
                )}
              </Text>
            </View>
            <View style={styles.divider} />
            <View style={styles.rowJustify}>
              <Text style={[styles.bold, { color: theme.text }]}>
                T·ªïng c·ªông
              </Text>
              <Text style={[styles.bold, { color: theme.text }]}>
                {toCurrency(totalCost)}
              </Text>
            </View>
          </View>
        </ScrollView>
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  emptyText: {
    marginTop: 12,
    fontSize: 16,
    textAlign: 'center',
    marginBottom: 20,
  },
  content: {
    padding: 12,
  },
  card: {
    backgroundColor: '#fff',
    borderRadius: 10,
    borderWidth: 1,
    padding: 12,
    marginBottom: 12,
  },
  cardTitle: {
    fontSize: 16,
    fontWeight: '700',
    marginBottom: 6,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '700',
    marginBottom: 8,
  },
  subtle: {
    fontSize: 13,
  },
  divider: {
    height: 1,
    backgroundColor: '#eaeaea',
    marginVertical: 8,
  },
  row: {
    flexDirection: 'row',
  },
  rowJustify: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginTop: 6,
  },
  bold: {
    fontWeight: '700',
  },
  inputBox: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 2,
  },
  workerRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 6,
  },
});

export default ExpenseListScreen;


--- END: src\screens\ExpenseListScreen.js ---


--- START: src\screens\FinalizeQuotationScreen.js ---
//src/screens/FinalizeQuotationScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  Alert,
  ActivityIndicator,
  Linking,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';

import * as Sharing from 'expo-sharing';
import { auth } from '../config/firebaseConfig';
import { saveQuotation } from '../api/quotationService';
import useQuotationGenerator from '../hooks/useQuotationGenerator';
import useContractGenerator from '../hooks/useContractGenerator';

// HTML2PDF API key
// const HTML2PDF_API_KEY = 'Uvwhf4HC3SED5GIYlCx1F8A6jq2r3iJEt3FH8C16u1LprY5J5hBNXGIVfsLtqRxH';
// const HTML2PDF_API_URL = 'https://api.html2pdf.app/v1/generate';

// H√†m chuy·ªÉn ƒë·ªïi s·ªë th√†nh ch·ªØ ti·∫øng Vi·ªát
const convertNumberToWords = (number) => {
  // M·∫£ng t·ª´ ng·ªØ cho c√°c s·ªë
  const units = [
    'kh√¥ng',
    'm·ªôt',
    'hai',
    'ba',
    'b·ªën',
    'nƒÉm',
    's√°u',
    'b·∫£y',
    't√°m',
    'ch√≠n',
  ];
  const teens = [
    'm∆∞·ªùi',
    'm∆∞·ªùi m·ªôt',
    'm∆∞·ªùi hai',
    'm∆∞·ªùi ba',
    'm∆∞·ªùi b·ªën',
    'm∆∞·ªùi lƒÉm',
    'm∆∞·ªùi s√°u',
    'm∆∞·ªùi b·∫£y',
    'm∆∞·ªùi t√°m',
    'm∆∞·ªùi ch√≠n',
  ];
  const tens = [
    '',
    'm∆∞·ªùi',
    'hai m∆∞∆°i',
    'ba m∆∞∆°i',
    'b·ªën m∆∞∆°i',
    'nƒÉm m∆∞∆°i',
    's√°u m∆∞∆°i',
    'b·∫£y m∆∞∆°i',
    't√°m m∆∞∆°i',
    'ch√≠n m∆∞∆°i',
  ];
  const scales = ['', 'ngh√¨n', 'tri·ªáu', 't·ª∑', 'ngh√¨n t·ª∑', 'tri·ªáu t·ª∑'];

  // H√†m x·ª≠ l√Ω s·ªë c√≥ 3 ch·ªØ s·ªë
  const handleHundreds = (num, isFirstGroup) => {
    let result = '';
    const originalNum = num;

    // X·ª≠ l√Ω h√†ng trƒÉm
    if (num >= 100) {
      result += units[Math.floor(num / 100)] + ' trƒÉm ';
      num %= 100;
    }

    // X·ª≠ l√Ω h√†ng ch·ª•c v√† ƒë∆°n v·ªã
    if (num > 0) {
      // Ch·ªâ th√™m "l·∫ª" n·∫øu n√≥ kh√¥ng ph·∫£i l√† nh√≥m ƒë·∫ßu ti√™n (nh√≥m ƒë∆°n v·ªã) v√† s·ªë c√≥ 1 ch·ªØ s·ªë
      // ho·∫∑c n·∫øu h√†ng trƒÉm c·ªßa nh√≥m ƒë√≥ > 0
      if (num < 10 && !isFirstGroup && originalNum > 99) {
        if (num === 1 && Math.floor(originalNum / 100) > 0) {
          result += 'linh m·ªôt'; // S·ª≠ d·ª•ng "linh m·ªôt" thay v√¨ "l·∫ª m·ªôt"
        } else {
          result += 'l·∫ª ' + units[num];
        }
      } else if (num < 10) {
        result += units[num];
      } else if (num < 20) {
        // N·∫øu s·ªë d∆∞ < 20, s·ª≠ d·ª•ng m·∫£ng teens
        result += teens[num - 10];
      } else {
        // N·∫øu s·ªë d∆∞ >= 20
        const ten = Math.floor(num / 10);
        const unit = num % 10;
        result += tens[ten];
        if (unit > 0) {
          // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát cho "m·ªët" v√† "lƒÉm"
          if (unit === 1 && ten > 1) {
            result += ' m·ªët';
          } else if (unit === 5 && ten > 0) {
            result += ' lƒÉm';
          } else {
            result += ' ' + units[unit];
          }
        }
      }
    }

    return result.trim();
  };

  // H√†m ch√≠nh ƒë·ªÉ chuy·ªÉn ƒë·ªïi s·ªë th√†nh ch·ªØ
  const convert = (num) => {
    if (num === 0) return 'kh√¥ng';

    let result = '';
    let scaleIndex = 0;

    // X·ª≠ l√Ω s·ªë theo t·ª´ng nh√≥m 3 ch·ªØ s·ªë
    while (num > 0) {
      const group = num % 1000;
      if (group !== 0) {
        const isFirstGroup = scaleIndex === 0;
        const groupText = handleHundreds(group, isFirstGroup);
        result =
          groupText +
          (scaleIndex > 0 ? ' ' + scales[scaleIndex] + ' ' : '') +
          result;
      }

      num = Math.floor(num / 1000);
      scaleIndex++;
    }

    return result.trim().replace(/\s\s+/g, ' '); // Lo·∫°i b·ªè kho·∫£ng tr·∫Øng th·ª´a
  };

  // X·ª≠ l√Ω s·ªë ti·ªÅn (ch·ªâ l·∫•y ph·∫ßn nguy√™n)
  const integerPart = Math.floor(number);

  let result = convert(integerPart) + ' ƒë·ªìng';

  // Vi·∫øt hoa ch·ªØ c√°i ƒë·∫ßu
  return result.charAt(0).toUpperCase() + result.slice(1);
};

const FinalizeQuotationScreen = ({ route, navigation }) => {
  const {
    materials: newMaterials,
    subTotal: newSubTotal,
    projectId,
    projectName,
    customerData,
    initialData,
    isRequote,
    originalQuotationId,
    isManualQuotation,
  } = route.params;

  // Determine if we are re-quoting and calculate subTotal accordingly
  const isRequoting = !!initialData;
  const materialsData = isRequoting ? initialData.materials : newMaterials;

  const subTotalData = isRequoting
    ? initialData.materials.reduce(
        (acc, item) => acc + (item.totalPrice || 0),
        0
      )
    : newSubTotal;

  // Initialize the quotation generator hook
  const {
    generateExcelQuotation,
    shareExcelQuotation,
    isLoading: isExcelLoading,
    excelUrl,
    pdfUrl,
    sharePdfQuotation,
    isPdfLoading,
  } = useQuotationGenerator({
    projectId,
    customerData,
    materials: materialsData,
  });

  // Initialize the contract generator hook
  const {
    generateContract,
    shareContractDoc,
    isLoading: isContractLoading,
    contractDocUrl,
  } = useContractGenerator({
    projectId,
    customerData,
    materials: materialsData,
    quotationData: {
      deliveryTime,
      paymentTerms,
      warrantyTerms,
    },
  });

  // Use initialData if it exists (for re-quoting), otherwise use new data
  const sourceData = initialData || route.params;

  // State cho c√°c tr∆∞·ªùng nh·∫≠p li·ªáu
  const [discountPercentage, setDiscountPercentage] = useState(
    sourceData.discountPercentage?.toString() || '0'
  );
  const [vatPercentage, setVatPercentage] = useState(
    sourceData.vatPercentage?.toString() || '10'
  );
  const [quoteValidity, setQuoteValidity] = useState(
    sourceData.quoteValidity || '7 ng√†y'
  );
  const [deliveryTime, setDeliveryTime] = useState(
    sourceData.deliveryTime || '15 ng√†y'
  );
  const [notes, setNotes] = useState(sourceData.notes || '');
  const [paymentTerms, setPaymentTerms] = useState(
    sourceData.paymentTerms ||
      'ƒê·ª£t 1: Thanh to√°n 50% ngay sau khi k√Ω h·ª£p ƒë·ªìng.\nƒê·ª£t 2: Thanh to√°n 50% c√≤n l·∫°i sau khi nghi·ªám thu v√† b√†n giao.'
  );
  const [warrantyTerms, setWarrantyTerms] = useState(
    sourceData.warrantyTerms || 'B·∫£o h√†nh 12 th√°ng cho to√†n b·ªô c√¥ng tr√¨nh.'
  );
  const [otherTerms, setOtherTerms] = useState(sourceData.otherTerms || '');
  const [bankDetails, setBankDetails] = useState(
    sourceData.bankDetails ||
      'T√™n t√†i kho·∫£n: C√îNG TY TNHH ABC\nS·ªë t√†i kho·∫£n: 123456789\nNg√¢n h√†ng: Vietcombank - Chi nh√°nh XYZ'
  );

  // State cho c√°c gi√° tr·ªã t√≠nh to√°n
  const [discountAmount, setDiscountAmount] = useState(0);
  const [afterDiscountTotal, setAfterDiscountTotal] = useState(subTotalData);
  const [vatAmount, setVatAmount] = useState(0);
  const [grandTotal, setGrandTotal] = useState(subTotalData);
  const [amountInWords, setAmountInWords] = useState('');

  // State cho qu√° tr√¨nh t·∫°o Excel

  const [materials, setMaterials] = useState(materialsData || []);

  // T√≠nh to√°n l·∫°i c√°c gi√° tr·ªã khi ng∆∞·ªùi d√πng thay ƒë·ªïi ƒë·∫ßu v√†o
  useEffect(() => {
    // Defensive calculations to prevent NaN issues
    const safeSubTotal = Number(subTotalData) || 0;
    const discountPercent = parseFloat(discountPercentage) || 0;
    const vatPercent = parseFloat(vatPercentage) || 0;

    // Calculate all financial values as local constants
    const calculatedDiscountAmount = (safeSubTotal * discountPercent) / 100;
    const calculatedAfterDiscountTotal =
      safeSubTotal - calculatedDiscountAmount;
    const calculatedVatAmount =
      (calculatedAfterDiscountTotal * vatPercent) / 100;
    const calculatedGrandTotal =
      calculatedAfterDiscountTotal + calculatedVatAmount;
    const calculatedAmountInWords = convertNumberToWords(calculatedGrandTotal);

    // Update all states at once
    setDiscountAmount(calculatedDiscountAmount);
    setAfterDiscountTotal(calculatedAfterDiscountTotal);
    setVatAmount(calculatedVatAmount);
    setGrandTotal(calculatedGrandTotal);
    setAmountInWords(calculatedAmountInWords);
  }, [subTotalData, discountPercentage, vatPercentage]);

  // H√†m t·∫°o b√°o gi√° Excel
  const handleGenerateExcel = async () => {
    try {
      const userId = auth.currentUser?.uid;

      if (!userId) {
        Alert.alert('L·ªói', 'B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ t·∫°o b√°o gi√° Excel.');
        return;
      }

      const effectiveProjectId = projectId || route?.params?.projectId;

      if (!effectiveProjectId) {
        Alert.alert('L·ªói', 'Kh√¥ng t√¨m th·∫•y th√¥ng tin d·ª± √°n. Vui l√≤ng th·ª≠ l·∫°i.');
        return;
      }

      // 1. Chu·∫©n b·ªã d·ªØ li·ªáu b√°o gi√°
      const quotationNumber = `THP-${new Date().getFullYear()}-${Math.floor(
        Math.random() * 1000
      )
        .toString()
        .padStart(3, '0')}`;

      // Assemble the complete quotation data
      const quotationData = {
        // Core Info
        quotationNumber,
        createdBy: userId,
        projectName: projectName,
        quotationDate: new Date().toISOString(),

        // Customer Info - ƒê·∫£m b·∫£o d·ªØ li·ªáu kh√°ch h√†ng ƒë∆∞·ª£c g·ª≠i ƒë√∫ng ƒë·ªãnh d·∫°ng
        metadata: {
          projectName: projectName,
          customerName: customerData?.name || '',
          customerAddress: customerData?.address || '',
          customerPhone: customerData?.phone || '',
          customerEmail: customerData?.email || '',
          customerTaxCode: customerData?.taxCode || '',
          customerContactPerson: customerData?.contactPerson || '',
          quotationNumber: quotationNumber,
          quoteValidity: quoteValidity,
          deliveryTime: deliveryTime,
        },

        // Financial Snapshot
        subTotal: subTotalData,
        discountPercentage: parseFloat(discountPercentage) || 0,
        discountAmount: discountAmount,
        afterDiscountTotal: afterDiscountTotal,
        vatPercentage: parseFloat(vatPercentage) || 0,
        vatAmount: vatAmount,
        grandTotal: grandTotal,
        amountInWords: amountInWords,

        // Materials Snapshot
        materials: materials.map((material) => ({
          no: material.stt || material.no || material.id || 0,
          stt: material.stt || material.no || material.id || 0, // Th√™m tr∆∞·ªùng stt ƒë·ªÉ ƒë·∫£m b·∫£o t∆∞∆°ng th√≠ch
          name: material.name || material.description || '',
          material: material.material || material.type || '',
          unit: material.unit || 'c√°i',
          quantity: material.quantity || 0,
          unitPrice: material.unitPrice || material.price || 0,
          total: material.totalPrice || material.total || 0,
          weight: material.weight || 0,
        })),

        // Terms Snapshot
        quoteValidity: quoteValidity,
        deliveryTime: deliveryTime,
        paymentTerms: paymentTerms,
        warrantyTerms: warrantyTerms,
        otherTerms: otherTerms,
        bankDetails: bankDetails,
        notes: notes,

        // T·ªïng h·ª£p th√¥ng tin t√†i ch√≠nh
        summary: {
          subTotal: subTotalData,
          vatPercentage: parseFloat(vatPercentage) || 0,
          vatAmount: vatAmount,
          grandTotal: grandTotal,
        },
      };

      // G·ªçi function t·∫°o b√°o gi√° Excel
      const url = await generateExcelQuotation(quotationData);

      if (url) {
        Alert.alert(
          'Th√†nh c√¥ng',
          'ƒê√£ t·∫°o b√°o gi√° Excel th√†nh c√¥ng. B·∫°n c√≥ mu·ªën chia s·∫ª file Excel kh√¥ng?',
          [
            { text: 'ƒê·ªÉ sau', style: 'cancel' },
            { text: 'Chia s·∫ª', onPress: () => shareExcelQuotation() },
          ]
        );
      }
    } catch (error) {
      console.error('Error generating Excel:', error);
      Alert.alert(
        'L·ªói',
        `Kh√¥ng th·ªÉ t·∫°o b√°o gi√° Excel: ${error.message || 'Unknown error'}`
      );
    }
  };

  // Function to handle contract generation
  const handleGenerateContract = async () => {
    try {
      await generateContract();
    } catch (error) {
      console.error('Error generating contract:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫°o h·ª£p ƒë·ªìng: ' + error.message);
    }
  };

  // Format s·ªë ti·ªÅn VND
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
    }).format(amount);
  };

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 64 : 0}
    >
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Ho√†n thi·ªán b√°o gi√°</Text>
        <View style={styles.placeholder} />
      </View>

      <ScrollView style={styles.content}>
        {/* Hi·ªÉn th·ªã t·ªïng ti·ªÅn v·∫≠t t∆∞ */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>T·ªïng c·ªông v·∫≠t t∆∞</Text>
          <Text style={styles.subTotalValue}>
            {formatCurrency(subTotalData)}
          </Text>
        </View>

        {/* Ph·∫ßn nh·∫≠p chi·∫øt kh·∫•u v√† VAT */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>ƒêi·ªÅu ch·ªânh gi√°</Text>

          <View style={styles.inputRow}>
            <Text style={styles.inputLabel}>Chi·∫øt kh·∫•u (%)</Text>
            <TextInput
              style={styles.input}
              value={discountPercentage}
              onChangeText={setDiscountPercentage}
              keyboardType="numeric"
              placeholder="0"
              maxLength={5}
            />
          </View>

          <View style={styles.inputRow}>
            <Text style={styles.inputLabel}>Thu·∫ø VAT (%)</Text>
            <TextInput
              style={styles.input}
              value={vatPercentage}
              onChangeText={setVatPercentage}
              keyboardType="numeric"
              placeholder="10"
              maxLength={5}
            />
          </View>
        </View>

        {/* Ph·∫ßn t√≥m t·∫Øt t√≠nh to√°n */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>T√≥m t·∫Øt</Text>

          <View style={styles.summaryRow}>
            <Text style={styles.summaryLabel}>T·ªïng c·ªông v·∫≠t t∆∞:</Text>
            <Text style={styles.summaryValue}>
              {formatCurrency(subTotalData)}
            </Text>
          </View>

          <View style={styles.summaryRow}>
            <Text style={styles.summaryLabel}>
              Chi·∫øt kh·∫•u ({discountPercentage}%):
            </Text>
            <Text style={styles.summaryValue}>
              - {formatCurrency(discountAmount)}
            </Text>
          </View>

          <View style={styles.summaryRow}>
            <Text style={styles.summaryLabel}>T·ªïng c·ªông sau chi·∫øt kh·∫•u:</Text>
            <Text style={styles.summaryValue}>
              {formatCurrency(afterDiscountTotal)}
            </Text>
          </View>

          <View style={styles.summaryRow}>
            <Text style={styles.summaryLabel}>
              Ti·ªÅn thu·∫ø VAT ({vatPercentage}%):
            </Text>
            <Text style={styles.summaryValue}>{formatCurrency(vatAmount)}</Text>
          </View>

          <View style={[styles.summaryRow, styles.totalRow]}>
            <Text style={styles.totalLabel}>T·ªîNG C·ªòNG ƒê√É BAO G·ªíM VAT:</Text>
            <Text style={styles.totalValue}>{formatCurrency(grandTotal)}</Text>
          </View>

          <View style={styles.wordsContainer}>
            <Text style={styles.wordsLabel}>B·∫±ng ch·ªØ:</Text>
            <Text style={styles.wordsValue}>{amountInWords}</Text>
          </View>
        </View>

        {/* Ph·∫ßn ƒëi·ªÅu kho·∫£n */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>ƒêi·ªÅu kho·∫£n b√°o gi√°</Text>

          <View style={styles.inputRow}>
            <Text style={styles.inputLabel}>Hi·ªáu l·ª±c b√°o gi√°</Text>
            <TextInput
              style={styles.input}
              value={quoteValidity}
              onChangeText={setQuoteValidity}
              placeholder="7 ng√†y"
            />
          </View>

          <View style={styles.inputRow}>
            <Text style={styles.inputLabel}>Th·ªùi gian giao h√†ng</Text>
            <TextInput
              style={styles.input}
              value={deliveryTime}
              onChangeText={setDeliveryTime}
              placeholder="15 ng√†y"
            />
          </View>

          <View style={styles.notesContainer}>
            <Text style={styles.inputLabel}>Ghi ch√∫</Text>
            <TextInput
              style={styles.notesInput}
              value={notes}
              onChangeText={setNotes}
              placeholder="Nh·∫≠p ghi ch√∫ (v√≠ d·ª•: + S∆†N EPOXY)"
              multiline
              numberOfLines={3}
              textAlignVertical="top"
            />
          </View>

          <View style={styles.notesContainer}>
            <Text style={styles.inputLabel}>Ph∆∞∆°ng th·ª©c thanh to√°n</Text>
            <TextInput
              style={styles.notesInput}
              value={paymentTerms}
              onChangeText={setPaymentTerms}
              placeholder="Nh·∫≠p ph∆∞∆°ng th·ª©c thanh to√°n"
              multiline
              numberOfLines={2}
              textAlignVertical="top"
            />
          </View>

          <View style={styles.notesContainer}>
            <Text style={styles.inputLabel}>ƒêi·ªÅu kho·∫£n b·∫£o h√†nh</Text>
            <TextInput
              style={styles.notesInput}
              value={warrantyTerms}
              onChangeText={setWarrantyTerms}
              placeholder="Nh·∫≠p ƒëi·ªÅu kho·∫£n b·∫£o h√†nh"
              multiline
              numberOfLines={2}
              textAlignVertical="top"
            />
          </View>

          <View style={styles.notesContainer}>
            <Text style={styles.inputLabel}>Th√¥ng tin ng√¢n h√†ng</Text>
            <TextInput
              style={styles.notesInput}
              value={bankDetails}
              onChangeText={setBankDetails}
              placeholder="Nh·∫≠p th√¥ng tin ng√¢n h√†ng"
              multiline
              numberOfLines={3}
              textAlignVertical="top"
            />
          </View>

          <View style={styles.notesContainer}>
            <Text style={styles.inputLabel}>ƒêi·ªÅu kho·∫£n kh√°c</Text>
            <TextInput
              style={styles.notesInput}
              value={otherTerms}
              onChangeText={setOtherTerms}
              placeholder="Nh·∫≠p c√°c ƒëi·ªÅu kho·∫£n kh√°c"
              multiline
              numberOfLines={2}
              textAlignVertical="top"
            />
          </View>
        </View>
      </ScrollView>

      {/* N√∫t t·∫°o Excel */}
      <View style={styles.footer}>
        <TouchableOpacity
          style={[styles.button, { backgroundColor: '#FF9800' }]}
          onPress={handleGenerateExcel}
          disabled={isExcelLoading}
        >
          {isExcelLoading ? (
            <ActivityIndicator size="small" color="#fff" />
          ) : (
            <>
              <Ionicons
                name="document-text"
                size={20}
                color="white"
                style={{ marginRight: 10 }}
              />
              <Text style={styles.buttonText}>T·∫°o B√°o Gi√° Excel</Text>
            </>
          )}
        </TouchableOpacity>

        {/* H·ª£p ƒë·ªìng chuy·ªÉn sang m·ª•c ri√™ng ·ªü m√†n h√¨nh ch√≠nh */}

        {excelUrl && (
          <TouchableOpacity
            style={[styles.button, { backgroundColor: '#009688' }]}
            onPress={shareExcelQuotation}
          >
            <Ionicons
              name="share-social"
              size={20}
              color="white"
              style={{ marginRight: 10 }}
            />
            <Text style={styles.buttonText}>Chia S·∫ª Excel</Text>
          </TouchableOpacity>
        )}

        {pdfUrl && (
          <TouchableOpacity
            style={[styles.button, { backgroundColor: '#3F51B5' }]}
            onPress={sharePdfQuotation}
          >
            <Ionicons
              name="share-outline"
              size={20}
              color="white"
              style={{ marginRight: 10 }}
            />
            <Text style={styles.buttonText}>Chia S·∫ª PDF</Text>
          </TouchableOpacity>
        )}
      </View>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F5F5',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  placeholder: {
    width: 24,
  },
  content: {
    flex: 1,
  },
  section: {
    backgroundColor: '#fff',
    marginBottom: 12,
    padding: 16,
    borderRadius: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginBottom: 16,
  },
  subTotalValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#0066cc',
  },
  inputRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  inputLabel: {
    fontSize: 16,
    color: '#555',
    flex: 1,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 6,
    padding: 10,
    fontSize: 16,
    width: '40%',
    textAlign: 'right',
  },
  notesContainer: {
    marginBottom: 16,
  },
  notesInput: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 6,
    padding: 10,
    fontSize: 16,
    marginTop: 8,
    height: 80,
  },
  summaryRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  summaryLabel: {
    fontSize: 16,
    color: '#555',
  },
  summaryValue: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
  },
  totalRow: {
    marginTop: 8,
    paddingTop: 12,
    borderTopWidth: 1,
    borderTopColor: '#ddd',
    borderBottomWidth: 0,
  },
  totalLabel: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  totalValue: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#0066cc',
  },
  wordsContainer: {
    marginTop: 16,
    padding: 12,
    backgroundColor: '#f5f5f5',
    borderRadius: 6,
  },
  wordsLabel: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
  },
  wordsValue: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    fontStyle: 'italic',
  },
  footer: {
    backgroundColor: '#fff',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 15,
    borderRadius: 8,
    marginVertical: 10,
    marginHorizontal: 20,
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
});

export default FinalizeQuotationScreen;


--- END: src\screens\FinalizeQuotationScreen.js ---


--- START: src\screens\FinancialDashboardScreen.js ---
// src/screens/FinancialDashboardScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  SafeAreaView,
  Dimensions,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import {
  collection,
  query,
  orderBy,
  limit,
  getDocs,
  getFirestore,
} from 'firebase/firestore';
import { LineChart, PieChart } from 'react-native-chart-kit';

const FinancialDashboardScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const { user } = useAuth();
  const [loading, setLoading] = useState(true);
  const [monthlySummaries, setMonthlySummaries] = useState([]);
  const [selectedMonth, setSelectedMonth] = useState(null);
  const screenWidth = Dimensions.get('window').width;

  useEffect(() => {
    // Only directors can access this screen
    if (!['giam_doc', 'director'].includes(user?.role)) {
      alert('B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p ch·ª©c nƒÉng n√†y');
      navigation.goBack();
      return;
    }

    loadData();
  }, [navigation, user]);

  const loadData = async () => {
    try {
      setLoading(true);
      const db = getFirestore();
      const q = query(
        collection(db, 'monthly_summaries'),
        orderBy('year', 'desc'),
        orderBy('month', 'desc'),
        limit(12)
      );

      const querySnapshot = await getDocs(q);
      const summaries = [];

      querySnapshot.forEach((doc) => {
        summaries.push({
          id: doc.id,
          ...doc.data(),
        });
      });

      setMonthlySummaries(summaries);
      if (summaries.length > 0) {
        setSelectedMonth(summaries[0]);
      }
    } catch (error) {
      console.error('Error loading financial data:', error);
    } finally {
      setLoading(false);
    }
  };

  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
      minimumFractionDigits: 0,
    }).format(amount);
  };

  const getMonthLabel = (monthNum) => {
    const months = [
      'Th√°ng 1',
      'Th√°ng 2',
      'Th√°ng 3',
      'Th√°ng 4',
      'Th√°ng 5',
      'Th√°ng 6',
      'Th√°ng 7',
      'Th√°ng 8',
      'Th√°ng 9',
      'Th√°ng 10',
      'Th√°ng 11',
      'Th√°ng 12',
    ];
    return months[monthNum - 1] || 'Kh√¥ng x√°c ƒë·ªãnh';
  };

  // Prepare chart data
  const revenueData = {
    labels: monthlySummaries
      .slice()
      .reverse()
      .map((s) => `T${s.month}`),
    datasets: [
      {
        data: monthlySummaries
          .slice()
          .reverse()
          .map((s) => s.totalRevenue / 1000000),
        color: (opacity = 1) => `rgba(54, 162, 235, ${opacity})`,
        strokeWidth: 2,
      },
    ],
    legend: ['Doanh thu (tri·ªáu VND)'],
  };

  const expenseData = {
    labels: monthlySummaries
      .slice()
      .reverse()
      .map((s) => `T${s.month}`),
    datasets: [
      {
        data: monthlySummaries
          .slice()
          .reverse()
          .map((s) => s.totalExpenses / 1000000),
        color: (opacity = 1) => `rgba(255, 99, 132, ${opacity})`,
        strokeWidth: 2,
      },
    ],
    legend: ['Chi ph√≠ (tri·ªáu VND)'],
  };

  const combinedData = {
    labels: monthlySummaries
      .slice()
      .reverse()
      .map((s) => `T${s.month}`),
    datasets: [
      {
        data: monthlySummaries
          .slice()
          .reverse()
          .map((s) => s.totalRevenue / 1000000),
        color: (opacity = 1) => `rgba(54, 162, 235, ${opacity})`,
        strokeWidth: 2,
      },
      {
        data: monthlySummaries
          .slice()
          .reverse()
          .map((s) => s.totalExpenses / 1000000),
        color: (opacity = 1) => `rgba(255, 99, 132, ${opacity})`,
        strokeWidth: 2,
      },
    ],
    legend: ['Doanh thu', 'Chi ph√≠'],
  };

  // Prepare pie chart data
  const expenseBreakdownData = selectedMonth
    ? [
        {
          name: 'V·∫≠t t∆∞',
          amount: selectedMonth.expenseBreakdown?.material || 0,
          color: '#FF6384',
          legendFontColor: theme.text,
          legendFontSize: 12,
        },
        {
          name: 'Nh√¢n c√¥ng',
          amount: selectedMonth.expenseBreakdown?.labor || 0,
          color: '#36A2EB',
          legendFontColor: theme.text,
          legendFontSize: 12,
        },
        {
          name: 'Chi ph√≠ gi√°n ti·∫øp',
          amount: selectedMonth.expenseBreakdown?.overhead || 0,
          color: '#FFCE56',
          legendFontColor: theme.text,
          legendFontSize: 12,
        },
      ].filter((item) => item.amount > 0)
    : [];

  const renderKPICard = (title, value, icon, color) => (
    <View style={[styles.kpiCard, { backgroundColor: theme.cardBackground }]}>
      <View style={[styles.kpiIconContainer, { backgroundColor: color }]}>
        <Ionicons name={icon} size={24} color="#FFFFFF" />
      </View>
      <View style={styles.kpiContent}>
        <Text style={[styles.kpiTitle, { color: theme.textSecondary }]}>
          {title}
        </Text>
        <Text style={[styles.kpiValue, { color: theme.text }]}>{value}</Text>
      </View>
    </View>
  );

  if (loading) {
    return (
      <SafeAreaView
        style={[styles.container, { backgroundColor: theme.background }]}
      >
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
          >
            <Ionicons name="arrow-back" size={24} color={theme.text} />
          </TouchableOpacity>
          <Text style={[styles.headerTitle, { color: theme.text }]}>
            B√°o c√°o T√†i ch√≠nh
          </Text>
        </View>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
            ƒêang t·∫£i d·ªØ li·ªáu...
          </Text>
        </View>
      </SafeAreaView>
    );
  }

  if (monthlySummaries.length === 0) {
    return (
      <SafeAreaView
        style={[styles.container, { backgroundColor: theme.background }]}
      >
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
          >
            <Ionicons name="arrow-back" size={24} color={theme.text} />
          </TouchableOpacity>
          <Text style={[styles.headerTitle, { color: theme.text }]}>
            B√°o c√°o T√†i ch√≠nh
          </Text>
        </View>
        <View style={styles.emptyContainer}>
          <Ionicons
            name="document-text-outline"
            size={60}
            color={theme.textMuted}
          />
          <Text style={[styles.emptyText, { color: theme.textSecondary }]}>
            Ch∆∞a c√≥ d·ªØ li·ªáu b√°o c√°o t√†i ch√≠nh.
          </Text>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={theme.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          B√°o c√°o T√†i ch√≠nh
        </Text>
      </View>

      <ScrollView style={styles.scrollContent}>
        {selectedMonth && (
          <View style={styles.selectedMonthContainer}>
            <Text style={[styles.selectedMonthTitle, { color: theme.text }]}>
              {getMonthLabel(selectedMonth.month)}/{selectedMonth.year}
            </Text>
          </View>
        )}

        {selectedMonth && (
          <View style={styles.kpiContainer}>
            {renderKPICard(
              'Doanh thu',
              formatCurrency(selectedMonth.totalRevenue),
              'cash-outline',
              '#1E88E5'
            )}

            {renderKPICard(
              'Chi ph√≠',
              formatCurrency(selectedMonth.totalExpenses),
              'wallet-outline',
              '#F44336'
            )}

            {renderKPICard(
              'L·ª£i nhu·∫≠n',
              formatCurrency(selectedMonth.profit),
              'trending-up-outline',
              '#4CAF50'
            )}

            {renderKPICard(
              'T·ª∑ su·∫•t LN',
              `${Math.round(
                (selectedMonth.profit / selectedMonth.totalRevenue) * 100
              )}%`,
              'analytics-outline',
              '#FF9800'
            )}
          </View>
        )}

        <View
          style={[
            styles.chartContainer,
            { backgroundColor: theme.cardBackground },
          ]}
        >
          <Text style={[styles.chartTitle, { color: theme.text }]}>
            Doanh thu v√† Chi ph√≠ 12 th√°ng g·∫ßn nh·∫•t
          </Text>
          {monthlySummaries.length > 0 && (
            <LineChart
              data={combinedData}
              width={screenWidth - 32}
              height={220}
              chartConfig={{
                backgroundColor: theme.cardBackground,
                backgroundGradientFrom: theme.cardBackground,
                backgroundGradientTo: theme.cardBackground,
                decimalPlaces: 0,
                color: (opacity = 1) => theme.text,
                labelColor: (opacity = 1) => theme.textSecondary,
                style: {
                  borderRadius: 16,
                },
                propsForDots: {
                  r: '6',
                  strokeWidth: '2',
                },
              }}
              bezier
              style={styles.chart}
            />
          )}
        </View>

        {selectedMonth && expenseBreakdownData.length > 0 && (
          <View
            style={[
              styles.chartContainer,
              { backgroundColor: theme.cardBackground },
            ]}
          >
            <Text style={[styles.chartTitle, { color: theme.text }]}>
              C∆° c·∫•u chi ph√≠
            </Text>
            <PieChart
              data={expenseBreakdownData}
              width={screenWidth - 32}
              height={220}
              chartConfig={{
                backgroundColor: theme.cardBackground,
                backgroundGradientFrom: theme.cardBackground,
                backgroundGradientTo: theme.cardBackground,
                color: (opacity = 1) => `rgba(0, 0, 0, ${opacity})`,
                labelColor: (opacity = 1) => theme.text,
                style: {
                  borderRadius: 16,
                },
              }}
              accessor="amount"
              backgroundColor="transparent"
              paddingLeft="15"
              absolute
            />
          </View>
        )}

        <View
          style={[
            styles.monthListContainer,
            { backgroundColor: theme.cardBackground },
          ]}
        >
          <Text style={[styles.monthListTitle, { color: theme.text }]}>
            L·ªãch s·ª≠ b√°o c√°o th√°ng
          </Text>
          <View style={styles.monthList}>
            {monthlySummaries.map((summary) => (
              <TouchableOpacity
                key={summary.id}
                style={[
                  styles.monthItem,
                  selectedMonth?.id === summary.id && {
                    backgroundColor: `${theme.primary}20`,
                  },
                ]}
                onPress={() => setSelectedMonth(summary)}
              >
                <Text
                  style={[
                    styles.monthItemText,
                    { color: theme.text },
                    selectedMonth?.id === summary.id && {
                      fontWeight: 'bold',
                      color: theme.primary,
                    },
                  ]}
                >
                  {getMonthLabel(summary.month)}/{summary.year}
                </Text>
              </TouchableOpacity>
            ))}
          </View>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  backButton: {
    marginRight: 16,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  emptyText: {
    marginTop: 16,
    fontSize: 16,
    textAlign: 'center',
  },
  scrollContent: {
    flex: 1,
    padding: 16,
  },
  selectedMonthContainer: {
    alignItems: 'center',
    marginBottom: 16,
  },
  selectedMonthTitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  kpiContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  kpiCard: {
    width: '48%',
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    flexDirection: 'row',
    alignItems: 'center',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
  },
  kpiIconContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  kpiContent: {
    flex: 1,
  },
  kpiTitle: {
    fontSize: 12,
    marginBottom: 4,
  },
  kpiValue: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  chartContainer: {
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
  },
  chartTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 16,
    textAlign: 'center',
  },
  chart: {
    marginVertical: 8,
    borderRadius: 16,
  },
  monthListContainer: {
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
  },
  monthListTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  monthList: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  monthItem: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 16,
    margin: 4,
  },
  monthItemText: {
    fontSize: 14,
  },
});

export default FinancialDashboardScreen;


--- END: src\screens\FinancialDashboardScreen.js ---


--- START: src\screens\FixedFeesManagementScreen.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Alert,
  Modal,
  TextInput,
  ActivityIndicator,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import salaryService from '../api/salaryService';

const FixedFeesManagementScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const { user } = useAuth();

  const [fees, setFees] = useState([]);
  const [loading, setLoading] = useState(true);
  const [modalVisible, setModalVisible] = useState(false);
  const [editingFee, setEditingFee] = useState(null);
  const [formData, setFormData] = useState({
    name: '',
    type: 'deduction',
    amount: '',
    percentage: '',
    calculationType: 'fixed', // 'fixed' ho·∫∑c 'percentage'
    description: '',
    isActive: true,
  });

  const feeTypes = [
    { key: 'deduction', label: 'Kh·∫•u tr·ª´', color: '#F44336' },
    { key: 'allowance', label: 'Ph·ª• c·∫•p', color: '#4CAF50' },
    { key: 'insurance', label: 'B·∫£o hi·ªÉm', color: '#2196F3' },
  ];

  useEffect(() => {
    loadFees();
  }, []);

  const loadFees = async () => {
    try {
      setLoading(true);
      const feesData = await salaryService.getAllFixedFees();
      setFees(feesData);
    } catch (error) {
      console.error('L·ªói khi t·∫£i danh s√°ch ph√≠:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch ph√≠ c·ªë ƒë·ªãnh');
    } finally {
      setLoading(false);
    }
  };

  const handleAddFee = () => {
    setEditingFee(null);
    setFormData({
      name: '',
      type: 'deduction',
      amount: '',
      percentage: '',
      calculationType: 'fixed',
      description: '',
      isActive: true,
    });
    setModalVisible(true);
  };

  const handleEditFee = (fee) => {
    setEditingFee(fee);
    setFormData({
      name: fee.name,
      type: fee.type,
      amount: fee.amount ? fee.amount.toString() : '',
      percentage: fee.percentage ? fee.percentage.toString() : '',
      calculationType: fee.calculationType || 'fixed',
      description: fee.description,
      isActive: fee.isActive,
    });
    setModalVisible(true);
  };

  const handleDeleteFee = async (feeId) => {
    Alert.alert('X√°c nh·∫≠n x√≥a', 'B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a lo·∫°i ph√≠ n√†y?', [
      { text: 'H·ªßy', style: 'cancel' },
      {
        text: 'X√≥a',
        style: 'destructive',
        onPress: async () => {
          try {
            await salaryService.deleteFixedFee(feeId);
            Alert.alert('Th√†nh c√¥ng', 'ƒê√£ x√≥a lo·∫°i ph√≠');
            loadFees();
          } catch (error) {
            console.error('L·ªói khi x√≥a ph√≠:', error);
            Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ x√≥a lo·∫°i ph√≠');
          }
        },
      },
    ]);
  };

  const handleSaveFee = async () => {
    if (!formData.name.trim()) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p t√™n ph√≠');
      return;
    }

    if (formData.calculationType === 'fixed' && !formData.amount.trim()) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p s·ªë ti·ªÅn c·ªë ƒë·ªãnh');
      return;
    }

    if (
      formData.calculationType === 'percentage' &&
      !formData.percentage.trim()
    ) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p ph·∫ßn trƒÉm');
      return;
    }

    try {
      if (editingFee) {
        await salaryService.updateFixedFee(editingFee.id, formData);
        Alert.alert('Th√†nh c√¥ng', 'ƒê√£ c·∫≠p nh·∫≠t lo·∫°i ph√≠');
      } else {
        await salaryService.createFixedFee(formData);
        Alert.alert('Th√†nh c√¥ng', 'ƒê√£ t·∫°o lo·∫°i ph√≠ m·ªõi');
      }

      setModalVisible(false);
      loadFees();
    } catch (error) {
      console.error('L·ªói khi l∆∞u ph√≠:', error);
      Alert.alert('L·ªói', error.message || 'Kh√¥ng th·ªÉ l∆∞u lo·∫°i ph√≠');
    }
  };

  const getFeeTypeLabel = (type) => {
    const feeType = feeTypes.find((ft) => ft.key === type);
    return feeType ? feeType.label : type;
  };

  const getFeeTypeColor = (type) => {
    const feeType = feeTypes.find((ft) => ft.key === type);
    return feeType ? feeType.color : '#666';
  };

  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
    }).format(amount);
  };

  if (loading) {
    return (
      <View style={[styles.container, { backgroundColor: theme.background }]}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
            ƒêang t·∫£i danh s√°ch ph√≠ c·ªë ƒë·ªãnh...
          </Text>
        </View>
      </View>
    );
  }

  return (
    <View style={[styles.container, { backgroundColor: theme.background }]}>
      {/* Header */}
      <View style={[styles.header, { backgroundColor: theme.primary }]}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#fff" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Qu·∫£n l√Ω ph√≠ c·ªë ƒë·ªãnh</Text>
        <TouchableOpacity style={styles.addButton} onPress={handleAddFee}>
          <Ionicons name="add" size={24} color="#fff" />
        </TouchableOpacity>
      </View>

      {/* Content */}
      <ScrollView style={styles.content}>
        {/* Th·ªëng k√™ */}
        <View style={[styles.statsContainer, { backgroundColor: theme.card }]}>
          <Text style={[styles.statsTitle, { color: theme.text }]}>
            Th·ªëng k√™
          </Text>
          <View style={styles.statsGrid}>
            <View style={styles.statItem}>
              <Text style={[styles.statNumber, { color: theme.primary }]}>
                {fees.length}
              </Text>
              <Text style={[styles.statLabel, { color: theme.textSecondary }]}>
                T·ªïng s·ªë lo·∫°i ph√≠
              </Text>
            </View>
            <View style={styles.statItem}>
              <Text style={[styles.statNumber, { color: '#4CAF50' }]}>
                {fees.filter((f) => f.type === 'allowance').length}
              </Text>
              <Text style={[styles.statLabel, { color: theme.textSecondary }]}>
                Ph·ª• c·∫•p
              </Text>
            </View>
            <View style={styles.statItem}>
              <Text style={[styles.statNumber, { color: '#F44336' }]}>
                {fees.filter((f) => f.type === 'deduction').length}
              </Text>
              <Text style={[styles.statLabel, { color: theme.textSecondary }]}>
                Kh·∫•u tr·ª´
              </Text>
            </View>
            <View style={styles.statItem}>
              <Text style={[styles.statNumber, { color: '#2196F3' }]}>
                {fees.filter((f) => f.type === 'insurance').length}
              </Text>
              <Text style={[styles.statLabel, { color: theme.textSecondary }]}>
                B·∫£o hi·ªÉm
              </Text>
            </View>
          </View>
        </View>

        {/* Danh s√°ch ph√≠ c·ªë ƒë·ªãnh */}
        <View style={styles.feesContainer}>
          <Text style={[styles.sectionTitle, { color: theme.text }]}>
            Danh s√°ch ph√≠ c·ªë ƒë·ªãnh
          </Text>

          {fees.length === 0 ? (
            <View
              style={[styles.emptyContainer, { backgroundColor: theme.card }]}
            >
              <Ionicons
                name="document-outline"
                size={48}
                color={theme.textMuted}
              />
              <Text style={[styles.emptyText, { color: theme.textMuted }]}>
                Ch∆∞a c√≥ lo·∫°i ph√≠ c·ªë ƒë·ªãnh n√†o
              </Text>
              <TouchableOpacity
                style={[styles.emptyButton, { backgroundColor: theme.primary }]}
                onPress={handleAddFee}
              >
                <Text style={styles.emptyButtonText}>
                  Th√™m lo·∫°i ph√≠ ƒë·∫ßu ti√™n
                </Text>
              </TouchableOpacity>
            </View>
          ) : (
            fees.map((fee) => (
              <View
                key={fee.id}
                style={[styles.feeCard, { backgroundColor: theme.card }]}
              >
                <View style={styles.feeHeader}>
                  <View style={styles.feeInfo}>
                    <Text style={[styles.feeName, { color: theme.text }]}>
                      {fee.name}
                    </Text>
                    <View
                      style={[
                        styles.feeType,
                        { backgroundColor: getFeeTypeColor(fee.type) },
                      ]}
                    >
                      <Text style={styles.feeTypeText}>
                        {getFeeTypeLabel(fee.type)}
                      </Text>
                    </View>
                  </View>
                  <View style={styles.feeActions}>
                    <TouchableOpacity
                      style={[
                        styles.actionButton,
                        { backgroundColor: theme.primary },
                      ]}
                      onPress={() => handleEditFee(fee)}
                    >
                      <Ionicons name="create-outline" size={16} color="#fff" />
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[
                        styles.actionButton,
                        { backgroundColor: '#F44336' },
                      ]}
                      onPress={() => handleDeleteFee(fee.id)}
                    >
                      <Ionicons name="trash-outline" size={16} color="#fff" />
                    </TouchableOpacity>
                  </View>
                </View>

                <View style={styles.feeDetails}>
                  {fee.calculationType === 'percentage' ? (
                    <Text style={[styles.feeAmount, { color: theme.primary }]}>
                      {fee.percentage}% l∆∞∆°ng
                    </Text>
                  ) : (
                    <Text style={[styles.feeAmount, { color: theme.primary }]}>
                      {formatCurrency(fee.amount || 0)}
                    </Text>
                  )}
                  {fee.description && (
                    <Text
                      style={[
                        styles.feeDescription,
                        { color: theme.textSecondary },
                      ]}
                    >
                      {fee.description}
                    </Text>
                  )}
                </View>

                <View style={styles.feeStatus}>
                  <View
                    style={[
                      styles.statusIndicator,
                      { backgroundColor: fee.isActive ? '#4CAF50' : '#F44336' },
                    ]}
                  />
                  <Text
                    style={[styles.statusText, { color: theme.textSecondary }]}
                  >
                    {fee.isActive ? 'ƒêang ho·∫°t ƒë·ªông' : 'ƒê√£ t·∫Øt'}
                  </Text>
                </View>
              </View>
            ))
          )}
        </View>
      </ScrollView>

      {/* Modal th√™m/s·ª≠a ph√≠ */}
      <Modal
        animationType="slide"
        transparent={true}
        visible={modalVisible}
        onRequestClose={() => setModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View
            style={[styles.modalContent, { backgroundColor: theme.background }]}
          >
            <View
              style={[styles.modalHeader, { backgroundColor: theme.primary }]}
            >
              <Text style={styles.modalTitle}>
                {editingFee ? 'S·ª≠a lo·∫°i ph√≠' : 'Th√™m lo·∫°i ph√≠ m·ªõi'}
              </Text>
              <TouchableOpacity
                style={styles.closeButton}
                onPress={() => setModalVisible(false)}
              >
                <Ionicons name="close" size={24} color="#fff" />
              </TouchableOpacity>
            </View>

            <ScrollView style={styles.modalBody}>
              {/* T√™n lo·∫°i ph√≠ */}
              <View style={styles.formGroup}>
                <Text style={[styles.formLabel, { color: theme.text }]}>
                  T√™n lo·∫°i ph√≠ *
                </Text>
                <TextInput
                  style={[
                    styles.formInput,
                    {
                      backgroundColor: theme.card,
                      borderColor: theme.border,
                      color: theme.text,
                    },
                  ]}
                  value={formData.name}
                  onChangeText={(text) =>
                    setFormData({ ...formData, name: text })
                  }
                  placeholder="VD: B·∫£o hi·ªÉm x√£ h·ªôi, Ph·ª• c·∫•p ƒÉn tr∆∞a..."
                  placeholderTextColor={theme.textMuted}
                />
              </View>

              {/* Lo·∫°i ph√≠ */}
              <View style={styles.formGroup}>
                <Text style={[styles.formLabel, { color: theme.text }]}>
                  Lo·∫°i ph√≠ *
                </Text>
                <View style={styles.typeSelector}>
                  {feeTypes.map((type) => (
                    <TouchableOpacity
                      key={type.key}
                      style={[
                        styles.typeOption,
                        formData.type === type.key && {
                          backgroundColor: type.color,
                        },
                      ]}
                      onPress={() =>
                        setFormData({ ...formData, type: type.key })
                      }
                    >
                      <Text
                        style={[
                          styles.typeOptionText,
                          formData.type === type.key && { color: '#fff' },
                        ]}
                      >
                        {type.label}
                      </Text>
                    </TouchableOpacity>
                  ))}
                </View>
              </View>

              {/* C√°ch t√≠nh ph√≠ */}
              <View style={styles.formGroup}>
                <Text style={[styles.formLabel, { color: theme.text }]}>
                  C√°ch t√≠nh ph√≠ *
                </Text>
                <View style={styles.typeSelector}>
                  <TouchableOpacity
                    style={[
                      styles.typeOption,
                      formData.calculationType === 'fixed' && {
                        backgroundColor: theme.primary,
                      },
                    ]}
                    onPress={() =>
                      setFormData({ ...formData, calculationType: 'fixed' })
                    }
                  >
                    <Text
                      style={[
                        styles.typeOptionText,
                        formData.calculationType === 'fixed' && {
                          color: '#fff',
                        },
                      ]}
                    >
                      S·ªë ti·ªÅn c·ªë ƒë·ªãnh
                    </Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[
                      styles.typeOption,
                      formData.calculationType === 'percentage' && {
                        backgroundColor: theme.primary,
                      },
                    ]}
                    onPress={() =>
                      setFormData({
                        ...formData,
                        calculationType: 'percentage',
                      })
                    }
                  >
                    <Text
                      style={[
                        styles.typeOptionText,
                        formData.calculationType === 'percentage' && {
                          color: '#fff',
                        },
                      ]}
                    >
                      Theo ph·∫ßn trƒÉm l∆∞∆°ng
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>

              {/* S·ªë ti·ªÅn ho·∫∑c ph·∫ßn trƒÉm */}
              {formData.calculationType === 'fixed' ? (
                <View style={styles.formGroup}>
                  <Text style={[styles.formLabel, { color: theme.text }]}>
                    S·ªë ti·ªÅn (VNƒê) *
                  </Text>
                  <TextInput
                    style={[
                      styles.formInput,
                      {
                        backgroundColor: theme.card,
                        borderColor: theme.border,
                        color: theme.text,
                      },
                    ]}
                    value={formData.amount}
                    onChangeText={(text) =>
                      setFormData({ ...formData, amount: text })
                    }
                    placeholder="VD: 500000"
                    placeholderTextColor={theme.textMuted}
                    keyboardType="numeric"
                  />
                </View>
              ) : (
                <View style={styles.formGroup}>
                  <Text style={[styles.formLabel, { color: theme.text }]}>
                    Ph·∫ßn trƒÉm (%) *
                  </Text>
                  <View style={styles.percentageInputContainer}>
                    <TextInput
                      style={[
                        styles.formInput,
                        {
                          backgroundColor: theme.card,
                          borderColor: theme.border,
                          color: theme.text,
                          flex: 1,
                        },
                      ]}
                      value={formData.percentage}
                      onChangeText={(text) =>
                        setFormData({ ...formData, percentage: text })
                      }
                      placeholder="VD: 8"
                      placeholderTextColor={theme.textMuted}
                      keyboardType="numeric"
                    />
                    <Text
                      style={[styles.percentageSymbol, { color: theme.text }]}
                    >
                      %
                    </Text>
                  </View>
                  <Text style={[styles.formHint, { color: theme.textMuted }]}>
                    VD: BHXH = 8%, BHYT = 1.5%, BHTN = 1%
                  </Text>
                </View>
              )}

              {/* M√¥ t·∫£ */}
              <View style={styles.formGroup}>
                <Text style={[styles.formLabel, { color: theme.text }]}>
                  M√¥ t·∫£
                </Text>
                <TextInput
                  style={[
                    styles.formTextArea,
                    {
                      backgroundColor: theme.card,
                      borderColor: theme.border,
                      color: theme.text,
                    },
                  ]}
                  value={formData.description}
                  onChangeText={(text) =>
                    setFormData({ ...formData, description: text })
                  }
                  placeholder="M√¥ t·∫£ chi ti·∫øt v·ªÅ lo·∫°i ph√≠ n√†y..."
                  placeholderTextColor={theme.textMuted}
                  multiline
                  numberOfLines={3}
                />
              </View>

              {/* Tr·∫°ng th√°i */}
              <View style={styles.formGroup}>
                <View style={styles.switchContainer}>
                  <Text style={[styles.formLabel, { color: theme.text }]}>
                    ƒêang ho·∫°t ƒë·ªông
                  </Text>
                  <TouchableOpacity
                    style={[
                      styles.switch,
                      {
                        backgroundColor: formData.isActive
                          ? theme.primary
                          : theme.textMuted,
                      },
                    ]}
                    onPress={() =>
                      setFormData({ ...formData, isActive: !formData.isActive })
                    }
                  >
                    <View
                      style={[
                        styles.switchThumb,
                        {
                          backgroundColor: '#fff',
                          transform: [
                            { translateX: formData.isActive ? 20 : 0 },
                          ],
                        },
                      ]}
                    />
                  </TouchableOpacity>
                </View>
              </View>
            </ScrollView>

            <View style={styles.modalFooter}>
              <TouchableOpacity
                style={[
                  styles.modalButton,
                  { backgroundColor: theme.textMuted },
                ]}
                onPress={() => setModalVisible(false)}
              >
                <Text style={styles.modalButtonText}>H·ªßy</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.modalButton, { backgroundColor: theme.primary }]}
                onPress={handleSaveFee}
              >
                <Text style={styles.modalButtonText}>
                  {editingFee ? 'C·∫≠p nh·∫≠t' : 'Th√™m m·ªõi'}
                </Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingTop: 50,
    paddingBottom: 16,
  },
  backButton: {
    padding: 8,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#fff',
    flex: 1,
    textAlign: 'center',
  },
  addButton: {
    padding: 8,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
  },
  statsContainer: {
    padding: 16,
    borderRadius: 12,
    marginBottom: 20,
  },
  statsTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  statsGrid: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  statItem: {
    alignItems: 'center',
    flex: 1,
  },
  statNumber: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  statLabel: {
    fontSize: 12,
    textAlign: 'center',
  },
  feesContainer: {
    flex: 1,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  emptyContainer: {
    padding: 32,
    borderRadius: 12,
    alignItems: 'center',
  },
  emptyText: {
    fontSize: 16,
    marginTop: 16,
    marginBottom: 24,
    textAlign: 'center',
  },
  emptyButton: {
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
  },
  emptyButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
  feeCard: {
    padding: 16,
    borderRadius: 12,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: 'rgba(0,0,0,0.1)',
  },
  feeHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 12,
  },
  feeInfo: {
    flex: 1,
  },
  feeName: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 8,
  },
  feeType: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    alignSelf: 'flex-start',
  },
  feeTypeText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '500',
  },
  feeActions: {
    flexDirection: 'row',
    gap: 8,
  },
  actionButton: {
    padding: 8,
    borderRadius: 8,
  },
  percentageInputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  percentageSymbol: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  formHint: {
    fontSize: 12,
    marginTop: 4,
    fontStyle: 'italic',
  },
  feeDetails: {
    marginBottom: 12,
  },
  feeAmount: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  feeDescription: {
    fontSize: 14,
    lineHeight: 20,
  },
  feeStatus: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  statusIndicator: {
    width: 8,
    height: 8,
    borderRadius: 4,
    marginRight: 8,
  },
  statusText: {
    fontSize: 12,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    width: '90%',
    maxHeight: '80%',
    borderRadius: 16,
    overflow: 'hidden',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#fff',
  },
  closeButton: {
    padding: 4,
  },
  modalBody: {
    padding: 16,
  },
  formGroup: {
    marginBottom: 20,
  },
  formLabel: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 8,
  },
  formInput: {
    borderWidth: 1,
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 12,
    fontSize: 16,
  },
  formTextArea: {
    borderWidth: 1,
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 12,
    fontSize: 16,
    minHeight: 80,
    textAlignVertical: 'top',
  },
  typeSelector: {
    flexDirection: 'row',
    gap: 8,
  },
  typeOption: {
    flex: 1,
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#ddd',
    alignItems: 'center',
  },
  typeOptionText: {
    fontSize: 14,
    fontWeight: '500',
  },
  switchContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  switch: {
    width: 44,
    height: 24,
    borderRadius: 12,
    padding: 2,
  },
  switchThumb: {
    width: 20,
    height: 20,
    borderRadius: 10,
  },
  modalFooter: {
    flexDirection: 'row',
    gap: 12,
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  modalButton: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 8,
    alignItems: 'center',
  },
  modalButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
});

export default FixedFeesManagementScreen;


--- END: src\screens\FixedFeesManagementScreen.js ---


--- START: src\screens\HomeScreen.js ---
//src/screens/HomeScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  StatusBar,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { getProjects } from '../api/projectService';
import { getCustomers } from '../api/customerService';
import { useFocusEffect } from '@react-navigation/native';
import {
  getAttendance,
  clockIn,
  clockOut,
  addOvertime,
  getAttendanceStatus,
} from '../api/attendanceService';
import { useAuth } from '../contexts/AuthContext';
import WorkerFeaturesMenu from '../components/WorkerFeaturesMenu';

const HomeScreen = ({ navigation }) => {
  const { theme, isDarkMode } = useTheme();
  const { user } = useAuth();
  const [recentProjects, setRecentProjects] = useState([]);
  const [recentCustomers, setRecentCustomers] = useState([]);
  const [loading, setLoading] = useState(true);

  // Attendance state
  const [attendance, setAttendance] = useState(null);
  const [attLoading, setAttLoading] = useState(true);

  const ROLE_CAN_ATTEND = ['ke_toan', 'cong_nhan', 'ky_su'];

  const canUseAttendance = ROLE_CAN_ATTEND.includes(
    (user?.role || '').toLowerCase()
  );

  // Ki·ªÉm tra role ƒë·ªÉ hi·ªÉn th·ªã c√°c ch·ª©c nƒÉng ƒë·∫∑c bi·ªát
  const isWorker = (user?.role || '').toLowerCase() === 'cong_nhan';
  const isEngineer = (user?.role || '').toLowerCase() === 'ky_su';
  const isAccountant = (user?.role || '').toLowerCase() === 'ke_toan';

  // C√°c role c√≥ th·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng ch·∫•m c√¥ng, ngh·ªâ ph√©p, ·ª©ng l∆∞∆°ng
  const canUseWorkerFeatures = isWorker || isEngineer || isAccountant;

  const loadAttendance = async () => {
    if (!user?.uid || !canUseAttendance) {
      setAttendance(null);
      setAttLoading(false);
      return;
    }
    try {
      setAttLoading(true);
      const doc = await getAttendance(user.uid);
      setAttendance(doc);
    } catch (err) {
      console.error('Load attendance error:', err);
    } finally {
      setAttLoading(false);
    }
  };

  // H√†m t·∫£i d·ªØ li·ªáu trang ch·ªß
  const loadHomeData = async () => {
    try {
      setLoading(true);

      // L·∫•y danh s√°ch d·ª± √°n v√† kh√°ch h√†ng
      const projectsData = await getProjects();
      const customersData = await getCustomers();

      // L·∫•y 3 d·ª± √°n m·ªõi nh·∫•t
      setRecentProjects(projectsData.slice(0, 3));

      // L·∫•y 3 kh√°ch h√†ng m·ªõi nh·∫•t
      setRecentCustomers(customersData.slice(0, 3));
    } catch (error) {
      console.error('L·ªói khi t·∫£i d·ªØ li·ªáu trang ch·ªß:', error);
    } finally {
      setLoading(false);
    }
  };

  // T·∫£i d·ªØ li·ªáu khi m√†n h√¨nh ƒë∆∞·ª£c m·ªü
  useEffect(() => {
    loadHomeData();
    loadAttendance();
  }, []);

  // L√†m m·ªõi d·ªØ li·ªáu khi m√†n h√¨nh ƒë∆∞·ª£c focus
  useFocusEffect(
    React.useCallback(() => {
      loadHomeData();
      loadAttendance();
    }, [])
  );

  const handleClockIn = async () => {
    try {
      setAttLoading(true);
      await clockIn(user.uid);
      loadAttendance();
    } catch (err) {
      console.error(err);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ch·∫•m c√¥ng v√†o.');
    }
  };

  const handleClockOut = async () => {
    try {
      setAttLoading(true);
      await clockOut(user.uid);
      loadAttendance();
    } catch (err) {
      console.error(err);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ch·∫•m c√¥ng ra.');
    }
  };

  const handleAddOvertime = async (hours) => {
    try {
      setAttLoading(true);
      await addOvertime(user.uid, hours);
      loadAttendance();
    } catch (err) {
      console.error(err);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ th√™m gi·ªù tƒÉng ca.');
    }
  };

  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng nh·∫•n v√†o d·ª± √°n
  const handleProjectPress = (project) => {
    navigation.navigate('ProjectDetail', { projectId: project.id });
  };

  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng nh·∫•n v√†o kh√°ch h√†ng
  const handleCustomerPress = (customer) => {
    navigation.navigate('CustomerDetail', { customerId: customer.id });
  };

  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng nh·∫•n v√†o n√∫t xem t·∫•t c·∫£ d·ª± √°n
  const handleViewAllProjects = () => {
    navigation.navigate('Projects');
  };

  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng nh·∫•n v√†o n√∫t xem t·∫•t c·∫£ kh√°ch h√†ng
  const handleViewAllCustomers = () => {
    navigation.navigate('Customers');
  };

  // H√†m l·∫•y m√†u tr·∫°ng th√°i d·ª± √°n
  const getStatusColor = (status) => {
    switch (status) {
      case 'completed':
        return theme.statusCompleted;
      case 'in-progress':
        return theme.statusInProgress;
      case 'pending':
        return theme.statusPending;
      case 'cancelled':
        return theme.statusCancelled;
      default:
        return theme.textMuted;
    }
  };

  // H√†m l·∫•y nh√£n tr·∫°ng th√°i d·ª± √°n
  const getStatusLabel = (status) => {
    switch (status) {
      case 'completed':
        return 'Ho√†n th√†nh';
      case 'in-progress':
        return 'ƒêang th·ª±c hi·ªán';
      case 'pending':
        return 'Ch·ªù x·ª≠ l√Ω';
      case 'cancelled':
        return 'ƒê√£ h·ªßy';
      default:
        return status || 'Kh√¥ng x√°c ƒë·ªãnh';
    }
  };

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <StatusBar
        barStyle={isDarkMode ? 'light-content' : 'dark-content'}
        backgroundColor={theme.background}
      />

      {canUseAttendance && (
        <View style={{ paddingHorizontal: 16, marginTop: 8 }}>
          <View
            style={{
              backgroundColor: theme.card,
              borderRadius: 8,
              padding: 16,
              borderWidth: 1,
              borderColor: theme.border,
              marginBottom: 16,
            }}
          >
            <Text
              style={{
                fontSize: 18,
                fontWeight: 'bold',
                color: theme.text,
                marginBottom: 8,
              }}
            >
              Ch·∫•m C√¥ng -{' '}
              {isWorker
                ? 'C√¥ng nh√¢n'
                : isEngineer
                ? 'K·ªπ s∆∞'
                : isAccountant
                ? 'K·∫ø to√°n'
                : 'Nh√¢n vi√™n'}
            </Text>
            {user?.role === 'ke_toan' ? (
              <TouchableOpacity
                style={getAttBtnStyle(theme)}
                onPress={() => navigation.navigate('Attendance')}
              >
                <Ionicons
                  name="eye-outline"
                  size={20}
                  color="#fff"
                  style={{ marginRight: 6 }}
                />
                <Text style={{ color: '#fff', fontWeight: '600' }}>
                  Xem B·∫£ng Ch·∫•m C√¥ng
                </Text>
              </TouchableOpacity>
            ) : user?.role === 'ky_su' ? (
              <>
                {attLoading ? (
                  <ActivityIndicator color={theme.primary} />
                ) : (
                  <>
                    {(() => {
                      const status = getAttendanceStatus(attendance);
                      if (status === 'none') {
                        return (
                          <TouchableOpacity
                            style={getAttBtnStyle(theme)}
                            onPress={handleClockIn}
                          >
                            <Ionicons
                              name="log-in-outline"
                              size={20}
                              color="#fff"
                              style={{ marginRight: 6 }}
                            />
                            <Text style={{ color: '#fff', fontWeight: '600' }}>
                              Ch·∫•m C√¥ng V√†o
                            </Text>
                          </TouchableOpacity>
                        );
                      }
                      if (status === 'clocked_in') {
                        return (
                          <>
                            <Text
                              style={{ color: theme.text, marginBottom: 8 }}
                            >
                              V√†o l√∫c:{' '}
                              {attendance.clockIn.toDate().toLocaleTimeString()}
                            </Text>
                            <TouchableOpacity
                              style={getAttBtnStyle(theme)}
                              onPress={handleClockOut}
                            >
                              <Ionicons
                                name="log-out-outline"
                                size={20}
                                color="#fff"
                                style={{ marginRight: 6 }}
                              />
                              <Text
                                style={{ color: '#fff', fontWeight: '600' }}
                              >
                                Ch·∫•m C√¥ng Ra
                              </Text>
                            </TouchableOpacity>
                          </>
                        );
                      }
                      if (status === 'clocked_out') {
                        return (
                          <>
                            <Text
                              style={{ color: theme.text, marginBottom: 4 }}
                            >
                              V√†o l√∫c:{' '}
                              {attendance.clockIn.toDate().toLocaleTimeString()}
                            </Text>
                            <Text
                              style={{ color: theme.text, marginBottom: 8 }}
                            >
                              Ra l√∫c:{' '}
                              {attendance.clockOut
                                .toDate()
                                .toLocaleTimeString()}
                            </Text>
                            <Text
                              style={{ color: theme.text, marginBottom: 8 }}
                            >
                              TƒÉng ca: {attendance.overtime || 0} gi·ªù
                            </Text>
                            <View style={{ flexDirection: 'row' }}>
                              {[1, 2, 3].map((h) => (
                                <TouchableOpacity
                                  key={h}
                                  style={getOvertimeBtnStyle(theme)}
                                  onPress={() => handleAddOvertime(h)}
                                >
                                  <Text style={{ color: '#fff' }}>+{h}</Text>
                                </TouchableOpacity>
                              ))}
                            </View>
                          </>
                        );
                      }
                      return null;
                    })()}
                  </>
                )}
              </>
            ) : (
              <>
                {attLoading ? (
                  <ActivityIndicator color={theme.primary} />
                ) : (
                  <>
                    {(() => {
                      const status = getAttendanceStatus(attendance);
                      if (status === 'none') {
                        return (
                          <TouchableOpacity
                            style={getAttBtnStyle(theme)}
                            onPress={handleClockIn}
                          >
                            <Ionicons
                              name="log-in-outline"
                              size={20}
                              color="#fff"
                              style={{ marginRight: 6 }}
                            />
                            <Text style={{ color: '#fff', fontWeight: '600' }}>
                              Ch·∫•m C√¥ng V√†o
                            </Text>
                          </TouchableOpacity>
                        );
                      }
                      if (status === 'clocked_in') {
                        return (
                          <>
                            <Text
                              style={{ color: theme.text, marginBottom: 8 }}
                            >
                              V√†o l√∫c:{' '}
                              {attendance.clockIn.toDate().toLocaleTimeString()}
                            </Text>
                            <TouchableOpacity
                              style={getAttBtnStyle(theme)}
                              onPress={handleClockOut}
                            >
                              <Ionicons
                                name="log-out-outline"
                                size={20}
                                color="#fff"
                                style={{ marginRight: 6 }}
                              />
                              <Text
                                style={{ color: '#fff', fontWeight: '600' }}
                              >
                                Ch·∫•m C√¥ng Ra
                              </Text>
                            </TouchableOpacity>
                          </>
                        );
                      }
                      if (status === 'clocked_out') {
                        return (
                          <>
                            <Text
                              style={{ color: theme.text, marginBottom: 4 }}
                            >
                              V√†o l√∫c:{' '}
                              {attendance.clockIn.toDate().toLocaleTimeString()}
                            </Text>
                            <Text
                              style={{ color: theme.text, marginBottom: 8 }}
                            >
                              Ra l√∫c:{' '}
                              {attendance.clockOut
                                .toDate()
                                .toLocaleTimeString()}
                            </Text>
                            <Text
                              style={{ color: theme.text, marginBottom: 8 }}
                            >
                              TƒÉng ca: {attendance.overtime || 0} gi·ªù
                            </Text>
                            <View style={{ flexDirection: 'row' }}>
                              {[1, 2, 3].map((h) => (
                                <TouchableOpacity
                                  key={h}
                                  style={getOvertimeBtnStyle(theme)}
                                  onPress={() => handleAddOvertime(h)}
                                >
                                  <Text style={{ color: '#fff' }}>+{h}</Text>
                                </TouchableOpacity>
                              ))}
                            </View>
                          </>
                        );
                      }
                    })()}
                  </>
                )}
              </>
            )}
          </View>
        </View>
      )}

      {/* Menu ch·ª©c nƒÉng cho c√¥ng nh√¢n, k·ªπ s∆∞, k·∫ø to√°n */}
      {canUseWorkerFeatures && (
        <WorkerFeaturesMenu
          userRole={user?.role}
          onNavigate={(screen) => navigation.navigate(screen)}
        />
      )}

      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
            ƒêang t·∫£i d·ªØ li·ªáu...
          </Text>
        </View>
      ) : (
        <ScrollView
          style={styles.scrollView}
          contentContainerStyle={styles.scrollContent}
        >
          {/* Ph·∫ßn d·ª± √°n g·∫ßn ƒë√¢y */}
          <View style={styles.section}>
            <View style={styles.sectionHeader}>
              <Text style={[styles.sectionTitle, { color: theme.text }]}>
                D·ª± √°n g·∫ßn ƒë√¢y
              </Text>
              <TouchableOpacity onPress={handleViewAllProjects}>
                <Text style={[styles.viewAllText, { color: theme.primary }]}>
                  Xem t·∫•t c·∫£
                </Text>
              </TouchableOpacity>
            </View>

            {recentProjects.length > 0 ? (
              recentProjects.map((project) => (
                <TouchableOpacity
                  key={project.id}
                  style={[
                    styles.card,
                    { backgroundColor: theme.card, borderColor: theme.border },
                  ]}
                  onPress={() => handleProjectPress(project)}
                >
                  <View style={styles.cardContent}>
                    <View style={styles.cardMain}>
                      <Text style={[styles.cardTitle, { color: theme.text }]}>
                        {project.name || 'Ch∆∞a c√≥ t√™n'}
                      </Text>
                      {project.customerName && (
                        <View style={styles.cardRow}>
                          <Ionicons
                            name="business-outline"
                            size={14}
                            color={theme.textSecondary}
                          />
                          <Text
                            style={[
                              styles.cardText,
                              { color: theme.textSecondary },
                            ]}
                          >
                            {project.customerName}
                          </Text>
                        </View>
                      )}
                    </View>
                    <View
                      style={[
                        styles.statusBadge,
                        { backgroundColor: getStatusColor(project.status) },
                      ]}
                    >
                      <Text style={styles.statusText}>
                        {getStatusLabel(project.status)}
                      </Text>
                    </View>
                  </View>
                </TouchableOpacity>
              ))
            ) : (
              <View
                style={[
                  styles.emptyCard,
                  { backgroundColor: theme.card, borderColor: theme.border },
                ]}
              >
                <Ionicons
                  name="briefcase-outline"
                  size={24}
                  color={theme.textMuted}
                />
                <Text style={[styles.emptyText, { color: theme.textMuted }]}>
                  Ch∆∞a c√≥ d·ª± √°n n√†o
                </Text>
              </View>
            )}
          </View>

          {/* Expense Tracking Section for Accountants & Managers */}
          {(user?.role === 'ke_toan' ||
            user?.role === 'giam_doc' ||
            user?.role === 'pho_giam_doc') && (
            <View
              style={[
                styles.section,
                { backgroundColor: theme.cardBackground },
              ]}
            >
              <Text style={[styles.sectionTitle, { color: theme.text }]}>
                Qu·∫£n l√Ω chi ph√≠
              </Text>
              <View style={styles.expenseActionsContainer}>
                <TouchableOpacity
                  style={[
                    styles.expenseActionButton,
                    { backgroundColor: '#FF9800' },
                  ]}
                  onPress={() => navigation.navigate('ExpenseList')}
                >
                  <Ionicons name="list-outline" size={24} color="#fff" />
                  <Text style={styles.expenseActionText}>Chi ph√≠ d·ª± √°n</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[
                    styles.expenseActionButton,
                    { backgroundColor: '#673AB7' },
                  ]}
                  onPress={() => navigation.navigate('AddCompanyExpense')}
                >
                  <Ionicons name="add-circle-outline" size={24} color="#fff" />
                  <Text style={styles.expenseActionText}>
                    Th√™m chi ph√≠ c√¥ng ty
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          )}

          {/* Â∫ìÂ≠òÁÆ°ÁêÜËèúÂçï - Âè™ÂØπÁâπÂÆöËßíËâ≤ÊòæÁ§∫ */}
          {['thuong_mai', 'ky_su', 'ke_toan'].includes(
            (user?.role || '').toLowerCase()
          ) && (
            <View style={styles.section}>
              <View style={styles.sectionHeader}>
                <Text style={[styles.sectionTitle, { color: theme.text }]}>
                  Qu·∫£n l√Ω kho
                </Text>
              </View>
              <View style={styles.menuGrid}>
                <TouchableOpacity
                  style={[
                    styles.menuCard,
                    { backgroundColor: theme.card, borderColor: theme.border },
                  ]}
                  onPress={() =>
                    navigation.navigate('Inventory', {
                      screen: 'InventoryMain',
                    })
                  }
                >
                  <View
                    style={[styles.menuIcon, { backgroundColor: '#4CAF50' }]}
                  >
                    <Ionicons name="cube" size={24} color="#fff" />
                  </View>
                  <Text style={[styles.menuText, { color: theme.text }]}>
                    V·∫≠t t∆∞ t·ªìn kho
                  </Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[
                    styles.menuCard,
                    { backgroundColor: theme.card, borderColor: theme.border },
                  ]}
                  onPress={() =>
                    navigation.navigate('Inventory', {
                      screen: 'InventoryReport',
                    })
                  }
                >
                  <View
                    style={[styles.menuIcon, { backgroundColor: '#FF9800' }]}
                  >
                    <Ionicons name="bar-chart" size={24} color="#fff" />
                  </View>
                  <Text style={[styles.menuText, { color: theme.text }]}>
                    B√°o c√°o kho
                  </Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[
                    styles.menuCard,
                    { backgroundColor: theme.card, borderColor: theme.border },
                  ]}
                  onPress={() =>
                    navigation.navigate('Inventory', {
                      screen: 'InventoryTransaction',
                    })
                  }
                >
                  <View
                    style={[styles.menuIcon, { backgroundColor: '#2196F3' }]}
                  >
                    <Ionicons name="swap-horizontal" size={24} color="#fff" />
                  </View>
                  <Text style={[styles.menuText, { color: theme.text }]}>
                    Giao d·ªãch kho
                  </Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[
                    styles.menuCard,
                    { backgroundColor: theme.card, borderColor: theme.border },
                  ]}
                  onPress={() =>
                    navigation.navigate('Inventory', {
                      screen: 'AddInventoryItem',
                    })
                  }
                >
                  <View
                    style={[styles.menuIcon, { backgroundColor: '#673AB7' }]}
                  >
                    <Ionicons name="add-circle" size={24} color="#fff" />
                  </View>
                  <Text style={[styles.menuText, { color: theme.text }]}>
                    Th√™m v·∫≠t t∆∞
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          )}

          {/* Ph·∫ßn kh√°ch h√†ng g·∫ßn ƒë√¢y */}
          <View style={styles.section}>
            <View style={styles.sectionHeader}>
              <Text style={[styles.sectionTitle, { color: theme.text }]}>
                Kh√°ch h√†ng g·∫ßn ƒë√¢y
              </Text>
              <TouchableOpacity onPress={handleViewAllCustomers}>
                <Text style={[styles.viewAllText, { color: theme.primary }]}>
                  Xem t·∫•t c·∫£
                </Text>
              </TouchableOpacity>
            </View>

            {recentCustomers.length > 0 ? (
              recentCustomers.map((customer) => (
                <TouchableOpacity
                  key={customer.id}
                  style={[
                    styles.card,
                    { backgroundColor: theme.card, borderColor: theme.border },
                  ]}
                  onPress={() => handleCustomerPress(customer)}
                >
                  <View style={styles.cardContent}>
                    <View style={styles.cardMain}>
                      <Text style={[styles.cardTitle, { color: theme.text }]}>
                        {customer.name || 'Ch∆∞a c√≥ t√™n'}
                      </Text>
                      {customer.contactPerson && (
                        <View style={styles.cardRow}>
                          <Ionicons
                            name="person-outline"
                            size={14}
                            color={theme.textSecondary}
                          />
                          <Text
                            style={[
                              styles.cardText,
                              { color: theme.textSecondary },
                            ]}
                          >
                            {customer.contactPerson}
                          </Text>
                        </View>
                      )}
                      {customer.phone && (
                        <View style={styles.cardRow}>
                          <Ionicons
                            name="call-outline"
                            size={14}
                            color={theme.textSecondary}
                          />
                          <Text
                            style={[
                              styles.cardText,
                              { color: theme.textSecondary },
                            ]}
                          >
                            {customer.phone}
                          </Text>
                        </View>
                      )}
                    </View>
                    <Ionicons
                      name="chevron-forward"
                      size={20}
                      color={theme.textMuted}
                    />
                  </View>
                </TouchableOpacity>
              ))
            ) : (
              <View
                style={[
                  styles.emptyCard,
                  { backgroundColor: theme.card, borderColor: theme.border },
                ]}
              >
                <Ionicons
                  name="people-outline"
                  size={24}
                  color={theme.textMuted}
                />
                <Text style={[styles.emptyText, { color: theme.textMuted }]}>
                  Ch∆∞a c√≥ kh√°ch h√†ng n√†o
                </Text>
              </View>
            )}
          </View>

          {/* Th√¥ng tin ·ª©ng d·ª•ng */}
          <View
            style={[styles.infoCard, { backgroundColor: theme.primaryLight }]}
          >
            <Ionicons
              name="information-circle-outline"
              size={24}
              color={theme.primary}
            />
            <Text style={[styles.infoText, { color: theme.text }]}>
              THP App - Phi√™n b·∫£n 1.0.0
            </Text>
          </View>

          {/* N√∫t qu·∫£n l√Ω nh√† cung c·∫•p */}
          <TouchableOpacity
            style={styles.menuItem}
            onPress={() => navigation.navigate('SupplierManagement')}
          >
            <View style={[styles.menuIcon, { backgroundColor: '#4caf50' }]}>
              <Ionicons name="business-outline" size={24} color="#fff" />
            </View>
            <Text style={styles.menuText}>Qu·∫£n l√Ω nh√† cung c·∫•p</Text>
            <Ionicons name="chevron-forward" size={20} color="#999" />
          </TouchableOpacity>

          {/* Qu·∫£n l√Ω v·∫≠t li·ªáu */}
          {console.log(
            'Rendering Material Management button, user role:',
            user?.role
          )}
          <TouchableOpacity
            style={styles.menuItem}
            onPress={() => {
              console.log('Material Management button pressed');
              navigation.navigate('MaterialManagement');
            }}
          >
            <View style={[styles.menuIcon, { backgroundColor: '#FF5722' }]}>
              <Ionicons name="cube-outline" size={24} color="#fff" />
            </View>
            <View style={{ flex: 1 }}>
              <Text style={styles.menuText}>Qu·∫£n l√Ω v·∫≠t li·ªáu</Text>
              <Text
                style={[styles.menuDescription, { color: theme.textMuted }]}
              >
                Qu·∫£n l√Ω danh s√°ch v·∫≠t li·ªáu v√† c·∫≠p nh·∫≠t gi√° c·∫£
              </Text>
            </View>
            <Ionicons name="chevron-forward" size={20} color="#999" />
          </TouchableOpacity>

          {/* Qu·∫£n l√Ω l∆∞∆°ng - Ch·ªâ hi·ªÉn th·ªã cho k·∫ø to√°n */}
          {isAccountant && (
            <>
              <TouchableOpacity
                style={styles.menuItem}
                onPress={() => navigation.navigate('FixedFeesManagement')}
              >
                <View style={[styles.menuIcon, { backgroundColor: '#9C27B0' }]}>
                  <Ionicons name="settings-outline" size={24} color="#fff" />
                </View>
                <View style={{ flex: 1 }}>
                  <Text style={styles.menuText}>Qu·∫£n l√Ω ph√≠ c·ªë ƒë·ªãnh</Text>
                  <Text
                    style={[styles.menuDescription, { color: theme.textMuted }]}
                  >
                    C√†i ƒë·∫∑t BHXH, ph·ª• c·∫•p, kh·∫•u tr·ª´ c·ªë ƒë·ªãnh
                  </Text>
                </View>
                <Ionicons name="chevron-forward" size={20} color="#999" />
              </TouchableOpacity>

              <TouchableOpacity
                style={styles.menuItem}
                onPress={() => navigation.navigate('SalarySlipCreation')}
              >
                <View style={[styles.menuIcon, { backgroundColor: '#4CAF50' }]}>
                  <Ionicons
                    name="document-text-outline"
                    size={24}
                    color="#fff"
                  />
                </View>
                <View style={{ flex: 1 }}>
                  <Text style={styles.menuText}>T·∫°o phi·∫øu l∆∞∆°ng</Text>
                  <Text
                    style={[styles.menuDescription, { color: theme.textMuted }]}
                  >
                    T·∫°o v√† xu·∫•t phi·∫øu l∆∞∆°ng Excel v√†o Google Drive
                  </Text>
                </View>
                <Ionicons name="chevron-forward" size={20} color="#999" />
              </TouchableOpacity>
            </>
          )}

          {/* Test Role - Hi·ªÉn th·ªã role hi·ªán t·∫°i */}
          <TouchableOpacity
            style={styles.menuItem}
            onPress={() =>
              Alert.alert(
                'Role hi·ªán t·∫°i',
                `Role: ${user?.role || 'Kh√¥ng c√≥ role'}`
              )
            }
          >
            <View style={[styles.menuIcon, { backgroundColor: '#9E9E9E' }]}>
              <Ionicons
                name="information-circle-outline"
                size={24}
                color="#fff"
              />
            </View>
            <View style={{ flex: 1 }}>
              <Text style={styles.menuText}>Test Role</Text>
              <Text
                style={[styles.menuDescription, { color: theme.textMuted }]}
              >
                Role hi·ªán t·∫°i: {user?.role || 'Kh√¥ng c√≥ role'}
              </Text>
            </View>
            <Ionicons name="chevron-forward" size={20} color="#999" />
          </TouchableOpacity>

          {/* Test Navigation - Ki·ªÉm tra navigation c√≥ ho·∫°t ƒë·ªông kh√¥ng */}
          <TouchableOpacity
            style={styles.menuItem}
            onPress={() => {
              console.log('Test navigation button pressed');
              Alert.alert('Test', 'Navigation test button works!');
            }}
          >
            <View style={[styles.menuIcon, { backgroundColor: '#FF9800' }]}>
              <Ionicons name="bug-outline" size={24} color="#fff" />
            </View>
            <View style={{ flex: 1 }}>
              <Text style={styles.menuText}>Test Navigation</Text>
              <Text
                style={[styles.menuDescription, { color: theme.textMuted }]}
              >
                Ki·ªÉm tra navigation c√≥ ho·∫°t ƒë·ªông kh√¥ng
              </Text>
            </View>
            <Ionicons name="chevron-forward" size={20} color="#999" />
          </TouchableOpacity>

          {/* Kiosk X∆∞·ªüng S·∫£n Xu·∫•t */}
          <TouchableOpacity
            style={styles.menuItem}
            onPress={() => navigation.navigate('Kiosk')}
          >
            <View style={[styles.menuIcon, { backgroundColor: '#FF9800' }]}>
              <Ionicons name="desktop-outline" size={24} color="#fff" />
            </View>
            <View style={{ flex: 1 }}>
              <Text style={styles.menuText}>Kiosk X∆∞·ªüng S·∫£n Xu·∫•t</Text>
              <Text
                style={[styles.menuDescription, { color: theme.textMuted }]}
              >
                Theo d√µi c√¥ng vi·ªác v√† b·∫•m gi·ªù th·ªùi gian th·ª±c
              </Text>
            </View>
            <Ionicons name="chevron-forward" size={20} color="#999" />
          </TouchableOpacity>

          {/* Starboard - B·∫£ng Ti·∫øn ƒê·ªô D·ª± √Ån */}
          <TouchableOpacity
            style={styles.menuItem}
            onPress={() => navigation.navigate('Starboard')}
          >
            <View style={[styles.menuIcon, { backgroundColor: '#4CAF50' }]}>
              <Ionicons name="grid-outline" size={24} color="#fff" />
            </View>
            <View style={{ flex: 1 }}>
              <Text style={styles.menuText}>B·∫£ng Ti·∫øn ƒê·ªô D·ª± √Ån</Text>
              <Text
                style={[styles.menuDescription, { color: theme.textMuted }]}
              >
                Gi√°m s√°t ti·∫øn ƒë·ªô c√°c d·ª± √°n ƒëang th·ª±c hi·ªán
              </Text>
            </View>
            <Ionicons name="chevron-forward" size={20} color="#999" />
          </TouchableOpacity>

          {/* Giao vi·ªác & H∆∞·ªõng d·∫´n */}
          <TouchableOpacity
            style={styles.menuItem}
            onPress={() => navigation.navigate('WorkAllocation')}
          >
            <View style={[styles.menuIcon, { backgroundColor: '#9C27B0' }]}>
              <Ionicons name="clipboard-outline" size={24} color="#fff" />
            </View>
            <View style={{ flex: 1 }}>
              <Text style={styles.menuText}>Giao vi·ªác & H∆∞·ªõng d·∫´n</Text>
              <Text
                style={[styles.menuDescription, { color: theme.textMuted }]}
              >
                Ph√¢n c√¥ng c√¥ng vi·ªác v√† t·∫°o h∆∞·ªõng d·∫´n chi ti·∫øt
              </Text>
            </View>
            <Ionicons name="chevron-forward" size={20} color="#999" />
          </TouchableOpacity>

          {/* Production Dashboard for Management */}
          {(user?.role === 'giam_doc' ||
            user?.role === 'pho_giam_doc' ||
            user?.role === 'ky_su') && (
            <TouchableOpacity
              style={styles.menuItem}
              onPress={() => navigation.navigate('ProductionDashboard')}
            >
              <View style={[styles.menuIcon, { backgroundColor: '#2196F3' }]}>
                <Ionicons name="analytics-outline" size={24} color="#fff" />
              </View>
              <View style={{ flex: 1 }}>
                <Text style={styles.menuText}>Dashboard S·∫£n Xu·∫•t</Text>
                <Text
                  style={[styles.menuDescription, { color: theme.textMuted }]}
                >
                  Gi√°m s√°t v√† qu·∫£n l√Ω s·∫£n xu·∫•t th·ªùi gian th·ª±c
                </Text>
              </View>
              <Ionicons name="chevron-forward" size={20} color="#999" />
            </TouchableOpacity>
          )}

          {/* Qu·∫£n l√Ω m√°y m√≥c - hi·ªÉn th·ªã cho Gi√°m ƒë·ªëc, K·ªπ s∆∞, Ph√≥ gi√°m ƒë·ªëc */}
          {(user?.role === 'giam_doc' ||
            user?.role === 'pho_giam_doc' ||
            user?.role === 'ky_su') && (
            <TouchableOpacity
              style={styles.menuItem}
              onPress={() => navigation.navigate('MachinesManagement')}
            >
              <View style={[styles.menuIcon, { backgroundColor: '#00695C' }]}>
                <Ionicons name="construct-outline" size={24} color="#fff" />
              </View>
              <View style={{ flex: 1 }}>
                <Text style={styles.menuText}>Qu·∫£n l√Ω m√°y m√≥c</Text>
                <Text
                  style={[styles.menuDescription, { color: theme.textMuted }]}
                >
                  Danh s√°ch m√°y, tr·∫°ng th√°i, b·∫£o tr√¨
                </Text>
              </View>
              <Ionicons name="chevron-forward" size={20} color="#999" />
            </TouchableOpacity>
          )}

          {/* Trong ph·∫ßn menu items, th√™m m·ª•c qu·∫£n l√Ω kho */}
          <TouchableOpacity
            style={styles.menuItem}
            onPress={() => navigation.navigate('Inventory')}
          >
            <View style={[styles.menuIcon, { backgroundColor: '#4CAF50' }]}>
              <Ionicons name="package-variant" size={24} color="#fff" />
            </View>
            <View style={{ flex: 1 }}>
              <Text style={styles.menuText}>Qu·∫£n l√Ω kho</Text>
              <Text
                style={[styles.menuDescription, { color: theme.textMuted }]}
              >
                Qu·∫£n l√Ω v·∫≠t t∆∞, nh·∫≠p xu·∫•t kho
              </Text>
            </View>
            <Ionicons name="chevron-forward" size={20} color="#999" />
          </TouchableOpacity>
        </ScrollView>
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    padding: 16,
    paddingBottom: 32,
  },
  section: {
    marginBottom: 24,
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  viewAllText: {
    fontSize: 14,
    fontWeight: '500',
  },
  card: {
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  cardContent: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  cardMain: {
    flex: 1,
  },
  cardTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  cardRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 4,
  },
  cardText: {
    fontSize: 14,
    marginLeft: 6,
  },
  statusBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  statusText: {
    fontSize: 12,
    fontWeight: '500',
    color: 'white',
  },
  emptyCard: {
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    alignItems: 'center',
    justifyContent: 'center',
    height: 100,
  },
  emptyText: {
    fontSize: 14,
    marginTop: 8,
  },
  infoCard: {
    borderRadius: 8,
    padding: 16,
    marginTop: 12,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  infoText: {
    fontSize: 14,
    marginLeft: 8,
    fontWeight: '500',
  },
  // Note: dynamic button styles are generated via helper functions below
  menuItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 8,
    marginBottom: 12,
    backgroundColor: '#f5f5f5',
  },
  menuIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  menuText: {
    flex: 1,
    marginLeft: 12,
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
  },
  menuDescription: {
    fontSize: 12,
    marginTop: 4,
  },
  menuGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  menuCard: {
    width: '48%',
    padding: 16,
    borderRadius: 10,
    borderWidth: 1,
    marginBottom: 12,
    alignItems: 'center',
  },
  expenseActionsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    marginTop: 12,
  },
  expenseActionButton: {
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 16,
    borderRadius: 8,
    minWidth: '48%',
  },
  expenseActionText: {
    color: '#fff',
    marginTop: 8,
    fontWeight: 'bold',
    textAlign: 'center',
  },
});

// Dynamic styles generators
const getAttBtnStyle = (theme) => ({
  backgroundColor: theme.primary,
  borderRadius: 8,
  paddingVertical: 12,
  paddingHorizontal: 20,
  flexDirection: 'row',
  alignItems: 'center',
  justifyContent: 'center',
  marginTop: 10,
});

const getOvertimeBtnStyle = (theme) => ({
  backgroundColor: theme.primary,
  borderRadius: 20,
  paddingVertical: 8,
  paddingHorizontal: 15,
  marginHorizontal: 5,
});

export default HomeScreen;


--- END: src\screens\HomeScreen.js ---


--- START: src\screens\IconSettingsScreen.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  Alert,
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import StageIconManager from '../components/StageIconManager';
import {
  STAGE_ICONS,
  getStageIcon,
  createCustomIconMapping,
} from '../utils/stageIcons';
import { Image } from 'react-native';

const IconSettingsScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const [customIcons, setCustomIcons] = useState({});
  const [showIconManager, setShowIconManager] = useState(false);
  const [selectedProcessKey, setSelectedProcessKey] = useState(null);

  // Load custom icons from storage
  useEffect(() => {
    loadCustomIcons();
  }, []);

  const loadCustomIcons = async () => {
    try {
      const saved = await AsyncStorage.getItem('customStageIcons');
      if (saved) {
        setCustomIcons(JSON.parse(saved));
      }
    } catch (error) {
      console.error('Error loading custom icons:', error);
    }
  };

  const saveCustomIcons = async (newCustomIcons) => {
    try {
      await AsyncStorage.setItem(
        'customStageIcons',
        JSON.stringify(newCustomIcons)
      );
      setCustomIcons(newCustomIcons);
    } catch (error) {
      console.error('Error saving custom icons:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ l∆∞u c√†i ƒë·∫∑t icon');
    }
  };

  const handleIconSelect = (processKey, iconData, isCustom = false) => {
    let newCustomIcons;

    if (isCustom) {
      // For custom icons, store the full icon object
      newCustomIcons = {
        ...customIcons,
        [processKey]: {
          type: 'custom',
          data: iconData,
        },
      };
    } else {
      // For regular icons, store just the icon name
      newCustomIcons = {
        ...customIcons,
        [processKey]: {
          type: 'ionicon',
          data: iconData,
        },
      };
    }

    saveCustomIcons(newCustomIcons);
    Alert.alert('Th√†nh c√¥ng', `ƒê√£ c·∫≠p nh·∫≠t icon cho ${processKey}`);
  };

  const handleResetIcon = (processKey) => {
    Alert.alert(
      'X√°c nh·∫≠n',
      `B·∫°n c√≥ mu·ªën kh√¥i ph·ª•c icon m·∫∑c ƒë·ªãnh cho ${processKey}?`,
      [
        { text: 'H·ªßy', style: 'cancel' },
        {
          text: 'Kh√¥i ph·ª•c',
          onPress: () => {
            const newCustomIcons = { ...customIcons };
            delete newCustomIcons[processKey];
            saveCustomIcons(newCustomIcons);
          },
        },
      ]
    );
  };

  const handleResetAll = () => {
    Alert.alert('X√°c nh·∫≠n', 'B·∫°n c√≥ mu·ªën kh√¥i ph·ª•c t·∫•t c·∫£ icon v·ªÅ m·∫∑c ƒë·ªãnh?', [
      { text: 'H·ªßy', style: 'cancel' },
      {
        text: 'Kh√¥i ph·ª•c t·∫•t c·∫£',
        style: 'destructive',
        onPress: () => saveCustomIcons({}),
      },
    ]);
  };

  const getCurrentIcon = (processKey) => {
    const customIcon = customIcons[processKey];
    if (customIcon) {
      return customIcon;
    }
    return {
      type: 'ionicon',
      data: STAGE_ICONS[processKey] || STAGE_ICONS.default,
    };
  };

  const renderStageItem = ({ item }) => {
    const [processKey, defaultIcon] = item;
    const currentIcon = getCurrentIcon(processKey);
    const isCustomized = customIcons[processKey] !== undefined;

    return (
      <View style={styles.stageItem}>
        <View style={styles.stageInfo}>
          <View style={styles.iconContainer}>
            {currentIcon.type === 'custom' ? (
              <Image
                source={{ uri: currentIcon.data.uri }}
                style={styles.customIconImage}
              />
            ) : (
              <Ionicons name={currentIcon.data} size={24} color="#007AFF" />
            )}
            {isCustomized && (
              <View style={styles.customBadge}>
                <Ionicons name="star" size={8} color="#FFD700" />
              </View>
            )}
          </View>
          <View style={styles.textContainer}>
            <Text style={styles.processName}>{processKey}</Text>
            <Text style={styles.iconName}>
              {currentIcon.type === 'custom'
                ? currentIcon.data.name
                : currentIcon.data}
            </Text>
          </View>
        </View>

        <View style={styles.actions}>
          <TouchableOpacity
            style={styles.editButton}
            onPress={() => {
              setSelectedProcessKey(processKey);
              setShowIconManager(true);
            }}
          >
            <Ionicons name="create" size={20} color="#007AFF" />
          </TouchableOpacity>

          {isCustomized && (
            <TouchableOpacity
              style={styles.resetButton}
              onPress={() => handleResetIcon(processKey)}
            >
              <Ionicons name="refresh" size={20} color="#FF6B6B" />
            </TouchableOpacity>
          )}
        </View>
      </View>
    );
  };

  const stageEntries = Object.entries(STAGE_ICONS).filter(
    ([key]) => key !== 'default'
  );

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back" size={24} color="#007AFF" />
        </TouchableOpacity>
        <Text style={styles.title}>C√†i ƒë·∫∑t Icon Stage</Text>
        <TouchableOpacity onPress={handleResetAll}>
          <Text style={styles.resetAllText}>Reset All</Text>
        </TouchableOpacity>
      </View>

      <View style={styles.infoContainer}>
        <Text style={styles.infoText}>
          T√πy ch·ªânh icon cho c√°c lo·∫°i c√¥ng ƒëo·∫°n s·∫£n xu·∫•t. Icon c√≥ d·∫•u ‚≠ê ƒë√£ ƒë∆∞·ª£c
          t√πy ch·ªânh.
        </Text>
      </View>

      <FlatList
        data={stageEntries}
        renderItem={renderStageItem}
        keyExtractor={([key]) => key}
        contentContainerStyle={styles.list}
      />

      <StageIconManager
        visible={showIconManager}
        onClose={() => setShowIconManager(false)}
        onIconSelect={handleIconSelect}
        currentProcessKey={selectedProcessKey}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  resetAllText: {
    color: '#FF6B6B',
    fontSize: 14,
  },
  infoContainer: {
    padding: 16,
    backgroundColor: '#f8f9fa',
  },
  infoText: {
    fontSize: 14,
    color: '#666',
    lineHeight: 20,
  },
  list: {
    padding: 16,
  },
  stageItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    marginBottom: 8,
    backgroundColor: '#f8f8f8',
    borderRadius: 8,
  },
  stageInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  iconContainer: {
    position: 'relative',
    marginRight: 12,
  },
  customBadge: {
    position: 'absolute',
    top: -4,
    right: -4,
    width: 12,
    height: 12,
    borderRadius: 6,
    backgroundColor: '#FFD700',
    justifyContent: 'center',
    alignItems: 'center',
  },
  textContainer: {
    flex: 1,
  },
  processName: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 2,
  },
  iconName: {
    fontSize: 12,
    color: '#666',
  },
  actions: {
    flexDirection: 'row',
  },
  editButton: {
    padding: 8,
    marginLeft: 8,
  },
  resetButton: {
    padding: 8,
    marginLeft: 8,
  },
  customIconImage: {
    width: 24,
    height: 24,
    resizeMode: 'contain',
    borderRadius: 4,
  },
});

export default IconSettingsScreen;


--- END: src\screens\IconSettingsScreen.js ---


--- START: src\screens\InventoryItemDetailScreen.js ---
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, ScrollView, Image, Alert } from 'react-native';
import {
  Text,
  Card,
  Button,
  List,
  Divider,
  FAB,
  ActivityIndicator,
  Dialog,
  Portal,
  TextInput,
  HelperText,
} from 'react-native-paper';
import { useNavigation, useRoute } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import useInventory from '../hooks/useInventory';
import { firebase } from '../config/firebaseConfig';
import StatusIndicator from '../components/StatusIndicator';

const InventoryItemDetailScreen = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { itemId } = route.params || {};

  const { getInventoryItemDetail } = useInventory();

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [itemDetail, setItemDetail] = useState(null);
  const [transactionDialogVisible, setTransactionDialogVisible] =
    useState(false);
  const [transactionType, setTransactionType] = useState('IN');
  const [transactionData, setTransactionData] = useState({
    quantity: '1',
    note: '',
  });
  const [transactionErrors, setTransactionErrors] = useState({});
  const [processingTransaction, setProcessingTransaction] = useState(false);

  useEffect(() => {
    if (itemId) {
      fetchItemDetail();
    } else {
      setError('Kh√¥ng t√¨m th·∫•y ID v·∫≠t t∆∞');
      setLoading(false);
    }
  }, [itemId]);

  const fetchItemDetail = async () => {
    try {
      setLoading(true);
      const detail = await getInventoryItemDetail(itemId);
      setItemDetail(detail);
    } catch (error) {
      console.error('L·ªói khi l·∫•y th√¥ng tin v·∫≠t t∆∞:', error);
      setError('Kh√¥ng th·ªÉ l·∫•y th√¥ng tin v·∫≠t t∆∞');
    } finally {
      setLoading(false);
    }
  };

  const getStockStatus = () => {
    if (!itemDetail || !itemDetail.minQuantity) return 'normal';

    if (itemDetail.stockQuantity <= 0) {
      return 'critical';
    } else if (itemDetail.stockQuantity <= itemDetail.minQuantity) {
      return 'warning';
    } else {
      return 'normal';
    }
  };

  const renderStockStatus = () => {
    if (!itemDetail) return null;

    const status = getStockStatus();
    let statusText = 'B√¨nh th∆∞·ªùng';

    if (status === 'critical') {
      statusText = 'H·∫øt h√†ng';
    } else if (status === 'warning') {
      statusText = 'D∆∞·ªõi m·ª©c t·ªëi thi·ªÉu';
    }

    return <StatusIndicator status={status} text={statusText} />;
  };

  const openTransactionDialog = (type) => {
    setTransactionType(type);
    setTransactionData({
      quantity: '1',
      note: type === 'IN' ? 'Nh·∫≠p kho' : 'Xu·∫•t kho',
    });
    setTransactionErrors({});
    setTransactionDialogVisible(true);
  };

  const handleTransactionChange = (field, value) => {
    setTransactionData({
      ...transactionData,
      [field]: value,
    });

    if (transactionErrors[field]) {
      setTransactionErrors({
        ...transactionErrors,
        [field]: null,
      });
    }
  };

  const validateTransactionForm = () => {
    const newErrors = {};
    const quantity = parseFloat(transactionData.quantity);

    if (isNaN(quantity) || quantity <= 0) {
      newErrors.quantity = 'S·ªë l∆∞·ª£ng ph·∫£i l·ªõn h∆°n 0';
    }

    if (transactionType === 'OUT' && quantity > itemDetail.stockQuantity) {
      newErrors.quantity = 'S·ªë l∆∞·ª£ng xu·∫•t v∆∞·ª£t qu√° t·ªìn kho';
    }

    if (!transactionData.note.trim()) {
      newErrors.note = 'Vui l√≤ng nh·∫≠p ghi ch√∫';
    }

    setTransactionErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleTransaction = async () => {
    if (!validateTransactionForm()) return;

    setProcessingTransaction(true);

    try {
      const db = firebase.firestore();
      const user = firebase.auth().currentUser;

      if (!user) {
        throw new Error('B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ th·ª±c hi·ªán giao d·ªãch');
      }

      const quantity = parseFloat(transactionData.quantity);
      const transaction = {
        type: transactionType,
        itemId,
        quantity,
        date: firebase.firestore.Timestamp.now(),
        note: transactionData.note,
        userId: user.uid,
        status: 'COMPLETED',
      };

      let newQuantity = itemDetail.stockQuantity;
      if (transactionType === 'IN') {
        newQuantity += quantity;
      } else if (transactionType === 'OUT') {
        newQuantity -= quantity;
      }

      await db.runTransaction(async (transaction) => {
        const transactionRef = db.collection('inventory_transactions').doc();
        transaction.set(transactionRef, transaction);

        const itemRef = db.collection('inventory').doc(itemId);
        transaction.update(itemRef, {
          stockQuantity: newQuantity,
          lastUpdated: firebase.firestore.Timestamp.now(),
        });
      });

      setTransactionDialogVisible(false);
      Alert.alert(
        'Th√†nh c√¥ng',
        `ƒê√£ ${transactionType === 'IN' ? 'nh·∫≠p' : 'xu·∫•t'} ${quantity} ${
          itemDetail.unit
        }`,
        [{ text: 'OK' }]
      );

      await fetchItemDetail();
    } catch (error) {
      console.error('L·ªói khi th·ª±c hi·ªán giao d·ªãch:', error);
      Alert.alert('L·ªói', error.message || 'Kh√¥ng th·ªÉ th·ª±c hi·ªán giao d·ªãch');
    } finally {
      setProcessingTransaction(false);
    }
  };

  const handleEdit = () => {
    navigation.navigate('EditInventoryItem', { itemId, item: itemDetail });
  };

  const handleAddToQuotation = () => {
    navigation.navigate('QuotationScreen', {
      screen: 'CreateQuotation',
      params: { selectedItem: itemDetail },
    });
  };

  const formatTimestamp = (timestamp) => {
    if (!timestamp) return '';

    const date = timestamp.toDate();
    return date.toLocaleDateString('vi-VN', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" />
        <Text style={{ marginTop: 16 }}>ƒêang t·∫£i th√¥ng tin v·∫≠t t∆∞...</Text>
      </View>
    );
  }

  if (error || !itemDetail) {
    return (
      <View style={styles.errorContainer}>
        <Ionicons name="alert-circle-outline" size={48} color="#f44336" />
        <Text style={styles.errorText}>
          {error || 'Kh√¥ng t√¨m th·∫•y th√¥ng tin v·∫≠t t∆∞'}
        </Text>
        <Button
          mode="contained"
          onPress={() => navigation.goBack()}
          style={{ marginTop: 16 }}
        >
          Quay l·∫°i
        </Button>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {/* ƒê√É B·ªé Appbar.Header ƒë·ªÉ tr√°nh tr√πng header v·ªõi navigator */}

      <ScrollView style={styles.scrollView}>
        <Card style={styles.card}>
          <Card.Content>
            {itemDetail.imageUrl ? (
              <Image
                source={{ uri: itemDetail.imageUrl }}
                style={styles.itemImage}
                resizeMode="contain"
              />
            ) : null}

            <View style={styles.header}>
              <View>
                <Text style={styles.itemName}>{itemDetail.name}</Text>
                <Text style={styles.itemCode}>M√£: {itemDetail.code}</Text>
              </View>
              {renderStockStatus()}
            </View>

            <Divider style={styles.divider} />

            <View style={styles.detailGrid}>
              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>T·ªìn kho:</Text>
                <Text style={styles.detailValue}>
                  {itemDetail.stockQuantity} {itemDetail.unit}
                </Text>
              </View>

              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>T·ªìn t·ªëi thi·ªÉu:</Text>
                <Text style={styles.detailValue}>
                  {itemDetail.minQuantity || 0} {itemDetail.unit}
                </Text>
              </View>

              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Danh m·ª•c:</Text>
                <Text style={styles.detailValue}>
                  {itemDetail.category?.name || 'Kh√¥ng c√≥'}
                </Text>
              </View>

              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>ƒê∆°n v·ªã t√≠nh:</Text>
                <Text style={styles.detailValue}>{itemDetail.unit}</Text>
              </View>

              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>V·∫≠t li·ªáu:</Text>
                <Text style={styles.detailValue}>
                  {itemDetail.material || 'Kh√¥ng c√≥'}
                </Text>
              </View>

              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>Kh·ªëi l∆∞·ª£ng:</Text>
                <Text style={styles.detailValue}>
                  {itemDetail.weight ? `${itemDetail.weight} kg` : 'Kh√¥ng c√≥'}
                </Text>
              </View>

              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>ƒê∆°n gi√°:</Text>
                <Text style={styles.detailValue}>
                  {itemDetail.price
                    ? itemDetail.price.toLocaleString('vi-VN') + ' ƒë'
                    : 'Kh√¥ng c√≥'}
                </Text>
              </View>

              <View style={styles.detailRow}>
                <Text style={styles.detailLabel}>C·∫≠p nh·∫≠t:</Text>
                <Text style={styles.detailValue}>
                  {formatTimestamp(itemDetail.lastUpdated)}
                </Text>
              </View>
            </View>

            {itemDetail.description ? (
              <>
                <Divider style={styles.divider} />
                <Text style={styles.sectionTitle}>M√¥ t·∫£</Text>
                <Text style={styles.description}>{itemDetail.description}</Text>
              </>
            ) : null}
          </Card.Content>
        </Card>

        <View style={styles.actionButtons}>
          <Button
            mode="contained"
            icon="arrow-down-bold"
            style={styles.inButton}
            onPress={() => openTransactionDialog('IN')}
          >
            Nh·∫≠p kho
          </Button>
          <Button
            mode="contained"
            icon="arrow-up-bold"
            style={styles.outButton}
            onPress={() => openTransactionDialog('OUT')}
            disabled={itemDetail.stockQuantity <= 0}
          >
            Xu·∫•t kho
          </Button>
        </View>

        <Card style={styles.card}>
          <Card.Title title="L·ªãch s·ª≠ giao d·ªãch" />
          <Card.Content>
            {itemDetail.transactions && itemDetail.transactions.length > 0 ? (
              itemDetail.transactions.slice(0, 5).map((transaction, index) => (
                <React.Fragment key={transaction.id || index}>
                  <List.Item
                    title={transaction.type === 'IN' ? 'Nh·∫≠p kho' : 'Xu·∫•t kho'}
                    description={`${transaction.note || ''}\n${formatTimestamp(
                      transaction.date
                    )}`}
                    left={() => (
                      <List.Icon
                        icon={
                          transaction.type === 'IN'
                            ? 'arrow-down-bold'
                            : 'arrow-up-bold'
                        }
                        color={
                          transaction.type === 'IN' ? '#4CAF50' : '#F44336'
                        }
                      />
                    )}
                    right={() => (
                      <View style={{ alignItems: 'flex-end' }}>
                        <Text style={{ fontWeight: 'bold' }}>
                          {transaction.type === 'IN' ? '+' : '-'}
                          {transaction.quantity} {itemDetail.unit}
                        </Text>
                      </View>
                    )}
                  />
                  {index < itemDetail.transactions.length - 1 && <Divider />}
                </React.Fragment>
              ))
            ) : (
              <Text style={{ textAlign: 'center', padding: 16, color: '#666' }}>
                Ch∆∞a c√≥ giao d·ªãch n√†o
              </Text>
            )}

            {itemDetail.transactions && itemDetail.transactions.length > 5 && (
              <Button
                mode="text"
                onPress={() =>
                  navigation.navigate('InventoryTransaction', { itemId })
                }
              >
                Xem t·∫•t c·∫£ giao d·ªãch
              </Button>
            )}
          </Card.Content>
        </Card>
      </ScrollView>

      <Portal>
        <Dialog
          visible={transactionDialogVisible}
          onDismiss={() =>
            !processingTransaction && setTransactionDialogVisible(false)
          }
        >
          <Dialog.Title>
            {transactionType === 'IN' ? 'Nh·∫≠p kho' : 'Xu·∫•t kho'}
          </Dialog.Title>

          <Dialog.Content>
            <TextInput
              label="S·ªë l∆∞·ª£ng"
              value={transactionData.quantity}
              onChangeText={(text) => handleTransactionChange('quantity', text)}
              keyboardType="numeric"
              error={!!transactionErrors.quantity}
              style={styles.dialogInput}
              right={<TextInput.Affix text={itemDetail.unit} />}
              disabled={processingTransaction}
            />
            {transactionErrors.quantity && (
              <HelperText type="error">{transactionErrors.quantity}</HelperText>
            )}

            <TextInput
              label="Ghi ch√∫"
              value={transactionData.note}
              onChangeText={(text) => handleTransactionChange('note', text)}
              error={!!transactionErrors.note}
              style={styles.dialogInput}
              disabled={processingTransaction}
            />
            {transactionErrors.note && (
              <HelperText type="error">{transactionErrors.note}</HelperText>
            )}

            <Text style={styles.stockInfo}>
              T·ªìn kho hi·ªán t·∫°i: {itemDetail.stockQuantity} {itemDetail.unit}
            </Text>
          </Dialog.Content>

          <Dialog.Actions>
            <Button
              onPress={() => setTransactionDialogVisible(false)}
              disabled={processingTransaction}
            >
              H·ªßy
            </Button>
            <Button
              mode="contained"
              onPress={handleTransaction}
              loading={processingTransaction}
              disabled={processingTransaction}
            >
              X√°c nh·∫≠n
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      <FAB
        style={styles.fab}
        icon="file-document-edit"
        label="Th√™m v√†o b√°o gi√°"
        onPress={handleAddToQuotation}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollView: {
    flex: 1,
    padding: 16,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  errorText: {
    marginTop: 8,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  card: {
    marginBottom: 16,
    elevation: 2,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
  },
  itemImage: {
    width: '100%',
    height: 200,
    marginBottom: 16,
    borderRadius: 4,
  },
  itemName: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  itemCode: {
    fontSize: 14,
    color: '#666',
    marginBottom: 8,
  },
  divider: {
    marginVertical: 12,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  description: {
    color: '#333',
  },
  detailGrid: {
    marginTop: 8,
  },
  detailRow: {
    flexDirection: 'row',
    paddingVertical: 6,
  },
  detailLabel: {
    width: 100,
    color: '#666',
  },
  detailValue: {
    flex: 1,
    fontWeight: '500',
  },
  actionButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  inButton: {
    flex: 1,
    marginRight: 8,
    backgroundColor: '#4CAF50',
  },
  outButton: {
    flex: 1,
    marginLeft: 8,
    backgroundColor: '#F44336',
  },
  dialogInput: {
    marginBottom: 12,
  },
  stockInfo: {
    marginTop: 8,
    color: '#666',
    fontStyle: 'italic',
  },
  fab: {
    position: 'absolute',
    margin: 16,
    right: 0,
    bottom: 0,
    backgroundColor: '#3f51b5',
  },
});

export default InventoryItemDetailScreen;


--- END: src\screens\InventoryItemDetailScreen.js ---


--- START: src\screens\InventoryReportScreen.js ---
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  FlatList,
} from 'react-native';
import {
  Appbar,
  Text,
  Card,
  Title,
  Paragraph,
  DataTable,
  ProgressBar,
  Divider,
  ActivityIndicator,
  Chip,
  Button,
  SegmentedButtons,
} from 'react-native-paper';
import { useNavigation, useFocusEffect } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import useInventory from '../hooks/useInventory';
import { firebase } from '../config/firebaseConfig';
import StatusIndicator from '../components/StatusIndicator';

const InventoryReportScreen = () => {
  const navigation = useNavigation();

  const {
    fetchInventoryItems,
    inventoryItems,
    categories,
    fetchCategories,
    loading,
  } = useInventory();

  const [reportType, setReportType] = useState('lowStock');
  const [categoryFilter, setCategoryFilter] = useState(null);
  const [topItems, setTopItems] = useState([]);
  const [summaryData, setSummaryData] = useState({
    totalItems: 0,
    totalValue: 0,
    lowStockItems: 0,
    outOfStockItems: 0,
    normalItems: 0,
  });

  // C·∫≠p nh·∫≠t d·ªØ li·ªáu khi m√†n h√¨nh ƒë∆∞·ª£c focus
  useFocusEffect(
    useCallback(() => {
      loadData();
    }, [])
  );

  // Load d·ªØ li·ªáu b√°o c√°o
  const loadData = async () => {
    try {
      // L·∫•y d·ªØ li·ªáu v·∫≠t t∆∞ v√† danh m·ª•c
      await Promise.all([fetchInventoryItems(), fetchCategories()]);

      // T√≠nh to√°n c√°c s·ªë li·ªáu t·ªïng h·ª£p
      calculateSummary();

      // T√≠nh top v·∫≠t t∆∞ c√≥ gi√° tr·ªã cao
      calculateTopItems();
    } catch (error) {
      console.error('L·ªói khi t·∫£i d·ªØ li·ªáu b√°o c√°o:', error);
    }
  };

  // T√≠nh to√°n s·ªë li·ªáu t·ªïng h·ª£p
  const calculateSummary = () => {
    const total = inventoryItems.length;
    let totalValue = 0;
    let lowStock = 0;
    let outOfStock = 0;

    inventoryItems.forEach((item) => {
      // T√≠nh t·ªïng gi√° tr·ªã
      totalValue += (item.price || 0) * (item.stockQuantity || 0);

      // ƒê·∫øm s·ªë v·∫≠t t∆∞ t·ªìn th·∫•p
      if (
        item.stockQuantity <= (item.minQuantity || 0) &&
        item.minQuantity > 0
      ) {
        lowStock++;
      }

      // ƒê·∫øm s·ªë v·∫≠t t∆∞ h·∫øt h√†ng
      if (item.stockQuantity <= 0) {
        outOfStock++;
      }
    });

    setSummaryData({
      totalItems: total,
      totalValue,
      lowStockItems: lowStock,
      outOfStockItems: outOfStock,
      normalItems: total - lowStock,
    });
  };

  // T√≠nh to√°n top v·∫≠t t∆∞ c√≥ gi√° tr·ªã cao
  const calculateTopItems = () => {
    // Sao ch√©p m·∫£ng ƒë·ªÉ kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn d·ªØ li·ªáu g·ªëc
    const items = [...inventoryItems];

    // S·∫Øp x·∫øp theo gi√° tr·ªã t·ªìn kho (s·ªë l∆∞·ª£ng * ƒë∆°n gi√°)
    items.sort((a, b) => {
      const valueA = (a.stockQuantity || 0) * (a.price || 0);
      const valueB = (b.stockQuantity || 0) * (b.price || 0);
      return valueB - valueA;
    });

    // L·∫•y 10 v·∫≠t t∆∞ ƒë·∫ßu ti√™n
    setTopItems(items.slice(0, 10));
  };

  // L·ªçc v·∫≠t t∆∞ theo lo·∫°i b√°o c√°o v√† danh m·ª•c
  const getFilteredItems = () => {
    let filteredItems = [...inventoryItems];

    // L·ªçc theo danh m·ª•c n·∫øu c√≥
    if (categoryFilter) {
      filteredItems = filteredItems.filter(
        (item) => item.categoryId === categoryFilter
      );
    }

    // L·ªçc theo lo·∫°i b√°o c√°o
    switch (reportType) {
      case 'lowStock':
        return filteredItems.filter(
          (item) =>
            item.stockQuantity <= (item.minQuantity || 0) &&
            item.minQuantity > 0
        );
      case 'outOfStock':
        return filteredItems.filter((item) => item.stockQuantity <= 0);
      case 'allItems':
      default:
        return filteredItems;
    }
  };

  // L·∫•y t√™n danh m·ª•c t·ª´ ID
  const getCategoryName = (categoryId) => {
    const category = categories.find((cat) => cat.id === categoryId);
    return category ? category.name : 'Kh√¥ng c√≥';
  };

  // Format s·ªë ti·ªÅn VNƒê
  const formatCurrency = (value) => {
    return value.toLocaleString('vi-VN') + ' ƒë';
  };

  // Render bi·ªÉu ƒë·ªì ph√¢n t√≠ch
  const renderAnalyticsChart = () => {
    const { totalItems, lowStockItems, outOfStockItems, normalItems } =
      summaryData;

    if (totalItems === 0) return null;

    const normalPercent = (normalItems / totalItems) * 100;
    const lowPercent = (lowStockItems / totalItems) * 100;
    const outPercent = (outOfStockItems / totalItems) * 100;

    return (
      <Card style={styles.card}>
        <Card.Content>
          <Title>Ph√¢n t√≠ch t·ªìn kho</Title>

          <View style={styles.chartContainer}>
            <View style={styles.chartRow}>
              <View style={styles.chartLabelContainer}>
                <View
                  style={[
                    styles.colorIndicator,
                    { backgroundColor: '#4CAF50' },
                  ]}
                />
                <Text>B√¨nh th∆∞·ªùng</Text>
              </View>
              <View style={styles.chartBarContainer}>
                <ProgressBar
                  progress={normalPercent / 100}
                  color="#4CAF50"
                  style={styles.progressBar}
                />
                <Text style={styles.percentageText}>
                  {Math.round(normalPercent)}% ({normalItems})
                </Text>
              </View>
            </View>

            <View style={styles.chartRow}>
              <View style={styles.chartLabelContainer}>
                <View
                  style={[
                    styles.colorIndicator,
                    { backgroundColor: '#FFC107' },
                  ]}
                />
                <Text>T·ªìn th·∫•p</Text>
              </View>
              <View style={styles.chartBarContainer}>
                <ProgressBar
                  progress={lowPercent / 100}
                  color="#FFC107"
                  style={styles.progressBar}
                />
                <Text style={styles.percentageText}>
                  {Math.round(lowPercent)}% ({lowStockItems - outOfStockItems})
                </Text>
              </View>
            </View>

            <View style={styles.chartRow}>
              <View style={styles.chartLabelContainer}>
                <View
                  style={[
                    styles.colorIndicator,
                    { backgroundColor: '#F44336' },
                  ]}
                />
                <Text>H·∫øt h√†ng</Text>
              </View>
              <View style={styles.chartBarContainer}>
                <ProgressBar
                  progress={outPercent / 100}
                  color="#F44336"
                  style={styles.progressBar}
                />
                <Text style={styles.percentageText}>
                  {Math.round(outPercent)}% ({outOfStockItems})
                </Text>
              </View>
            </View>
          </View>
        </Card.Content>
      </Card>
    );
  };

  // Render ph·∫ßn t·ªïng quan
  const renderSummary = () => {
    return (
      <Card style={styles.card}>
        <Card.Content>
          <Title>T·ªïng quan kho h√†ng</Title>

          <View style={styles.summaryContainer}>
            <View style={styles.summaryItem}>
              <Text style={styles.summaryValue}>{summaryData.totalItems}</Text>
              <Text style={styles.summaryLabel}>T·ªïng v·∫≠t t∆∞</Text>
            </View>

            <View style={styles.summaryItem}>
              <Text style={styles.summaryValue}>
                {formatCurrency(summaryData.totalValue)}
              </Text>
              <Text style={styles.summaryLabel}>Gi√° tr·ªã kho</Text>
            </View>
          </View>

          <View style={styles.summaryContainer}>
            <View style={styles.summaryItem}>
              <Text style={[styles.summaryValue, { color: '#FFC107' }]}>
                {summaryData.lowStockItems}
              </Text>
              <Text style={styles.summaryLabel}>C·∫ßn nh·∫≠p th√™m</Text>
            </View>

            <View style={styles.summaryItem}>
              <Text style={[styles.summaryValue, { color: '#F44336' }]}>
                {summaryData.outOfStockItems}
              </Text>
              <Text style={styles.summaryLabel}>H·∫øt h√†ng</Text>
            </View>
          </View>
        </Card.Content>
      </Card>
    );
  };

  // Render top v·∫≠t t∆∞ gi√° tr·ªã cao
  const renderTopItems = () => {
    if (topItems.length === 0) return null;

    return (
      <Card style={styles.card}>
        <Card.Content>
          <Title>Top v·∫≠t t∆∞ gi√° tr·ªã cao</Title>

          <DataTable>
            <DataTable.Header>
              <DataTable.Title>T√™n v·∫≠t t∆∞</DataTable.Title>
              <DataTable.Title numeric>T·ªìn kho</DataTable.Title>
              <DataTable.Title numeric>Gi√° tr·ªã</DataTable.Title>
            </DataTable.Header>

            {topItems.slice(0, 5).map((item) => {
              const value = (item.stockQuantity || 0) * (item.price || 0);
              return (
                <DataTable.Row
                  key={item.id}
                  onPress={() =>
                    navigation.navigate('InventoryItemDetail', {
                      itemId: item.id,
                    })
                  }
                >
                  <DataTable.Cell>{item.name}</DataTable.Cell>
                  <DataTable.Cell numeric>
                    {item.stockQuantity} {item.unit}
                  </DataTable.Cell>
                  <DataTable.Cell numeric>
                    {formatCurrency(value)}
                  </DataTable.Cell>
                </DataTable.Row>
              );
            })}
          </DataTable>

          {topItems.length > 5 && (
            <Button
              mode="text"
              onPress={() =>
                navigation.navigate('Inventory', { filter: 'valueHigh' })
              }
              style={{ marginTop: 8 }}
            >
              Xem t·∫•t c·∫£
            </Button>
          )}
        </Card.Content>
      </Card>
    );
  };

  // Render danh s√°ch v·∫≠t t∆∞ theo filter
  const renderInventoryList = () => {
    const filteredItems = getFilteredItems();

    return (
      <Card style={styles.card}>
        <Card.Content>
          <View style={styles.listHeader}>
            <Title>
              {reportType === 'lowStock' && 'V·∫≠t t∆∞ t·ªìn th·∫•p'}
              {reportType === 'outOfStock' && 'V·∫≠t t∆∞ h·∫øt h√†ng'}
              {reportType === 'allItems' && 'T·∫•t c·∫£ v·∫≠t t∆∞'}
            </Title>

            <Text style={styles.itemCount}>{filteredItems.length} v·∫≠t t∆∞</Text>
          </View>

          <View style={styles.filterChips}>
            {categories.slice(0, 5).map((category) => (
              <Chip
                key={category.id}
                selected={categoryFilter === category.id}
                onPress={() =>
                  setCategoryFilter(
                    categoryFilter === category.id ? null : category.id
                  )
                }
                style={styles.filterChip}
              >
                {category.name}
              </Chip>
            ))}

            {categories.length > 5 && (
              <Chip
                onPress={() => navigation.navigate('Inventory')}
                style={styles.filterChip}
              >
                +{categories.length - 5} th√™m
              </Chip>
            )}
          </View>

          <SegmentedButtons
            value={reportType}
            onValueChange={setReportType}
            buttons={[
              { value: 'lowStock', label: 'T·ªìn th·∫•p' },
              { value: 'outOfStock', label: 'H·∫øt h√†ng' },
              { value: 'allItems', label: 'T·∫•t c·∫£' },
            ]}
            style={styles.segmentedButtons}
          />

          <Divider style={{ marginTop: 16 }} />

          {filteredItems.length > 0 ? (
            filteredItems.slice(0, 10).map((item) => (
              <TouchableOpacity
                key={item.id}
                onPress={() =>
                  navigation.navigate('InventoryItemDetail', {
                    itemId: item.id,
                  })
                }
              >
                <View style={styles.itemRow}>
                  <View style={styles.itemInfo}>
                    <Text style={styles.itemName}>{item.name}</Text>
                    <Text style={styles.itemCode}>M√£: {item.code}</Text>
                    <Text style={styles.itemCategory}>
                      {getCategoryName(item.categoryId)}
                    </Text>
                  </View>

                  <View style={styles.itemQuantity}>
                    <Text style={styles.quantityValue}>
                      {item.stockQuantity} {item.unit}
                    </Text>
                    <StatusIndicator
                      status={
                        item.stockQuantity <= 0
                          ? 'critical'
                          : item.stockQuantity <= (item.minQuantity || 0)
                          ? 'warning'
                          : 'normal'
                      }
                      text={
                        item.stockQuantity <= 0
                          ? 'H·∫øt h√†ng'
                          : item.stockQuantity <= (item.minQuantity || 0)
                          ? 'T·ªìn th·∫•p'
                          : 'B√¨nh th∆∞·ªùng'
                      }
                    />
                  </View>
                </View>
                <Divider />
              </TouchableOpacity>
            ))
          ) : (
            <View style={styles.emptyListContainer}>
              <Ionicons name="cube-outline" size={48} color="#ccc" />
              <Text style={styles.emptyListText}>
                Kh√¥ng c√≥ v·∫≠t t∆∞ n√†o
                {reportType === 'lowStock' && ' t·ªìn th·∫•p'}
                {reportType === 'outOfStock' && ' h·∫øt h√†ng'}
                {categoryFilter &&
                  ` trong danh m·ª•c ${getCategoryName(categoryFilter)}`}
              </Text>
            </View>
          )}

          {filteredItems.length > 10 && (
            <Button
              mode="outlined"
              onPress={() =>
                navigation.navigate('Inventory', {
                  reportType,
                  categoryId: categoryFilter,
                })
              }
              style={{ marginTop: 16 }}
            >
              Xem t·∫•t c·∫£ {filteredItems.length} v·∫≠t t∆∞
            </Button>
          )}
        </Card.Content>
      </Card>
    );
  };

  return (
    <View style={styles.container}>
      <Appbar.Header>
        <Appbar.BackAction onPress={() => navigation.goBack()} />
        <Appbar.Content title="B√°o c√°o kho" />
        <Appbar.Action icon="refresh" onPress={loadData} />
        <Appbar.Action
          icon="file-export-outline"
          onPress={() => alert('Ch·ª©c nƒÉng xu·∫•t b√°o c√°o s·∫Ω ƒë∆∞·ª£c ph√°t tri·ªÉn sau')}
        />
      </Appbar.Header>

      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" />
          <Text style={{ marginTop: 16 }}>ƒêang t·∫£i d·ªØ li·ªáu b√°o c√°o...</Text>
        </View>
      ) : (
        <ScrollView style={styles.scrollView}>
          {renderSummary()}
          {renderAnalyticsChart()}
          {renderTopItems()}
          {renderInventoryList()}

          <View style={styles.footer}>
            <Text style={styles.footerText}>
              D·ªØ li·ªáu ƒë∆∞·ª£c c·∫≠p nh·∫≠t l·∫ßn cu·ªëi:{' '}
              {new Date().toLocaleString('vi-VN')}
            </Text>
          </View>
        </ScrollView>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollView: {
    flex: 1,
    padding: 16,
  },
  card: {
    marginBottom: 16,
    elevation: 2,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  summaryContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginVertical: 16,
  },
  summaryItem: {
    alignItems: 'center',
  },
  summaryValue: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#3f51b5',
  },
  summaryLabel: {
    fontSize: 12,
    color: '#666',
    marginTop: 4,
  },
  chartContainer: {
    marginTop: 16,
  },
  chartRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  chartLabelContainer: {
    width: 100,
    flexDirection: 'row',
    alignItems: 'center',
  },
  colorIndicator: {
    width: 16,
    height: 16,
    borderRadius: 8,
    marginRight: 8,
  },
  chartBarContainer: {
    flex: 1,
  },
  progressBar: {
    height: 8,
    borderRadius: 4,
  },
  percentageText: {
    fontSize: 12,
    color: '#666',
    marginTop: 2,
  },
  listHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  itemCount: {
    fontSize: 14,
    color: '#666',
  },
  filterChips: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginVertical: 12,
  },
  filterChip: {
    marginRight: 8,
    marginBottom: 8,
  },
  segmentedButtons: {
    marginTop: 8,
  },
  itemRow: {
    flexDirection: 'row',
    paddingVertical: 12,
    justifyContent: 'space-between',
  },
  itemInfo: {
    flex: 1,
  },
  itemName: {
    fontWeight: 'bold',
    fontSize: 16,
  },
  itemCode: {
    fontSize: 12,
    color: '#666',
  },
  itemCategory: {
    fontSize: 12,
    color: '#3f51b5',
    marginTop: 4,
  },
  itemQuantity: {
    alignItems: 'flex-end',
  },
  quantityValue: {
    fontWeight: 'bold',
    marginBottom: 4,
  },
  emptyListContainer: {
    alignItems: 'center',
    paddingVertical: 32,
  },
  emptyListText: {
    marginTop: 16,
    color: '#666',
    textAlign: 'center',
  },
  footer: {
    alignItems: 'center',
    marginTop: 8,
    marginBottom: 24,
  },
  footerText: {
    fontSize: 12,
    color: '#666',
    fontStyle: 'italic',
  },
});

export default InventoryReportScreen;


--- END: src\screens\InventoryReportScreen.js ---


--- START: src\screens\InventoryScreen.js ---
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  FlatList,
  StyleSheet,
  ActivityIndicator,
  Text,
  Alert,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import {
  Searchbar,
  FAB,
  Button,
  Chip,
  Menu,
  Portal,
  Dialog,
  TextInput,
  Paragraph,
  Divider,
  List,
} from 'react-native-paper';
import { db, functions } from '../config/firebaseConfig';
import { collection, getDocs, query, orderBy } from 'firebase/firestore';
import {
  useNavigation,
  useFocusEffect,
  useRoute,
} from '@react-navigation/native';
import InventoryItemCard from '../components/InventoryItemCard';
import { TouchableOpacity } from 'react-native';
import useInventory from '../hooks/useInventory';
import { useAuth } from '../contexts/AuthContext';
import { GoogleSignin } from '@react-native-google-signin/google-signin';
import { httpsCallable } from 'firebase/functions';

/**
 * M√†n h√¨nh qu·∫£n l√Ω kho
 */
const InventoryScreen = () => {
  const [items, setItems] = useState([]);
  const [filteredItems, setFilteredItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState('');
  const [categories, setCategories] = useState([]);
  const [selectedCategory, setSelectedCategory] = useState(null);
  const [menuVisible, setMenuVisible] = useState(false);
  const [sortOption, setSortOption] = useState('name'); // M·∫∑c ƒë·ªãnh s·∫Øp x·∫øp theo t√™n
  const [filterLowStock, setFilterLowStock] = useState(false);
  const [importDialogVisible, setImportDialogVisible] = useState(false);
  const [driveFolderId, setDriveFolderId] = useState(
    '1ipw1E6FaVNVnCREuVVC9Ts8vRQ42VZas'
  );
  const [importLoading, setImportLoading] = useState(false);
  const [importResult, setImportResult] = useState(null);
  const [importResultDialogVisible, setImportResultDialogVisible] =
    useState(false);
  const [driveFiles, setDriveFiles] = useState([]);
  const [isPickerVisible, setIsPickerVisible] = useState(false);
  const [isLoadingFiles, setIsLoadingFiles] = useState(false);
  const [refreshKey, setRefreshKey] = useState(0);

  const navigation = useNavigation();
  const route = useRoute();
  const { user } = useAuth();
  const [fabOpen, setFabOpen] = useState(false);
  const [isScreenFocused, setIsScreenFocused] = useState(false);

  // X·ª≠ l√Ω tham s·ªë refresh
  useEffect(() => {
    // Ki·ªÉm tra n·∫øu c√≥ tham s·ªë refresh t·ª´ m√†n h√¨nh AddInventoryItem
    if (route.params?.refresh) {
      console.log('Refreshing inventory list from navigation param');
      // Reset param ƒë·ªÉ tr√°nh refresh v√¥ h·∫°n
      navigation.setParams({ refresh: undefined });
      // Trigger refresh b·∫±ng c√°ch tƒÉng refreshKey
      setRefreshKey((prev) => prev + 1);
    }
  }, [route.params?.refresh, navigation]);

  // S·ª≠ d·ª•ng navigation listener ƒë·ªÉ qu·∫£n l√Ω vi·ªác hi·ªÉn th·ªã FAB
  useEffect(() => {
    const unsubscribe = navigation.addListener('focus', () => {
      console.log('InventoryScreen focused - setting isScreenFocused to true');
      setIsScreenFocused(true);
    });

    const unsubscribeBlur = navigation.addListener('blur', () => {
      console.log(
        'InventoryScreen unfocused - setting isScreenFocused to false'
      );
      setIsScreenFocused(false);
    });

    return () => {
      unsubscribe();
      unsubscribeBlur();
    };
  }, [navigation]);

  // L·∫•y danh s√°ch v·∫≠t t∆∞ t·ª´ Firestore - t·ªëi ∆∞u hi·ªáu su·∫•t
  const fetchInventory = useCallback(async () => {
    setLoading(true);
    try {
      console.log('=== INVENTORYSCREEN: B·∫ÆT ƒê·∫¶U FETCH INVENTORY ===');
      const inventoryRef = collection(db, 'inventory');

      // Th·ª≠ query v·ªõi lastUpdated tr∆∞·ªõc, n·∫øu l·ªói th√¨ fallback v·ªÅ query kh√¥ng c√≥ orderBy
      let q;
      let snapshot;

      try {
        // Th·ª≠ query v·ªõi lastUpdated (cho v·∫≠t t∆∞ m·ªõi th√™m th·ªß c√¥ng)
        console.log('=== INVENTORYSCREEN: TH·ª¨ QUERY V·ªöI lastUpdated ===');
        q = query(inventoryRef, orderBy('lastUpdated', 'desc'));
        snapshot = await getDocs(q);
        console.log('=== INVENTORYSCREEN: QUERY lastUpdated TH√ÄNH C√îNG ===');
      } catch (orderByError) {
        console.log(
          '=== INVENTORYSCREEN: QUERY lastUpdated TH·∫§T B·∫†I, TH·ª¨ QUERY KH√îNG C√ì ORDERBY ==='
        );
        console.log('L·ªói orderBy:', orderByError.message);

        // Fallback: query kh√¥ng c√≥ orderBy ƒë·ªÉ l·∫•y t·∫•t c·∫£ v·∫≠t t∆∞
        q = query(inventoryRef);
        snapshot = await getDocs(q);
        console.log(
          '=== INVENTORYSCREEN: QUERY KH√îNG C√ì ORDERBY TH√ÄNH C√îNG ==='
        );
      }

      console.log('=== INVENTORYSCREEN: K·∫æT QU·∫¢ QUERY ===');
      console.log('S·ªë l∆∞·ª£ng documents:', snapshot.docs.length);

      const fetchedItems = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));

      console.log('=== INVENTORYSCREEN: D·ªÆ LI·ªÜU ƒê√É PARSE ===');
      console.log('S·ªë l∆∞·ª£ng items:', fetchedItems.length);
      console.log('Items ƒë·∫ßu ti√™n:', fetchedItems[0]);

      // S·∫Øp x·∫øp th·ªß c√¥ng n·∫øu c·∫ßn
      const sortedItems = fetchedItems.sort((a, b) => {
        // ∆Øu ti√™n lastUpdated, sau ƒë√≥ updatedAt, cu·ªëi c√πng createdAt
        const aTime = a.lastUpdated || a.updatedAt || a.createdAt;
        const bTime = b.lastUpdated || b.updatedAt || b.createdAt;

        if (aTime && bTime) {
          return bTime.toDate().getTime() - aTime.toDate().getTime();
        }
        return 0;
      });

      console.log('=== INVENTORYSCREEN: D·ªÆ LI·ªÜU ƒê√É S·∫ÆP X·∫æP ===');
      console.log('S·ªë l∆∞·ª£ng items sau khi s·∫Øp x·∫øp:', sortedItems.length);

      setItems(sortedItems);
      applyFiltersAndSort(
        sortedItems,
        searchQuery,
        selectedCategory,
        filterLowStock,
        sortOption
      );

      console.log('=== INVENTORYSCREEN: HO√ÄN TH√ÄNH FETCH ===');
    } catch (error) {
      console.error('=== INVENTORYSCREEN: L·ªñI FETCH ===');
      console.error('L·ªói khi l·∫•y d·ªØ li·ªáu kho:', error);
      console.error('Error details:', error.message, error.code);
    } finally {
      setLoading(false);
    }
  }, [searchQuery, selectedCategory, filterLowStock, sortOption]);

  // L·∫•y danh s√°ch danh m·ª•c
  const fetchCategories = useCallback(async () => {
    try {
      const snapshot = await getDocs(collection(db, 'inventory_categories'));
      const fetchedCategories = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));
      setCategories(fetchedCategories);
    } catch (error) {
      console.error('L·ªói khi l·∫•y danh m·ª•c:', error);
    }
  }, []);

  // Load d·ªØ li·ªáu khi m√†n h√¨nh ƒë∆∞·ª£c focus ho·∫∑c refresh
  useFocusEffect(
    useCallback(() => {
      fetchInventory();
      fetchCategories();
      return () => {}; // cleanup function
    }, [fetchInventory, fetchCategories, refreshKey])
  );

  // H√†m √°p d·ª•ng b·ªô l·ªçc v√† s·∫Øp x·∫øp - ƒë√£ t·ªëi ∆∞u ƒë·ªÉ tr√°nh re-render
  const applyFiltersAndSort = useCallback(
    (itemsToFilter, query, category, lowStock, sort) => {
      // L·ªçc theo t·ª´ kh√≥a t√¨m ki·∫øm
      let result = [...itemsToFilter];

      if (query) {
        const normalizedQuery = query.toLowerCase().trim();
        result = result.filter(
          (item) =>
            item.name?.toLowerCase().includes(normalizedQuery) ||
            item.code?.toLowerCase().includes(normalizedQuery) ||
            item.material?.toLowerCase().includes(normalizedQuery)
        );
      }

      // L·ªçc theo danh m·ª•c
      if (category) {
        result = result.filter((item) => item.categoryId === category.id);
      }

      // L·ªçc v·∫≠t t∆∞ c√≥ t·ªìn kho th·∫•p
      if (lowStock) {
        result = result.filter(
          (item) =>
            item.stockQuantity <= (item.minQuantity || 0) &&
            item.minQuantity > 0
        );
      }

      // S·∫Øp x·∫øp
      switch (sort) {
        case 'name':
          result.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
          break;
        case 'stockLow':
          result.sort(
            (a, b) => (a.stockQuantity || 0) - (b.stockQuantity || 0)
          );
          break;
        case 'stockHigh':
          result.sort(
            (a, b) => (b.stockQuantity || 0) - (a.stockQuantity || 0)
          );
          break;
        case 'code':
          result.sort((a, b) => (a.code || '').localeCompare(b.code || ''));
          break;
      }

      setFilteredItems(result);
    },
    []
  );

  // X·ª≠ l√Ω thay ƒë·ªïi t·ª´ kh√≥a t√¨m ki·∫øm
  const onChangeSearch = (query) => {
    setSearchQuery(query);
    applyFiltersAndSort(
      items,
      query,
      selectedCategory,
      filterLowStock,
      sortOption
    );
  };

  // X·ª≠ l√Ω ch·ªçn danh m·ª•c
  const handleCategorySelect = (category) => {
    setSelectedCategory(category === selectedCategory ? null : category);
    applyFiltersAndSort(
      items,
      searchQuery,
      category === selectedCategory ? null : category,
      filterLowStock,
      sortOption
    );
  };

  // X·ª≠ l√Ω thay ƒë·ªïi s·∫Øp x·∫øp
  const handleSortChange = (option) => {
    setSortOption(option);
    setMenuVisible(false);
    applyFiltersAndSort(
      items,
      searchQuery,
      selectedCategory,
      filterLowStock,
      option
    );
  };

  // X·ª≠ l√Ω l·ªçc h√†ng t·ªìn th·∫•p
  const toggleLowStockFilter = () => {
    const newFilterValue = !filterLowStock;
    setFilterLowStock(newFilterValue);
    applyFiltersAndSort(
      items,
      searchQuery,
      selectedCategory,
      newFilterValue,
      sortOption
    );
  };

  // X·ª≠ l√Ω ch·ªçn v·∫≠t t∆∞
  const handleItemPress = (item) => {
    navigation.navigate('InventoryItemDetail', { itemId: item.id });
  };

  // X·ª≠ l√Ω th√™m m·ªõi
  const handleAddItem = () => {
    navigation.navigate('AddInventoryItem');
  };

  const fetchGoogleDriveFiles = async (token, folderId = null) => {
    setIsLoadingFiles(true);
    const baseUrl = 'https://www.googleapis.com/drive/v3/files';
    const params = new URLSearchParams();

    // Build query based on whether we have a specific folder ID or not
    let query =
      "mimeType='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' and trashed=false";
    if (folderId) {
      query = `'${folderId}' in parents and ${query}`;
    }

    params.append('q', query);
    params.append('orderBy', 'modifiedTime desc');
    params.append('fields', 'files(id, name, modifiedTime, iconLink)');
    const url = `${baseUrl}?${params.toString()}`;

    try {
      const response = await fetch(url, {
        headers: { Authorization: `Bearer ${token}` },
      });
      if (!response.ok) {
        throw new Error(`Google Drive API error: ${response.status}`);
      }
      const json = await response.json();
      return json.files || [];
    } catch (error) {
      console.error('Error in fetchGoogleDriveFiles:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ l·∫•y danh s√°ch file t·ª´ Google Drive.');
      throw error;
    } finally {
      setIsLoadingFiles(false);
    }
  };

  // X·ª≠ l√Ω nh·∫≠p v·∫≠t t∆∞ t·ª´ Google Drive
  const handleImportFromDrive = async () => {
    setImportLoading(true);
    try {
      // Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng nh·∫≠p Google ch∆∞a
      const isSignedIn = await GoogleSignin.isSignedIn();
      if (!isSignedIn) {
        await GoogleSignin.signIn();
      }
      // L·∫•y token
      const tokens = await GoogleSignin.getTokens();
      const accessToken = tokens.accessToken;

      if (!accessToken) {
        throw new Error('Kh√¥ng th·ªÉ l·∫•y ƒë∆∞·ª£c access token.');
      }

      if (!driveFolderId) {
        Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p ID th∆∞ m·ª•c Google Drive');
        return;
      }

      // L·∫•y danh s√°ch file Excel t·ª´ folder
      const files = await fetchGoogleDriveFiles(accessToken, driveFolderId);
      if (files && files.length > 0) {
        setDriveFiles(files);
        setImportDialogVisible(false);
        setIsPickerVisible(true);
      } else {
        Alert.alert(
          'Kh√¥ng t√¨m th·∫•y file',
          'Kh√¥ng t√¨m th·∫•y file Excel n√†o trong th∆∞ m·ª•c Google Drive n√†y.'
        );
      }
    } catch (error) {
      console.error('L·ªói khi nh·∫≠p v·∫≠t t∆∞:', error);
      if (error.code !== 'SIGN_IN_CANCELLED') {
        Alert.alert(
          'L·ªói nh·∫≠p v·∫≠t t∆∞',
          error.message || 'Kh√¥ng th·ªÉ nh·∫≠p v·∫≠t t∆∞ t·ª´ Google Drive'
        );
      }
    } finally {
      setImportLoading(false);
    }
  };

  const handleFileSelect = async (file) => {
    setIsPickerVisible(false);
    setImportLoading(true);

    try {
      // L·∫•y access token
      const tokens = await GoogleSignin.getTokens();
      const { accessToken } = tokens;

      if (!accessToken) {
        throw new Error('Kh√¥ng th·ªÉ l·∫•y ƒë∆∞·ª£c access token c·ªßa Google.');
      }

      // G·ªçi Cloud Function ƒë·ªÉ x·ª≠ l√Ω v√† nh·∫≠p v·∫≠t t∆∞
      const importInventory = httpsCallable(
        functions,
        'importInventoryFromExcel'
      );
      const result = await importInventory({
        driveFileId: file.id,
        accessToken,
      });

      // X·ª≠ l√Ω k·∫øt qu·∫£
      console.log('K·∫øt qu·∫£ nh·∫≠p v·∫≠t t∆∞:', result.data);
      setImportResult(result.data);
      setImportResultDialogVisible(true);

      // C·∫≠p nh·∫≠t l·∫°i danh s√°ch v·∫≠t t∆∞ - d√πng refreshKey ƒë·ªÉ trigger useFocusEffect
      setRefreshKey((prev) => prev + 1);
    } catch (error) {
      console.error('L·ªói khi x·ª≠ l√Ω file Excel:', error);

      let errorMessage = error.message;
      if (error.code === 'functions/unauthenticated') {
        errorMessage =
          'X√°c th·ª±c th·∫•t b·∫°i. Vui l√≤ng ƒëƒÉng xu·∫•t v√† ƒëƒÉng nh·∫≠p l·∫°i.';
      } else if (error.code === 'functions/permission-denied') {
        errorMessage =
          'Token truy c·∫≠p Google Drive ƒë√£ h·∫øt h·∫°n. Vui l√≤ng th·ª≠ l·∫°i.';
      }

      Alert.alert('L·ªói x·ª≠ l√Ω file', `Chi ti·∫øt: ${errorMessage}`);
    } finally {
      setImportLoading(false);
    }
  };

  const handleCloseResultDialog = () => {
    setImportResultDialogVisible(false);
    // ƒê·∫£m b·∫£o danh s√°ch ƒë∆∞·ª£c t·∫£i l·∫°i sau khi ƒë√≥ng dialog
    setTimeout(() => {
      fetchInventory();
    }, 300);
  };

  // Hi·ªÉn th·ªã c√°c danh m·ª•c
  const renderCategoryChips = () => {
    return (
      <FlatList
        data={categories}
        horizontal
        showsHorizontalScrollIndicator={false}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <Chip
            style={[
              styles.chip,
              selectedCategory?.id === item.id ? styles.selectedChip : null,
            ]}
            onPress={() => handleCategorySelect(item)}
            mode={selectedCategory?.id === item.id ? 'flat' : 'outlined'}
          >
            {item.name}
          </Chip>
        )}
        contentContainerStyle={styles.chipsContainer}
      />
    );
  };

  return (
    <View style={styles.container}>
      {/* Thanh t√¨m ki·∫øm */}
      <Searchbar
        placeholder="T√¨m ki·∫øm v·∫≠t t∆∞..."
        onChangeText={onChangeSearch}
        value={searchQuery}
        style={styles.searchBar}
      />

      {/* Thanh c√¥ng c·ª• */}
      <View style={styles.toolbar}>
        {/* Menu s·∫Øp x·∫øp */}
        <Menu
          visible={menuVisible}
          onDismiss={() => setMenuVisible(false)}
          anchor={
            <Button
              mode="outlined"
              onPress={() => setMenuVisible(true)}
              icon="sort"
            >
              S·∫Øp x·∫øp
            </Button>
          }
        >
          <Menu.Item
            title="Theo t√™n (A-Z)"
            onPress={() => handleSortChange('name')}
          />
          <Menu.Item
            title="T·ªìn kho (Th·∫•p-Cao)"
            onPress={() => handleSortChange('stockLow')}
          />
          <Menu.Item
            title="T·ªìn kho (Cao-Th·∫•p)"
            onPress={() => handleSortChange('stockHigh')}
          />
          <Menu.Item title="Theo m√£" onPress={() => handleSortChange('code')} />
        </Menu>

        {/* N√∫t l·ªçc h√†ng t·ªìn th·∫•p */}
        <Button
          mode={filterLowStock ? 'contained' : 'outlined'}
          onPress={toggleLowStockFilter}
          icon="alert-circle"
        >
          T·ªìn th·∫•p
        </Button>
      </View>

      {/* Danh s√°ch danh m·ª•c */}
      {renderCategoryChips()}

      {/* Danh s√°ch v·∫≠t t∆∞ */}
      {loading ? (
        <ActivityIndicator size="large" style={styles.loader} />
      ) : filteredItems.length > 0 ? (
        <FlatList
          data={filteredItems}
          keyExtractor={(item) => item.id}
          renderItem={({ item }) => (
            <InventoryItemCard item={item} onPress={handleItemPress} />
          )}
          contentContainerStyle={styles.listContainer}
        />
      ) : (
        <View style={styles.emptyState}>
          <Text style={styles.emptyText}>
            Kh√¥ng c√≥ v·∫≠t t∆∞ n√†o{' '}
            {searchQuery ? 'ph√π h·ª£p v·ªõi t√¨m ki·∫øm' : 'trong kho'}
          </Text>
        </View>
      )}

      {/* FAB ƒë∆°n gi·∫£n - ch·ªâ hi·ªÉn th·ªã khi m√†n h√¨nh ƒë∆∞·ª£c focus */}
      {console.log(
        'Rendering FAB, isScreenFocused:',
        isScreenFocused,
        'fabOpen:',
        fabOpen
      )}
      {isScreenFocused && (
        <FAB
          icon={fabOpen ? 'close' : 'plus'}
          style={styles.fab}
          onPress={() => {
            console.log('FAB pressed, current fabOpen:', fabOpen);
            if (fabOpen) {
              // N·∫øu FAB ƒëang m·ªü, hi·ªÉn th·ªã menu
              setFabOpen(false);
            } else {
              // N·∫øu FAB ƒëang ƒë√≥ng, m·ªü menu
              setFabOpen(true);
            }
          }}
        />
      )}

      {/* Menu cho c√°c h√†nh ƒë·ªông khi FAB ƒë∆∞·ª£c m·ªü */}
      {isScreenFocused && fabOpen && (
        <View style={styles.fabMenu}>
          <TouchableOpacity
            style={styles.fabMenuItem}
            onPress={() => {
              setFabOpen(false);
              handleAddItem();
            }}
          >
            <Ionicons name="add" size={20} color="#fff" />
            <Text style={styles.fabMenuText}>Th√™m v·∫≠t t∆∞ m·ªõi</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.fabMenuItem}
            onPress={() => {
              setFabOpen(false);
              setImportDialogVisible(true);
            }}
          >
            <Ionicons name="file-excel" size={20} color="#fff" />
            <Text style={styles.fabMenuText}>Nh·∫≠p t·ª´ Excel</Text>
          </TouchableOpacity>
        </View>
      )}

      {/* Dialog nh·∫≠p t·ª´ Google Drive */}
      <Portal>
        <Dialog
          visible={importDialogVisible}
          onDismiss={() => !importLoading && setImportDialogVisible(false)}
        >
          <Dialog.Title>Nh·∫≠p v·∫≠t t∆∞ t·ª´ Google Drive</Dialog.Title>
          <Dialog.Content>
            <Paragraph>
              Ch·ª©c nƒÉng n√†y s·∫Ω nh·∫≠p v·∫≠t t∆∞ t·ª´ file Excel m·ªõi nh·∫•t trong th∆∞ m·ª•c
              Google Drive. File c·∫ßn c√≥ ƒë·ªãnh d·∫°ng v·ªõi c√°c c·ªôt sau:
            </Paragraph>

            <View style={styles.excelInfo}>
              <List.Item
                title="C·ªôt A: M√£ v·∫≠t t∆∞ (code)"
                left={(props) => <List.Icon {...props} icon="pound" />}
              />
              <List.Item
                title="C·ªôt B: T√™n v·∫≠t t∆∞ (name)"
                left={(props) => <List.Icon {...props} icon="text" />}
              />
              <List.Item
                title="C·ªôt C: M√¥ t·∫£ (description)"
                left={(props) => <List.Icon {...props} icon="text-box" />}
              />
              <List.Item
                title="C·ªôt D: Danh m·ª•c (category)"
                left={(props) => <List.Icon {...props} icon="folder" />}
              />
              <List.Item
                title="C·ªôt E: ƒê∆°n v·ªã t√≠nh (unit)"
                left={(props) => <List.Icon {...props} icon="cube" />}
              />
              <List.Item
                title="C·ªôt F: S·ªë l∆∞·ª£ng (stockQuantity)"
                left={(props) => <List.Icon {...props} icon="counter" />}
              />
              <List.Item
                title="C·ªôt G: S·ªë l∆∞·ª£ng t·ªëi thi·ªÉu (minQuantity)"
                left={(props) => <List.Icon {...props} icon="alert" />}
              />
              <List.Item
                title="C·ªôt H: ƒê∆°n gi√° (price)"
                left={(props) => <List.Icon {...props} icon="currency-usd" />}
              />
              <List.Item
                title="C·ªôt I: V·∫≠t li·ªáu (material)"
                left={(props) => <List.Icon {...props} icon="tools" />}
              />
              <List.Item
                title="C·ªôt J: Kh·ªëi l∆∞·ª£ng (weight)"
                left={(props) => <List.Icon {...props} icon="weight" />}
              />
            </View>

            <Divider style={styles.divider} />

            <TextInput
              label="Google Drive Folder ID"
              value={driveFolderId}
              onChangeText={setDriveFolderId}
              style={styles.input}
              disabled={importLoading}
            />
          </Dialog.Content>
          <Dialog.Actions>
            <Button
              onPress={() => setImportDialogVisible(false)}
              disabled={importLoading}
            >
              H·ªßy
            </Button>
            <Button
              mode="contained"
              onPress={handleImportFromDrive}
              loading={importLoading}
              disabled={importLoading}
            >
              Ti·∫øp t·ª•c
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* Dialog ch·ªçn file t·ª´ Drive */}
      <Portal>
        <Dialog
          visible={isPickerVisible}
          onDismiss={() => !importLoading && setIsPickerVisible(false)}
          style={styles.filePickerDialog}
        >
          <Dialog.Title>Ch·ªçn file Excel</Dialog.Title>
          <Dialog.Content>
            {isLoadingFiles ? (
              <ActivityIndicator size="large" style={styles.loader} />
            ) : driveFiles.length > 0 ? (
              <FlatList
                data={driveFiles}
                keyExtractor={(item) => item.id}
                renderItem={({ item }) => (
                  <List.Item
                    title={item.name}
                    description={`S·ª≠a ƒë·ªïi: ${new Date(
                      item.modifiedTime
                    ).toLocaleString()}`}
                    left={(props) => <List.Icon {...props} icon="file-excel" />}
                    onPress={() => handleFileSelect(item)}
                    disabled={importLoading}
                  />
                )}
                style={styles.fileList}
              />
            ) : (
              <Text style={styles.emptyText}>Kh√¥ng t√¨m th·∫•y file Excel</Text>
            )}
          </Dialog.Content>
          <Dialog.Actions>
            <Button
              onPress={() => setIsPickerVisible(false)}
              disabled={importLoading}
            >
              H·ªßy
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>

      {/* Dialog k·∫øt qu·∫£ nh·∫≠p */}
      <Portal>
        <Dialog
          visible={importResultDialogVisible}
          onDismiss={handleCloseResultDialog}
        >
          <Dialog.Title>K·∫øt qu·∫£ nh·∫≠p v·∫≠t t∆∞</Dialog.Title>
          <Dialog.Content>
            {importResult && (
              <View>
                <Paragraph style={styles.resultText}>
                  T·ªïng s·ªë v·∫≠t t∆∞ ƒë√£ x·ª≠ l√Ω: {importResult.total}
                </Paragraph>
                <Paragraph style={styles.resultText}>
                  S·ªë v·∫≠t t∆∞ ƒë√£ th√™m m·ªõi:{' '}
                  <Text style={styles.successText}>{importResult.added}</Text>
                </Paragraph>
                <Paragraph style={styles.resultText}>
                  S·ªë v·∫≠t t∆∞ ƒë√£ c·∫≠p nh·∫≠t:{' '}
                  <Text style={styles.warningText}>{importResult.updated}</Text>
                </Paragraph>
                <Paragraph style={styles.resultText}>
                  S·ªë v·∫≠t t∆∞ b·ªã b·ªè qua:{' '}
                  <Text style={styles.errorText}>{importResult.skipped}</Text>
                </Paragraph>

                {importResult.errors && importResult.errors.length > 0 && (
                  <View style={styles.errorList}>
                    <Text style={styles.errorHeader}>C√°c l·ªói g·∫∑p ph·∫£i:</Text>
                    {importResult.errors.map((error, index) => (
                      <Text key={index} style={styles.errorItem}>
                        H√†ng {error.row}: {error.message}
                      </Text>
                    ))}
                  </View>
                )}
              </View>
            )}
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={handleCloseResultDialog}>ƒê√≥ng</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  searchBar: {
    margin: 16,
    elevation: 2,
  },
  toolbar: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    marginBottom: 10,
  },
  chipsContainer: {
    paddingHorizontal: 16,
    marginBottom: 10,
  },
  chip: {
    marginRight: 8,
  },
  selectedChip: {
    backgroundColor: '#3f51b5',
  },
  listContainer: {
    paddingBottom: 80, // ƒê·ªÉ kh√¥ng b·ªã FAB che khu·∫•t
  },
  fab: {
    position: 'absolute',
    margin: 16,
    right: 0,
    bottom: 0,
    backgroundColor: '#3f51b5',
  },
  fabMenu: {
    position: 'absolute',
    right: 16,
    bottom: 80,
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 8,
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  fabMenuItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 6,
    marginBottom: 4,
  },
  fabMenuText: {
    marginLeft: 12,
    fontSize: 14,
    color: '#333',
    fontWeight: '500',
  },
  loader: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  emptyState: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  emptyText: {
    fontSize: 16,
    color: '#888',
    textAlign: 'center',
  },
  divider: {
    marginVertical: 16,
  },
  input: {
    marginBottom: 10,
    backgroundColor: 'white',
  },
  excelInfo: {
    marginVertical: 10,
    backgroundColor: '#f5f5f5',
    borderRadius: 8,
    padding: 10,
    maxHeight: 250,
  },
  resultText: {
    fontSize: 16,
    marginBottom: 8,
  },
  successText: {
    color: '#4CAF50',
    fontWeight: 'bold',
  },
  warningText: {
    color: '#FF9800',
    fontWeight: 'bold',
  },
  errorText: {
    color: '#F44336',
    fontWeight: 'bold',
  },
  errorList: {
    marginTop: 16,
    backgroundColor: '#FFEBEE',
    padding: 12,
    borderRadius: 8,
  },
  errorHeader: {
    fontWeight: 'bold',
    marginBottom: 8,
    color: '#F44336',
  },
  errorItem: {
    color: '#D32F2F',
    marginBottom: 4,
  },
  filePickerDialog: {
    maxHeight: '80%',
  },
  fileList: {
    maxHeight: 300,
  },
});

export default InventoryScreen;


--- END: src\screens\InventoryScreen.js ---


--- START: src\screens\InventoryTransactionScreen.js ---
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, FlatList, TouchableOpacity } from 'react-native';
import {
  Appbar,
  Text,
  Divider,
  List,
  ActivityIndicator,
  Chip,
  Searchbar,
  Button,
  Card,
  Menu,
} from 'react-native-paper';
import { useNavigation, useRoute } from '@react-navigation/native';
import { firebase } from '../config/firebaseConfig';
import DateTimePicker from '@react-native-community/datetimepicker';
import { Ionicons } from '@expo/vector-icons';

const InventoryTransactionScreen = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { itemId } = route.params || {};

  const [loading, setLoading] = useState(true);
  const [transactions, setTransactions] = useState([]);
  const [item, setItem] = useState(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [filterType, setFilterType] = useState(null);
  const [dateRange, setDateRange] = useState({
    start: null,
    end: null,
  });

  const [showDatePicker, setShowDatePicker] = useState(false);
  const [datePickerMode, setDatePickerMode] = useState('start');
  const [menuVisible, setMenuVisible] = useState(false);

  // L·∫•y d·ªØ li·ªáu giao d·ªãch khi m·ªü m√†n h√¨nh
  useEffect(() => {
    fetchData();
  }, [itemId]);

  // L·∫•y danh s√°ch giao d·ªãch v√† th√¥ng tin v·∫≠t t∆∞
  const fetchData = async () => {
    try {
      setLoading(true);

      // L·∫•y th√¥ng tin chi ti·∫øt v·∫≠t t∆∞ n·∫øu c√≥ itemId
      if (itemId) {
        const itemDoc = await firebase
          .firestore()
          .collection('inventory')
          .doc(itemId)
          .get();

        if (itemDoc.exists) {
          setItem({
            id: itemDoc.id,
            ...itemDoc.data(),
          });
        }

        // L·∫•y giao d·ªãch c·ªßa v·∫≠t t∆∞ c·ª• th·ªÉ
        const query = firebase
          .firestore()
          .collection('inventory_transactions')
          .where('itemId', '==', itemId)
          .orderBy('date', 'desc');

        const snapshot = await query.get();
        const transactionsData = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        }));

        setTransactions(transactionsData);
      } else {
        // L·∫•y t·∫•t c·∫£ giao d·ªãch kho
        const query = firebase
          .firestore()
          .collection('inventory_transactions')
          .orderBy('date', 'desc')
          .limit(100); // Gi·ªõi h·∫°n ƒë·ªÉ tr√°nh l·∫•y qu√° nhi·ªÅu d·ªØ li·ªáu

        const snapshot = await query.get();
        const transactionsData = await Promise.all(
          snapshot.docs.map(async (doc) => {
            const data = {
              id: doc.id,
              ...doc.data(),
            };

            // N·∫øu kh√¥ng c√≥ item ·ªü prop, l·∫•y th√¥ng tin v·∫≠t t∆∞
            if (!data.itemName) {
              try {
                const itemDoc = await firebase
                  .firestore()
                  .collection('inventory')
                  .doc(data.itemId)
                  .get();

                if (itemDoc.exists) {
                  data.itemName = itemDoc.data().name;
                  data.itemUnit = itemDoc.data().unit;
                }
              } catch (error) {
                console.error('L·ªói khi l·∫•y th√¥ng tin v·∫≠t t∆∞:', error);
              }
            }

            return data;
          })
        );

        setTransactions(transactionsData);
      }
    } catch (error) {
      console.error('L·ªói khi l·∫•y d·ªØ li·ªáu giao d·ªãch:', error);
    } finally {
      setLoading(false);
    }
  };

  // X·ª≠ l√Ω t√¨m ki·∫øm
  const handleSearch = (query) => {
    setSearchQuery(query);
  };

  // X·ª≠ l√Ω ch·ªçn lo·∫°i giao d·ªãch ƒë·ªÉ l·ªçc
  const handleFilterType = (type) => {
    setFilterType(type === filterType ? null : type);
  };

  // X·ª≠ l√Ω ch·ªçn ng√†y b·∫Øt ƒë·∫ßu
  const handleStartDateSelect = (event, date) => {
    setShowDatePicker(false);
    if (date) {
      setDateRange({
        ...dateRange,
        start: date,
      });
    }
  };

  // X·ª≠ l√Ω ch·ªçn ng√†y k·∫øt th√∫c
  const handleEndDateSelect = (event, date) => {
    setShowDatePicker(false);
    if (date) {
      setDateRange({
        ...dateRange,
        end: date,
      });
    }
  };

  // M·ªü date picker
  const showDatePickerDialog = (mode) => {
    setDatePickerMode(mode);
    setShowDatePicker(true);
  };

  // X√≥a b·ªô l·ªçc
  const clearFilters = () => {
    setFilterType(null);
    setDateRange({
      start: null,
      end: null,
    });
    setSearchQuery('');
  };

  // L·ªçc giao d·ªãch
  const filteredTransactions = () => {
    let result = [...transactions];

    // L·ªçc theo lo·∫°i
    if (filterType) {
      result = result.filter((transaction) => transaction.type === filterType);
    }

    // L·ªçc theo ng√†y b·∫Øt ƒë·∫ßu
    if (dateRange.start) {
      const startTimestamp = firebase.firestore.Timestamp.fromDate(
        dateRange.start
      );
      result = result.filter(
        (transaction) =>
          transaction.date && transaction.date.seconds >= startTimestamp.seconds
      );
    }

    // L·ªçc theo ng√†y k·∫øt th√∫c
    if (dateRange.end) {
      // Th√™m 1 ng√†y ƒë·ªÉ bao g·ªìm c·∫£ ng√†y ƒë∆∞·ª£c ch·ªçn
      const endDate = new Date(dateRange.end);
      endDate.setDate(endDate.getDate() + 1);
      const endTimestamp = firebase.firestore.Timestamp.fromDate(endDate);

      result = result.filter(
        (transaction) =>
          transaction.date && transaction.date.seconds < endTimestamp.seconds
      );
    }

    // L·ªçc theo t·ª´ kh√≥a t√¨m ki·∫øm
    if (searchQuery) {
      const normalizedQuery = searchQuery.toLowerCase().trim();
      result = result.filter(
        (transaction) =>
          transaction.note?.toLowerCase().includes(normalizedQuery) ||
          transaction.itemName?.toLowerCase().includes(normalizedQuery)
      );
    }

    return result;
  };

  // Format ng√†y gi·ªù
  const formatDate = (timestamp) => {
    if (!timestamp) return '';

    const date = timestamp.toDate();
    return date.toLocaleDateString('vi-VN', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  // Render m·ªói giao d·ªãch
  const renderTransactionItem = ({ item: transaction }) => {
    const isIn = transaction.type === 'IN';
    return (
      <Card style={styles.transactionCard}>
        <Card.Content>
          <View style={styles.transactionHeader}>
            <View>
              <Text style={styles.transactionTitle}>
                {isIn ? 'Nh·∫≠p kho' : 'Xu·∫•t kho'}
              </Text>
              <Text style={styles.transactionDate}>
                {formatDate(transaction.date)}
              </Text>
            </View>

            <Chip
              mode="outlined"
              style={[
                styles.transactionTypeChip,
                { borderColor: isIn ? '#4CAF50' : '#F44336' },
              ]}
              textStyle={{
                color: isIn ? '#4CAF50' : '#F44336',
                fontWeight: 'bold',
              }}
            >
              {isIn ? '+' : '-'}
              {transaction.quantity} {transaction.itemUnit || item?.unit || ''}
            </Chip>
          </View>

          {!itemId && transaction.itemName && (
            <Text style={styles.itemName}>{transaction.itemName}</Text>
          )}

          <Text style={styles.transactionNote}>{transaction.note}</Text>

          <View style={styles.transactionFooter}>
            <Text style={styles.transactionUser}>
              {transaction.userId
                ? transaction.userId.substring(0, 8)
                : 'Kh√¥ng x√°c ƒë·ªãnh'}
            </Text>
            <Text style={styles.transactionStatus}>
              {transaction.status === 'COMPLETED' ? 'Ho√†n th√†nh' : 'Ch·ªù x·ª≠ l√Ω'}
            </Text>
          </View>
        </Card.Content>
      </Card>
    );
  };

  return (
    <View style={styles.container}>
      <Appbar.Header>
        <Appbar.BackAction onPress={() => navigation.goBack()} />
        <Appbar.Content
          title={item ? `Giao d·ªãch c·ªßa ${item.name}` : 'L·ªãch s·ª≠ giao d·ªãch kho'}
          subtitle={item ? `M√£: ${item.code}` : ''}
        />
        <Appbar.Action icon="refresh" onPress={fetchData} />
      </Appbar.Header>

      <View style={styles.filterContainer}>
        <Searchbar
          placeholder="T√¨m ki·∫øm giao d·ªãch..."
          onChangeText={handleSearch}
          value={searchQuery}
          style={styles.searchBar}
        />

        <View style={styles.chipRow}>
          <Chip
            selected={filterType === 'IN'}
            onPress={() => handleFilterType('IN')}
            style={styles.filterChip}
            icon="arrow-down"
          >
            Nh·∫≠p kho
          </Chip>
          <Chip
            selected={filterType === 'OUT'}
            onPress={() => handleFilterType('OUT')}
            style={styles.filterChip}
            icon="arrow-up"
          >
            Xu·∫•t kho
          </Chip>
          <Menu
            visible={menuVisible}
            onDismiss={() => setMenuVisible(false)}
            anchor={
              <Chip
                onPress={() => setMenuVisible(true)}
                style={styles.filterChip}
                icon="calendar"
              >
                Ng√†y
              </Chip>
            }
          >
            <Menu.Item
              title="Ch·ªçn ng√†y b·∫Øt ƒë·∫ßu"
              onPress={() => {
                setMenuVisible(false);
                showDatePickerDialog('start');
              }}
            />
            <Menu.Item
              title="Ch·ªçn ng√†y k·∫øt th√∫c"
              onPress={() => {
                setMenuVisible(false);
                showDatePickerDialog('end');
              }}
            />
            <Divider />
            <Menu.Item
              title="X√≥a l·ªçc ng√†y"
              onPress={() => {
                setMenuVisible(false);
                setDateRange({ start: null, end: null });
              }}
            />
          </Menu>

          {(filterType || dateRange.start || dateRange.end || searchQuery) && (
            <Chip
              onPress={clearFilters}
              style={styles.clearChip}
              icon="close-circle"
            >
              X√≥a l·ªçc
            </Chip>
          )}
        </View>

        {(dateRange.start || dateRange.end) && (
          <View style={styles.dateRangeContainer}>
            <Text style={styles.dateRangeText}>
              {dateRange.start
                ? formatDate(
                    firebase.firestore.Timestamp.fromDate(dateRange.start)
                  )
                : 'T·ª´ ƒë·∫ßu'}
              {' ‚Üí '}
              {dateRange.end
                ? formatDate(
                    firebase.firestore.Timestamp.fromDate(dateRange.end)
                  )
                : 'ƒë·∫øn nay'}
            </Text>
          </View>
        )}
      </View>

      {showDatePicker && (
        <DateTimePicker
          value={
            datePickerMode === 'start'
              ? dateRange.start || new Date()
              : dateRange.end || new Date()
          }
          mode="date"
          display="default"
          onChange={
            datePickerMode === 'start'
              ? handleStartDateSelect
              : handleEndDateSelect
          }
        />
      )}

      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" />
          <Text style={{ marginTop: 16 }}>ƒêang t·∫£i d·ªØ li·ªáu giao d·ªãch...</Text>
        </View>
      ) : (
        <FlatList
          data={filteredTransactions()}
          keyExtractor={(item) => item.id}
          renderItem={renderTransactionItem}
          contentContainerStyle={styles.listContainer}
          ListEmptyComponent={() => (
            <View style={styles.emptyContainer}>
              <Ionicons name="archive-outline" size={48} color="#666" />
              <Text style={styles.emptyText}>
                {searchQuery || filterType || dateRange.start || dateRange.end
                  ? 'Kh√¥ng t√¨m th·∫•y giao d·ªãch n√†o kh·ªõp v·ªõi ƒëi·ªÅu ki·ªán l·ªçc'
                  : 'Ch∆∞a c√≥ giao d·ªãch n√†o'}
              </Text>
              {(searchQuery ||
                filterType ||
                dateRange.start ||
                dateRange.end) && (
                <Button
                  mode="outlined"
                  onPress={clearFilters}
                  style={{ marginTop: 16 }}
                >
                  X√≥a b·ªô l·ªçc
                </Button>
              )}
            </View>
          )}
        />
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  filterContainer: {
    padding: 16,
    backgroundColor: 'white',
    elevation: 2,
  },
  searchBar: {
    marginBottom: 12,
    elevation: 0,
    backgroundColor: '#f0f0f0',
  },
  chipRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  filterChip: {
    marginRight: 8,
    marginBottom: 8,
  },
  clearChip: {
    backgroundColor: '#e57373',
    marginRight: 8,
    marginBottom: 8,
  },
  dateRangeContainer: {
    marginTop: 8,
    backgroundColor: '#f0f0f0',
    padding: 8,
    borderRadius: 4,
  },
  dateRangeText: {
    fontStyle: 'italic',
    color: '#666',
  },
  listContainer: {
    padding: 16,
    paddingBottom: 80,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 32,
    marginTop: 50,
  },
  emptyText: {
    marginTop: 16,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  transactionCard: {
    marginBottom: 12,
    elevation: 1,
  },
  transactionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
  },
  transactionTitle: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  transactionDate: {
    fontSize: 12,
    color: '#666',
    marginTop: 4,
  },
  transactionTypeChip: {
    minWidth: 80,
    justifyContent: 'center',
  },
  itemName: {
    fontWeight: '500',
    marginTop: 8,
    color: '#3f51b5',
  },
  transactionNote: {
    marginTop: 8,
    marginBottom: 8,
  },
  transactionFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 8,
  },
  transactionUser: {
    fontSize: 12,
    color: '#666',
  },
  transactionStatus: {
    fontSize: 12,
    fontWeight: '500',
    color: '#4CAF50',
  },
});

export default InventoryTransactionScreen;


--- END: src\screens\InventoryTransactionScreen.js ---


--- START: src\screens\KioskScreen.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  RefreshControl,
  Alert,
  Dimensions,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import ProductionService from '../api/productionService';
import { updateWorkflowStageStatus } from '../api/projectService';
import WorkerCard from '../components/WorkerCard';
import WorkDetailModal from '../components/WorkDetailModal';

const { width, height } = Dimensions.get('window');

const KioskScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const { currentUser } = useAuth();

  // State management
  const [factoryStatus, setFactoryStatus] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [selectedWorker, setSelectedWorker] = useState(null);
  const [showWorkModal, setShowWorkModal] = useState(false);
  const [completedTasks, setCompletedTasks] = useState(new Set()); // üÜï Track completed tasks
  const [screenDimensions, setScreenDimensions] = useState({ width, height });

  // Handle screen orientation changes
  useEffect(() => {
    const updateDimensions = () => {
      const { width: newWidth, height: newHeight } = Dimensions.get('window');
      setScreenDimensions({ width: newWidth, height: newHeight });
    };

    Dimensions.addEventListener('change', updateDimensions);
    return () => {
      // Cleanup if needed
    };
  }, []);

  // Real-time subscription
  useEffect(() => {
    let unsubscribe = null;

    const setupRealtimeUpdates = async () => {
      try {
        // Initial load
        await loadFactoryStatus();

        // Setup real-time subscription
        unsubscribe = ProductionService.subscribeLiveFactoryStatus((status) => {
          console.log(
            'Real-time factory status update:',
            status.length,
            'workers'
          );
          setFactoryStatus(status);
          setLoading(false);
        });
      } catch (error) {
        console.error('Error setting up real-time updates:', error);
        setLoading(false);
      }
    };

    setupRealtimeUpdates();

    // Cleanup subscription on unmount
    return () => {
      if (unsubscribe) {
        unsubscribe();
      }
    };
  }, []);

  // Load factory status
  const loadFactoryStatus = async () => {
    try {
      const status = await ProductionService.getLiveFactoryStatus();
      setFactoryStatus(status);
    } catch (error) {
      console.error('Error loading factory status:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i tr·∫°ng th√°i x∆∞·ªüng');
    }
  };

  // Handle refresh
  const handleRefresh = async () => {
    setRefreshing(true);
    await loadFactoryStatus();
    setRefreshing(false);
  };

  // Handle worker card press
  const handleWorkerPress = async (worker) => {
    try {
      setSelectedWorker(worker);
      setShowWorkModal(true);
    } catch (error) {
      console.error('Error selecting worker:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ m·ªü chi ti·∫øt c√¥ng nh√¢n');
    }
  };

  // Handle start work session
  const handleStartWork = async (workerId, workerName, task) => {
    try {
      const sessionId = await ProductionService.startWorkSession(
        workerId,
        workerName,
        task.projectId,
        task.projectName,
        task.stageId,
        task.stageName
      );

      console.log('Started work session:', sessionId);
      setShowWorkModal(false);

      // Update task status to 'in_progress'
      await updateWorkflowStageStatus(
        task.projectId,
        task.stageId,
        'in_progress',
        workerId
      );

      Alert.alert('B·∫Øt ƒë·∫ßu', `${workerName} ƒë√£ b·∫Øt ƒë·∫ßu: ${task.stageName}`, [
        { text: 'OK' },
      ]);
    } catch (error) {
      console.error('Error starting work session:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu c√¥ng vi·ªác');
    }
  };

  // Handle stop work session
  const handleStopWork = async (workerId, workerName) => {
    try {
      const runningSession = await ProductionService.getRunningSessionForWorker(
        workerId
      );

      if (!runningSession) {
        Alert.alert('L·ªói', 'Kh√¥ng c√≥ phi√™n l√†m vi·ªác n√†o ƒëang ch·∫°y');
        return;
      }

      const duration = await ProductionService.stopWorkSession(
        runningSession.id
      );

      // Update task status to 'completed'
      await updateWorkflowStageStatus(
        runningSession.projectId,
        runningSession.stageId,
        'completed',
        workerId
      );

      setShowWorkModal(false);
      Alert.alert(
        'Ho√†n th√†nh',
        `${workerName} ƒë√£ ho√†n th√†nh: ${
          runningSession.stageName
        }\nTh·ªùi gian: ${formatDuration(duration)}`,
        [{ text: 'OK' }]
      );
    } catch (error) {
      console.error('Error stopping work session:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ k·∫øt th√∫c c√¥ng vi·ªác');
    }
  };

  // Handle task completion
  const handleTaskCompleted = (taskId) => {
    setCompletedTasks((prev) => new Set([...prev, taskId]));
  };

  // Format duration for display
  const formatDuration = (hours) => {
    const h = Math.floor(hours);
    const m = Math.round((hours - h) * 60);
    return `${h} gi·ªù ${m} ph√∫t`;
  };

  // Calculate grid columns based on screen dimensions - optimized for tablet landscape
  const getNumColumns = () => {
    const { width: currentWidth, height: currentHeight } = screenDimensions;
    const isLandscape = currentWidth > currentHeight;

    if (isLandscape) {
      // Landscape mode - optimize for more columns
      if (currentWidth > 1400) return 7; // Large tablets/desktop
      if (currentWidth > 1200) return 6; // Medium-large tablets
      if (currentWidth > 900) return 5; // Medium tablets
      if (currentWidth > 700) return 4; // Small tablets
      return 3; // Large phones in landscape
    } else {
      // Portrait mode
      if (currentWidth > 1200) return 4; // Large tablets
      if (currentWidth > 900) return 3; // Medium tablets
      if (currentWidth > 600) return 2; // Small tablets
      return 2; // Phones
    }
  };

  // Render worker card
  const renderWorkerCard = ({ item }) => (
    <WorkerCard
      worker={item}
      onPress={() => handleWorkerPress(item)}
      theme={theme}
    />
  );

  // Get status summary
  const getStatusSummary = () => {
    const working = factoryStatus.filter((w) => w.status === 'working').length;
    const idle = factoryStatus.filter((w) => w.status === 'idle').length;
    const totalTasks = factoryStatus.reduce(
      (sum, w) => sum + w.newTasksCount,
      0
    );

    return { working, idle, totalTasks };
  };

  const statusSummary = getStatusSummary();
  const numColumns = getNumColumns();

  return (
    <View style={[styles.container, { backgroundColor: theme.background }]}>
      {/* Header */}
      <View style={[styles.header, { backgroundColor: theme.cardBackground }]}>
        <View style={styles.headerLeft}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
          >
            <Ionicons name="arrow-back" size={24} color={theme.text} />
          </TouchableOpacity>
          <Text style={[styles.headerTitle, { color: theme.text }]}>
            Kiosk X∆∞·ªüng S·∫£n Xu·∫•t
          </Text>
        </View>

        <View style={styles.headerRight}>
          <TouchableOpacity
            style={[styles.refreshButton, { backgroundColor: theme.primary }]}
            onPress={handleRefresh}
            disabled={refreshing}
          >
            <Ionicons
              name="refresh"
              size={20}
              color="#fff"
              style={refreshing ? { opacity: 0.5 } : {}}
            />
          </TouchableOpacity>
        </View>
      </View>

      {/* Status Summary */}
      <View
        style={[styles.statusBar, { backgroundColor: theme.cardBackground }]}
      >
        <View style={styles.statusItem}>
          <View style={[styles.statusDot, { backgroundColor: '#4CAF50' }]} />
          <Text style={[styles.statusText, { color: theme.text }]}>
            ƒêang l√†m: {statusSummary.working}
          </Text>
        </View>

        <View style={styles.statusItem}>
          <View style={[styles.statusDot, { backgroundColor: '#9E9E9E' }]} />
          <Text style={[styles.statusText, { color: theme.text }]}>
            R·∫£nh: {statusSummary.idle}
          </Text>
        </View>

        <View style={styles.statusItem}>
          <Ionicons name="notifications" size={16} color={theme.primary} />
          <Text style={[styles.statusText, { color: theme.text }]}>
            Vi·ªác m·ªõi: {statusSummary.totalTasks}
          </Text>
        </View>

        {/* Show grid info in landscape */}
        {screenDimensions.width > screenDimensions.height && (
          <View style={styles.statusItem}>
            <Ionicons name="grid" size={16} color={theme.primary} />
            <Text style={[styles.statusText, { color: theme.text }]}>
              Layout: {numColumns} c·ªôt
            </Text>
          </View>
        )}
      </View>

      {/* Worker Grid */}
      <FlatList
        data={factoryStatus}
        renderItem={renderWorkerCard}
        keyExtractor={(item) => item.workerId}
        numColumns={numColumns}
        key={`${numColumns}-${screenDimensions.width}-${screenDimensions.height}`} // Force re-render when dimensions change
        contentContainerStyle={[
          styles.gridContainer,
          { paddingHorizontal: screenDimensions.width > 900 ? 24 : 16 },
        ]}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={[theme.primary]}
            tintColor={theme.primary}
          />
        }
        ListEmptyComponent={
          <View style={styles.emptyContainer}>
            <Ionicons
              name="people-outline"
              size={64}
              color={theme.textSecondary}
            />
            <Text style={[styles.emptyText, { color: theme.textSecondary }]}>
              {loading ? 'ƒêang t·∫£i...' : 'Kh√¥ng c√≥ c√¥ng nh√¢n n√†o'}
            </Text>
          </View>
        }
      />

      {/* Work Detail Modal */}
      <WorkDetailModal
        visible={showWorkModal}
        worker={selectedWorker}
        onClose={() => setShowWorkModal(false)}
        onStartWork={handleStartWork}
        onStopWork={handleStopWork}
        onTaskCompleted={handleTaskCompleted} // üÜï Pass callback
        theme={theme}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  headerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  backButton: {
    marginRight: 16,
    padding: 8,
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  headerRight: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  refreshButton: {
    padding: 8,
    borderRadius: 20,
  },
  statusBar: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
    flexWrap: 'wrap',
  },
  statusItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginHorizontal: 4,
  },
  statusDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
    marginRight: 6,
  },
  statusText: {
    fontSize: 14,
    fontWeight: '500',
  },
  gridContainer: {
    padding: 16,
    paddingBottom: 32,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 64,
  },
  emptyText: {
    fontSize: 16,
    marginTop: 16,
    textAlign: 'center',
  },
});

export default KioskScreen;


--- END: src\screens\KioskScreen.js ---


--- START: src\screens\LeaveRequestScreen.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  StatusBar,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
  TextInput,
  Modal,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import DateTimePicker from '@react-native-community/datetimepicker';
import {
  submitLeaveRequest,
  fetchLeaveRequestsByUser,
} from '../api/requestService';

const LeaveRequestScreen = ({ navigation }) => {
  const { theme, isDarkMode } = useTheme();
  const { user } = useAuth();
  const [loading, setLoading] = useState(false);
  const [leaveRequests, setLeaveRequests] = useState([]);
  const [showForm, setShowForm] = useState(false);

  // Form state
  const [leaveType, setLeaveType] = useState('annual');
  const [startDate, setStartDate] = useState(new Date());
  const [endDate, setEndDate] = useState(new Date());
  const [reason, setReason] = useState('');
  const [showStartPicker, setShowStartPicker] = useState(false);
  const [showEndPicker, setShowEndPicker] = useState(false);

  useEffect(() => {
    loadLeaveRequests();
  }, []);

  const loadLeaveRequests = async () => {
    try {
      setLoading(true);
      if (!user?.uid) return;
      const requests = await fetchLeaveRequestsByUser(user.uid);
      setLeaveRequests(requests);
    } catch (error) {
      console.error('L·ªói khi t·∫£i ƒë∆°n xin ngh·ªâ:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch ƒë∆°n xin ngh·ªâ');
    } finally {
      setLoading(false);
    }
  };

  const getLeaveTypeLabel = (type) => {
    switch (type) {
      case 'annual':
        return 'Ngh·ªâ ph√©p nƒÉm';
      case 'sick':
        return 'Ngh·ªâ ·ªëm';
      case 'personal':
        return 'Ngh·ªâ vi·ªác ri√™ng';
      case 'maternity':
        return 'Ngh·ªâ thai s·∫£n';
      default:
        return 'Kh√°c';
    }
  };

  const getLeaveTypeIcon = (type) => {
    switch (type) {
      case 'annual':
        return 'beach-outline';
      case 'sick':
        return 'medical-outline';
      case 'personal':
        return 'person-outline';
      case 'maternity':
        return 'heart-outline';
      default:
        return 'calendar-outline';
    }
  };

  const getStatusLabel = (status) => {
    switch (status) {
      case 'pending':
        return 'Ch·ªù duy·ªát';
      case 'approved':
        return 'ƒê√£ duy·ªát';
      case 'rejected':
        return 'T·ª´ ch·ªëi';
      default:
        return 'Kh√¥ng x√°c ƒë·ªãnh';
    }
  };

  const getStatusColor = (status) => {
    switch (status) {
      case 'pending':
        return '#FF9800';
      case 'approved':
        return '#4CAF50';
      case 'rejected':
        return '#F44336';
      default:
        return '#9E9E9E';
    }
  };

  const formatDate = (date) => {
    if (!date) return '';
    const d = date.toDate ? date.toDate() : new Date(date);
    return d.toLocaleDateString('vi-VN');
  };

  const calculateDays = (start, end) => {
    const s = start?.toDate ? start.toDate() : new Date(start);
    const e = end?.toDate ? end.toDate() : new Date(end);
    const diffTime = Math.abs(e - s);
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    return diffDays + 1; // Include both start and end date
  };

  const handleSubmitLeaveRequest = async () => {
    if (!reason.trim()) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p l√Ω do ngh·ªâ ph√©p');
      return;
    }

    // Cho ph√©p ngh·ªâ 1 ng√†y: endDate c√≥ th·ªÉ b·∫±ng startDate
    if (endDate < startDate) {
      Alert.alert('L·ªói', 'Ng√†y k·∫øt th√∫c kh√¥ng ƒë∆∞·ª£c tr∆∞·ªõc ng√†y b·∫Øt ƒë·∫ßu');
      return;
    }

    try {
      setLoading(true);
      await submitLeaveRequest({
        userId: user.uid,
        userName: user?.displayName || user?.email || '',
        type: leaveType,
        startDate,
        endDate,
        reason,
      });

      Alert.alert(
        'Th√†nh c√¥ng',
        'ƒê∆°n xin ngh·ªâ ph√©p ƒë√£ ƒë∆∞·ª£c g·ª≠i v√† ƒëang ch·ªù duy·ªát'
      );
      setShowForm(false);
      resetForm();
      await loadLeaveRequests();
    } catch (error) {
      console.error('L·ªói khi g·ª≠i ƒë∆°n xin ngh·ªâ:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ g·ª≠i ƒë∆°n xin ngh·ªâ ph√©p');
    } finally {
      setLoading(false);
    }
  };

  const resetForm = () => {
    setLeaveType('annual');
    setStartDate(new Date());
    setEndDate(new Date());
    setReason('');
  };

  const onStartDateChange = (event, selectedDate) => {
    setShowStartPicker(false);
    if (selectedDate) {
      setStartDate(selectedDate);
      // N·∫øu ng√†y b·∫Øt ƒë·∫ßu sau ng√†y k·∫øt th√∫c hi·ªán t·∫°i th√¨ c·∫≠p nh·∫≠t ng√†y k·∫øt th√∫c = ng√†y b·∫Øt ƒë·∫ßu (ngh·ªâ 1 ng√†y)
      if (selectedDate > endDate) {
        setEndDate(selectedDate);
      }
    }
  };

  const onEndDateChange = (event, selectedDate) => {
    setShowEndPicker(false);
    if (selectedDate) {
      setEndDate(selectedDate);
    }
  };

  if (loading && leaveRequests.length === 0) {
    return (
      <SafeAreaView
        style={[styles.container, { backgroundColor: theme.background }]}
      >
        <StatusBar
          barStyle={isDarkMode ? 'light-content' : 'dark-content'}
          backgroundColor={theme.background}
        />
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
            ƒêang t·∫£i d·ªØ li·ªáu...
          </Text>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <StatusBar
        barStyle={isDarkMode ? 'light-content' : 'dark-content'}
        backgroundColor={theme.background}
      />

      {/* Header */}
      <View style={[styles.header, { backgroundColor: theme.card }]}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={theme.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Xin Ngh·ªâ Ph√©p
        </Text>
        <TouchableOpacity
          style={styles.addButton}
          onPress={() => setShowForm(true)}
        >
          <Ionicons name="add" size={24} color={theme.primary} />
        </TouchableOpacity>
      </View>

      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.scrollContent}
      >
        {/* Th·ªëng k√™ */}
        <View
          style={[
            styles.statsCard,
            { backgroundColor: theme.card, borderColor: theme.border },
          ]}
        >
          <Text style={[styles.statsTitle, { color: theme.text }]}>
            Th·ªëng k√™ ngh·ªâ ph√©p
          </Text>

          <View style={styles.statsGrid}>
            <View style={styles.statItem}>
              <Text style={[styles.statValue, { color: theme.primary }]}>
                {leaveRequests.filter((r) => r.status === 'approved').length}
              </Text>
              <Text style={[styles.statLabel, { color: theme.textSecondary }]}>
                ƒê√£ duy·ªát
              </Text>
            </View>

            <View style={styles.statItem}>
              <Text style={[styles.statValue, { color: '#FF9800' }]}>
                {leaveRequests.filter((r) => r.status === 'pending').length}
              </Text>
              <Text style={[styles.statLabel, { color: theme.textSecondary }]}>
                Ch·ªù duy·ªát
              </Text>
            </View>

            <View style={styles.statItem}>
              <Text style={[styles.statValue, { color: '#F44336' }]}>
                {leaveRequests.filter((r) => r.status === 'rejected').length}
              </Text>
              <Text style={[styles.statLabel, { color: theme.textSecondary }]}>
                T·ª´ ch·ªëi
              </Text>
            </View>
          </View>
        </View>

        {/* Danh s√°ch ƒë∆°n xin ngh·ªâ */}
        <View style={styles.section}>
          <Text style={[styles.sectionTitle, { color: theme.text }]}>
            L·ªãch s·ª≠ ƒë∆°n xin ngh·ªâ
          </Text>

          {leaveRequests.length > 0 ? (
            leaveRequests.map((request) => (
              <View
                key={request.id}
                style={[
                  styles.requestCard,
                  { backgroundColor: theme.card, borderColor: theme.border },
                ]}
              >
                <View style={styles.requestHeader}>
                  <View style={styles.requestType}>
                    <Ionicons
                      name={getLeaveTypeIcon(request.type)}
                      size={20}
                      color={theme.primary}
                    />
                    <Text
                      style={[styles.requestTypeText, { color: theme.text }]}
                    >
                      {getLeaveTypeLabel(request.type)}
                    </Text>
                  </View>

                  <View
                    style={[
                      styles.statusBadge,
                      { backgroundColor: getStatusColor(request.status) },
                    ]}
                  >
                    <Text style={styles.statusText}>
                      {getStatusLabel(request.status)}
                    </Text>
                  </View>
                </View>

                <View style={styles.requestDetails}>
                  <View style={styles.dateRow}>
                    <Ionicons
                      name="calendar-outline"
                      size={16}
                      color={theme.textSecondary}
                    />
                    <Text
                      style={[styles.dateText, { color: theme.textSecondary }]}
                    >
                      {formatDate(request.startDate)} -{' '}
                      {formatDate(request.endDate)}
                    </Text>
                    <Text style={[styles.daysText, { color: theme.primary }]}>
                      ({calculateDays(request.startDate, request.endDate)} ng√†y)
                    </Text>
                  </View>

                  <View style={styles.reasonRow}>
                    <Ionicons
                      name="chatbubble-outline"
                      size={16}
                      color={theme.textSecondary}
                    />
                    <Text style={[styles.reasonText, { color: theme.text }]}>
                      {request.reason}
                    </Text>
                  </View>

                  <View style={styles.submittedRow}>
                    <Ionicons
                      name="time-outline"
                      size={16}
                      color={theme.textSecondary}
                    />
                    <Text
                      style={[
                        styles.submittedText,
                        { color: theme.textSecondary },
                      ]}
                    >
                      G·ª≠i l√∫c: {formatDate(request.submittedAt)}
                    </Text>
                  </View>
                </View>
              </View>
            ))
          ) : (
            <View
              style={[
                styles.emptyCard,
                { backgroundColor: theme.card, borderColor: theme.border },
              ]}
            >
              <Ionicons
                name="document-outline"
                size={48}
                color={theme.textMuted}
              />
              <Text style={[styles.emptyText, { color: theme.textMuted }]}>
                Ch∆∞a c√≥ ƒë∆°n xin ngh·ªâ n√†o
              </Text>
            </View>
          )}
        </View>
      </ScrollView>

      {/* Modal form xin ngh·ªâ ph√©p */}
      <Modal
        visible={showForm}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setShowForm(false)}
      >
        <View style={styles.modalOverlay}>
          <View
            style={[styles.modalContent, { backgroundColor: theme.background }]}
          >
            <View style={styles.modalHeader}>
              <Text style={[styles.modalTitle, { color: theme.text }]}>
                ƒêƒÉng k√Ω ngh·ªâ ph√©p
              </Text>
              <TouchableOpacity
                style={styles.closeButton}
                onPress={() => setShowForm(false)}
              >
                <Ionicons name="close" size={24} color={theme.text} />
              </TouchableOpacity>
            </View>

            <ScrollView style={styles.formScroll}>
              {/* Lo·∫°i ngh·ªâ ph√©p */}
              <View style={styles.formSection}>
                <Text style={[styles.formLabel, { color: theme.text }]}>
                  Lo·∫°i ngh·ªâ ph√©p
                </Text>
                <View style={styles.typeSelector}>
                  {[
                    {
                      key: 'annual',
                      label: 'Ngh·ªâ ph√©p nƒÉm',
                      icon: 'beach-outline',
                    },
                    { key: 'sick', label: 'Ngh·ªâ ·ªëm', icon: 'medical-outline' },
                    {
                      key: 'personal',
                      label: 'Vi·ªác ri√™ng',
                      icon: 'person-outline',
                    },
                    {
                      key: 'maternity',
                      label: 'Thai s·∫£n',
                      icon: 'heart-outline',
                    },
                  ].map((type) => (
                    <TouchableOpacity
                      key={type.key}
                      style={[
                        styles.typeOption,
                        {
                          backgroundColor:
                            leaveType === type.key ? theme.primary : theme.card,
                          borderColor: theme.border,
                        },
                      ]}
                      onPress={() => setLeaveType(type.key)}
                    >
                      <Ionicons
                        name={type.icon}
                        size={20}
                        color={leaveType === type.key ? '#fff' : theme.text}
                      />
                      <Text
                        style={[
                          styles.typeOptionText,
                          {
                            color: leaveType === type.key ? '#fff' : theme.text,
                          },
                        ]}
                      >
                        {type.label}
                      </Text>
                    </TouchableOpacity>
                  ))}
                </View>
              </View>

              {/* Ng√†y b·∫Øt ƒë·∫ßu */}
              <View style={styles.formSection}>
                <Text style={[styles.formLabel, { color: theme.text }]}>
                  Ng√†y b·∫Øt ƒë·∫ßu
                </Text>
                <TouchableOpacity
                  style={[
                    styles.dateInput,
                    { backgroundColor: theme.card, borderColor: theme.border },
                  ]}
                  onPress={() => setShowStartPicker(true)}
                >
                  <Ionicons
                    name="calendar-outline"
                    size={20}
                    color={theme.textSecondary}
                  />
                  <Text style={[styles.dateInputText, { color: theme.text }]}>
                    {formatDate(startDate)}
                  </Text>
                </TouchableOpacity>
              </View>

              {/* Ng√†y k·∫øt th√∫c */}
              <View style={styles.formSection}>
                <Text style={[styles.formLabel, { color: theme.text }]}>
                  Ng√†y k·∫øt th√∫c
                </Text>
                <TouchableOpacity
                  style={[
                    styles.dateInput,
                    { backgroundColor: theme.card, borderColor: theme.border },
                  ]}
                  onPress={() => setShowEndPicker(true)}
                >
                  <Ionicons
                    name="calendar-outline"
                    size={20}
                    color={theme.textSecondary}
                  />
                  <Text style={[styles.dateInputText, { color: theme.text }]}>
                    {formatDate(endDate)}
                  </Text>
                </TouchableOpacity>
              </View>

              {/* L√Ω do */}
              <View style={styles.formSection}>
                <Text style={[styles.formLabel, { color: theme.text }]}>
                  L√Ω do ngh·ªâ ph√©p
                </Text>
                <TextInput
                  style={[
                    styles.reasonInput,
                    {
                      backgroundColor: theme.card,
                      borderColor: theme.border,
                      color: theme.text,
                    },
                  ]}
                  placeholder="Nh·∫≠p l√Ω do ngh·ªâ ph√©p..."
                  placeholderTextColor={theme.textMuted}
                  value={reason}
                  onChangeText={setReason}
                  multiline
                  numberOfLines={4}
                  textAlignVertical="top"
                />
              </View>

              {/* Th√¥ng tin t·ªïng quan */}
              <View
                style={[
                  styles.summaryInfo,
                  { backgroundColor: theme.cardBackground },
                ]}
              >
                <Text style={[styles.summaryInfoTitle, { color: theme.text }]}>
                  T·ªïng quan
                </Text>
                <Text
                  style={[
                    styles.summaryInfoText,
                    { color: theme.textSecondary },
                  ]}
                >
                  S·ªë ng√†y ngh·ªâ: {calculateDays(startDate, endDate)} ng√†y
                </Text>
                <Text
                  style={[
                    styles.summaryInfoText,
                    { color: theme.textSecondary },
                  ]}
                >
                  Lo·∫°i: {getLeaveTypeLabel(leaveType)}
                </Text>
              </View>
            </ScrollView>

            {/* N√∫t g·ª≠i */}
            <View style={styles.formActions}>
              <TouchableOpacity
                style={[styles.cancelButton, { borderColor: theme.border }]}
                onPress={() => setShowForm(false)}
              >
                <Text style={[styles.cancelButtonText, { color: theme.text }]}>
                  H·ªßy
                </Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.submitButton,
                  { backgroundColor: theme.primary },
                ]}
                onPress={handleSubmitLeaveRequest}
                disabled={loading}
              >
                {loading ? (
                  <ActivityIndicator color="#fff" size="small" />
                ) : (
                  <Text style={styles.submitButtonText}>G·ª≠i ƒë∆°n</Text>
                )}
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Date Pickers */}
      {showStartPicker && (
        <DateTimePicker
          value={startDate}
          mode="date"
          display="default"
          onChange={onStartDateChange}
          minimumDate={new Date()}
        />
      )}

      {showEndPicker && (
        <DateTimePicker
          value={endDate}
          mode="date"
          display="default"
          onChange={onEndDateChange}
          minimumDate={startDate}
        />
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  addButton: {
    padding: 4,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    padding: 16,
    paddingBottom: 32,
  },
  statsCard: {
    borderRadius: 12,
    padding: 20,
    marginBottom: 20,
    borderWidth: 1,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  statsTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 16,
    textAlign: 'center',
  },
  statsGrid: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  statItem: {
    alignItems: 'center',
  },
  statValue: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  statLabel: {
    fontSize: 12,
    textAlign: 'center',
  },
  section: {
    marginBottom: 24,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  requestCard: {
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  requestHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  requestType: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  requestTypeText: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  statusBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  statusText: {
    fontSize: 12,
    fontWeight: '500',
    color: 'white',
  },
  requestDetails: {
    gap: 8,
  },
  dateRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  dateText: {
    fontSize: 14,
  },
  daysText: {
    fontSize: 14,
    fontWeight: '500',
  },
  reasonRow: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    gap: 8,
  },
  reasonText: {
    fontSize: 14,
    flex: 1,
  },
  submittedRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  submittedText: {
    fontSize: 12,
  },
  emptyCard: {
    borderRadius: 12,
    padding: 40,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderStyle: 'dashed',
  },
  emptyText: {
    fontSize: 16,
    marginTop: 12,
    textAlign: 'center',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    minHeight: '80%',
    maxHeight: '90%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  closeButton: {
    padding: 4,
  },
  formScroll: {
    padding: 20,
  },
  formSection: {
    marginBottom: 20,
  },
  formLabel: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 8,
  },
  typeSelector: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  typeOption: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 8,
    borderWidth: 1,
    gap: 6,
    minWidth: '45%',
  },
  typeOptionText: {
    fontSize: 12,
    fontWeight: '500',
  },
  dateInput: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 8,
    borderWidth: 1,
    gap: 12,
  },
  dateInputText: {
    fontSize: 16,
  },
  reasonInput: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 8,
    borderWidth: 1,
    fontSize: 16,
    minHeight: 100,
  },
  summaryInfo: {
    padding: 16,
    borderRadius: 8,
    marginTop: 20,
  },
  summaryInfoTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  summaryInfoText: {
    fontSize: 14,
    marginBottom: 4,
  },
  formActions: {
    flexDirection: 'row',
    padding: 20,
    gap: 12,
    borderTopWidth: 1,
    borderTopColor: '#e0e0e0',
  },
  cancelButton: {
    flex: 1,
    paddingVertical: 16,
    borderRadius: 8,
    borderWidth: 1,
    alignItems: 'center',
  },
  cancelButtonText: {
    fontSize: 16,
    fontWeight: '500',
  },
  submitButton: {
    flex: 2,
    paddingVertical: 16,
    borderRadius: 8,
    alignItems: 'center',
  },
  submitButtonText: {
    fontSize: 16,
    fontWeight: '500',
    color: '#fff',
  },
});

export default LeaveRequestScreen;




--- END: src\screens\LeaveRequestScreen.js ---


--- START: src\screens\LoginScreen.js ---
//src/screens/LoginScreen.js
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  Image,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  ActivityIndicator,
  Alert,
  Dimensions,
  Keyboard,
} from 'react-native';
import { useAuth } from '../contexts/AuthContext';
import { Ionicons } from '@expo/vector-icons';
import { SafeAreaView } from 'react-native-safe-area-context';
import StyledTextInput from '../components/StyledTextInput';

const { width, height } = Dimensions.get('window');

const LoginScreen = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [isEmailValid, setIsEmailValid] = useState(true);
  const [isFormValid, setIsFormValid] = useState(false);
  const [isLoggingIn, setIsLoggingIn] = useState(false);
  const [keyboardVisible, setKeyboardVisible] = useState(false);

  const passwordRef = useRef(null);
  const { login, error } = useAuth();

  // Ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa form
  useEffect(() => {
    const validateEmail = (email) => {
      const re =
        /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
      return re.test(String(email).toLowerCase());
    };

    const isValid =
      email.trim() !== '' && password.trim() !== '' && validateEmail(email);

    setIsEmailValid(email === '' || validateEmail(email));
    setIsFormValid(isValid);
  }, [email, password]);

  // Theo d√µi tr·∫°ng th√°i hi·ªÉn th·ªã c·ªßa b√†n ph√≠m
  useEffect(() => {
    const keyboardDidShowListener = Keyboard.addListener(
      'keyboardDidShow',
      () => {
        setKeyboardVisible(true);
      }
    );
    const keyboardDidHideListener = Keyboard.addListener(
      'keyboardDidHide',
      () => {
        setKeyboardVisible(false);
      }
    );

    return () => {
      keyboardDidShowListener.remove();
      keyboardDidHideListener.remove();
    };
  }, []);

  // X·ª≠ l√Ω ƒëƒÉng nh·∫≠p
  const handleLogin = async () => {
    if (!isFormValid) {
      Alert.alert('L·ªói ƒëƒÉng nh·∫≠p', 'Vui l√≤ng nh·∫≠p email v√† m·∫≠t kh·∫©u h·ª£p l·ªá');
      return;
    }

    Keyboard.dismiss();
    setIsLoggingIn(true);
    try {
      const success = await login(email, password);
      if (!success) {
        console.log('ƒêƒÉng nh·∫≠p th·∫•t b·∫°i');
      }
    } catch (error) {
      console.error('L·ªói khi ƒëƒÉng nh·∫≠p:', error);
      Alert.alert(
        'L·ªói ƒëƒÉng nh·∫≠p',
        'ƒê√£ x·∫£y ra l·ªói khi ƒëƒÉng nh·∫≠p. Vui l√≤ng th·ª≠ l·∫°i sau.'
      );
    } finally {
      setIsLoggingIn(false);
    }
  };

  // X·ª≠ l√Ω qu√™n m·∫≠t kh·∫©u
  const handleForgotPassword = () => {
    // S·∫Ω tri·ªÉn khai sau
    Alert.alert(
      'Qu√™n m·∫≠t kh·∫©u',
      'T√≠nh nƒÉng n√†y s·∫Ω ƒë∆∞·ª£c tri·ªÉn khai trong phi√™n b·∫£n ti·∫øp theo.'
    );
  };

  // T·∫°o n√∫t hi·ªÉn th·ªã/·∫©n m·∫≠t kh·∫©u
  const PasswordToggleButton = (
    <TouchableOpacity
      onPress={() => setShowPassword(!showPassword)}
      style={styles.passwordToggle}
    >
      <Ionicons
        name={showPassword ? 'eye-off-outline' : 'eye-outline'}
        size={20}
        color="#666"
      />
    </TouchableOpacity>
  );

  return (
    <SafeAreaView style={styles.safeArea}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.container}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 0 : 20}
      >
        <ScrollView
          contentContainerStyle={[
            styles.scrollContainer,
            keyboardVisible && { justifyContent: 'flex-start', paddingTop: 20 },
          ]}
          keyboardShouldPersistTaps="handled"
          showsVerticalScrollIndicator={false}
        >
          <View
            style={[
              styles.logoContainer,
              keyboardVisible && {
                marginBottom: 10,
                transform: [{ scale: 0.8 }],
              },
            ]}
          >
            <Image
              source={require('../../assets/logo-placeholder.png')}
              style={styles.logo}
              resizeMode="contain"
            />
            <Text style={styles.appName}>T√¢n H√≤a Ph√°t</Text>
            <Text style={styles.appDescription}>
              H·ªá th·ªëng qu·∫£n l√Ω kh√°ch h√†ng
            </Text>
          </View>

          <View style={styles.formContainer}>
            <Text style={styles.welcomeText}>ƒêƒÉng nh·∫≠p</Text>

            <StyledTextInput
              iconName="mail-outline"
              placeholder="Email"
              value={email}
              onChangeText={setEmail}
              keyboardType="email-address"
              autoCapitalize="none"
              returnKeyType="next"
              blurOnSubmit={false}
              onSubmitEditing={() => passwordRef.current.focus()}
              error={!isEmailValid ? 'Email kh√¥ng h·ª£p l·ªá' : null}
            />

            <StyledTextInput
              ref={passwordRef}
              iconName="lock-closed-outline"
              placeholder="M·∫≠t kh·∫©u"
              value={password}
              onChangeText={setPassword}
              secureTextEntry={!showPassword}
              returnKeyType="done"
              onSubmitEditing={handleLogin}
              rightIcon={PasswordToggleButton}
            />

            <TouchableOpacity
              style={styles.forgotPassword}
              onPress={handleForgotPassword}
            >
              <Text style={styles.forgotPasswordText}>Qu√™n m·∫≠t kh·∫©u?</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.loginButton,
                (!isFormValid || isLoggingIn) && styles.loginButtonDisabled,
              ]}
              onPress={handleLogin}
              disabled={!isFormValid || isLoggingIn}
            >
              {isLoggingIn ? (
                <ActivityIndicator color="#fff" size="small" />
              ) : (
                <Text style={styles.loginButtonText}>ƒêƒÉng nh·∫≠p</Text>
              )}
            </TouchableOpacity>

            {error && (
              <View style={styles.errorContainer}>
                <Ionicons
                  name="alert-circle-outline"
                  size={18}
                  color="#e74c3c"
                />
                <Text style={styles.errorMessage}>{error}</Text>
              </View>
            )}
          </View>

          {!keyboardVisible && (
            <View style={styles.footer}>
              <Text style={styles.footerText}>
                ¬© 2023 T√¢n H√≤a Ph√°t. All rights reserved.
              </Text>
            </View>
          )}
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  scrollContainer: {
    flexGrow: 1,
    justifyContent: 'center',
    padding: 20,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 30,
  },
  logo: {
    width: 100,
    height: 100,
    marginBottom: 10,
  },
  appName: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#0066cc',
    marginBottom: 5,
  },
  appDescription: {
    fontSize: 16,
    color: '#666',
  },
  formContainer: {
    backgroundColor: '#fff',
    borderRadius: 10,
    padding: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
    marginBottom: 20,
    width: '100%',
  },
  welcomeText: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center',
    color: '#333',
  },
  passwordToggle: {
    padding: 8,
  },
  forgotPassword: {
    alignSelf: 'flex-end',
    marginBottom: 20,
  },
  forgotPasswordText: {
    color: '#0066cc',
    fontSize: 14,
  },
  loginButton: {
    backgroundColor: '#0066cc',
    borderRadius: 8,
    paddingVertical: 14,
    alignItems: 'center',
    justifyContent: 'center',
  },
  loginButtonDisabled: {
    backgroundColor: '#ccc',
  },
  loginButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#fde2e2',
    padding: 10,
    borderRadius: 8,
    marginTop: 15,
  },
  errorMessage: {
    color: '#e74c3c',
    fontSize: 14,
    marginLeft: 5,
    flex: 1,
  },
  footer: {
    marginTop: 20,
    alignItems: 'center',
  },
  footerText: {
    color: '#999',
    fontSize: 12,
  },
});

export default LoginScreen;


--- END: src\screens\LoginScreen.js ---


--- START: src\screens\MachinesManagementScreen.js ---
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  FlatList,
  Modal,
  ActivityIndicator,
  Alert,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import machineService from '../api/machineService';

const STATUS_OPTIONS = [
  { key: 'all', label: 'T·∫•t c·∫£' },
  { key: 'active', label: 'ƒêang ho·∫°t ƒë·ªông' },
  { key: 'maintenance', label: 'B·∫£o tr√¨' },
  { key: 'broken', label: 'H·ªèng' },
  { key: 'retired', label: 'Ng·ª´ng s·ª≠ d·ª•ng' },
];

const MachinesManagementScreen = ({ navigation }) => {
  const { theme } = useTheme();

  const [loading, setLoading] = useState(false);
  const [items, setItems] = useState([]);
  const [keyword, setKeyword] = useState('');
  const [status, setStatus] = useState('all');

  const [editVisible, setEditVisible] = useState(false);
  const [editing, setEditing] = useState(null);

  const load = async () => {
    setLoading(true);
    try {
      const data = await machineService.listMachines({
        keyword,
        status: status === 'all' ? undefined : status,
      });
      setItems(data);
    } catch (e) {
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch m√°y m√≥c');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    load();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [status]);

  const openCreate = () => {
    setEditing({
      code: '',
      name: '',
      model: '',
      vendor: '',
      location: '',
      status: 'active',
      notes: '',
    });
    setEditVisible(true);
  };

  const openEdit = (m) => {
    setEditing({ ...m });
    setEditVisible(true);
  };

  const save = async () => {
    try {
      setLoading(true);
      const payload = { ...editing };
      if (payload.id) {
        const id = payload.id;
        delete payload.id;
        await machineService.updateMachine(id, payload);
      } else {
        await machineService.createMachine(payload);
      }
      setEditVisible(false);
      await load();
    } catch (e) {
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ l∆∞u m√°y');
    } finally {
      setLoading(false);
    }
  };

  const remove = async (id) => {
    Alert.alert('X√°c nh·∫≠n', 'X√≥a m√°y n√†y?', [
      { text: 'H·ªßy', style: 'cancel' },
      {
        text: 'X√≥a',
        style: 'destructive',
        onPress: async () => {
          try {
            setLoading(true);
            await machineService.deleteMachine(id);
            await load();
          } catch (e) {
            Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ x√≥a');
          } finally {
            setLoading(false);
          }
        },
      },
    ]);
  };

  const renderItem = ({ item }) => (
    <TouchableOpacity
      style={[styles.item, { backgroundColor: theme.card }]}
      onPress={() => openEdit(item)}
    >
      <View style={{ flex: 1 }}>
        <Text style={[styles.itemTitle, { color: theme.text }]}>
          {item.code || '-'} ¬∑ {item.name || 'M√°y'}
        </Text>
        <Text style={{ color: theme.textSecondary, fontSize: 12 }}>
          {item.model || ''} {item.vendor ? '‚Ä¢ ' + item.vendor : ''}{' '}
          {item.location ? '‚Ä¢ ' + item.location : ''}
        </Text>
      </View>
      <View style={[styles.badge, { borderColor: theme.border }]}>
        <Text style={{ color: theme.textSecondary, fontSize: 12 }}>
          {STATUS_OPTIONS.find((s) => s.key === item.status)?.label || '‚Äî'}
        </Text>
      </View>
      <TouchableOpacity
        onPress={() => remove(item.id)}
        style={{ paddingHorizontal: 8 }}
      >
        <Ionicons
          name="trash-outline"
          size={18}
          color={theme.error || '#d00'}
        />
      </TouchableOpacity>
    </TouchableOpacity>
  );

  return (
    <View style={[styles.container, { backgroundColor: theme.background }]}>
      <View style={[styles.header, { backgroundColor: theme.primary }]}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back" size={24} color="#fff" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Qu·∫£n l√Ω m√°y m√≥c</Text>
        <View style={{ width: 24 }} />
      </View>

      <View style={styles.toolbar}>
        <View style={[styles.searchBox, { borderColor: theme.border }]}>
          <Ionicons name="search" size={16} color={theme.textSecondary} />
          <TextInput
            placeholder="T√¨m m√£, t√™n, v·ªã tr√≠, h√£ng..."
            placeholderTextColor={theme.textMuted}
            style={{ flex: 1, color: theme.text, paddingHorizontal: 8 }}
            value={keyword}
            onChangeText={setKeyword}
            onSubmitEditing={load}
            returnKeyType="search"
          />
          {keyword ? (
            <TouchableOpacity
              onPress={() => {
                setKeyword('');
                load();
              }}
            >
              <Ionicons name="close-circle" size={16} color={theme.textMuted} />
            </TouchableOpacity>
          ) : null}
        </View>
        <View style={styles.filtersRow}>
          {STATUS_OPTIONS.map((s) => (
            <TouchableOpacity
              key={s.key}
              style={[
                styles.chip,
                {
                  borderColor: theme.border,
                  backgroundColor:
                    status === s.key ? theme.primary + '22' : 'transparent',
                },
              ]}
              onPress={() => setStatus(s.key)}
            >
              <Text
                style={{ color: status === s.key ? theme.primary : theme.text }}
              >
                {s.label}
              </Text>
            </TouchableOpacity>
          ))}
        </View>
      </View>

      {loading ? (
        <ActivityIndicator style={{ marginTop: 16 }} color={theme.primary} />
      ) : (
        <FlatList
          data={items}
          keyExtractor={(it) => it.id}
          renderItem={renderItem}
          contentContainerStyle={{ padding: 12 }}
          ListEmptyComponent={
            <Text
              style={{
                color: theme.textSecondary,
                textAlign: 'center',
                marginTop: 24,
              }}
            >
              Ch∆∞a c√≥ m√°y n√†o
            </Text>
          }
        />
      )}

      <TouchableOpacity
        style={[styles.fab, { backgroundColor: theme.primary }]}
        onPress={openCreate}
      >
        <Ionicons name="add" size={24} color="#fff" />
      </TouchableOpacity>

      <Modal
        visible={editVisible}
        transparent
        animationType="slide"
        onRequestClose={() => setEditVisible(false)}
      >
        <View style={styles.modalBackdrop}>
          <View style={[styles.modalContent, { backgroundColor: theme.card }]}>
            <Text style={[styles.modalTitle, { color: theme.text }]}>
              {editing?.id ? 'S·ª≠a m√°y' : 'Th√™m m√°y'}
            </Text>

            <View style={styles.formRow}>
              <TextInput
                placeholder="M√£ m√°y"
                placeholderTextColor={theme.textMuted}
                value={editing?.code}
                onChangeText={(v) => setEditing((e) => ({ ...e, code: v }))}
                style={[
                  styles.input,
                  { color: theme.text, borderColor: theme.border },
                ]}
              />
            </View>
            <View style={styles.formRow}>
              <TextInput
                placeholder="T√™n m√°y"
                placeholderTextColor={theme.textMuted}
                value={editing?.name}
                onChangeText={(v) => setEditing((e) => ({ ...e, name: v }))}
                style={[
                  styles.input,
                  { color: theme.text, borderColor: theme.border },
                ]}
              />
            </View>
            <View style={styles.formRow}>
              <TextInput
                placeholder="Model"
                placeholderTextColor={theme.textMuted}
                value={editing?.model}
                onChangeText={(v) => setEditing((e) => ({ ...e, model: v }))}
                style={[
                  styles.input,
                  { color: theme.text, borderColor: theme.border },
                ]}
              />
            </View>
            <View style={styles.formRow}>
              <TextInput
                placeholder="H√£ng (Vendor)"
                placeholderTextColor={theme.textMuted}
                value={editing?.vendor}
                onChangeText={(v) => setEditing((e) => ({ ...e, vendor: v }))}
                style={[
                  styles.input,
                  { color: theme.text, borderColor: theme.border },
                ]}
              />
            </View>
            <View style={styles.formRow}>
              <TextInput
                placeholder="V·ªã tr√≠"
                placeholderTextColor={theme.textMuted}
                value={editing?.location}
                onChangeText={(v) => setEditing((e) => ({ ...e, location: v }))}
                style={[
                  styles.input,
                  { color: theme.text, borderColor: theme.border },
                ]}
              />
            </View>
            <View style={styles.formRow}>
              <TextInput
                placeholder="Tr·∫°ng th√°i (active/maintenance/broken/retired)"
                placeholderTextColor={theme.textMuted}
                value={editing?.status}
                onChangeText={(v) => setEditing((e) => ({ ...e, status: v }))}
                style={[
                  styles.input,
                  { color: theme.text, borderColor: theme.border },
                ]}
              />
            </View>
            <View style={styles.formRow}>
              <TextInput
                placeholder="Ghi ch√∫"
                placeholderTextColor={theme.textMuted}
                value={editing?.notes}
                onChangeText={(v) => setEditing((e) => ({ ...e, notes: v }))}
                style={[
                  styles.input,
                  { color: theme.text, borderColor: theme.border },
                ]}
              />
            </View>

            <View style={styles.modalActions}>
              <TouchableOpacity
                style={[styles.modalButton]}
                onPress={() => setEditVisible(false)}
              >
                <Text style={{ color: theme.text }}>Hu·ª∑</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.modalButton, { backgroundColor: theme.primary }]}
                onPress={save}
              >
                <Text style={{ color: '#fff' }}>L∆∞u</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1 },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 12,
    paddingTop: Platform.OS === 'ios' ? 52 : 20,
  },
  headerTitle: { color: '#fff', fontSize: 18, fontWeight: 'bold' },
  toolbar: { padding: 12 },
  searchBox: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
  },
  filtersRow: { flexDirection: 'row', flexWrap: 'wrap', gap: 8, marginTop: 8 },
  chip: {
    paddingVertical: 6,
    paddingHorizontal: 10,
    borderRadius: 16,
    borderWidth: 1,
  },
  item: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    borderRadius: 10,
    marginBottom: 10,
  },
  itemTitle: { fontSize: 14, fontWeight: '600' },
  badge: {
    borderWidth: 1,
    paddingVertical: 4,
    paddingHorizontal: 8,
    borderRadius: 12,
    marginHorizontal: 8,
  },
  fab: {
    position: 'absolute',
    bottom: 20,
    right: 20,
    width: 56,
    height: 56,
    borderRadius: 28,
    alignItems: 'center',
    justifyContent: 'center',
    elevation: 4,
  },
  modalBackdrop: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    alignItems: 'center',
    justifyContent: 'center',
  },
  modalContent: { width: '90%', borderRadius: 12, padding: 16 },
  modalTitle: { fontSize: 18, fontWeight: 'bold', marginBottom: 12 },
  formRow: { marginBottom: 8 },
  input: { borderWidth: 1, borderRadius: 8, padding: 10 },
  modalActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 10,
    marginTop: 8,
  },
  modalButton: { paddingVertical: 10, paddingHorizontal: 14, borderRadius: 8 },
});

export default MachinesManagementScreen;


--- END: src\screens\MachinesManagementScreen.js ---


--- START: src\screens\ManualQuotationScreen.js ---
import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  FlatList,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  Alert,
  Modal,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { Picker } from '@react-native-picker/picker';
import SearchInventoryModal from '../components/SearchInventoryModal';

const MATERIAL_OPTIONS = ['SUS304', 'SS400', 'SUS316', 'SUS304 2B', 'Kh√°c'];

const UNIT_OPTIONS = ['C√°i', 'C√¢y', 'B·ªô', 'Kg', 'm'];

const ManualQuotationScreen = ({ route, navigation }) => {
  const {
    projectId,
    projectName,
    project,
    existingMaterials,
    isRequote,
    originalQuotationId,
  } = route.params;

  const [materials, setMaterials] = useState(() => {
    // N·∫øu l√† requote v√† c√≥ existingMaterials, s·ª≠ d·ª•ng d·ªØ li·ªáu c≈©
    if (isRequote && existingMaterials && Array.isArray(existingMaterials)) {
      return existingMaterials.map((item, index) => {
        const quantity = parseFloat(item.quantity) || 0;
        const unitPrice = parseFloat(item.unitPrice) || 0;
        const totalPrice = quantity * unitPrice; // T√≠nh l·∫°i totalPrice

        return {
          stt: item.no || item.stt || '', // L·∫•y STT t·ª´ tr∆∞·ªùng 'no' (ƒë∆∞·ª£c l∆∞u trong Firestore) ho·∫∑c 'stt'
          name: item.name || '',
          material: item.material || MATERIAL_OPTIONS[0],
          unit: item.unit || UNIT_OPTIONS[0],
          quantity: item.quantity ? item.quantity.toString() : '',
          unitPrice: item.unitPrice ? item.unitPrice.toString() : '0',
          totalPrice: totalPrice, // S·ª≠ d·ª•ng totalPrice ƒë√£ t√≠nh l·∫°i
          selected: false,
        };
      });
    }

    // N·∫øu kh√¥ng ph·∫£i requote, s·ª≠ d·ª•ng d·ªØ li·ªáu m·∫∑c ƒë·ªãnh
    return [
      {
        stt: '', // ƒê·ªÉ tr·ªëng STT nh∆∞ QuotationScreen
        name: '',
        material: MATERIAL_OPTIONS[0],
        unit: UNIT_OPTIONS[0],
        quantity: '',
        unitPrice: '0',
        totalPrice: 0,
        selected: false,
      },
    ];
  });

  const [searchModalVisible, setSearchModalVisible] = useState(false);
  const [activeSearchIndex, setActiveSearchIndex] = useState(-1);

  // Add new states for bulk price update
  const [showBulkPriceModal, setShowBulkPriceModal] = useState(false);
  const [bulkPrice, setBulkPrice] = useState('');
  const [hasSelections, setHasSelections] = useState(false);

  const addMaterialRow = () => {
    setMaterials((prev) => [
      ...prev,
      {
        stt: '', // ƒê·ªÉ tr·ªëng STT nh∆∞ QuotationScreen
        name: '',
        material: MATERIAL_OPTIONS[0],
        unit: UNIT_OPTIONS[0],
        quantity: '',
        unitPrice: '0',
        totalPrice: 0,
        selected: false,
      },
    ]);
  };

  const handleChange = (index, field, value) => {
    setMaterials((prev) => {
      const newArr = [...prev];
      newArr[index][field] = value;

      // Auto-recalculate total
      const qty = parseFloat(newArr[index].quantity) || 0;
      const unitP = parseFloat(newArr[index].unitPrice) || 0;
      newArr[index].totalPrice = qty * unitP;

      // Update hasSelections state if needed
      if (field === 'selected') {
        const anySelected = newArr.some((item) => item.selected);
        setHasSelections(anySelected);
      }

      return newArr;
    });
  };

  const handleSelectFromInventory = (item) => {
    if (activeSearchIndex === -1) return;

    handleChange(activeSearchIndex, 'name', item.name);
    handleChange(activeSearchIndex, 'material', item.material || '');
    handleChange(activeSearchIndex, 'unit', item.unit || 'c√°i');
    // Ensure unitPrice is set correctly
    const price = item.price || item.unitPrice || 0;
    handleChange(activeSearchIndex, 'unitPrice', price.toString());
    // You might want to also bring the item code and description
    handleChange(activeSearchIndex, 'code', item.code || '');
  };

  // Handle bulk price update
  const handleApplyBulkPrice = () => {
    if (!bulkPrice || isNaN(parseFloat(bulkPrice))) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p gi√° h·ª£p l·ªá');
      return;
    }

    const price = parseFloat(bulkPrice);

    setMaterials((prev) => {
      return prev.map((item) => {
        if (item.selected) {
          const qty = parseFloat(item.quantity) || 0;
          return {
            ...item,
            unitPrice: price.toString(),
            totalPrice: qty * price,
          };
        }
        return item;
      });
    });

    setShowBulkPriceModal(false);
    setBulkPrice('');
  };

  const toggleSelectAll = (value) => {
    setMaterials((prev) =>
      prev.map((item) => ({
        ...item,
        selected: value,
      }))
    );
    setHasSelections(value);
  };

  const formatNumber = (num) => {
    if (num === null || num === undefined || num === '') return '0';
    return num.toString();
  };

  const computeSubTotal = () => {
    return materials.reduce((sum, m) => sum + (m.totalPrice || 0), 0);
  };

  const handleContinue = () => {
    // Validate
    if (materials.length === 0) {
      Alert.alert('Th√¥ng b√°o', 'Vui l√≤ng nh·∫≠p √≠t nh·∫•t 1 v·∫≠t t∆∞.');
      return;
    }

    const cleaned = materials.filter((m) => (m.name || '').trim() !== '');

    if (cleaned.length === 0) {
      Alert.alert('Th√¥ng b√°o', 'T√™n v·∫≠t t∆∞ kh√¥ng ƒë∆∞·ª£c b·ªè tr·ªëng.');
      return;
    }

    const subTotal = computeSubTotal();

    const customerData = {
      id: project.customerId || '',
      name: project.customerName || 'Kh√°ch h√†ng',
      address: project.customerAddress || '',
      phone: project.customerPhone || '',
      email: project.customerEmail || '',
      contactPerson: project.customerContactPerson || '',
      taxCode: project.customerTaxCode || '',
    };

    // Remove selected property before navigation
    const cleanedWithoutSelected = cleaned.map(({ selected, ...rest }) => rest);

    navigation.navigate('FinalizeQuotation', {
      materials: cleanedWithoutSelected,
      subTotal,
      projectId,
      projectName: project.name || projectName || 'D·ª± √°n',
      customerData,
      isRequote,
      originalQuotationId,
      isManualQuotation: true, // ƒê√°nh d·∫•u ƒë√¢y l√† manual quotation
    });
  };

  const renderRow = ({ item, index }) => {
    return (
      <View style={styles.row}>
        <TouchableOpacity
          style={styles.checkbox}
          onPress={() => handleChange(index, 'selected', !item.selected)}
        >
          <Ionicons
            name={item.selected ? 'checkbox' : 'square-outline'}
            size={20}
            color={item.selected ? '#0066CC' : '#999'}
          />
        </TouchableOpacity>

        <View
          style={[
            styles.sttCol,
            {
              flex: 0.8,
              justifyContent: 'center',
              backgroundColor: '#f8f8f8',
              borderRightWidth: 1,
              borderRightColor: '#ddd',
              marginRight: 2,
            },
          ]}
        >
          <Text
            style={{
              fontSize: 13,
              fontWeight: 'bold',
              color: '#333',
              textAlign: 'center',
            }}
          >
            {item.stt || ''}
          </Text>
        </View>

        <TextInput
          style={[styles.input, { flex: 2 }]}
          placeholder="T√™n v·∫≠t t∆∞"
          value={item.name}
          onChangeText={(text) => handleChange(index, 'name', text)}
        />

        <TouchableOpacity
          style={[styles.pickerButton, { flex: 1.5 }]}
          onPress={() => {
            setActiveMaterialPicker(index);
            setShowMaterialModal(true);
          }}
        >
          <Text>{item.material || MATERIAL_OPTIONS[0]}</Text>
          <Ionicons name="chevron-down" size={16} color="#666" />
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.pickerButton, { flex: 0.9 }]}
          onPress={() => {
            setActiveUnitPicker(index);
            setShowUnitModal(true);
          }}
        >
          <Text>{item.unit || UNIT_OPTIONS[0]}</Text>
          <Ionicons name="chevron-down" size={16} color="#666" />
        </TouchableOpacity>

        <TextInput
          style={[styles.input, { flex: 0.8 }]}
          placeholder="SL"
          keyboardType="numeric"
          value={item.quantity || ''}
          onChangeText={(text) => handleChange(index, 'quantity', text)}
        />

        <TextInput
          style={[styles.input, { flex: 1 }]}
          placeholder="0"
          keyboardType="numeric"
          value={item.unitPrice || '0'}
          onChangeText={(text) => handleChange(index, 'unitPrice', text)}
        />

        <View style={[styles.totalCol, { flex: 1 }]}>
          <Text>
            {item.totalPrice ? item.totalPrice.toLocaleString('vi-VN') : ''}
          </Text>
        </View>
        <TouchableOpacity
          onPress={() => {
            setActiveSearchIndex(index);
            setSearchModalVisible(true);
          }}
          style={styles.searchIcon}
        >
          <Ionicons name="search" size={20} color="#007AFF" />
        </TouchableOpacity>
      </View>
    );
  };

  const [showMaterialModal, setShowMaterialModal] = useState(false);
  const [showUnitModal, setShowUnitModal] = useState(false);
  const [activeMaterialPicker, setActiveMaterialPicker] = useState(-1);
  const [activeUnitPicker, setActiveUnitPicker] = useState(-1);

  const handleSelectMaterial = (value) => {
    if (activeMaterialPicker >= 0) {
      handleChange(activeMaterialPicker, 'material', value);
    }
    setShowMaterialModal(false);
  };

  const handleSelectUnit = (value) => {
    if (activeUnitPicker >= 0) {
      handleChange(activeUnitPicker, 'unit', value);
    }
    setShowUnitModal(false);
  };

  const subTotal = computeSubTotal();

  return (
    <KeyboardAvoidingView
      style={{ flex: 1 }}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
    >
      <ScrollView contentContainerStyle={{ padding: 16 }}>
        <Text style={styles.title}>
          {isRequote ? 'B√°o Gi√° L·∫°i Th·ªß C√¥ng' : 'B√°o Gi√° Th·ªß C√¥ng'} ‚Äì{' '}
          {projectName}
        </Text>

        <View style={styles.bulkActionContainer}>
          <View style={styles.selectAllContainer}>
            <TouchableOpacity
              style={styles.actionButton}
              onPress={() => toggleSelectAll(true)}
            >
              <Ionicons name="checkbox-outline" size={18} color="#fff" />
              <Text style={styles.actionButtonText}>Ch·ªçn t·∫•t c·∫£</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.actionButton, styles.unselectButton]}
              onPress={() => toggleSelectAll(false)}
            >
              <Ionicons name="square-outline" size={18} color="#fff" />
              <Text style={styles.actionButtonText}>B·ªè ch·ªçn</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.actionButton,
                styles.priceButton,
                !hasSelections && styles.disabledButton,
              ]}
              disabled={!hasSelections}
              onPress={() => setShowBulkPriceModal(true)}
            >
              <Ionicons name="pricetag-outline" size={18} color="#fff" />
              <Text style={styles.actionButtonText}>√Åp d·ª•ng gi√°</Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.tableHeader}>
          <View style={{ width: 30 }}></View>
          <Text style={[styles.headerCell, { flex: 0.8 }]}>STT</Text>
          <Text style={[styles.headerCell, { flex: 2 }]}>T√™n VT</Text>
          <Text style={[styles.headerCell, { flex: 1.5 }]}>V·∫≠t Li·ªáu</Text>
          <Text style={[styles.headerCell, { flex: 0.9 }]}>ƒêVT</Text>
          <Text style={[styles.headerCell, { flex: 0.8 }]}>SL</Text>
          <Text style={[styles.headerCell, { flex: 1 }]}>ƒê∆°n gi√°</Text>
          <Text style={[styles.headerCell, { flex: 1 }]}>Th√†nh ti·ªÅn</Text>
          <View style={{ width: 40 }} />
        </View>

        <FlatList
          data={materials}
          keyExtractor={(_, idx) => idx.toString()}
          renderItem={renderRow}
          scrollEnabled={false}
        />

        <TouchableOpacity style={styles.addBtn} onPress={addMaterialRow}>
          <Ionicons name="add-circle-outline" size={20} color="#fff" />
          <Text style={{ color: '#fff', marginLeft: 6 }}>Th√™m v·∫≠t t∆∞</Text>
        </TouchableOpacity>

        <View style={styles.subTotalRow}>
          <Text style={styles.subTotalLabel}>T·ªïng c·ªông:</Text>
          <Text style={styles.subTotalVal}>
            {subTotal.toLocaleString('vi-VN')} ƒë
          </Text>
        </View>

        <TouchableOpacity style={styles.continueBtn} onPress={handleContinue}>
          <Ionicons name="arrow-forward-circle" size={22} color="#fff" />
          <Text style={{ color: '#fff', marginLeft: 8 }}>Ti·∫øp t·ª•c</Text>
        </TouchableOpacity>
      </ScrollView>

      {/* Material Selection Modal */}
      <Modal
        transparent={true}
        visible={showMaterialModal}
        animationType="slide"
        onRequestClose={() => setShowMaterialModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Ch·ªçn v·∫≠t li·ªáu</Text>
            {MATERIAL_OPTIONS.map((option) => (
              <TouchableOpacity
                key={option}
                style={styles.modalItem}
                onPress={() => handleSelectMaterial(option)}
              >
                <Text style={styles.modalItemText}>{option}</Text>
              </TouchableOpacity>
            ))}
            <TouchableOpacity
              style={styles.modalCloseButton}
              onPress={() => setShowMaterialModal(false)}
            >
              <Text style={styles.modalCloseText}>ƒê√≥ng</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Unit Selection Modal */}
      <Modal
        transparent={true}
        visible={showUnitModal}
        animationType="slide"
        onRequestClose={() => setShowUnitModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Ch·ªçn ƒë∆°n v·ªã t√≠nh</Text>
            {UNIT_OPTIONS.map((option) => (
              <TouchableOpacity
                key={option}
                style={styles.modalItem}
                onPress={() => handleSelectUnit(option)}
              >
                <Text style={styles.modalItemText}>{option}</Text>
              </TouchableOpacity>
            ))}
            <TouchableOpacity
              style={styles.modalCloseButton}
              onPress={() => setShowUnitModal(false)}
            >
              <Text style={styles.modalCloseText}>ƒê√≥ng</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Bulk Price Modal */}
      <Modal
        transparent={true}
        visible={showBulkPriceModal}
        animationType="slide"
        onRequestClose={() => setShowBulkPriceModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>√Åp d·ª•ng gi√° cho m·ª•c ƒë√£ ch·ªçn</Text>

            <TextInput
              style={styles.bulkPriceInput}
              placeholder="Nh·∫≠p ƒë∆°n gi√° √°p d·ª•ng"
              keyboardType="numeric"
              value={bulkPrice}
              onChangeText={setBulkPrice}
              autoFocus
            />

            <View style={styles.bulkPriceActions}>
              <TouchableOpacity
                style={[styles.bulkPriceActionButton, styles.cancelButton]}
                onPress={() => setShowBulkPriceModal(false)}
              >
                <Text style={styles.cancelButtonText}>H·ªßy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.bulkPriceActionButton, styles.applyButton]}
                onPress={handleApplyBulkPrice}
              >
                <Text style={styles.applyButtonText}>√Åp d·ª•ng</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      <SearchInventoryModal
        visible={searchModalVisible}
        onClose={() => setSearchModalVisible(false)}
        onSelect={handleSelectFromInventory}
      />
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  tableHeader: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    paddingVertical: 6,
    alignItems: 'center',
  },
  headerCell: {
    fontWeight: '600',
    textAlign: 'center',
  },
  row: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 4,
  },
  checkbox: {
    width: 30,
    alignItems: 'center',
    justifyContent: 'center',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 4,
    padding: 6,
    marginRight: 4,
    textAlign: 'center',
  },
  pickerContainer: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 4,
    overflow: 'hidden',
    marginRight: 4,
    height: 40,
  },
  totalCol: {
    alignItems: 'flex-end',
    paddingHorizontal: 4,
  },
  sttCol: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingHorizontal: 4,
  },
  sttText: {
    fontSize: 12,
    fontWeight: 'bold',
    color: '#333',
  },
  searchIcon: {
    width: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  addBtn: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#007AFF',
    padding: 10,
    borderRadius: 6,
    alignSelf: 'flex-start',
    marginTop: 8,
  },
  subTotalRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
  },
  subTotalLabel: {
    fontWeight: 'bold',
    fontSize: 16,
  },
  subTotalVal: {
    fontWeight: 'bold',
    fontSize: 16,
    color: '#d11a2a',
  },
  continueBtn: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#28a745',
    justifyContent: 'center',
    padding: 12,
    borderRadius: 8,
    marginTop: 20,
  },
  pickerButton: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 4,
    paddingHorizontal: 10,
    paddingVertical: 8,
    marginRight: 4,
    backgroundColor: '#fff',
  },
  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.5)',
    padding: 20,
  },
  modalContent: {
    backgroundColor: '#fff',
    borderRadius: 10,
    padding: 20,
    width: '80%',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 15,
    textAlign: 'center',
  },
  modalItem: {
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  modalItemText: {
    fontSize: 16,
  },
  modalCloseButton: {
    marginTop: 15,
    backgroundColor: '#0066CC',
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
  },
  modalCloseText: {
    color: '#fff',
    fontWeight: 'bold',
    fontSize: 16,
  },
  bulkActionContainer: {
    marginBottom: 16,
  },
  selectAllContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'flex-start',
    flexWrap: 'wrap',
    gap: 10,
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 6,
    backgroundColor: '#0066CC',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 1.5,
    minWidth: 110,
  },
  unselectButton: {
    backgroundColor: '#6c757d',
  },
  priceButton: {
    backgroundColor: '#28a745',
  },
  actionButtonText: {
    color: '#fff',
    marginLeft: 6,
    fontWeight: '500',
  },
  disabledButton: {
    backgroundColor: '#ccc',
    opacity: 0.7,
  },
  bulkPriceButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#0066CC',
    paddingVertical: 6,
    paddingHorizontal: 10,
    borderRadius: 4,
  },
  bulkPriceText: {
    color: '#fff',
    marginLeft: 5,
  },
  bulkPriceInput: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 4,
    padding: 12,
    fontSize: 16,
    marginTop: 10,
    marginBottom: 20,
  },
  bulkPriceActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  bulkPriceActionButton: {
    paddingVertical: 10,
    paddingHorizontal: 15,
    borderRadius: 4,
    flex: 1,
    marginHorizontal: 5,
    alignItems: 'center',
  },
  cancelButton: {
    backgroundColor: '#f8f9fa',
    borderWidth: 1,
    borderColor: '#ccc',
  },
  cancelButtonText: {
    color: '#333',
  },
  applyButton: {
    backgroundColor: '#28a745',
  },
  applyButtonText: {
    color: '#fff',
    fontWeight: 'bold',
  },
});

export default ManualQuotationScreen;


--- END: src\screens\ManualQuotationScreen.js ---


--- START: src\screens\MaterialManagementScreen.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  FlatList,
  TextInput,
  Modal,
  Alert,
  ActivityIndicator,
  SafeAreaView,
  StatusBar,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import {
  getMaterials,
  addMaterial,
  updateMaterial,
  deleteMaterial,
} from '../api/materialService';
import {
  getFixedCosts,
  addFixedCost,
  updateFixedCost,
  deleteFixedCost,
} from '../api/fixedCostService';

const MaterialManagementScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const { user: currentUser } = useAuth();

  const [activeTab, setActiveTab] = useState('materials'); // 'materials' or 'fixedCosts'
  const [materials, setMaterials] = useState([]);
  const [fixedCosts, setFixedCosts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [modalVisible, setModalVisible] = useState(false);
  const [editingItem, setEditingItem] = useState(null);
  const [formData, setFormData] = useState({
    name: '',
    pricePerKg: '',
    monthlyCost: '',
    description: '',
  });

  // Ki·ªÉm tra quy·ªÅn truy c·∫≠p
  const hasAccess = ['thuong_mai', 'giam_doc', 'ke_toan', 'ky_su'].includes(
    currentUser?.role
  );

  useEffect(() => {
    if (hasAccess) {
      loadData();
    }
  }, [hasAccess, activeTab]);

  const loadData = async () => {
    try {
      setLoading(true);
      if (activeTab === 'materials') {
        const materialsData = await getMaterials();
        setMaterials(materialsData);
      } else {
        const fixedCostsData = await getFixedCosts();
        setFixedCosts(fixedCostsData);
      }
    } catch (error) {
      console.error('L·ªói khi t·∫£i d·ªØ li·ªáu:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch d·ªØ li·ªáu');
    } finally {
      setLoading(false);
    }
  };

  const resetForm = () => {
    setFormData({
      name: '',
      pricePerKg: '',
      monthlyCost: '',
      description: '',
    });
    setEditingItem(null);
  };

  const openAddModal = () => {
    setEditingItem(null);
    resetForm();
    setModalVisible(true);
  };

  const openEditModal = (item) => {
    setEditingItem(item);
    setFormData({
      name: item.name || '',
      pricePerKg: item.pricePerKg?.toString() || '',
      monthlyCost: item.monthlyCost?.toString() || '',
      description: item.description || '',
    });
    setModalVisible(true);
  };

  const handleSave = async () => {
    if (!formData.name.trim()) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p t√™n');
      return;
    }

    if (activeTab === 'materials') {
      if (!formData.pricePerKg || Number(formData.pricePerKg) <= 0) {
        Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p gi√° h·ª£p l·ªá');
        return;
      }
    } else {
      if (!formData.monthlyCost || Number(formData.monthlyCost) <= 0) {
        Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p chi ph√≠ h√†ng th√°ng h·ª£p l·ªá');
        return;
      }
    }

    try {
      if (activeTab === 'materials') {
        const materialData = {
          name: formData.name.trim(),
          pricePerKg: Number(formData.pricePerKg),
          description: formData.description.trim(),
        };

        if (editingItem) {
          await updateMaterial(editingItem.id, materialData, currentUser.uid);
          Alert.alert('Th√†nh c√¥ng', 'C·∫≠p nh·∫≠t v·∫≠t li·ªáu th√†nh c√¥ng');
        } else {
          await addMaterial(materialData, currentUser.uid);
          Alert.alert('Th√†nh c√¥ng', 'Th√™m v·∫≠t li·ªáu th√†nh c√¥ng');
        }
      } else {
        const fixedCostData = {
          name: formData.name.trim(),
          monthlyCost: Number(formData.monthlyCost),
          description: formData.description.trim(),
        };

        if (editingItem) {
          await updateFixedCost(editingItem.id, fixedCostData, currentUser.uid);
          Alert.alert('Th√†nh c√¥ng', 'C·∫≠p nh·∫≠t chi ph√≠ c·ªë ƒë·ªãnh th√†nh c√¥ng');
        } else {
          await addFixedCost(fixedCostData, currentUser.uid);
          Alert.alert('Th√†nh c√¥ng', 'Th√™m chi ph√≠ c·ªë ƒë·ªãnh th√†nh c√¥ng');
        }
      }

      setModalVisible(false);
      loadData();
    } catch (error) {
      console.error('L·ªói khi l∆∞u d·ªØ li·ªáu:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ l∆∞u d·ªØ li·ªáu. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  };

  const handleDelete = (item) => {
    const itemType = activeTab === 'materials' ? 'v·∫≠t li·ªáu' : 'chi ph√≠ c·ªë ƒë·ªãnh';
    Alert.alert(
      'X√°c nh·∫≠n x√≥a',
      `B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a ${itemType} "${item.name}"?`,
      [
        { text: 'H·ªßy', style: 'cancel' },
        {
          text: 'X√≥a',
          style: 'destructive',
          onPress: async () => {
            try {
              if (activeTab === 'materials') {
                await deleteMaterial(item.id);
                Alert.alert('Th√†nh c√¥ng', 'X√≥a v·∫≠t li·ªáu th√†nh c√¥ng');
              } else {
                await deleteFixedCost(item.id);
                Alert.alert('Th√†nh c√¥ng', 'X√≥a chi ph√≠ c·ªë ƒë·ªãnh th√†nh c√¥ng');
              }
              loadData();
            } catch (error) {
              console.error('L·ªói khi x√≥a d·ªØ li·ªáu:', error);
              Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ x√≥a d·ªØ li·ªáu. Vui l√≤ng th·ª≠ l·∫°i.');
            }
          },
        },
      ]
    );
  };

  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
      minimumFractionDigits: 0,
    }).format(amount || 0);
  };

  const renderMaterialItem = ({ item }) => (
    <View
      style={[
        styles.materialCard,
        { backgroundColor: theme.card, borderColor: theme.border },
      ]}
    >
      <View style={styles.materialInfo}>
        <Text style={[styles.materialName, { color: theme.text }]}>
          {item.name}
        </Text>
        {item.description && (
          <Text
            style={[styles.materialDescription, { color: theme.textSecondary }]}
          >
            {item.description}
          </Text>
        )}
        <Text style={[styles.materialPrice, { color: theme.primary }]}>
          {formatCurrency(item.pricePerKg)}/kg
        </Text>
      </View>
      <View style={styles.materialActions}>
        <TouchableOpacity
          onPress={() => openEditModal(item)}
          style={[styles.actionButton, { backgroundColor: theme.primary }]}
        >
          <Ionicons name="pencil" size={16} color="white" />
        </TouchableOpacity>
        <TouchableOpacity
          onPress={() => handleDelete(item)}
          style={[styles.actionButton, { backgroundColor: '#ff4444' }]}
        >
          <Ionicons name="trash" size={16} color="white" />
        </TouchableOpacity>
      </View>
    </View>
  );

  const renderFixedCostItem = ({ item }) => (
    <View
      style={[
        styles.materialCard,
        { backgroundColor: theme.card, borderColor: theme.border },
      ]}
    >
      <View style={styles.materialInfo}>
        <Text style={[styles.materialName, { color: theme.text }]}>
          {item.name}
        </Text>
        {item.description && (
          <Text
            style={[styles.materialDescription, { color: theme.textSecondary }]}
          >
            {item.description}
          </Text>
        )}
        <Text style={[styles.materialPrice, { color: theme.primary }]}>
          {formatCurrency(item.monthlyCost)}/th√°ng
        </Text>
      </View>
      <View style={styles.materialActions}>
        <TouchableOpacity
          onPress={() => openEditModal(item)}
          style={[styles.actionButton, { backgroundColor: theme.primary }]}
        >
          <Ionicons name="pencil" size={16} color="white" />
        </TouchableOpacity>
        <TouchableOpacity
          onPress={() => handleDelete(item)}
          style={[styles.actionButton, { backgroundColor: '#ff4444' }]}
        >
          <Ionicons name="trash" size={16} color="white" />
        </TouchableOpacity>
      </View>
    </View>
  );

  if (!hasAccess) {
    return (
      <SafeAreaView
        style={[styles.container, { backgroundColor: theme.background }]}
      >
        <StatusBar
          barStyle={theme.dark ? 'light-content' : 'dark-content'}
          backgroundColor={theme.background}
        />
        <View style={styles.header}>
          <TouchableOpacity onPress={() => navigation.goBack()}>
            <Ionicons name="arrow-back" size={24} color={theme.text} />
          </TouchableOpacity>
          <Text style={[styles.headerTitle, { color: theme.text }]}>
            Qu·∫£n l√Ω v·∫≠t li·ªáu
          </Text>
          <View style={{ width: 24 }} />
        </View>
        <View style={styles.accessDenied}>
          <Ionicons name="lock-closed" size={60} color={theme.textMuted} />
          <Text
            style={[styles.accessDeniedText, { color: theme.textSecondary }]}
          >
            B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p t√≠nh nƒÉng n√†y
          </Text>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <StatusBar
        barStyle={theme.dark ? 'light-content' : 'dark-content'}
        backgroundColor={theme.background}
      />

      {/* Header */}
      <View style={[styles.header, { borderBottomColor: theme.border }]}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back" size={24} color={theme.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Qu·∫£n l√Ω chi ph√≠ c·ªë ƒë·ªãnh
        </Text>
        <TouchableOpacity onPress={openAddModal}>
          <Ionicons name="add" size={24} color={theme.primary} />
        </TouchableOpacity>
      </View>

      {/* Tabs */}
      <View style={[styles.tabContainer, { borderBottomColor: theme.border }]}>
        <TouchableOpacity
          style={[
            styles.tab,
            activeTab === 'materials' && { borderBottomColor: theme.primary },
          ]}
          onPress={() => setActiveTab('materials')}
        >
          <Text
            style={[
              styles.tabText,
              {
                color:
                  activeTab === 'materials'
                    ? theme.primary
                    : theme.textSecondary,
              },
            ]}
          >
            V·∫≠t li·ªáu
          </Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[
            styles.tab,
            activeTab === 'fixedCosts' && { borderBottomColor: theme.primary },
          ]}
          onPress={() => setActiveTab('fixedCosts')}
        >
          <Text
            style={[
              styles.tabText,
              {
                color:
                  activeTab === 'fixedCosts'
                    ? theme.primary
                    : theme.textSecondary,
              },
            ]}
          >
            Chi ph√≠ c·ªë ƒë·ªãnh
          </Text>
        </TouchableOpacity>
      </View>

      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
            ƒêang t·∫£i...
          </Text>
        </View>
      ) : (
        <FlatList
          data={activeTab === 'materials' ? materials : fixedCosts}
          renderItem={
            activeTab === 'materials' ? renderMaterialItem : renderFixedCostItem
          }
          keyExtractor={(item) => item.id}
          contentContainerStyle={styles.listContainer}
          ListEmptyComponent={
            <View style={styles.emptyContainer}>
              <Ionicons
                name={
                  activeTab === 'materials'
                    ? 'cube-outline'
                    : 'calculator-outline'
                }
                size={60}
                color={theme.textMuted}
              />
              <Text style={[styles.emptyText, { color: theme.textSecondary }]}>
                {activeTab === 'materials'
                  ? 'Ch∆∞a c√≥ v·∫≠t li·ªáu n√†o'
                  : 'Ch∆∞a c√≥ chi ph√≠ c·ªë ƒë·ªãnh n√†o'}
              </Text>
              <TouchableOpacity
                onPress={openAddModal}
                style={[styles.addButton, { backgroundColor: theme.primary }]}
              >
                <Text style={styles.addButtonText}>
                  {activeTab === 'materials'
                    ? 'Th√™m v·∫≠t li·ªáu ƒë·∫ßu ti√™n'
                    : 'Th√™m chi ph√≠ c·ªë ƒë·ªãnh ƒë·∫ßu ti√™n'}
                </Text>
              </TouchableOpacity>
            </View>
          }
        />
      )}

      {/* Modal th√™m/s·ª≠a v·∫≠t li·ªáu */}
      <Modal
        visible={modalVisible}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View
            style={[
              styles.modalContent,
              { backgroundColor: theme.card, borderColor: theme.border },
            ]}
          >
            <View style={styles.modalHeader}>
              <Text style={[styles.modalTitle, { color: theme.text }]}>
                {editingItem
                  ? activeTab === 'materials'
                    ? 'S·ª≠a v·∫≠t li·ªáu'
                    : 'S·ª≠a chi ph√≠ c·ªë ƒë·ªãnh'
                  : activeTab === 'materials'
                  ? 'Th√™m v·∫≠t li·ªáu m·ªõi'
                  : 'Th√™m chi ph√≠ c·ªë ƒë·ªãnh m·ªõi'}
              </Text>
              <TouchableOpacity onPress={() => setModalVisible(false)}>
                <Ionicons name="close" size={24} color={theme.text} />
              </TouchableOpacity>
            </View>

            <View style={styles.formGroup}>
              <Text style={[styles.label, { color: theme.text }]}>
                {activeTab === 'materials'
                  ? 'T√™n v·∫≠t li·ªáu *'
                  : 'T√™n chi ph√≠ c·ªë ƒë·ªãnh *'}
              </Text>
              <TextInput
                style={[
                  styles.input,
                  {
                    backgroundColor: theme.background,
                    color: theme.text,
                    borderColor: theme.border,
                  },
                ]}
                value={formData.name}
                onChangeText={(text) =>
                  setFormData({ ...formData, name: text })
                }
                placeholder={
                  activeTab === 'materials'
                    ? 'V√≠ d·ª•: SUS304, SS400'
                    : 'V√≠ d·ª•: ƒêi·ªán, N∆∞·ªõc, M·∫∑t b·∫±ng'
                }
                placeholderTextColor={theme.textMuted}
              />
            </View>

            {activeTab === 'materials' ? (
              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>
                  Gi√°/kg (VNƒê) *
                </Text>
                <TextInput
                  style={[
                    styles.input,
                    {
                      backgroundColor: theme.background,
                      color: theme.text,
                      borderColor: theme.border,
                    },
                  ]}
                  value={formData.pricePerKg}
                  onChangeText={(text) =>
                    setFormData({
                      ...formData,
                      pricePerKg: text.replace(/[^0-9]/g, ''),
                    })
                  }
                  placeholder="Nh·∫≠p gi√°/kg"
                  placeholderTextColor={theme.textMuted}
                  keyboardType="numeric"
                />
              </View>
            ) : (
              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>
                  Chi ph√≠ h√†ng th√°ng (VNƒê) *
                </Text>
                <TextInput
                  style={[
                    styles.input,
                    {
                      backgroundColor: theme.background,
                      color: theme.text,
                      borderColor: theme.border,
                    },
                  ]}
                  value={formData.monthlyCost}
                  onChangeText={(text) =>
                    setFormData({
                      ...formData,
                      monthlyCost: text.replace(/[^0-9]/g, ''),
                    })
                  }
                  placeholder="Nh·∫≠p chi ph√≠ h√†ng th√°ng"
                  placeholderTextColor={theme.textMuted}
                  keyboardType="numeric"
                />
              </View>
            )}

            <View style={styles.formGroup}>
              <Text style={[styles.label, { color: theme.text }]}>M√¥ t·∫£</Text>
              <TextInput
                style={[
                  styles.textArea,
                  {
                    backgroundColor: theme.background,
                    color: theme.text,
                    borderColor: theme.border,
                  },
                ]}
                value={formData.description}
                onChangeText={(text) =>
                  setFormData({ ...formData, description: text })
                }
                placeholder={
                  activeTab === 'materials'
                    ? 'M√¥ t·∫£ th√™m v·ªÅ v·∫≠t li·ªáu...'
                    : 'M√¥ t·∫£ th√™m v·ªÅ chi ph√≠ c·ªë ƒë·ªãnh...'
                }
                placeholderTextColor={theme.textMuted}
                multiline
                numberOfLines={3}
              />
            </View>

            <View style={styles.modalActions}>
              <TouchableOpacity
                onPress={() => setModalVisible(false)}
                style={[styles.modalButton, { borderColor: theme.border }]}
              >
                <Text style={[styles.modalButtonText, { color: theme.text }]}>
                  H·ªßy
                </Text>
              </TouchableOpacity>
              <TouchableOpacity
                onPress={handleSave}
                style={[styles.modalButton, { backgroundColor: theme.primary }]}
              >
                <Text style={[styles.modalButtonText, { color: 'white' }]}>
                  {editingItem ? 'C·∫≠p nh·∫≠t' : 'Th√™m'}
                </Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  tabContainer: {
    flexDirection: 'row',
    borderBottomWidth: 1,
  },
  tab: {
    flex: 1,
    paddingVertical: 12,
    alignItems: 'center',
    borderBottomWidth: 2,
    borderBottomColor: 'transparent',
  },
  tabText: {
    fontSize: 16,
    fontWeight: '500',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
  },
  listContainer: {
    padding: 16,
  },
  materialCard: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    marginBottom: 12,
    borderRadius: 8,
    borderWidth: 1,
  },
  materialInfo: {
    flex: 1,
  },
  materialName: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  materialDescription: {
    fontSize: 14,
    marginBottom: 4,
  },
  materialPrice: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  materialActions: {
    flexDirection: 'row',
    gap: 8,
  },
  actionButton: {
    width: 32,
    height: 32,
    borderRadius: 16,
    justifyContent: 'center',
    alignItems: 'center',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 40,
  },
  emptyText: {
    fontSize: 16,
    marginTop: 12,
    marginBottom: 20,
    textAlign: 'center',
  },
  addButton: {
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
  },
  addButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  accessDenied: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 40,
  },
  accessDeniedText: {
    fontSize: 16,
    marginTop: 12,
    textAlign: 'center',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    width: '90%',
    maxWidth: 400,
    borderRadius: 12,
    borderWidth: 1,
    padding: 20,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  formGroup: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 8,
  },
  input: {
    borderWidth: 1,
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    fontSize: 16,
  },
  textArea: {
    borderWidth: 1,
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 10,
    fontSize: 16,
    textAlignVertical: 'top',
  },
  modalActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 12,
    marginTop: 20,
  },
  modalButton: {
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 8,
    borderWidth: 1,
    minWidth: 80,
    alignItems: 'center',
  },
  modalButtonText: {
    fontSize: 16,
    fontWeight: '600',
  },
});

export default MaterialManagementScreen;


--- END: src\screens\MaterialManagementScreen.js ---


--- START: src\screens\MaterialPurchaseScreen.js ---
// src/screens/MaterialPurchaseScreen.js
import React, { useState, useEffect, useCallback, memo } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  ActivityIndicator,
  TouchableOpacity,
  Alert,
  SafeAreaView,
  ScrollView,
  Modal,
  TextInput,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';
import { useProjectDetails } from '../hooks/useProjectDetails';
import { useAuth } from '../contexts/AuthContext';
import { db } from '../config/firebaseConfig';
import {
  collection,
  doc,
  getDoc,
  getDocs,
  addDoc,
  updateDoc,
  query,
  orderBy,
  serverTimestamp,
  where,
} from 'firebase/firestore';
import { getQuotationsByProject } from '../api/quotationService';
import {
  getProposalsByStatus,
  updateProposalMaterialPrices,
} from '../api/proposalService';

// Memoized row component for the materials list
const MaterialRow = memo(({ item, index, onTogglePurchased }) => {
  return (
    <View style={styles.tableRow}>
      <TouchableOpacity
        style={styles.checkbox}
        onPress={() => onTogglePurchased(index)}
      >
        <Ionicons
          name={item.purchased ? 'checkbox' : 'square-outline'}
          size={18}
          color={item.purchased ? '#4CAF50' : '#999'}
        />
      </TouchableOpacity>
      <View style={[styles.tableCell, { flex: 3 }]}>
        <Text style={styles.materialName}>{item.name}</Text>
        {item.material ? (
          <Text style={styles.materialType}>{item.material}</Text>
        ) : null}
        {item.quyCach ? (
          <Text style={styles.materialType}>Quy c√°ch: {item.quyCach}</Text>
        ) : null}
      </View>
      <Text style={[styles.tableCell, { flex: 1, textAlign: 'center' }]}>
        {formatNumber(item.quantity)}
      </Text>
      <Text style={[styles.tableCell, { flex: 1, textAlign: 'center' }]}>
        {formatNumber(item.weight)}
      </Text>
      <Text style={[styles.tableCell, { flex: 0.8, textAlign: 'center' }]}>
        {item.unit}
      </Text>
    </View>
  );
});

// Helper functions
const formatNumber = (num) => {
  if (typeof num !== 'number' || isNaN(num)) return '0';
  const roundedNum = Math.round(num * 10) / 10;
  return roundedNum.toString().replace('.', ',');
};

const MaterialPurchaseScreen = ({ route, navigation }) => {
  const { projectId, projectName, project } = route.params;
  const { currentUser } = useAuth();
  const { project: projectDetails, loading: loadingProject } =
    useProjectDetails(projectId);

  const [materials, setMaterials] = useState([]);
  const [purchaseHistory, setPurchaseHistory] = useState([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [selectedForProposal, setSelectedForProposal] = useState([]);
  const [quotations, setQuotations] = useState([]);
  const [approvedProposals, setApprovedProposals] = useState([]);
  const [showPriceModal, setShowPriceModal] = useState(false);
  const [editableMaterials, setEditableMaterials] = useState([]);
  const [currentProposalId, setCurrentProposalId] = useState(null);
  const [loadingProposals, setLoadingProposals] = useState(false);
  const [showConfirmModal, setShowConfirmModal] = useState(false);
  const [purchasedMaterials, setPurchasedMaterials] = useState([]);
  const [showHistoryDetailModal, setShowHistoryDetailModal] = useState(false);
  const [selectedHistory, setSelectedHistory] = useState(null);
  const [historyMaterials, setHistoryMaterials] = useState([]);
  const [updatingHistory, setUpdatingHistory] = useState(false);

  const handleTogglePurchased = (index) => {
    setMaterials((prev) => {
      const updated = [...prev];
      updated[index] = {
        ...updated[index],
        purchased: !updated[index].purchased,
        selectedForProposal: !updated[index].purchased, // ƒê·ªìng b·ªô v·ªõi tr·∫°ng th√°i purchased
      };
      return updated;
    });
  };

  const handleToggleSelectForProposal = (index) => {
    setMaterials((prev) => {
      const arr = [...prev];
      arr[index].selectedForProposal = !arr[index].selectedForProposal;
      return arr;
    });
  };

  const handleCreateProposal = () => {
    // L·ªçc theo thu·ªôc t√≠nh purchased thay v√¨ selectedForProposal
    const selected = materials.filter((m) => m.purchased);
    if (!selected.length)
      return Alert.alert(
        'Ch∆∞a ch·ªçn v·∫≠t t∆∞',
        'Vui l√≤ng tick ch·ªçn c√°c v·∫≠t t∆∞ c·∫ßn mua.'
      );
    navigation.navigate('CreateProposal', {
      projectId,
      projectName: projectDetails?.name || projectName,
      selectedItems: selected,
    });
  };

  // Modified function to show confirmation before saving
  const handleSavePurchaseList = () => {
    const selected = materials.filter((m) => m.purchased);

    if (selected.length === 0) {
      Alert.alert(
        'Ch∆∞a ch·ªçn v·∫≠t t∆∞',
        'Vui l√≤ng tick ch·ªçn c√°c v·∫≠t t∆∞ ƒë√£ mua tr∆∞·ªõc khi l∆∞u.'
      );
      return;
    }

    setPurchasedMaterials(selected);
    setShowConfirmModal(true);
  };

  // New function to actually save the purchase list after confirmation
  const confirmSavePurchaseList = async () => {
    setSaving(true);
    try {
      // Create a map of material names to purchase status
      const purchasedItems = {};
      materials.forEach((item) => {
        purchasedItems[item.name] = item.purchased === true;
      });

      // Save to purchase history collection
      const purchaseRef = collection(db, 'projects', projectId, 'purchases');
      await addDoc(purchaseRef, {
        projectId,
        purchasedItems,
        createdAt: serverTimestamp(),
        createdBy: currentUser?.uid || 'unknown',
        createdByName: currentUser?.displayName || 'Ng∆∞·ªùi d√πng',
      });

      // Calculate if all items are purchased
      const allItems = Object.values(purchasedItems);
      const purchasedCount = allItems.filter((v) => v === true).length;
      const totalCount = allItems.length;

      // Update project task status based on purchase progress
      const projectRef = doc(db, 'projects', projectId);
      await updateDoc(projectRef, {
        'tasks.material_purchasing.status':
          purchasedCount === totalCount ? 'completed' : 'in_progress',
      });

      // Close modal and show success message
      setShowConfirmModal(false);
      Alert.alert(
        'Th√†nh c√¥ng',
        `ƒê√£ l∆∞u danh s√°ch ${purchasedCount} v·∫≠t t∆∞ ƒë√£ mua.`
      );

      // Reload purchase history
      const purchaseQuery = query(purchaseRef, orderBy('createdAt', 'desc'));
      const purchaseSnapshot = await getDocs(purchaseQuery);
      setPurchaseHistory(
        purchaseSnapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }))
      );
    } catch (error) {
      console.error('L·ªói khi l∆∞u danh s√°ch:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ l∆∞u danh s√°ch v·∫≠t t∆∞.');
    } finally {
      setSaving(false);
    }
  };

  // Handle loading quotation materials
  const handleRequote = useCallback(
    (quotation) => {
      if (quotation.materials && Array.isArray(quotation.materials)) {
        // Get purchase history to merge with quotation materials
        const loadPurchaseHistory = async () => {
          try {
            const purchaseRef = collection(
              db,
              'projects',
              projectId,
              'purchases'
            );
            const purchaseQuery = query(
              purchaseRef,
              orderBy('createdAt', 'desc')
            );
            const purchaseSnapshot = await getDocs(purchaseQuery);

            let purchasedItems = {};
            if (!purchaseSnapshot.empty) {
              const latestPurchase = purchaseSnapshot.docs[0].data();
              purchasedItems = latestPurchase.purchasedItems || {};
              setPurchaseHistory(
                purchaseSnapshot.docs.map((doc) => ({
                  id: doc.id,
                  ...doc.data(),
                }))
              );
            }

            // Merge purchased state with materials
            const materialsWithPurchaseState = quotation.materials.map(
              (item) => ({
                ...item,
                purchased: purchasedItems[item.name] === true,
              })
            );

            setMaterials(materialsWithPurchaseState);
          } catch (error) {
            console.error('L·ªói khi t·∫£i l·ªãch s·ª≠ mua h√†ng:', error);
          }
        };

        loadPurchaseHistory();
        Alert.alert(
          'T·∫£i th√†nh c√¥ng',
          `ƒê√£ t·∫£i d·ªØ li·ªáu t·ª´ b√°o gi√° ${
            quotation.quotationNumber || 'm·ªõi nh·∫•t'
          }.`
        );
      } else {
        Alert.alert('L·ªói', 'B√°o gi√° n√†y kh√¥ng ch·ª©a d·ªØ li·ªáu v·∫≠t t∆∞ ƒë·ªÉ t·∫£i.');
      }
    },
    [projectId]
  );

  // Load approved proposals
  const loadApprovedProposals = useCallback(async () => {
    setLoadingProposals(true);
    try {
      // Get all approved proposals
      const allApproved = await getProposalsByStatus('approved');

      // Filter for this project if projectId is provided
      let projectProposals = allApproved;
      if (projectId) {
        projectProposals = allApproved.filter((p) => p.projectId === projectId);
      }

      setApprovedProposals(projectProposals);
    } catch (error) {
      console.error('L·ªói khi t·∫£i ƒë·ªÅ xu·∫•t ƒë√£ duy·ªát:', error);
    } finally {
      setLoadingProposals(false);
    }
  }, [projectId]);

  // Handle price updates for a proposal
  const openPriceEditor = (proposal) => {
    // Create a deep copy of materials with price fields
    const materialsWithPrices = proposal.items
      ? JSON.parse(JSON.stringify(proposal.items))
      : [];

    // Ensure each material has price and totalPrice fields
    materialsWithPrices.forEach((item) => {
      if (!item.price) item.price = '';
      if (!item.totalPrice) item.totalPrice = '';
    });

    setEditableMaterials(materialsWithPrices);
    setCurrentProposalId(proposal.id);
    setShowPriceModal(true);
  };

  const handlePriceChange = (index, price) => {
    const updatedMaterials = [...editableMaterials];
    updatedMaterials[index].price = price;

    // Calculate total price if both price and quantity exist
    const quantity = parseFloat(updatedMaterials[index].quantity);
    const priceValue = parseFloat(price);

    if (!isNaN(quantity) && !isNaN(priceValue)) {
      updatedMaterials[index].totalPrice = (quantity * priceValue).toString();
    }

    setEditableMaterials(updatedMaterials);
  };

  const savePriceUpdates = async () => {
    if (!currentProposalId) return;

    try {
      await updateProposalMaterialPrices(currentProposalId, editableMaterials);
      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ c·∫≠p nh·∫≠t gi√° v·∫≠t t∆∞');
      setShowPriceModal(false);
      loadApprovedProposals(); // Reload to get updated data
    } catch (error) {
      console.error('Error updating prices:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t gi√° v·∫≠t t∆∞');
    }
  };

  // Load project materials and purchase history
  useFocusEffect(
    useCallback(() => {
      const loadData = async () => {
        setLoading(true);
        try {
          // Load quotations to get materials
          const pastQuotations = await getQuotationsByProject(projectId);
          setQuotations(pastQuotations);

          if (pastQuotations.length > 0) {
            // Automatically load the latest quotation
            const latestQuotation = pastQuotations[0];
            handleRequote(latestQuotation);
          }

          // Load approved proposals
          await loadApprovedProposals();
        } catch (error) {
          console.error('L·ªói khi t·∫£i d·ªØ li·ªáu:', error);
          Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu v·∫≠t t∆∞.');
        } finally {
          setLoading(false);
        }
      };

      loadData();
    }, [projectId, handleRequote, loadApprovedProposals])
  );

  // Calculate purchase stats
  const calculateStats = () => {
    if (!materials.length)
      return { purchasedCount: 0, totalCount: 0, percentComplete: 0 };

    const purchasedCount = materials.filter((item) => item.purchased).length;
    const totalCount = materials.length;
    const percentComplete = Math.round((purchasedCount / totalCount) * 100);

    return { purchasedCount, totalCount, percentComplete };
  };

  const stats = calculateStats();

  const renderHeader = () => (
    <View style={styles.header}>
      <Text style={styles.headerTitle}>Danh S√°ch V·∫≠t T∆∞ C·∫ßn Mua</Text>
      <Text style={styles.projectName}>
        {projectDetails?.name || projectName}
      </Text>

      {materials.length > 0 && (
        <View style={styles.statsContainer}>
          <View style={styles.progressBar}>
            <View
              style={[
                styles.progressFill,
                { width: `${stats.percentComplete}%` },
              ]}
            />
          </View>
          <Text style={styles.statsText}>
            {stats.purchasedCount}/{stats.totalCount} v·∫≠t t∆∞ ƒë√£ mua (
            {stats.percentComplete}%)
          </Text>
        </View>
      )}
    </View>
  );

  const renderMaterialsSection = () => (
    <View style={styles.section}>
      <Text style={styles.sectionTitle}>Danh s√°ch v·∫≠t t∆∞</Text>
      {materials.length > 0 ? (
        <>
          <View style={styles.tableHeader}>
            <View style={{ width: 30 }}></View>
            <Text style={[styles.headerCell, { flex: 3 }]}>T√™n v·∫≠t t∆∞</Text>
            <Text style={[styles.headerCell, { flex: 1, textAlign: 'center' }]}>
              SL
            </Text>
            <Text style={[styles.headerCell, { flex: 1, textAlign: 'center' }]}>
              KL
            </Text>
            <Text
              style={[styles.headerCell, { flex: 0.8, textAlign: 'center' }]}
            >
              ƒêVT
            </Text>
          </View>
          <FlatList
            data={materials}
            keyExtractor={(item, index) => `material-row-${index}`}
            renderItem={({ item, index }) => (
              <MaterialRow
                item={item}
                index={index}
                onTogglePurchased={handleTogglePurchased}
              />
            )}
            nestedScrollEnabled={true}
            style={{ maxHeight: 300 }}
          />
        </>
      ) : (
        <View style={styles.emptyContainer}>
          <Ionicons name="list-outline" size={48} color="#ccc" />
          <Text style={styles.emptyText}>
            Ch∆∞a c√≥ d·ªØ li·ªáu v·∫≠t t∆∞ t·ª´ b√°o gi√°
          </Text>
          <TouchableOpacity
            style={styles.createQuotationButton}
            onPress={() =>
              navigation.navigate('Quotation', {
                projectId,
                projectName: projectDetails?.name || projectName,
                project: projectDetails,
              })
            }
          >
            <Text style={styles.createQuotationButtonText}>T·∫°o b√°o gi√°</Text>
          </TouchableOpacity>
        </View>
      )}
    </View>
  );

  const renderPurchaseHistory = () => (
    <View style={styles.section}>
      <Text style={styles.sectionTitle}>Danh s√°ch c·∫ßn mua</Text>
      {purchaseHistory.length === 0 ? (
        <Text style={styles.emptyText}>
          Ch∆∞a c√≥ danh s√°ch mua h√†ng n√†o ƒë∆∞·ª£c l∆∞u.
        </Text>
      ) : (
        <FlatList
          data={purchaseHistory}
          keyExtractor={(item) => item.id}
          renderItem={({ item }) => {
            const purchasedCount = Object.values(item.purchasedItems).filter(
              (v) => v === true
            ).length;
            const totalCount = Object.values(item.purchasedItems).length;

            return (
              <TouchableOpacity
                style={styles.historyItem}
                onPress={() => viewHistoryDetails(item)}
              >
                <Text style={styles.historyDate}>
                  {item.createdAt
                    ? new Date(
                        item.createdAt.seconds * 1000
                      ).toLocaleDateString('vi-VN')
                    : 'Kh√¥ng r√µ ng√†y'}
                </Text>
                <Text style={styles.historyCreator}>
                  Ng∆∞·ªùi l∆∞u: {item.createdByName || 'Kh√¥ng x√°c ƒë·ªãnh'}
                </Text>
                <View style={styles.historyStats}>
                  <Text style={styles.historyStatText}>
                    ƒê√£ mua: {purchasedCount} v·∫≠t t∆∞
                  </Text>
                  <Text style={styles.historyStatText}>
                    Ch∆∞a mua: {totalCount - purchasedCount} v·∫≠t t∆∞
                  </Text>
                </View>
                <View style={styles.viewDetailsButton}>
                  <Text style={styles.viewDetailsText}>Xem chi ti·∫øt</Text>
                  <Ionicons name="chevron-forward" size={16} color="#0066cc" />
                </View>
              </TouchableOpacity>
            );
          }}
        />
      )}
    </View>
  );

  const renderQuotationsSection = () => (
    <View style={styles.section}>
      <Text style={styles.sectionTitle}>L·ªãch s·ª≠ b√°o gi√°</Text>
      {quotations.length === 0 ? (
        <Text style={styles.emptyText}>Ch∆∞a c√≥ b√°o gi√° n√†o.</Text>
      ) : (
        <FlatList
          horizontal
          data={quotations}
          keyExtractor={(item) => item.id}
          renderItem={({ item }) => (
            <TouchableOpacity
              style={styles.quotationItem}
              onPress={() => handleRequote(item)}
            >
              <Text style={styles.quotationNumber}>
                {item.quotationNumber || `B√°o gi√° #${item.id.substring(0, 5)}`}
              </Text>
              <Text style={styles.quotationDate}>
                {item.createdAt
                  ? new Date(item.createdAt.seconds * 1000).toLocaleDateString(
                      'vi-VN'
                    )
                  : 'Kh√¥ng r√µ'}
              </Text>
            </TouchableOpacity>
          )}
        />
      )}
    </View>
  );

  // Render approved proposals section
  const renderApprovedProposals = () => (
    <View style={styles.section}>
      <View style={styles.sectionHeader}>
        <Text style={styles.sectionTitle}>ƒê·ªÅ xu·∫•t ƒë√£ ƒë∆∞·ª£c duy·ªát</Text>
      </View>

      {loadingProposals ? (
        <ActivityIndicator size="small" color="#0066cc" />
      ) : approvedProposals.length === 0 ? (
        <Text style={styles.emptyText}>Ch∆∞a c√≥ ƒë·ªÅ xu·∫•t n√†o ƒë∆∞·ª£c duy·ªát</Text>
      ) : (
        <FlatList
          data={approvedProposals}
          keyExtractor={(item) => item.id}
          renderItem={({ item }) => (
            <View style={styles.proposalCard}>
              <View style={styles.proposalHeader}>
                <Text style={styles.proposalCode}>
                  {item.proposalCode || `PO-${item.id.substring(0, 6)}`}
                </Text>
                {item.hasPrices && (
                  <View style={styles.priceBadge}>
                    <Text style={styles.priceBadgeText}>ƒê√£ c√≥ gi√°</Text>
                  </View>
                )}
              </View>

              <Text style={styles.proposalProject}>{item.projectName}</Text>

              <View style={styles.proposalDetails}>
                <View style={styles.proposalDetailRow}>
                  <Text style={styles.proposalDetailLabel}>Ng√†y y√™u c·∫ßu:</Text>
                  <Text style={styles.proposalDetailValue}>
                    {item.requiredDate
                      ? new Date(
                          item.requiredDate.seconds * 1000
                        ).toLocaleDateString('vi-VN')
                      : 'N/A'}
                  </Text>
                </View>

                <View style={styles.proposalDetailRow}>
                  <Text style={styles.proposalDetailLabel}>
                    S·ªë l∆∞·ª£ng v·∫≠t t∆∞:
                  </Text>
                  <Text style={styles.proposalDetailValue}>
                    {item.items?.length || 0}
                  </Text>
                </View>

                {item.totalValue && (
                  <View style={styles.proposalDetailRow}>
                    <Text style={styles.proposalDetailLabel}>
                      T·ªïng gi√° tr·ªã:
                    </Text>
                    <Text style={styles.proposalDetailValue}>
                      {item.totalValue.toLocaleString('vi-VN')} VNƒê
                    </Text>
                  </View>
                )}
              </View>

              <View style={styles.proposalActions}>
                <TouchableOpacity
                  style={[styles.proposalButton, styles.viewButton]}
                  onPress={() => navigation.navigate('ProposalList')}
                >
                  <Ionicons name="eye-outline" size={16} color="#0066cc" />
                  <Text style={styles.viewButtonText}>Xem chi ti·∫øt</Text>
                </TouchableOpacity>

                <TouchableOpacity
                  style={[styles.proposalButton, styles.priceButton]}
                  onPress={() => openPriceEditor(item)}
                >
                  <Ionicons name="cash-outline" size={16} color="#28a745" />
                  <Text style={[styles.viewButtonText, { color: '#28a745' }]}>
                    {item.hasPrices ? 'C·∫≠p nh·∫≠t gi√°' : 'Nh·∫≠p gi√°'}
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          )}
          contentContainerStyle={styles.proposalList}
        />
      )}
    </View>
  );

  // New function to render the confirmation modal
  const renderConfirmationModal = () => (
    <Modal visible={showConfirmModal} transparent animationType="slide">
      <View style={styles.modalOverlay}>
        <View style={styles.modalContainer}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>X√°c nh·∫≠n v·∫≠t t∆∞ ƒë√£ mua</Text>
            <TouchableOpacity onPress={() => setShowConfirmModal(false)}>
              <Ionicons name="close" size={24} color="#666" />
            </TouchableOpacity>
          </View>

          <Text style={styles.confirmText}>
            B·∫°n ƒëang x√°c nh·∫≠n ƒë√£ mua {purchasedMaterials.length} v·∫≠t t∆∞ sau:
          </Text>

          <ScrollView style={styles.confirmList}>
            {purchasedMaterials.map((item, index) => (
              <View key={index} style={styles.confirmItem}>
                <Ionicons
                  name="checkmark-circle"
                  size={18}
                  color="#4CAF50"
                  style={styles.confirmIcon}
                />
                <View style={styles.confirmItemContent}>
                  <Text style={styles.confirmItemName}>
                    {index + 1}. {item.name}
                  </Text>
                  <Text style={styles.confirmItemDetails}>
                    {item.quantity} {item.unit || 'c√°i'}
                    {item.quyCach ? ` - ${item.quyCach}` : ''}
                  </Text>
                </View>
              </View>
            ))}
          </ScrollView>

          <View style={styles.modalActions}>
            <TouchableOpacity
              style={[styles.modalButton, styles.cancelButton]}
              onPress={() => setShowConfirmModal(false)}
            >
              <Text style={styles.cancelButtonText}>H·ªßy</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.modalButton, styles.confirmButton]}
              onPress={confirmSavePurchaseList}
              disabled={saving}
            >
              {saving ? (
                <ActivityIndicator size="small" color="#fff" />
              ) : (
                <Text style={styles.confirmButtonText}>X√°c nh·∫≠n</Text>
              )}
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );

  // Function to view history details
  const viewHistoryDetails = async (historyItem) => {
    setSelectedHistory(historyItem);

    try {
      // Get the full material list from the latest quotation
      let materialsList = [...materials];

      // Merge with purchase status from history
      if (historyItem.purchasedItems) {
        materialsList = materialsList.map((material) => ({
          ...material,
          purchased: historyItem.purchasedItems[material.name] === true,
        }));
      }

      setHistoryMaterials(materialsList);
      setShowHistoryDetailModal(true);
    } catch (error) {
      console.error('L·ªói khi t·∫£i chi ti·∫øt l·ªãch s·ª≠:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i chi ti·∫øt l·ªãch s·ª≠ mua h√†ng.');
    }
  };

  // Function to toggle purchase status in history detail
  const toggleHistoryItemStatus = (index) => {
    setHistoryMaterials((prev) => {
      const updated = [...prev];
      updated[index] = {
        ...updated[index],
        purchased: !updated[index].purchased,
      };
      return updated;
    });
  };

  // Function to update purchase history
  const updatePurchaseHistory = async () => {
    if (!selectedHistory) return;

    setUpdatingHistory(true);
    try {
      // Create updated purchasedItems object
      const purchasedItems = {};
      historyMaterials.forEach((item) => {
        purchasedItems[item.name] = item.purchased === true;
      });

      // Update the history document
      const historyRef = doc(
        db,
        'projects',
        projectId,
        'purchases',
        selectedHistory.id
      );
      await updateDoc(historyRef, {
        purchasedItems,
        updatedAt: serverTimestamp(),
        updatedBy: currentUser?.uid || 'unknown',
        updatedByName:
          currentUser?.displayName || currentUser?.email || 'Ng∆∞·ªùi d√πng',
      });

      // Calculate if all items are purchased
      const purchasedCount = Object.values(purchasedItems).filter(
        (v) => v === true
      ).length;
      const totalCount = Object.values(purchasedItems).length;

      // Update project task status
      const projectRef = doc(db, 'projects', projectId);
      await updateDoc(projectRef, {
        'tasks.material_purchasing.status':
          purchasedCount === totalCount ? 'completed' : 'in_progress',
      });

      // Reload purchase history
      const purchaseRef = collection(db, 'projects', projectId, 'purchases');
      const purchaseQuery = query(purchaseRef, orderBy('createdAt', 'desc'));
      const purchaseSnapshot = await getDocs(purchaseQuery);
      setPurchaseHistory(
        purchaseSnapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }))
      );

      setShowHistoryDetailModal(false);
      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i mua h√†ng.');
    } catch (error) {
      console.error('L·ªói khi c·∫≠p nh·∫≠t l·ªãch s·ª≠:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t l·ªãch s·ª≠ mua h√†ng.');
    } finally {
      setUpdatingHistory(false);
    }
  };

  // New function to render history detail modal
  const renderHistoryDetailModal = () => (
    <Modal visible={showHistoryDetailModal} transparent animationType="slide">
      <View style={styles.modalOverlay}>
        <View style={[styles.modalContainer, styles.historyModalContainer]}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>Chi ti·∫øt mua h√†ng</Text>
            <TouchableOpacity onPress={() => setShowHistoryDetailModal(false)}>
              <Ionicons name="close" size={24} color="#666" />
            </TouchableOpacity>
          </View>

          {selectedHistory && (
            <View style={styles.historyDetailHeader}>
              <Text style={styles.historyDetailDate}>
                Ng√†y:{' '}
                {selectedHistory.createdAt
                  ? new Date(
                      selectedHistory.createdAt.seconds * 1000
                    ).toLocaleDateString('vi-VN')
                  : 'Kh√¥ng r√µ'}
              </Text>
              <Text style={styles.historyDetailPerson}>
                Ng∆∞·ªùi l∆∞u: {selectedHistory.createdByName || 'Kh√¥ng x√°c ƒë·ªãnh'}
              </Text>
              {selectedHistory.updatedAt && (
                <Text style={styles.historyDetailUpdate}>
                  C·∫≠p nh·∫≠t l·∫ßn cu·ªëi:{' '}
                  {new Date(
                    selectedHistory.updatedAt.seconds * 1000
                  ).toLocaleDateString('vi-VN')}
                </Text>
              )}
            </View>
          )}

          <Text style={styles.historyDetailInstruction}>
            Nh·∫•n v√†o √¥ vu√¥ng ƒë·ªÉ thay ƒë·ªïi tr·∫°ng th√°i ƒë√£ mua/ch∆∞a mua
          </Text>

          <ScrollView style={styles.historyDetailList}>
            {historyMaterials.length > 0 ? (
              historyMaterials.map((item, index) => (
                <TouchableOpacity
                  key={index}
                  style={styles.historyDetailItem}
                  onPress={() => toggleHistoryItemStatus(index)}
                >
                  <View style={styles.historyCheckbox}>
                    <Ionicons
                      name={item.purchased ? 'checkbox' : 'square-outline'}
                      size={22}
                      color={item.purchased ? '#4CAF50' : '#999'}
                    />
                  </View>
                  <View style={styles.historyItemContent}>
                    <Text style={styles.historyItemName}>{item.name}</Text>
                    <Text style={styles.historyItemDetails}>
                      {item.quantity} {item.unit || 'c√°i'}
                      {item.quyCach ? ` - ${item.quyCach}` : ''}
                    </Text>
                  </View>
                  <View
                    style={[
                      styles.historyItemStatus,
                      {
                        backgroundColor: item.purchased ? '#e8f5e9' : '#fff3e0',
                      },
                    ]}
                  >
                    <Text
                      style={[
                        styles.historyItemStatusText,
                        { color: item.purchased ? '#4CAF50' : '#FF9800' },
                      ]}
                    >
                      {item.purchased ? 'ƒê√£ mua' : 'Ch∆∞a mua'}
                    </Text>
                  </View>
                </TouchableOpacity>
              ))
            ) : (
              <Text style={styles.emptyText}>Kh√¥ng c√≥ d·ªØ li·ªáu v·∫≠t t∆∞</Text>
            )}
          </ScrollView>

          <View style={styles.modalActions}>
            <TouchableOpacity
              style={[styles.modalButton, styles.cancelButton]}
              onPress={() => setShowHistoryDetailModal(false)}
            >
              <Text style={styles.cancelButtonText}>ƒê√≥ng</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.modalButton, styles.updateButton]}
              onPress={updatePurchaseHistory}
              disabled={updatingHistory}
            >
              {updatingHistory ? (
                <ActivityIndicator size="small" color="#fff" />
              ) : (
                <Text style={styles.updateButtonText}>C·∫≠p nh·∫≠t</Text>
              )}
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );

  return (
    <SafeAreaView style={styles.container}>
      {renderHeader()}

      {loading || loadingProject ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#0066cc" />
          <Text style={styles.loadingText}>ƒêang t·∫£i d·ªØ li·ªáu...</Text>
        </View>
      ) : (
        <View style={{ flex: 1 }}>
          <ScrollView>
            {renderQuotationsSection()}
            {renderMaterialsSection()}
            {renderApprovedProposals()}
            {renderPurchaseHistory()}
          </ScrollView>

          {materials.length > 0 && (
            <View style={styles.buttonContainer}>
              <TouchableOpacity
                style={styles.saveButton}
                onPress={handleSavePurchaseList}
                disabled={saving}
              >
                <View style={styles.buttonContent}>
                  {saving ? (
                    <ActivityIndicator size="small" color="#fff" />
                  ) : (
                    <Ionicons name="save-outline" size={20} color="#fff" />
                  )}
                  <Text style={styles.saveButtonText}>
                    L∆∞u danh s√°ch mua h√†ng
                  </Text>
                </View>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.saveButton,
                  { backgroundColor: '#0066cc', marginTop: 8 },
                ]}
                onPress={handleCreateProposal}
              >
                <View style={styles.buttonContent}>
                  <Ionicons name="send" size={20} color="#fff" />
                  <Text style={styles.saveButtonText}>
                    T·∫°o ƒê·ªÅ Xu·∫•t Mua V·∫≠t T∆∞
                  </Text>
                </View>
              </TouchableOpacity>
            </View>
          )}
        </View>
      )}

      {/* Price Update Modal */}
      <Modal visible={showPriceModal} transparent animationType="slide">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContainer}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>C·∫≠p nh·∫≠t gi√° v·∫≠t t∆∞</Text>
              <TouchableOpacity onPress={() => setShowPriceModal(false)}>
                <Ionicons name="close" size={24} color="#666" />
              </TouchableOpacity>
            </View>

            <ScrollView style={styles.priceScrollView}>
              {editableMaterials && editableMaterials.length > 0 ? (
                editableMaterials.map((item, index) => (
                  <View key={index} style={styles.priceItem}>
                    <Text style={styles.materialName}>
                      {index + 1}. {item.name || 'Kh√¥ng c√≥ t√™n'}
                    </Text>
                    <View style={styles.materialDetails}>
                      {item.specification ? (
                        <Text style={styles.materialSpec}>
                          Quy c√°ch: {item.specification}
                        </Text>
                      ) : null}
                      <Text style={styles.materialQuantity}>
                        S·ªë l∆∞·ª£ng: {item.quantity || 0} {item.unit || ''}
                      </Text>

                      <View style={styles.priceInputContainer}>
                        <Text style={styles.priceLabel}>ƒê∆°n gi√° (VNƒê):</Text>
                        <TextInput
                          style={styles.priceInput}
                          value={item.price}
                          onChangeText={(text) =>
                            handlePriceChange(index, text)
                          }
                          keyboardType="numeric"
                          placeholder="Nh·∫≠p ƒë∆°n gi√°"
                        />
                      </View>

                      {item.totalPrice && (
                        <Text style={styles.materialTotalPrice}>
                          Th√†nh ti·ªÅn: {item.totalPrice} VNƒê
                        </Text>
                      )}
                    </View>
                  </View>
                ))
              ) : (
                <Text style={styles.emptyText}>Kh√¥ng c√≥ v·∫≠t t∆∞ n√†o.</Text>
              )}
            </ScrollView>

            <View style={styles.modalActions}>
              <TouchableOpacity
                style={[styles.modalButton, styles.cancelButton]}
                onPress={() => setShowPriceModal(false)}
              >
                <Text style={styles.cancelButtonText}>H·ªßy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.modalButton, styles.saveButton]}
                onPress={savePriceUpdates}
              >
                <Text style={styles.saveButtonText}>L∆∞u gi√°</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Confirmation Modal */}
      {renderConfirmationModal()}

      {/* History Detail Modal */}
      {renderHistoryDetailModal()}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  header: {
    padding: 16,
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  projectName: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
  section: {
    backgroundColor: '#fff',
    borderRadius: 8,
    margin: 8,
    padding: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 3,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 10,
  },
  tableHeader: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
    paddingBottom: 8,
    marginBottom: 8,
  },
  headerCell: {
    fontWeight: '600',
    fontSize: 14,
    color: '#333',
  },
  tableRow: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
    paddingVertical: 8,
    alignItems: 'center',
  },
  checkbox: {
    width: 30,
    alignItems: 'center',
    justifyContent: 'center',
  },
  tableCell: {
    paddingHorizontal: 4,
  },
  materialName: {
    fontSize: 14,
    fontWeight: '500',
  },
  materialType: {
    fontSize: 12,
    color: '#666',
    marginTop: 2,
  },
  saveButton: {
    backgroundColor: '#4CAF50',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center', // This will center the content
    paddingVertical: 12,
    marginHorizontal: 8,
    borderRadius: 8,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 3,
  },
  saveButtonText: {
    color: '#fff',
    fontWeight: '600',
    marginLeft: 8,
    fontSize: 15, // Slightly larger text
    textAlignVertical: 'center', // Align text vertically
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 12,
    color: '#666',
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 24,
  },
  emptyText: {
    color: '#999',
    marginTop: 8,
  },
  createQuotationButton: {
    marginTop: 16,
    paddingVertical: 8,
    paddingHorizontal: 16,
    backgroundColor: '#0066cc',
    borderRadius: 20,
  },
  createQuotationButtonText: {
    color: '#fff',
    fontWeight: '500',
  },
  historyItem: {
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderRadius: 8,
    padding: 12,
    marginBottom: 8,
    backgroundColor: '#fff',
  },
  historyDate: {
    fontWeight: '600',
    fontSize: 14,
  },
  historyCreator: {
    fontSize: 12,
    color: '#666',
    marginTop: 4,
  },
  historyStats: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 8,
    paddingTop: 8,
    borderTopWidth: 1,
    borderTopColor: '#f0f0f0',
  },
  historyStatText: {
    fontSize: 12,
  },
  statsContainer: {
    marginTop: 10,
    alignItems: 'center',
  },
  progressBar: {
    width: '100%',
    height: 8,
    backgroundColor: '#e0e0e0',
    borderRadius: 4,
    overflow: 'hidden',
    marginBottom: 5,
  },
  progressFill: {
    height: '100%',
    backgroundColor: '#4CAF50',
    borderRadius: 4,
  },
  statsText: {
    fontSize: 14,
    color: '#666',
  },
  quotationItem: {
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderRadius: 8,
    padding: 10,
    marginRight: 10,
    width: 150,
    backgroundColor: '#f9f9f9',
  },
  quotationNumber: {
    fontWeight: '600',
    fontSize: 14,
    marginBottom: 4,
  },
  quotationDate: {
    fontSize: 12,
    color: '#666',
  },
  buttonContainer: {
    paddingHorizontal: 8,
    paddingBottom: 16,
  },
  buttonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    width: '100%', // Ensure the content takes the full width
  },

  // Proposal card styles
  proposalCard: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 12,
    marginBottom: 10,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  proposalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  proposalCode: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  priceBadge: {
    backgroundColor: '#28a745',
    paddingVertical: 2,
    paddingHorizontal: 8,
    borderRadius: 12,
  },
  priceBadgeText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '500',
  },
  proposalProject: {
    fontSize: 14,
    color: '#444',
    marginBottom: 8,
  },
  proposalDetails: {
    marginBottom: 10,
  },
  proposalDetailRow: {
    flexDirection: 'row',
    marginBottom: 4,
  },
  proposalDetailLabel: {
    fontSize: 13,
    color: '#666',
    width: 100,
  },
  proposalDetailValue: {
    fontSize: 13,
    color: '#333',
    fontWeight: '500',
  },
  proposalActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    borderTopWidth: 1,
    borderTopColor: '#eee',
    paddingTop: 8,
  },
  proposalButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 6,
    paddingHorizontal: 12,
    borderRadius: 16,
    marginLeft: 8,
  },
  viewButton: {
    backgroundColor: '#f0f7ff',
  },
  priceButton: {
    backgroundColor: '#e8f5e9',
  },
  viewButtonText: {
    color: '#0066cc',
    fontSize: 12,
    fontWeight: '500',
    marginLeft: 4,
  },
  emptyText: {
    textAlign: 'center',
    color: '#666',
    padding: 16,
  },

  // Modal styles
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    width: '90%',
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    maxHeight: '80%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    paddingBottom: 8,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  priceScrollView: {
    maxHeight: '70%',
  },
  priceItem: {
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  materialName: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 4,
  },
  materialSpec: {
    fontSize: 13,
    color: '#666',
    marginBottom: 2,
  },
  materialQuantity: {
    fontSize: 13,
    color: '#333',
  },
  priceInputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 6,
    marginBottom: 4,
  },
  priceLabel: {
    fontSize: 13,
    color: '#555',
    width: 100,
  },
  priceInput: {
    flex: 1,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 4,
    paddingHorizontal: 8,
    paddingVertical: 4,
    fontSize: 13,
  },
  materialTotalPrice: {
    fontSize: 13,
    color: '#28a745',
    fontWeight: '500',
    marginTop: 2,
  },
  modalActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    marginTop: 16,
  },
  modalButton: {
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 4,
    marginLeft: 8,
  },
  cancelButton: {
    backgroundColor: '#f5f5f5',
  },
  cancelButtonText: {
    color: '#333',
  },
  saveButton: {
    backgroundColor: '#28a745',
  },
  saveButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
  // New styles for confirmation modal
  confirmText: {
    fontSize: 14,
    color: '#333',
    marginBottom: 12,
  },
  confirmList: {
    maxHeight: 300,
    marginBottom: 12,
  },
  confirmItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  confirmIcon: {
    marginRight: 8,
  },
  confirmItemContent: {
    flex: 1,
  },
  confirmItemName: {
    fontSize: 14,
    fontWeight: '500',
    color: '#333',
  },
  confirmItemDetails: {
    fontSize: 12,
    color: '#666',
    marginTop: 2,
  },
  confirmButton: {
    backgroundColor: '#4CAF50',
    minWidth: 100,
    justifyContent: 'center',
    alignItems: 'center',
  },
  confirmButtonText: {
    color: '#fff',
    fontWeight: '600',
  },

  // History detail modal styles
  historyModalContainer: {
    maxHeight: '80%',
    width: '90%',
  },
  historyDetailHeader: {
    backgroundColor: '#f9f9f9',
    padding: 12,
    borderRadius: 4,
    marginBottom: 16,
  },
  historyDetailDate: {
    fontSize: 15,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  historyDetailPerson: {
    fontSize: 13,
    color: '#666',
    marginBottom: 2,
  },
  historyDetailUpdate: {
    fontSize: 12,
    color: '#888',
    fontStyle: 'italic',
  },
  historyDetailInstruction: {
    fontSize: 13,
    color: '#666',
    marginBottom: 12,
    fontStyle: 'italic',
  },
  historyDetailList: {
    maxHeight: '60%',
  },
  historyDetailItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
    paddingHorizontal: 4,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  historyCheckbox: {
    width: 30,
    alignItems: 'center',
    justifyContent: 'center',
  },
  historyItemContent: {
    flex: 1,
    paddingHorizontal: 8,
  },
  historyItemName: {
    fontSize: 14,
    fontWeight: '500',
    color: '#333',
  },
  historyItemDetails: {
    fontSize: 12,
    color: '#666',
    marginTop: 2,
  },
  historyItemStatus: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    minWidth: 80,
    alignItems: 'center',
  },
  historyItemStatusText: {
    fontSize: 12,
    fontWeight: '500',
  },
  updateButton: {
    backgroundColor: '#0066cc',
    minWidth: 100,
    justifyContent: 'center',
    alignItems: 'center',
  },
  updateButtonText: {
    color: '#fff',
    fontWeight: '600',
  },

  // ... other existing styles ...
});

export default MaterialPurchaseScreen;


--- END: src\screens\MaterialPurchaseScreen.js ---


--- START: src\screens\MonthlyCostReportScreen.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  FlatList,
  Alert,
  ActivityIndicator,
  SafeAreaView,
  StatusBar,
  ScrollView,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import { generateMonthlyCostReport } from '../api/monthlyCostReportService';
import DateTimePicker from '@react-native-community/datetimepicker';

const MonthlyCostReportScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const { user: currentUser } = useAuth();

  const [loading, setLoading] = useState(false);
  const [reportData, setReportData] = useState(null);
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [showDatePicker, setShowDatePicker] = useState(false);

  // Ki·ªÉm tra quy·ªÅn truy c·∫≠p
  const hasAccess = ['giam_doc', 'pho_giam_doc', 'ke_toan', 'ky_su'].includes(
    currentUser?.role
  );

  useEffect(() => {
    if (hasAccess) {
      loadReport();
    }
  }, [hasAccess, selectedDate]);

  const loadReport = async () => {
    try {
      setLoading(true);
      const year = selectedDate.getFullYear();
      const month = selectedDate.getMonth() + 1; // getMonth() tr·∫£ v·ªÅ 0-11

      console.log('üìÖ T·∫£i b√°o c√°o cho:', { year, month });

      const report = await generateMonthlyCostReport(year, month);
      console.log('üìä K·∫øt qu·∫£ b√°o c√°o:', report);
      setReportData(report);
    } catch (error) {
      console.error('‚ùå L·ªói khi t·∫£i b√°o c√°o:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i b√°o c√°o chi ph√≠ h√†ng th√°ng');
    } finally {
      setLoading(false);
    }
  };

  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
      minimumFractionDigits: 0,
    }).format(amount || 0);
  };

  const formatDate = (date) => {
    return new Intl.DateTimeFormat('vi-VN', {
      year: 'numeric',
      month: 'long',
    }).format(date);
  };

  const handleDateChange = (event, date) => {
    setShowDatePicker(false);
    if (date) {
      setSelectedDate(date);
    }
  };

  const renderProjectItem = ({ item }) => (
    <View
      style={[
        styles.projectCard,
        { backgroundColor: theme.card, borderColor: theme.border },
      ]}
    >
      <View style={styles.projectHeader}>
        <Text style={[styles.projectName, { color: theme.text }]}>
          {item.project.name}
        </Text>
        <Text style={[styles.projectTotal, { color: theme.primary }]}>
          {formatCurrency(item.costBreakdown.totalCost)}
        </Text>
      </View>

      <View style={styles.costBreakdown}>
        <View style={styles.costItem}>
          <Text style={[styles.costLabel, { color: theme.textSecondary }]}>
            V·∫≠t li·ªáu:
          </Text>
          <Text style={[styles.costValue, { color: theme.text }]}>
            {formatCurrency(item.costBreakdown.materialCost)}
          </Text>
        </View>

        <View style={styles.costItem}>
          <Text style={[styles.costLabel, { color: theme.textSecondary }]}>
            Ph·ª• ki·ªán:
          </Text>
          <Text style={[styles.costValue, { color: theme.text }]}>
            {formatCurrency(item.costBreakdown.accessoryCost)}
          </Text>
        </View>
      </View>
    </View>
  );

  if (!hasAccess) {
    return (
      <SafeAreaView
        style={[styles.container, { backgroundColor: theme.background }]}
      >
        <StatusBar
          barStyle={theme.dark ? 'light-content' : 'dark-content'}
          backgroundColor={theme.background}
        />
        <View style={styles.header}>
          <TouchableOpacity onPress={() => navigation.goBack()}>
            <Ionicons name="arrow-back" size={24} color={theme.text} />
          </TouchableOpacity>
          <Text style={[styles.headerTitle, { color: theme.text }]}>
            B√°o c√°o chi ph√≠ h√†ng th√°ng
          </Text>
          <View style={{ width: 24 }} />
        </View>
        <View style={styles.accessDenied}>
          <Ionicons name="lock-closed" size={60} color={theme.textMuted} />
          <Text
            style={[styles.accessDeniedText, { color: theme.textSecondary }]}
          >
            B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p t√≠nh nƒÉng n√†y
          </Text>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <StatusBar
        barStyle={theme.dark ? 'light-content' : 'dark-content'}
        backgroundColor={theme.background}
      />

      {/* Header */}
      <View style={[styles.header, { borderBottomColor: theme.border }]}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back" size={24} color={theme.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          B√°o c√°o chi ph√≠ h√†ng th√°ng
        </Text>
        <View style={{ width: 24 }} />
      </View>

      {/* Date Picker */}
      <View style={[styles.dateContainer, { borderBottomColor: theme.border }]}>
        <TouchableOpacity
          style={[styles.dateButton, { borderColor: theme.border }]}
          onPress={() => setShowDatePicker(true)}
        >
          <Ionicons name="calendar-outline" size={20} color={theme.primary} />
          <Text style={[styles.dateText, { color: theme.text }]}>
            {formatDate(selectedDate)}
          </Text>
          <Ionicons name="chevron-down" size={16} color={theme.textSecondary} />
        </TouchableOpacity>

        {null}

        {null}
      </View>

      {showDatePicker && (
        <DateTimePicker
          value={selectedDate}
          mode="date"
          display="default"
          onChange={handleDateChange}
          maximumDate={new Date()}
        />
      )}

      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
            ƒêang t·∫£i b√°o c√°o...
          </Text>
        </View>
      ) : reportData ? (
        <ScrollView style={styles.content}>
          {/* Summary Cards */}
          <View style={styles.summaryContainer}>
            <View
              style={[
                styles.summaryCard,
                { backgroundColor: theme.card, borderColor: theme.border },
              ]}
            >
              <Text
                style={[styles.summaryTitle, { color: theme.textSecondary }]}
              >
                D·ª± √°n ho√†n th√†nh
              </Text>
              <Text style={[styles.summaryValue, { color: theme.text }]}>
                {reportData.projectCount}
              </Text>
            </View>

            <View
              style={[
                styles.summaryCard,
                { backgroundColor: theme.card, borderColor: theme.border },
              ]}
            >
              <Text
                style={[styles.summaryTitle, { color: theme.textSecondary }]}
              >
                Chi ph√≠ d·ª± √°n
              </Text>
              <Text style={[styles.summaryValue, { color: theme.primary }]}>
                {formatCurrency(reportData.totalProjectCost)}
              </Text>
            </View>

            <View
              style={[
                styles.summaryCard,
                { backgroundColor: theme.card, borderColor: theme.border },
              ]}
            >
              <Text
                style={[styles.summaryTitle, { color: theme.textSecondary }]}
              >
                Chi ph√≠ c·ªë ƒë·ªãnh
              </Text>
              <Text style={[styles.summaryValue, { color: '#FF9800' }]}>
                {formatCurrency(reportData.fixedCosts)}
              </Text>
            </View>

            <View
              style={[
                styles.summaryCard,
                { backgroundColor: theme.card, borderColor: theme.border },
              ]}
            >
              <Text
                style={[styles.summaryTitle, { color: theme.textSecondary }]}
              >
                L∆∞∆°ng nh√¢n vi√™n
              </Text>
              <Text style={[styles.summaryValue, { color: '#4CAF50' }]}>
                {formatCurrency(reportData.totalSalary)}
              </Text>
            </View>
          </View>

          {/* Total Cost */}
          <View
            style={[
              styles.totalCard,
              { backgroundColor: theme.card, borderColor: theme.border },
            ]}
          >
            <Text style={[styles.totalTitle, { color: theme.text }]}>
              T·ªïng c·ªông
            </Text>
            <Text style={[styles.totalValue, { color: theme.primary }]}>
              {formatCurrency(reportData.totalMonthlyCost)}
            </Text>
          </View>

          {/* Projects List */}
          <View style={styles.projectsSection}>
            <Text style={[styles.sectionTitle, { color: theme.text }]}>
              Chi ti·∫øt d·ª± √°n ({reportData.projectCount})
            </Text>

            {reportData.completedProjects.length > 0 ? (
              <FlatList
                data={reportData.completedProjects}
                renderItem={renderProjectItem}
                keyExtractor={(item, index) =>
                  item?.project?.id
                    ? `${item.project.id}-${index}`
                    : String(index)
                }
                scrollEnabled={false}
                contentContainerStyle={styles.projectsList}
              />
            ) : (
              <View style={styles.emptyContainer}>
                <Ionicons
                  name="document-outline"
                  size={60}
                  color={theme.textMuted}
                />
                <Text
                  style={[styles.emptyText, { color: theme.textSecondary }]}
                >
                  Kh√¥ng c√≥ d·ª± √°n n√†o ho√†n th√†nh trong th√°ng n√†y
                </Text>
              </View>
            )}
          </View>
        </ScrollView>
      ) : (
        <View style={styles.emptyContainer}>
          <Ionicons
            name="analytics-outline"
            size={60}
            color={theme.textMuted}
          />
          <Text style={[styles.emptyText, { color: theme.textSecondary }]}>
            Kh√¥ng c√≥ d·ªØ li·ªáu b√°o c√°o
          </Text>
        </View>
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  dateContainer: {
    padding: 16,
    borderBottomWidth: 1,
  },
  dateButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 12,
    borderWidth: 1,
    borderRadius: 8,
  },
  dateText: {
    fontSize: 16,
    fontWeight: '500',
  },
  debugButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 8,
    borderWidth: 1,
    borderRadius: 6,
    marginTop: 8,
  },
  debugText: {
    fontSize: 12,
    marginLeft: 4,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
  },
  content: {
    flex: 1,
  },
  summaryContainer: {
    flexDirection: 'row',
    padding: 16,
    gap: 12,
  },
  summaryCard: {
    flex: 1,
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    alignItems: 'center',
  },
  summaryTitle: {
    fontSize: 12,
    marginBottom: 8,
  },
  summaryValue: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  totalCard: {
    margin: 16,
    padding: 20,
    borderRadius: 8,
    borderWidth: 1,
    alignItems: 'center',
  },
  totalTitle: {
    fontSize: 16,
    marginBottom: 8,
  },
  totalValue: {
    fontSize: 24,
    fontWeight: 'bold',
  },
  projectsSection: {
    padding: 16,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  projectsList: {
    gap: 12,
  },
  projectCard: {
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
  },
  projectHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  projectName: {
    fontSize: 16,
    fontWeight: '600',
    flex: 1,
  },
  projectTotal: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  costBreakdown: {
    gap: 8,
  },
  costItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  costLabel: {
    fontSize: 14,
  },
  costValue: {
    fontSize: 14,
    fontWeight: '500',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 32,
  },
  emptyText: {
    marginTop: 16,
    fontSize: 16,
    textAlign: 'center',
  },
  accessDenied: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 32,
  },
  accessDeniedText: {
    marginTop: 16,
    fontSize: 16,
    textAlign: 'center',
  },
});

export default MonthlyCostReportScreen;


--- END: src\screens\MonthlyCostReportScreen.js ---


--- START: src\screens\NotificationsScreen.js ---
// src/screens/NotificationsScreen.js
import React, { useState, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  ActivityIndicator,
  TouchableOpacity,
  RefreshControl,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';
import { useAuth } from '../contexts/AuthContext';
import {
  getUserNotifications,
  markNotificationAsRead,
} from '../api/notificationService';

const NotificationsScreen = ({ navigation }) => {
  const { currentUser } = useAuth();
  const [notifications, setNotifications] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  const loadNotifications = useCallback(async () => {
    setLoading(true);
    const data = await getUserNotifications(currentUser?.uid);
    setNotifications(data);
    setLoading(false);
  }, [currentUser]);

  useFocusEffect(
    useCallback(() => {
      loadNotifications();
    }, [loadNotifications])
  );

  const onRefresh = useCallback(() => {
    setRefreshing(true);
    loadNotifications().then(() => setRefreshing(false));
  }, [loadNotifications]);

  const handleNotificationPress = async (item) => {
    if (!item.read) {
      await markNotificationAsRead(item.id);
      // Update UI instantly
      setNotifications((prev) =>
        prev.map((n) => (n.id === item.id ? { ...n, read: true } : n))
      );
    }

    if (item.navLink?.screen) {
      navigation.navigate(item.navLink.screen, item.navLink.params || {});
    }
  };

  const renderItem = ({ item }) => (
    <TouchableOpacity
      style={[styles.notificationItem, !item.read && styles.unreadItem]}
      onPress={() => handleNotificationPress(item)}
    >
      <Ionicons
        name={
          item.type === 'PROPOSAL_APPROVED'
            ? 'checkmark-circle'
            : 'close-circle'
        }
        size={24}
        color={item.type === 'PROPOSAL_APPROVED' ? '#28a745' : '#dc3545'}
        style={styles.icon}
      />
      <View style={styles.content}>
        <Text style={styles.message}>{item.message}</Text>
        <Text style={styles.date}>
          {item.createdAt
            ? new Date(item.createdAt.seconds * 1000).toLocaleString('vi-VN')
            : ''}
        </Text>
      </View>
    </TouchableOpacity>
  );

  if (loading && !refreshing) {
    return (
      <View style={[styles.container, styles.center]}>
        <ActivityIndicator size="large" color="#0066cc" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {notifications.length === 0 ? (
        <View style={styles.center}>
          <Ionicons name="notifications-off-outline" size={60} color="#ccc" />
          <Text style={styles.emptyText}>B·∫°n kh√¥ng c√≥ th√¥ng b√°o n√†o.</Text>
        </View>
      ) : (
        <FlatList
          data={notifications}
          renderItem={renderItem}
          keyExtractor={(item) => item.id}
          contentContainerStyle={styles.list}
          refreshControl={
            <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
          }
        />
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  center: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  list: {
    padding: 16,
  },
  notificationItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#fff',
    padding: 16,
    borderRadius: 8,
    marginBottom: 12,
    elevation: 1,
  },
  unreadItem: {
    backgroundColor: '#eef7ff',
    borderLeftWidth: 4,
    borderLeftColor: '#0066cc',
  },
  icon: {
    marginRight: 16,
  },
  content: {
    flex: 1,
  },
  message: {
    fontSize: 14,
    color: '#333',
    marginBottom: 4,
  },
  date: {
    fontSize: 12,
    color: '#888',
  },
  emptyText: {
    marginTop: 16,
    fontSize: 16,
    color: '#666',
  },
});

export default NotificationsScreen;


--- END: src\screens\NotificationsScreen.js ---


--- START: src\screens\PaymentRequestDetailScreen.js ---
// src/screens/PaymentRequestDetailScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  FlatList,
  ActivityIndicator,
  SafeAreaView,
  Alert,
  TextInput,
  Modal,
  ScrollView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import {
  getPaymentRequestById,
  logPayment,
  updateMisaInvoiceNumber,
} from '../api/paymentService';
import DateTimePicker from '@react-native-community/datetimepicker';

const PaymentRequestDetailScreen = ({ route, navigation }) => {
  const { requestId } = route.params;
  const { theme } = useTheme();
  const { currentUser } = useAuth();
  const [paymentRequest, setPaymentRequest] = useState(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);

  // MISA Invoice Number
  const [misaInvoiceNumber, setMisaInvoiceNumber] = useState('');
  const [editingMisaInvoice, setEditingMisaInvoice] = useState(false);

  // Payment modal
  const [showPaymentModal, setShowPaymentModal] = useState(false);
  const [paymentAmount, setPaymentAmount] = useState('');
  const [paymentMethod, setPaymentMethod] = useState('Chuy·ªÉn kho·∫£n');
  const [paymentNotes, setPaymentNotes] = useState('');
  const [paymentDate, setPaymentDate] = useState(new Date());
  const [showDatePicker, setShowDatePicker] = useState(false);

  useEffect(() => {
    loadPaymentRequestData();
  }, [requestId]);

  const loadPaymentRequestData = async () => {
    try {
      setLoading(true);
      const data = await getPaymentRequestById(requestId);
      if (!data) {
        Alert.alert('L·ªói', 'Kh√¥ng t√¨m th·∫•y th√¥ng tin y√™u c·∫ßu thanh to√°n');
        navigation.goBack();
        return;
      }

      setPaymentRequest(data);
      setMisaInvoiceNumber(data.misaInvoiceNumber || '');
    } catch (error) {
      console.error('Error loading payment request:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i th√¥ng tin y√™u c·∫ßu thanh to√°n');
    } finally {
      setLoading(false);
    }
  };

  const handleSaveMisaInvoice = async () => {
    try {
      setEditingMisaInvoice(false);
      await updateMisaInvoiceNumber(requestId, misaInvoiceNumber);

      // Update local state to reflect changes
      setPaymentRequest((prev) => ({
        ...prev,
        misaInvoiceNumber,
      }));

      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ c·∫≠p nh·∫≠t m√£ s·ªë h√≥a ƒë∆°n MISA');
    } catch (error) {
      console.error('Error updating MISA invoice number:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t m√£ s·ªë h√≥a ƒë∆°n MISA');
    }
  };

  const handleAddPayment = async () => {
    if (!paymentAmount) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p s·ªë ti·ªÅn thanh to√°n');
      return;
    }

    // Parse amount from formatted string
    const amountValue = parseFloat(paymentAmount.replace(/[^0-9]/g, ''));

    if (amountValue <= 0) {
      Alert.alert('L·ªói', 'S·ªë ti·ªÅn thanh to√°n ph·∫£i l·ªõn h∆°n 0');
      return;
    }

    // Check if payment amount exceeds remaining amount
    const remainingAmount =
      (paymentRequest?.amount || 0) - (paymentRequest?.totalPaid || 0);
    if (amountValue > remainingAmount) {
      Alert.alert(
        'C·∫£nh b√°o',
        `S·ªë ti·ªÅn thanh to√°n (${formatCurrency(
          amountValue
        )}) v∆∞·ª£t qu√° s·ªë ti·ªÅn c√≤n l·∫°i (${formatCurrency(
          remainingAmount
        )}). B·∫°n c√≥ mu·ªën ti·∫øp t·ª•c?`,
        [
          { text: 'H·ªßy', style: 'cancel' },
          { text: 'Ti·∫øp t·ª•c', onPress: () => submitPayment(amountValue) },
        ]
      );
      return;
    }

    submitPayment(amountValue);
  };

  const submitPayment = async (amountValue) => {
    try {
      setSaving(true);

      // Create payment data
      const paymentData = {
        amountPaid: amountValue,
        paymentMethod: paymentMethod,
        paymentDate: paymentDate,
        notes: paymentNotes,
        loggedBy: currentUser?.uid,
        loggedByName: currentUser?.displayName || currentUser?.email,
      };

      await logPayment(requestId, paymentData);

      // Reset form
      setPaymentAmount('');
      setPaymentMethod('Chuy·ªÉn kho·∫£n');
      setPaymentNotes('');
      setPaymentDate(new Date());
      setShowPaymentModal(false);

      // Reload data
      await loadPaymentRequestData();

      Alert.alert(
        'Th√†nh c√¥ng',
        `ƒê√£ th√™m thanh to√°n: ${formatCurrency(amountValue)}`
      );
    } catch (error) {
      console.error('Error adding payment:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ th√™m thanh to√°n. Vui l√≤ng th·ª≠ l·∫°i.');
    } finally {
      setSaving(false);
    }
  };

  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
      minimumFractionDigits: 0,
    }).format(amount);
  };

  const formatDate = (timestamp) => {
    if (!timestamp) return 'Ch∆∞a x√°c ƒë·ªãnh';

    try {
      const date = timestamp.seconds
        ? new Date(timestamp.seconds * 1000)
        : new Date(timestamp);

      return date.toLocaleDateString('vi-VN');
    } catch (error) {
      return 'Ng√†y kh√¥ng h·ª£p l·ªá';
    }
  };

  const getStatusColor = (status) => {
    switch (status) {
      case 'paid':
        return '#4CAF50'; // Green
      case 'partially_paid':
        return '#FF9800'; // Orange
      case 'overdue':
        return '#F44336'; // Red
      case 'pending':
      default:
        return '#2196F3'; // Blue
    }
  };

  const getStatusLabel = (status) => {
    switch (status) {
      case 'paid':
        return 'ƒê√£ thanh to√°n';
      case 'partially_paid':
        return 'Thanh to√°n m·ªôt ph·∫ßn';
      case 'overdue':
        return 'Qu√° h·∫°n';
      case 'pending':
      default:
        return 'Ch·ªù thanh to√°n';
    }
  };

  const handlePaymentDateChange = (event, selectedDate) => {
    const currentDate = selectedDate || paymentDate;
    setShowDatePicker(Platform.OS === 'ios');
    setPaymentDate(currentDate);
  };

  const handleAmountChange = (text) => {
    // Remove non-digit characters
    const numberOnly = text.replace(/[^0-9]/g, '');
    if (numberOnly === '') {
      setPaymentAmount('');
      return;
    }

    // Format as currency
    const formatted = new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
      minimumFractionDigits: 0,
    }).format(numberOnly);

    setPaymentAmount(formatted);
  };

  // Render project item
  const renderPaymentItem = ({ item }) => (
    <View
      style={[styles.paymentItem, { backgroundColor: theme.cardBackground }]}
    >
      <View style={styles.paymentHeader}>
        <View style={styles.paymentAmountContainer}>
          <Text style={[styles.paymentAmount, { color: theme.primary }]}>
            {formatCurrency(item.amountPaid)}
          </Text>
          {item.isManualPayment && (
            <View style={styles.manualPaymentBadge}>
              <Ionicons name="hand-left-outline" size={12} color="#FF9800" />
              <Text style={styles.manualPaymentText}>Th·ªß c√¥ng</Text>
            </View>
          )}
        </View>
        <Text style={[styles.paymentDate, { color: theme.textSecondary }]}>
          {formatDate(item.paymentDate)}
        </Text>
      </View>

      <View style={styles.paymentDetails}>
        <View style={styles.paymentMethodRow}>
          <Ionicons
            name={getPaymentMethodIcon(item.paymentMethod)}
            size={16}
            color={theme.textSecondary}
          />
          <Text style={[styles.paymentMethod, { color: theme.text }]}>
            {item.paymentMethod || 'Kh√¥ng c√≥ th√¥ng tin'}
          </Text>
        </View>

        {item.notes && (
          <View style={styles.paymentNotesRow}>
            <Ionicons
              name="document-text-outline"
              size={16}
              color={theme.textSecondary}
            />
            <Text style={[styles.paymentNotes, { color: theme.textSecondary }]}>
              {item.notes}
            </Text>
          </View>
        )}

        {item.loggedByName && (
          <View style={styles.paymentLoggedByRow}>
            <Ionicons
              name="person-outline"
              size={16}
              color={theme.textSecondary}
            />
            <Text
              style={[styles.paymentLoggedBy, { color: theme.textSecondary }]}
            >
              Ghi nh·∫≠n b·ªüi: {item.loggedByName}
            </Text>
          </View>
        )}
      </View>
    </View>
  );

  // Helper function to get payment method icon
  const getPaymentMethodIcon = (method) => {
    switch (method) {
      case 'Chuy·ªÉn kho·∫£n':
        return 'card-outline';
      case 'Ti·ªÅn m·∫∑t':
        return 'cash-outline';
      case 'S√©c':
        return 'document-text-outline';
      default:
        return 'wallet-outline';
    }
  };

  if (loading) {
    return (
      <SafeAreaView
        style={[styles.container, { backgroundColor: theme.background }]}
      >
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
            ƒêang t·∫£i d·ªØ li·ªáu...
          </Text>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <View style={[styles.header, { borderBottomColor: theme.border }]}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={theme.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Chi ti·∫øt Y√™u c·∫ßu Thanh to√°n
        </Text>
      </View>

      <ScrollView style={styles.content}>
        {/* Request Header */}
        <View
          style={[
            styles.requestHeader,
            { backgroundColor: theme.cardBackground },
          ]}
        >
          <View style={styles.requestHeaderRow}>
            <View style={styles.requestInfo}>
              <Text style={[styles.requestNumber, { color: theme.text }]}>
                {paymentRequest?.requestNumber || 'YCTT-???'}
              </Text>
              {paymentRequest?.isManualPayment && (
                <View style={styles.manualPaymentBadge}>
                  <Ionicons
                    name="hand-left-outline"
                    size={12}
                    color="#FF9800"
                  />
                  <Text style={styles.manualPaymentText}>Th·ªß c√¥ng</Text>
                </View>
              )}
            </View>
            <View
              style={[
                styles.statusBadge,
                { backgroundColor: getStatusColor(paymentRequest?.status) },
              ]}
            >
              <Text style={styles.statusText}>
                {getStatusLabel(paymentRequest?.status)}
              </Text>
            </View>
          </View>

          <Text style={[styles.description, { color: theme.text }]}>
            {paymentRequest?.description || 'Kh√¥ng c√≥ m√¥ t·∫£'}
          </Text>

          {paymentRequest?.isManualPayment && (
            <View style={styles.manualPaymentInfo}>
              <Ionicons
                name="information-circle-outline"
                size={16}
                color="#FF9800"
              />
              <Text style={styles.manualPaymentInfoText}>
                ƒê√¢y l√† thanh to√°n th·ªß c√¥ng - ƒë√£ ho√†n th√†nh ngay khi t·∫°o
              </Text>
            </View>
          )}

          <View style={styles.infoRow}>
            <View style={styles.infoItem}>
              <Text style={[styles.infoLabel, { color: theme.textSecondary }]}>
                Ng√†y y√™u c·∫ßu:
              </Text>
              <Text style={[styles.infoValue, { color: theme.text }]}>
                {formatDate(paymentRequest?.issueDate)}
              </Text>
            </View>

            <View style={styles.infoItem}>
              <Text style={[styles.infoLabel, { color: theme.textSecondary }]}>
                H·∫°n thanh to√°n:
              </Text>
              <Text
                style={[
                  styles.infoValue,
                  {
                    color:
                      paymentRequest?.status === 'overdue'
                        ? '#F44336'
                        : theme.text,
                  },
                ]}
              >
                {formatDate(paymentRequest?.dueDate)}
              </Text>
            </View>
          </View>

          <View style={styles.infoRow}>
            <View style={styles.infoItem}>
              <Text style={[styles.infoLabel, { color: theme.textSecondary }]}>
                Kh√°ch h√†ng:
              </Text>
              <Text style={[styles.infoValue, { color: theme.text }]}>
                {paymentRequest?.customerName || 'Kh√¥ng x√°c ƒë·ªãnh'}
              </Text>
            </View>
          </View>

          <View style={styles.amountRow}>
            <View>
              <Text
                style={[styles.amountLabel, { color: theme.textSecondary }]}
              >
                S·ªë ti·ªÅn y√™u c·∫ßu:
              </Text>
              <Text style={[styles.amountValue, { color: theme.primary }]}>
                {formatCurrency(paymentRequest?.amount || 0)}
              </Text>
            </View>

            <View style={{ alignItems: 'flex-end' }}>
              <Text
                style={[styles.amountLabel, { color: theme.textSecondary }]}
              >
                ƒê√£ thanh to√°n:
              </Text>
              <Text
                style={[
                  styles.amountValue,
                  {
                    color:
                      (paymentRequest?.totalPaid || 0) >=
                      (paymentRequest?.amount || 0)
                        ? '#4CAF50'
                        : theme.primary,
                  },
                ]}
              >
                {formatCurrency(paymentRequest?.totalPaid || 0)}
              </Text>
            </View>
          </View>

          {/* T·ªïng ti·ªÅn ƒë√£ thanh to√°n */}
          <View
            style={[
              styles.totalPaidContainer,
              { borderTopColor: theme.border },
            ]}
          >
            <View style={styles.totalPaidRow}>
              <Text
                style={[styles.totalPaidLabel, { color: theme.textSecondary }]}
              >
                T·ªïng ti·ªÅn ƒë√£ thanh to√°n:
              </Text>
              <Text style={[styles.totalPaidValue, { color: '#4CAF50' }]}>
                {formatCurrency(paymentRequest?.totalPaid || 0)}
              </Text>
            </View>

            <View style={styles.totalPaidRow}>
              <Text
                style={[styles.totalPaidLabel, { color: theme.textSecondary }]}
              >
                C√≤n l·∫°i:
              </Text>
              <Text
                style={[
                  styles.totalPaidValue,
                  {
                    color:
                      (paymentRequest?.amount || 0) -
                        (paymentRequest?.totalPaid || 0) >
                      0
                        ? '#FF9800'
                        : '#4CAF50',
                  },
                ]}
              >
                {formatCurrency(
                  (paymentRequest?.amount || 0) -
                    (paymentRequest?.totalPaid || 0)
                )}
              </Text>
            </View>

            {/* N√∫t th√™m thanh to√°n th·ªß c√¥ng */}
            <TouchableOpacity
              style={[
                styles.addManualPaymentButton,
                { backgroundColor: theme.primary },
              ]}
              onPress={() => setShowPaymentModal(true)}
            >
              <Ionicons name="add-circle-outline" size={20} color="#FFFFFF" />
              <Text style={styles.addManualPaymentText}>
                Th√™m thanh to√°n th·ªß c√¥ng
              </Text>
            </TouchableOpacity>
          </View>

          {/* MISA Invoice */}
          <View
            style={[styles.misaContainer, { borderTopColor: theme.border }]}
          >
            <Text style={[styles.misaLabel, { color: theme.textSecondary }]}>
              S·ªë h√≥a ƒë∆°n MISA:
            </Text>

            {editingMisaInvoice ? (
              <View style={styles.misaInputContainer}>
                <TextInput
                  style={[
                    styles.misaInput,
                    {
                      backgroundColor: theme.inputBackground,
                      color: theme.text,
                      borderColor: theme.border,
                    },
                  ]}
                  value={misaInvoiceNumber}
                  onChangeText={setMisaInvoiceNumber}
                  placeholder="Nh·∫≠p s·ªë h√≥a ƒë∆°n"
                  placeholderTextColor={theme.textMuted}
                />
                <TouchableOpacity
                  style={[
                    styles.misaButton,
                    { backgroundColor: theme.primary },
                  ]}
                  onPress={handleSaveMisaInvoice}
                >
                  <Ionicons name="checkmark" size={18} color="#FFFFFF" />
                </TouchableOpacity>
                <TouchableOpacity
                  style={[
                    styles.misaButton,
                    { backgroundColor: theme.danger || '#F44336' },
                  ]}
                  onPress={() => {
                    setEditingMisaInvoice(false);
                    setMisaInvoiceNumber(
                      paymentRequest?.misaInvoiceNumber || ''
                    );
                  }}
                >
                  <Ionicons name="close" size={18} color="#FFFFFF" />
                </TouchableOpacity>
              </View>
            ) : (
              <View style={styles.misaValueContainer}>
                <Text style={[styles.misaValue, { color: theme.text }]}>
                  {paymentRequest?.misaInvoiceNumber || 'Ch∆∞a c√≥'}
                </Text>
                <TouchableOpacity
                  style={styles.editButton}
                  onPress={() => setEditingMisaInvoice(true)}
                >
                  <Ionicons name="pencil" size={18} color={theme.primary} />
                </TouchableOpacity>
              </View>
            )}
          </View>
        </View>

        {/* Payment History */}
        <View
          style={[
            styles.paymentHistoryContainer,
            { backgroundColor: theme.cardBackground },
          ]}
        >
          <View style={styles.paymentHistoryHeader}>
            <Text style={[styles.paymentHistoryTitle, { color: theme.text }]}>
              L·ªãch s·ª≠ thanh to√°n
            </Text>
            <Text
              style={[
                styles.paymentHistoryCount,
                { color: theme.textSecondary },
              ]}
            >
              ({paymentRequest?.payments?.length || 0} thanh to√°n)
            </Text>
          </View>

          {paymentRequest?.payments && paymentRequest.payments.length > 0 ? (
            <FlatList
              data={paymentRequest.payments}
              renderItem={renderPaymentItem}
              keyExtractor={(item, index) => `payment-${index}`}
              scrollEnabled={false}
              contentContainerStyle={styles.paymentList}
            />
          ) : (
            <View style={styles.emptyPayments}>
              <Ionicons
                name="receipt-outline"
                size={48}
                color={theme.textMuted}
              />
              <Text
                style={[
                  styles.emptyPaymentsText,
                  { color: theme.textSecondary },
                ]}
              >
                Ch∆∞a c√≥ thanh to√°n n√†o ƒë∆∞·ª£c ghi nh·∫≠n
              </Text>
            </View>
          )}
        </View>
      </ScrollView>

      {/* Payment Modal */}
      <Modal
        visible={showPaymentModal}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setShowPaymentModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View
            style={[
              styles.modalContent,
              { backgroundColor: theme.cardBackground },
            ]}
          >
            <View style={styles.modalHeader}>
              <Text style={[styles.modalTitle, { color: theme.text }]}>
                Th√™m thanh to√°n th·ªß c√¥ng
              </Text>
              <TouchableOpacity
                onPress={() => setShowPaymentModal(false)}
                style={styles.closeButton}
              >
                <Ionicons name="close" size={24} color={theme.text} />
              </TouchableOpacity>
            </View>

            <ScrollView style={styles.modalBody}>
              {/* Th√¥ng tin YCTT */}
              <View
                style={[
                  styles.modalInfoSection,
                  { borderBottomColor: theme.border },
                ]}
              >
                <Text
                  style={[
                    styles.modalInfoTitle,
                    { color: theme.textSecondary },
                  ]}
                >
                  Th√¥ng tin YCTT
                </Text>
                <Text style={[styles.modalInfoText, { color: theme.text }]}>
                  {paymentRequest?.requestNumber || 'YCTT-???'}
                </Text>
                <Text style={[styles.modalInfoText, { color: theme.text }]}>
                  Kh√°ch h√†ng: {paymentRequest?.customerName || 'Kh√¥ng x√°c ƒë·ªãnh'}
                </Text>
                <Text style={[styles.modalInfoText, { color: theme.text }]}>
                  S·ªë ti·ªÅn: {formatCurrency(paymentRequest?.amount || 0)}
                </Text>
                <Text style={[styles.modalInfoText, { color: theme.text }]}>
                  ƒê√£ thanh to√°n:{' '}
                  {formatCurrency(paymentRequest?.totalPaid || 0)}
                </Text>
                <Text style={[styles.modalInfoText, { color: '#FF9800' }]}>
                  C√≤n l·∫°i:{' '}
                  {formatCurrency(
                    (paymentRequest?.amount || 0) -
                      (paymentRequest?.totalPaid || 0)
                  )}
                </Text>
              </View>

              {/* Form thanh to√°n */}
              <View style={styles.modalFormSection}>
                <Text style={[styles.modalFormTitle, { color: theme.text }]}>
                  Th√¥ng tin thanh to√°n
                </Text>

                <View style={styles.formGroup}>
                  <Text
                    style={[styles.formLabel, { color: theme.textSecondary }]}
                  >
                    S·ªë ti·ªÅn thanh to√°n *
                  </Text>
                  <TextInput
                    style={[
                      styles.formInput,
                      {
                        backgroundColor: theme.inputBackground,
                        color: theme.text,
                        borderColor: theme.border,
                      },
                    ]}
                    value={paymentAmount}
                    onChangeText={handleAmountChange}
                    placeholder="Nh·∫≠p s·ªë ti·ªÅn"
                    placeholderTextColor={theme.textMuted}
                    keyboardType="numeric"
                  />
                </View>

                <View style={styles.formGroup}>
                  <Text
                    style={[styles.formLabel, { color: theme.textSecondary }]}
                  >
                    Ph∆∞∆°ng th·ª©c thanh to√°n
                  </Text>
                  <View style={styles.paymentMethodContainer}>
                    {['Chuy·ªÉn kho·∫£n', 'Ti·ªÅn m·∫∑t', 'S√©c', 'Kh√°c'].map(
                      (method) => (
                        <TouchableOpacity
                          key={method}
                          style={[
                            styles.paymentMethodOption,
                            {
                              backgroundColor:
                                paymentMethod === method
                                  ? theme.primary
                                  : theme.inputBackground,
                              borderColor: theme.border,
                            },
                          ]}
                          onPress={() => setPaymentMethod(method)}
                        >
                          <Text
                            style={[
                              styles.paymentMethodText,
                              {
                                color:
                                  paymentMethod === method
                                    ? '#FFFFFF'
                                    : theme.text,
                              },
                            ]}
                          >
                            {method}
                          </Text>
                        </TouchableOpacity>
                      )
                    )}
                  </View>
                </View>

                <View style={styles.formGroup}>
                  <Text
                    style={[styles.formLabel, { color: theme.textSecondary }]}
                  >
                    Ng√†y thanh to√°n
                  </Text>
                  <TouchableOpacity
                    style={[
                      styles.datePickerButton,
                      {
                        backgroundColor: theme.inputBackground,
                        borderColor: theme.border,
                      },
                    ]}
                    onPress={() => setShowDatePicker(true)}
                  >
                    <Ionicons
                      name="calendar-outline"
                      size={20}
                      color={theme.text}
                    />
                    <Text
                      style={[styles.datePickerText, { color: theme.text }]}
                    >
                      {formatDate(paymentDate)}
                    </Text>
                  </TouchableOpacity>
                </View>

                <View style={styles.formGroup}>
                  <Text
                    style={[styles.formLabel, { color: theme.textSecondary }]}
                  >
                    Ghi ch√∫
                  </Text>
                  <TextInput
                    style={[
                      styles.formTextArea,
                      {
                        backgroundColor: theme.inputBackground,
                        color: theme.text,
                        borderColor: theme.border,
                      },
                    ]}
                    value={paymentNotes}
                    onChangeText={setPaymentNotes}
                    placeholder="Nh·∫≠p ghi ch√∫ (t√πy ch·ªçn)"
                    placeholderTextColor={theme.textMuted}
                    multiline
                    numberOfLines={3}
                  />
                </View>
              </View>
            </ScrollView>

            <View style={styles.modalFooter}>
              <TouchableOpacity
                style={[styles.modalButton, styles.cancelButton]}
                onPress={() => setShowPaymentModal(false)}
              >
                <Text style={styles.cancelButtonText}>H·ªßy</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[
                  styles.modalButton,
                  styles.saveButton,
                  { backgroundColor: theme.primary },
                  saving && { opacity: 0.6 },
                ]}
                onPress={handleAddPayment}
                disabled={saving}
              >
                {saving ? (
                  <ActivityIndicator size="small" color="#FFFFFF" />
                ) : (
                  <Text style={styles.saveButtonText}>Th√™m thanh to√°n</Text>
                )}
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
      {/* Date Picker Modal */}
      {showDatePicker && (
        <DateTimePicker
          value={paymentDate}
          mode="date"
          display="default"
          onChange={(event, selectedDate) => {
            setShowDatePicker(false);
            if (selectedDate) {
              setPaymentDate(selectedDate);
            }
          }}
        />
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
  },
  backButton: {
    marginRight: 16,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  requestHeader: {
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  requestHeaderRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  requestInfo: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  requestNumber: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  manualPaymentBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#FFF3E0', // Light orange background
    borderRadius: 12,
    paddingHorizontal: 6,
    paddingVertical: 2,
    marginLeft: 8,
  },
  manualPaymentText: {
    fontSize: 12,
    fontWeight: '500',
    color: '#FF9800', // Orange color
    marginLeft: 4,
  },
  manualPaymentInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 8,
    marginBottom: 12,
    padding: 10,
    backgroundColor: '#FFFDE7', // Light yellow background
    borderRadius: 8,
    borderLeftWidth: 4,
    borderLeftColor: '#FF9800', // Orange border
  },
  manualPaymentInfoText: {
    fontSize: 13,
    color: '#FF9800', // Orange color
    marginLeft: 8,
  },
  statusBadge: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 12,
  },
  statusText: {
    fontSize: 12,
    fontWeight: '500',
    color: '#FFFFFF',
  },
  description: {
    fontSize: 14,
    marginBottom: 12,
  },
  infoRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  infoItem: {
    flex: 1,
  },
  infoLabel: {
    fontSize: 12,
    marginBottom: 2,
  },
  infoValue: {
    fontSize: 14,
  },
  amountRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 8,
    marginBottom: 16,
  },
  amountLabel: {
    fontSize: 12,
    marginBottom: 2,
  },
  amountValue: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  totalPaidContainer: {
    marginTop: 16,
    paddingTop: 16,
    borderTopWidth: 1,
  },
  totalPaidRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  totalPaidLabel: {
    fontSize: 14,
  },
  totalPaidValue: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  addManualPaymentButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
    marginTop: 16,
  },
  addManualPaymentText: {
    color: '#FFFFFF',
    marginLeft: 4,
    fontSize: 14,
  },
  misaContainer: {
    marginTop: 8,
    paddingTop: 16,
    borderTopWidth: 1,
  },
  misaLabel: {
    fontSize: 14,
    marginBottom: 8,
  },
  misaValueContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  misaValue: {
    fontSize: 16,
    flex: 1,
  },
  editButton: {
    padding: 4,
  },
  misaInputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  misaInput: {
    flex: 1,
    height: 40,
    borderWidth: 1,
    borderRadius: 4,
    paddingHorizontal: 8,
    marginRight: 8,
  },
  misaButton: {
    width: 36,
    height: 36,
    borderRadius: 4,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 4,
  },
  paymentsSection: {
    marginBottom: 16,
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  addButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
  },
  addButtonText: {
    color: '#FFFFFF',
    marginLeft: 4,
    fontSize: 14,
  },
  paymentItem: {
    borderRadius: 8,
    padding: 12,
    marginBottom: 8,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  paymentHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 4,
  },
  paymentAmountContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  paymentAmount: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  paymentDate: {
    fontSize: 14,
  },
  paymentDetails: {
    marginTop: 4,
  },
  paymentMethodRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
  },
  paymentMethod: {
    fontSize: 14,
    marginLeft: 8,
  },
  paymentNotesRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 4,
  },
  paymentNotes: {
    fontSize: 13,
    marginLeft: 8,
  },
  paymentLoggedByRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 4,
  },
  paymentLoggedBy: {
    fontSize: 13,
    marginLeft: 8,
  },
  emptyPayments: {
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  emptyText: {
    marginTop: 8,
    fontSize: 14,
    textAlign: 'center',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    width: '90%',
    borderRadius: 8,
    padding: 16,
    maxHeight: '80%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  closeButton: {
    padding: 4,
  },
  modalBody: {
    flex: 1,
  },
  modalInfoSection: {
    paddingBottom: 16,
    borderBottomWidth: 1,
  },
  modalInfoTitle: {
    fontSize: 14,
    marginBottom: 8,
  },
  modalInfoText: {
    fontSize: 16,
    marginBottom: 4,
  },
  modalFormSection: {
    paddingTop: 16,
  },
  modalFormTitle: {
    fontSize: 14,
    marginBottom: 16,
  },
  formGroup: {
    marginBottom: 16,
  },
  formLabel: {
    fontSize: 14,
    marginBottom: 8,
  },
  formInput: {
    borderWidth: 1,
    borderRadius: 4,
    height: 40,
    paddingHorizontal: 8,
    justifyContent: 'center',
  },
  paymentMethodContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-around',
    marginTop: -8, // Adjust for spacing between options
  },
  paymentMethodOption: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 4,
    marginVertical: 4,
    marginHorizontal: 4,
    borderWidth: 1,
  },
  paymentMethodText: {
    fontSize: 14,
  },
  datePickerButton: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderRadius: 4,
    height: 40,
    paddingHorizontal: 8,
    justifyContent: 'center',
  },
  datePickerText: {
    marginLeft: 8,
    fontSize: 16,
  },
  formTextArea: {
    borderWidth: 1,
    borderRadius: 4,
    height: 80,
    paddingHorizontal: 8,
    paddingTop: 8,
    textAlignVertical: 'top',
  },
  modalFooter: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginTop: 16,
    paddingTop: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  modalButton: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 4,
    alignItems: 'center',
    justifyContent: 'center',
  },
  cancelButton: {
    backgroundColor: '#E0E0E0',
    marginRight: 8,
  },
  cancelButtonText: {
    color: '#333',
    fontSize: 16,
    fontWeight: 'bold',
  },
  saveButton: {
    backgroundColor: '#4CAF50',
  },
  saveButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  paymentHistoryContainer: {
    borderRadius: 8,
    padding: 16,
    marginTop: 16,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  paymentHistoryHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  paymentHistoryTitle: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  paymentHistoryCount: {
    fontSize: 14,
  },
  paymentList: {
    paddingBottom: 16,
  },
  emptyPaymentsText: {
    marginTop: 8,
    fontSize: 14,
    textAlign: 'center',
  },
});

export default PaymentRequestDetailScreen;


--- END: src\screens\PaymentRequestDetailScreen.js ---


--- START: src\screens\PaymentRequestListScreen.js ---
// src/screens/PaymentRequestListScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  FlatList,
  ActivityIndicator,
  SafeAreaView,
  Alert,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { getProjectById } from '../api/projectService';
import { getPaymentRequestsByProject } from '../api/paymentService';
import { getQuotationsByProject } from '../api/quotationService';

const PaymentRequestListScreen = ({ route, navigation }) => {
  const { projectId } = route.params;
  const { theme } = useTheme();
  const [project, setProject] = useState(null);
  const [paymentRequests, setPaymentRequests] = useState([]);
  const [loading, setLoading] = useState(true);
  const [latestQuotation, setLatestQuotation] = useState(null);
  const [totalPaidAmount, setTotalPaidAmount] = useState(0);

  useEffect(() => {
    const loadData = async () => {
      try {
        setLoading(true);
        // Load project details
        const projectData = await getProjectById(projectId);
        if (!projectData) {
          Alert.alert('L·ªói', 'Kh√¥ng t√¨m th·∫•y th√¥ng tin d·ª± √°n');
          navigation.goBack();
          return;
        }
        setProject(projectData);

        // Load payment requests
        const requests = await getPaymentRequestsByProject(projectId);
        setPaymentRequests(requests);

        // Calculate total paid amount
        const totalPaid = requests.reduce((sum, request) => {
          return sum + (request.totalPaid || 0);
        }, 0);
        setTotalPaidAmount(totalPaid);

        // Load latest quotation
        const quotations = await getQuotationsByProject(projectId);
        if (quotations && quotations.length > 0) {
          setLatestQuotation(quotations[0]);
        }
      } catch (error) {
        console.error('Error loading payment requests:', error);
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch y√™u c·∫ßu thanh to√°n');
      } finally {
        setLoading(false);
      }
    };

    loadData();

    // Refresh data when screen is focused
    const unsubscribe = navigation.addListener('focus', () => {
      loadData();
    });

    return unsubscribe;
  }, [projectId, navigation]);

  // Helper function to get quotation total amount
  const getQuotationTotalAmount = (quotation) => {
    if (!quotation) return 0;

    // Check multiple possible field names for total amount
    return (
      quotation.grandTotal ||
      quotation.totalAmount ||
      quotation.amount ||
      quotation.total ||
      quotation.quotationAmount ||
      quotation.finalAmount ||
      quotation.afterDiscountTotal ||
      quotation.subTotal ||
      0
    );
  };

  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
      minimumFractionDigits: 0,
    }).format(amount);
  };

  const formatDate = (timestamp) => {
    if (!timestamp) return 'Ch∆∞a x√°c ƒë·ªãnh';

    try {
      const date = timestamp.seconds
        ? new Date(timestamp.seconds * 1000)
        : new Date(timestamp);

      return date.toLocaleDateString('vi-VN');
    } catch (error) {
      return 'Ng√†y kh√¥ng h·ª£p l·ªá';
    }
  };

  const getStatusColor = (status) => {
    switch (status) {
      case 'paid':
        return '#4CAF50'; // Green
      case 'partially_paid':
        return '#FF9800'; // Orange
      case 'overdue':
        return '#F44336'; // Red
      case 'pending':
      default:
        return '#2196F3'; // Blue
    }
  };

  const getStatusLabel = (status) => {
    switch (status) {
      case 'paid':
        return 'ƒê√£ thanh to√°n';
      case 'partially_paid':
        return 'Thanh to√°n m·ªôt ph·∫ßn';
      case 'overdue':
        return 'Qu√° h·∫°n';
      case 'pending':
      default:
        return 'Ch·ªù thanh to√°n';
    }
  };

  const renderPaymentRequest = ({ item }) => (
    <TouchableOpacity
      style={[
        styles.paymentRequestCard,
        { backgroundColor: theme.cardBackground },
      ]}
      onPress={() =>
        navigation.navigate('PaymentRequestDetail', { requestId: item.id })
      }
    >
      <View style={styles.cardHeader}>
        <View style={styles.requestInfo}>
          <Text style={[styles.requestNumber, { color: theme.text }]}>
            {item.requestNumber}
          </Text>
          {item.isManualPayment && (
            <View style={styles.manualPaymentBadge}>
              <Ionicons name="hand-left-outline" size={12} color="#FF9800" />
              <Text style={styles.manualPaymentText}>Th·ªß c√¥ng</Text>
            </View>
          )}
        </View>
        <View
          style={[
            styles.statusBadge,
            { backgroundColor: getStatusColor(item.status) },
          ]}
        >
          <Text style={styles.statusText}>{getStatusLabel(item.status)}</Text>
        </View>
      </View>

      <Text style={[styles.description, { color: theme.textSecondary }]}>
        {item.description}
      </Text>

      <View style={styles.amountRow}>
        <View style={styles.amountInfo}>
          <Text style={[styles.amountLabel, { color: theme.textSecondary }]}>
            S·ªë ti·ªÅn:
          </Text>
          <Text style={[styles.amountValue, { color: theme.text }]}>
            {formatCurrency(item.amount)}
          </Text>
        </View>
        <View style={styles.amountInfo}>
          <Text style={[styles.amountLabel, { color: theme.textSecondary }]}>
            ƒê√£ thanh to√°n:
          </Text>
          <Text
            style={[
              styles.amountValue,
              {
                color:
                  item.totalPaid >= item.amount ? '#4CAF50' : theme.primary,
              },
            ]}
          >
            {formatCurrency(item.totalPaid || 0)}
          </Text>
        </View>
      </View>

      <View style={styles.dateRow}>
        <View style={styles.dateInfo}>
          <Ionicons
            name="calendar-outline"
            size={16}
            color={theme.textSecondary}
          />
          <Text style={[styles.dateText, { color: theme.textSecondary }]}>
            {formatDate(item.issueDate)}
          </Text>
        </View>
        <View style={styles.dateInfo}>
          <Ionicons name="time-outline" size={16} color={theme.textSecondary} />
          <Text style={[styles.dateText, { color: theme.textSecondary }]}>
            H·∫°n: {formatDate(item.dueDate)}
          </Text>
        </View>
      </View>

      {item.isManualPayment && (
        <View style={styles.manualPaymentInfo}>
          <Ionicons
            name="information-circle-outline"
            size={16}
            color="#FF9800"
          />
          <Text style={styles.manualPaymentInfoText}>
            Thanh to√°n th·ªß c√¥ng - ƒë√£ ho√†n th√†nh
          </Text>
        </View>
      )}
    </TouchableOpacity>
  );

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <View style={[styles.header, { borderBottomColor: theme.border }]}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={theme.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Qu·∫£n l√Ω Thanh to√°n
        </Text>
      </View>

      <View
        style={[styles.projectInfo, { backgroundColor: theme.cardBackground }]}
      >
        <Text style={[styles.projectName, { color: theme.text }]}>
          {project?.name || 'ƒêang t·∫£i...'}
        </Text>
        <Text style={[styles.customerName, { color: theme.textSecondary }]}>
          {project?.customerName || ''}
        </Text>
      </View>

      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
            ƒêang t·∫£i d·ªØ li·ªáu...
          </Text>
        </View>
      ) : (
        <>
          {/* Payment Progress Summary */}
          {latestQuotation && (
            <View
              style={[
                styles.paymentProgressCard,
                { backgroundColor: theme.cardBackground },
              ]}
            >
              <Text style={[styles.progressTitle, { color: theme.text }]}>
                T·ªïng quan thanh to√°n
              </Text>
              <View style={styles.progressInfo}>
                <View style={styles.progressRow}>
                  <Text
                    style={[
                      styles.progressLabel,
                      { color: theme.textSecondary },
                    ]}
                  >
                    B√°o gi√° g·∫ßn nh·∫•t:
                  </Text>
                  <Text style={[styles.progressValue, { color: theme.text }]}>
                    {formatCurrency(getQuotationTotalAmount(latestQuotation))}
                  </Text>
                </View>
                <View style={styles.progressRow}>
                  <Text
                    style={[
                      styles.progressLabel,
                      { color: theme.textSecondary },
                    ]}
                  >
                    ƒê√£ thanh to√°n:
                  </Text>
                  <Text style={[styles.progressValue, { color: '#4CAF50' }]}>
                    {formatCurrency(totalPaidAmount)}
                  </Text>
                </View>
                <View style={styles.progressRow}>
                  <Text
                    style={[
                      styles.progressLabel,
                      { color: theme.textSecondary },
                    ]}
                  >
                    C√≤n l·∫°i:
                  </Text>
                  <Text style={[styles.progressValue, { color: '#FF9800' }]}>
                    {formatCurrency(
                      getQuotationTotalAmount(latestQuotation) - totalPaidAmount
                    )}
                  </Text>
                </View>
              </View>
              <View style={styles.progressBarContainer}>
                <Text
                  style={[styles.progressText, { color: theme.textSecondary }]}
                >
                  Ti·∫øn ƒë·ªô: {formatCurrency(totalPaidAmount)} /{' '}
                  {formatCurrency(getQuotationTotalAmount(latestQuotation))}
                </Text>
                <View style={styles.progressBar}>
                  <View
                    style={[
                      styles.progressFill,
                      {
                        width: `${Math.min(
                          100,
                          (totalPaidAmount /
                            (getQuotationTotalAmount(latestQuotation) || 1)) *
                            100
                        )}%`,
                        backgroundColor:
                          totalPaidAmount >=
                          getQuotationTotalAmount(latestQuotation)
                            ? '#4CAF50'
                            : theme.primary,
                      },
                    ]}
                  />
                </View>
              </View>
            </View>
          )}

          {/* Payment Requests List */}
          {paymentRequests.length === 0 ? (
            <View style={styles.emptyContainer}>
              <Ionicons name="cash-outline" size={60} color={theme.textMuted} />
              <Text style={[styles.emptyText, { color: theme.textSecondary }]}>
                Ch∆∞a c√≥ y√™u c·∫ßu thanh to√°n n√†o
              </Text>
            </View>
          ) : (
            <FlatList
              data={paymentRequests}
              renderItem={renderPaymentRequest}
              keyExtractor={(item) => item.id}
              contentContainerStyle={styles.listContainer}
              showsVerticalScrollIndicator={false}
            />
          )}
        </>
      )}

      <TouchableOpacity
        style={[styles.fab, { backgroundColor: theme.primary }]}
        onPress={() =>
          navigation.navigate('CreatePaymentRequest', { projectId })
        }
      >
        <Ionicons name="add" size={24} color="#FFFFFF" />
      </TouchableOpacity>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
  },
  backButton: {
    marginRight: 16,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  projectInfo: {
    padding: 16,
    marginBottom: 8,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  projectName: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  customerName: {
    fontSize: 14,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  emptyText: {
    marginTop: 16,
    fontSize: 16,
    textAlign: 'center',
  },
  listContainer: {
    padding: 16,
  },
  paymentRequestCard: {
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  cardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  requestInfo: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  requestNumber: {
    fontSize: 18,
    fontWeight: 'bold',
    marginRight: 8,
  },
  manualPaymentBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#FFF3E0',
    borderRadius: 12,
    paddingHorizontal: 6,
    paddingVertical: 2,
  },
  manualPaymentText: {
    fontSize: 12,
    fontWeight: '500',
    color: '#FF9800',
    marginLeft: 4,
  },
  statusBadge: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 12,
  },
  statusText: {
    fontSize: 12,
    fontWeight: '500',
    color: '#FFFFFF',
  },
  description: {
    fontSize: 14,
    marginBottom: 12,
  },
  amountRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  amountInfo: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  amountLabel: {
    fontSize: 14,
    marginRight: 8,
  },
  amountValue: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  dateRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  dateInfo: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  dateText: {
    fontSize: 14,
    marginLeft: 8,
  },
  manualPaymentInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#FFF3E0',
    borderRadius: 12,
    paddingHorizontal: 8,
    paddingVertical: 4,
    marginTop: 8,
  },
  manualPaymentInfoText: {
    fontSize: 12,
    fontWeight: '500',
    color: '#FF9800',
    marginLeft: 8,
  },
  fab: {
    position: 'absolute',
    right: 16,
    bottom: 16,
    width: 56,
    height: 56,
    borderRadius: 28,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 4,
  },
  paymentProgressCard: {
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  progressTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  progressInfo: {
    marginBottom: 12,
  },
  progressRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 4,
  },
  progressLabel: {
    fontSize: 14,
  },
  progressValue: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  progressBarContainer: {
    marginTop: 12,
  },
  progressText: {
    fontSize: 14,
    marginBottom: 8,
  },
  progressBar: {
    height: 8,
    backgroundColor: '#E0E0E0',
    borderRadius: 4,
    overflow: 'hidden',
  },
  progressFill: {
    height: '100%',
    borderRadius: 4,
  },
});

export default PaymentRequestListScreen;


--- END: src\screens\PaymentRequestListScreen.js ---


--- START: src\screens\POListScreen.js ---
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ActivityIndicator,
  FlatList,
  TouchableOpacity,
  Image,
  Linking,
  ScrollView,
} from 'react-native';
import {
  useNavigation,
  useRoute,
  useFocusEffect,
} from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import { getPOsByProject, getAllPOs } from '../api/purchaseOrderService';
import { getProposalsByProject } from '../api/proposalService';

const POListScreen = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { projectId, projectName: routeProjectName } = route.params || {};

  const [pos, setPos] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [expandedId, setExpandedId] = useState(null);

  // Handler to create PO with materials pre-filled from approved proposal
  const handleCreatePO = async () => {
    if (!projectId) {
      navigation.navigate('CreatePO');
      return;
    }

    try {
      // Fetch proposals for this project
      const proposals = await getProposalsByProject(projectId);
      // Find first approved proposal (could enhance to choose latest or prompt user)
      const approved = proposals.find((p) => p.status === 'approved');

      if (!approved) {
        navigation.navigate('CreatePO', { projectId });
        return;
      }

      const poData = {
        projectId,
        projectName: approved.projectName,
        materials:
          approved.items?.map((item) => ({
            name: item.name,
            specs: item.specification || '',
            unit: item.unit || '',
            quantity: item.quantity?.toString() || '',
            unitPrice: item.price?.toString() || '',
          })) || [],
        vatPercentage: 10,
        proposalId: approved.id,
        proposalCode: approved.proposalCode,
      };

      navigation.navigate('CreatePO', poData);
    } catch (e) {
      console.error('Failed to fetch proposals for PO creation', e);
      navigation.navigate('CreatePO', { projectId });
    }
  };

  // Header button to create new PO
  React.useLayoutEffect(() => {
    navigation.setOptions({
      headerRight: () => (
        <TouchableOpacity onPress={handleCreatePO} style={{ marginRight: 15 }}>
          <Ionicons name="add" size={24} color="#007AFF" />
        </TouchableOpacity>
      ),
    });
  }, [navigation, projectId]);

  const loadPOs = async () => {
    try {
      setLoading(true);
      const data = projectId
        ? await getPOsByProject(projectId)
        : await getAllPOs();
      setPos(data);
    } catch (e) {
      console.error('Failed to load POs', e);
    } finally {
      setLoading(false);
    }
  };

  useFocusEffect(
    useCallback(() => {
      loadPOs();
    }, [projectId])
  );

  const handleRefresh = async () => {
    setRefreshing(true);
    await loadPOs();
    setRefreshing(false);
  };

  const formatDate = (timestamp) => {
    if (!timestamp) return 'N/A';
    const date = timestamp.seconds
      ? new Date(timestamp.seconds * 1000)
      : new Date(timestamp);
    return date.toLocaleDateString('vi-VN');
  };

  const renderMaterials = (materials = []) => (
    <View style={styles.materialsContainer}>
      {materials.map((m, index) => (
        <View key={index.toString()} style={styles.materialRow}>
          <Text style={styles.materialName}>
            {index + 1}. {m.name} {m.specs ? `(${m.specs})` : ''}
          </Text>
          <Text style={styles.materialInfo}>
            {m.quantity} {m.unit} x {m.unitPrice}
          </Text>
        </View>
      ))}
    </View>
  );

  const renderItem = ({ item }) => {
    const expanded = expandedId === item.id;
    const isReceived = item.status === 'received';

    return (
      <View style={styles.card}>
        <TouchableOpacity
          style={styles.cardHeader}
          onPress={() => setExpandedId(expanded ? null : item.id)}
        >
          <View style={{ flex: 1 }}>
            <Text style={styles.poNumber}>{item.poNumber || item.id}</Text>
            <Text style={styles.supplierName}>{item.supplierName}</Text>
            <Text style={styles.createdAt}>{formatDate(item.createdAt)}</Text>
          </View>
          <View style={styles.headerRight}>
            {isReceived && (
              <View style={styles.statusBadge}>
                <Text style={styles.statusText}>ƒê√£ nh·∫≠n</Text>
              </View>
            )}
            <Ionicons
              name={expanded ? 'chevron-up' : 'chevron-down'}
              size={20}
              color="#555"
            />
          </View>
        </TouchableOpacity>

        {expanded && (
          <View style={styles.cardBody}>
            {item.projectName || routeProjectName ? (
              <Text style={styles.label}>
                D·ª± √°n: {item.projectName || routeProjectName}
              </Text>
            ) : null}
            {item.proposalNumber ? (
              <Text style={styles.label}>
                S·ªë ƒë·ªÅ xu·∫•t: {item.proposalNumber}
              </Text>
            ) : null}
            {item.deliveryTime ? (
              <Text style={styles.label}>Giao h√†ng: {item.deliveryTime}</Text>
            ) : null}
            <Text style={styles.sectionTitle}>V·∫≠t t∆∞</Text>
            {renderMaterials(item.materials)}

            {isReceived ? (
              <View>
                <View style={styles.receivedInfo}>
                  <Ionicons name="checkmark-circle" size={18} color="#28a745" />
                  <Text style={styles.receivedText}>
                    ƒê√£ x√°c nh·∫≠n nh·∫≠n h√†ng ng√†y {formatDate(item.receivedAt)}
                  </Text>
                </View>

                {/* Hi·ªÉn th·ªã ghi ch√∫ n·∫øu c√≥ */}
                {item.receiptRemarks ? (
                  <Text style={styles.remarksLabel}>Ghi ch√∫:</Text>
                ) : null}
                {item.receiptRemarks ? (
                  <Text style={styles.remarksText}>{item.receiptRemarks}</Text>
                ) : null}

                {/* Hi·ªÉn th·ªã ·∫£nh n·∫øu c√≥ */}
                {item.receiptPhotos && item.receiptPhotos.length > 0 && (
                  <ScrollView
                    horizontal
                    style={styles.photosContainer}
                    contentContainerStyle={{ paddingVertical: 4 }}
                  >
                    {item.receiptPhotos.map((photo, idx) => (
                      <TouchableOpacity
                        key={idx}
                        onPress={() => photo.url && Linking.openURL(photo.url)}
                      >
                        <Image
                          source={{ uri: photo.preview || photo.url }}
                          style={styles.photoThumb}
                        />
                      </TouchableOpacity>
                    ))}
                  </ScrollView>
                )}
              </View>
            ) : (
              <TouchableOpacity
                style={styles.confirmBtn}
                onPress={() =>
                  navigation.navigate('ConfirmPOReceipt', { po: item })
                }
              >
                <Ionicons name="checkbox-outline" size={18} color="#fff" />
                <Text style={styles.confirmBtnText}>
                  X√°c nh·∫≠n ƒë√£ nh·∫≠n v√† th√™m v√†o kho
                </Text>
              </TouchableOpacity>
            )}
          </View>
        )}
      </View>
    );
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0066cc" />
        <Text style={{ marginTop: 8 }}>ƒêang t·∫£i...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <FlatList
        data={pos}
        keyExtractor={(item) => item.id}
        renderItem={renderItem}
        refreshing={refreshing}
        onRefresh={handleRefresh}
        ListEmptyComponent={
          <View style={styles.emptyContainer}>
            <Ionicons name="document-text-outline" size={48} color="#ccc" />
            <Text style={styles.emptyText}>Ch∆∞a c√≥ ƒë∆°n ƒë·∫∑t h√†ng</Text>
          </View>
        }
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 40,
  },
  emptyText: {
    marginTop: 8,
    color: '#666',
  },
  card: {
    backgroundColor: '#fff',
    borderRadius: 8,
    marginBottom: 12,
    elevation: 2,
  },
  cardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
  },
  headerRight: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  statusBadge: {
    backgroundColor: '#28a745',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    marginRight: 8,
  },
  statusText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '500',
  },
  poNumber: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  supplierName: {
    fontSize: 14,
    color: '#555',
  },
  createdAt: {
    color: '#888',
    fontSize: 12,
  },
  cardBody: {
    padding: 12,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  label: {
    fontSize: 14,
    marginBottom: 4,
  },
  sectionTitle: {
    fontSize: 15,
    fontWeight: 'bold',
    marginTop: 8,
  },
  materialsContainer: {
    marginTop: 4,
  },
  materialRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  materialName: {
    fontSize: 13,
    flex: 1,
  },
  materialInfo: {
    fontSize: 13,
    color: '#555',
  },
  confirmBtn: {
    marginTop: 12,
    backgroundColor: '#28a745',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 8,
    borderRadius: 6,
  },
  confirmBtnText: {
    color: '#fff',
    marginLeft: 6,
    fontSize: 14,
    fontWeight: '600',
  },
  receivedInfo: {
    marginTop: 12,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#e8f5e9',
    padding: 8,
    borderRadius: 6,
  },
  receivedText: {
    marginLeft: 8,
    color: '#2e7d32',
    fontSize: 14,
  },
  remarksLabel: {
    fontSize: 14,
    fontWeight: 'bold',
    marginTop: 8,
  },
  remarksText: {
    fontSize: 13,
    color: '#555',
    marginTop: 4,
  },
  photosContainer: {
    marginTop: 8,
    paddingVertical: 4,
  },
  photoThumb: {
    width: 80,
    height: 80,
    borderRadius: 4,
    marginHorizontal: 4,
    borderWidth: 1,
    borderColor: '#eee',
  },
});

export default POListScreen;


--- END: src\screens\POListScreen.js ---


--- START: src\screens\ProductionDashboard.js ---
//src/screens/ProductionDashboard.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  RefreshControl,
  Dimensions,
  Alert,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import ProductionService from '../api/productionService';
import { updateWorkflowStageStatus } from '../api/projectService';
import WorkerCard from '../components/WorkerCard';
import WorkDetailModal from '../components/WorkDetailModal';

const { width } = Dimensions.get('window');

const ProductionDashboard = ({ navigation }) => {
  const { theme } = useTheme();
  const { currentUser } = useAuth();

  // State management
  const [factoryStatus, setFactoryStatus] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [selectedWorker, setSelectedWorker] = useState(null);
  const [showWorkModal, setShowWorkModal] = useState(false);
  const [completedTasks, setCompletedTasks] = useState(new Set()); // üÜï Track completed tasks

  useEffect(() => {
    loadDashboardData();

    // Setup real-time subscription
    const unsubscribe = ProductionService.subscribeLiveFactoryStatus(
      (status) => {
        console.log(
          'Production Dashboard - Real-time update:',
          status.length,
          'workers'
        );
        setFactoryStatus(status);
        setLoading(false);
      }
    );

    return () => {
      if (unsubscribe) {
        unsubscribe();
      }
    };
  }, []);

  const loadDashboardData = async () => {
    try {
      setLoading(true);

      // Factory status will be loaded via real-time subscription
      // No need to load projects data for this dashboard
    } catch (error) {
      console.error('Error loading dashboard data:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu dashboard');
    } finally {
      setLoading(false);
    }
  };

  const handleRefresh = async () => {
    setRefreshing(true);
    await loadDashboardData();
    setRefreshing(false);
  };

  const handleWorkerPress = (worker) => {
    setSelectedWorker(worker);
    setShowWorkModal(true);
  };

  const handleStartWork = async (workerId, workerName, task) => {
    try {
      const sessionId = await ProductionService.startWorkSession(
        workerId,
        task.projectId,
        task.stageId,
        task.stageName,
        task.projectName
      );

      console.log('Started work session:', sessionId);

      // Close modal and show success
      setShowWorkModal(false);
      Alert.alert('Th√†nh c√¥ng', `${workerName} ƒë√£ b·∫Øt ƒë·∫ßu: ${task.stageName}`, [
        { text: 'OK' },
      ]);
    } catch (error) {
      console.error('Error starting work session:', error);
      Alert.alert('L·ªói', `Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu c√¥ng vi·ªác: ${error.message}`);
    }
  };

  // Handle task completion (optimistic update callback)
  const handleTaskCompleted = (completedTaskId, workerId) => {
    console.log(
      'üöÄ Task completed optimistically:',
      completedTaskId,
      'for worker:',
      workerId
    );

    // Add to completed tasks set
    setCompletedTasks((prev) => new Set([...prev, completedTaskId]));

    // Update factory status to reflect completed task
    setFactoryStatus((prevStatus) =>
      prevStatus.map((worker) => {
        if (worker.workerId === workerId) {
          return {
            ...worker,
            // Remove completed task from worker's task count
            taskCount: Math.max(0, (worker.taskCount || 0) - 1),
            // Clear running session if this was the running task
            runningSession:
              worker.runningSession?.stageId === completedTaskId
                ? null
                : worker.runningSession,
          };
        }
        return worker;
      })
    );
  };

  const handleStopWork = async (workerId, workerName, runningSession) => {
    try {
      // Stop the work session
      const duration = await ProductionService.stopWorkSession(
        runningSession.id
      );

      console.log(
        'Stopped work session:',
        runningSession.id,
        'Duration:',
        duration
      );

      // Update workflow stage status to completed
      if (runningSession.projectId && runningSession.stageId) {
        await updateWorkflowStageStatus(
          runningSession.projectId,
          runningSession.stageId,
          'completed'
        );
        console.log(
          'Updated workflow stage status to completed:',
          runningSession.stageId
        );
      }

      // Close modal and show success
      setShowWorkModal(false);
      Alert.alert(
        'Ho√†n th√†nh',
        `${workerName} ƒë√£ ho√†n th√†nh: ${
          runningSession.stageName
        }\nTh·ªùi gian: ${formatDuration(duration)}`,
        [{ text: 'OK' }]
      );
    } catch (error) {
      console.error('Error stopping work session:', error);
      Alert.alert('L·ªói', `Kh√¥ng th·ªÉ k·∫øt th√∫c c√¥ng vi·ªác: ${error.message}`);
    }
  };

  const formatDuration = (seconds) => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    return `${hours.toString().padStart(2, '0')}:${minutes
      .toString()
      .padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  // Calculate grid columns based on screen width
  const getNumColumns = () => {
    if (width > 1200) return 6; // Large tablets/desktop
    if (width > 900) return 4; // Medium tablets
    if (width > 600) return 3; // Small tablets
    return 2; // Phones
  };

  // Get status summary
  const getStatusSummary = () => {
    const working = factoryStatus.filter((w) => w.status === 'working').length;
    const idle = factoryStatus.filter((w) => w.status === 'idle').length;
    const totalTasks = factoryStatus.reduce(
      (sum, w) => sum + w.newTasksCount,
      0
    );

    return { working, idle, totalTasks };
  };

  const { working, idle, totalTasks } = getStatusSummary();

  return (
    <View style={[styles.container, { backgroundColor: theme.background }]}>
      {/* Header */}
      <View style={[styles.header, { backgroundColor: theme.primary }]}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#fff" />
        </TouchableOpacity>

        <View style={styles.headerCenter}>
          <Text style={styles.headerTitle}>Dashboard S·∫£n Xu·∫•t</Text>
          <Text style={styles.headerSubtitle}>Gi√°m s√°t th·ªùi gian th·ª±c</Text>
        </View>

        <TouchableOpacity
          style={styles.refreshButton}
          onPress={handleRefresh}
          disabled={refreshing}
        >
          <Ionicons
            name="refresh"
            size={20}
            color="#fff"
            style={refreshing ? { opacity: 0.5 } : {}}
          />
        </TouchableOpacity>
      </View>

      {/* Status Summary */}
      <View
        style={[styles.statusBar, { backgroundColor: theme.cardBackground }]}
      >
        <View style={styles.statusItem}>
          <View style={[styles.statusDot, { backgroundColor: '#4CAF50' }]} />
          <Text style={[styles.statusLabel, { color: theme.textSecondary }]}>
            ƒêang l√†m vi·ªác
          </Text>
          <Text style={[styles.statusValue, { color: theme.text }]}>
            {working}
          </Text>
        </View>

        <View style={styles.statusItem}>
          <View style={[styles.statusDot, { backgroundColor: '#9E9E9E' }]} />
          <Text style={[styles.statusLabel, { color: theme.textSecondary }]}>
            ƒêang r·∫£nh
          </Text>
          <Text style={[styles.statusValue, { color: theme.text }]}>
            {idle}
          </Text>
        </View>

        <View style={styles.statusItem}>
          <Ionicons name="notifications" size={16} color={theme.primary} />
          <Text style={[styles.statusLabel, { color: theme.textSecondary }]}>
            C√¥ng vi·ªác m·ªõi
          </Text>
          <Text style={[styles.statusValue, { color: theme.text }]}>
            {totalTasks}
          </Text>
        </View>
      </View>

      {/* Workers Grid */}
      <ScrollView
        style={styles.content}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} />
        }
        showsVerticalScrollIndicator={false}
      >
        <View style={styles.workersGrid}>
          {factoryStatus.map((worker) => (
            <WorkerCard
              key={worker.workerId}
              worker={worker}
              onPress={() => handleWorkerPress(worker)}
              screenWidth={width}
              numColumns={getNumColumns()}
            />
          ))}
        </View>

        {factoryStatus.length === 0 && !loading && (
          <View style={styles.emptyContainer}>
            <Ionicons
              name="people-outline"
              size={64}
              color={theme.textSecondary}
            />
            <Text style={[styles.emptyText, { color: theme.textSecondary }]}>
              {loading ? 'ƒêang t·∫£i...' : 'Kh√¥ng c√≥ c√¥ng nh√¢n n√†o'}
            </Text>
          </View>
        )}
      </ScrollView>

      {/* Work Detail Modal */}
      <WorkDetailModal
        visible={showWorkModal}
        worker={selectedWorker}
        onClose={() => {
          setShowWorkModal(false);
          setSelectedWorker(null);
        }}
        onStartWork={handleStartWork}
        onStopWork={handleStopWork}
        onTaskCompleted={handleTaskCompleted} // üÜï Pass callback
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingTop: 50,
    paddingBottom: 16,
    paddingHorizontal: 16,
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  backButton: {
    padding: 8,
  },
  headerCenter: {
    flex: 1,
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#fff',
  },
  headerSubtitle: {
    fontSize: 12,
    color: 'rgba(255, 255, 255, 0.8)',
    marginTop: 2,
  },
  refreshButton: {
    padding: 8,
  },
  statusBar: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    paddingVertical: 16,
    paddingHorizontal: 16,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  statusItem: {
    alignItems: 'center',
    flex: 1,
  },
  statusDot: {
    width: 12,
    height: 12,
    borderRadius: 6,
    marginBottom: 4,
  },
  statusLabel: {
    fontSize: 12,
    textAlign: 'center',
    marginBottom: 2,
  },
  statusValue: {
    fontSize: 18,
    fontWeight: 'bold',
    textAlign: 'center',
  },
  content: {
    flex: 1,
    paddingHorizontal: 16,
  },
  workersGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    paddingVertical: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 60,
  },
  emptyText: {
    fontSize: 16,
    textAlign: 'center',
    marginTop: 16,
  },
});

export default ProductionDashboard;


--- END: src\screens\ProductionDashboard.js ---


--- START: src\screens\ProjectCostScreen.js ---
// src/screens/ProjectCostScreen.js
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  FlatList,
  SafeAreaView,
  Dimensions,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { getProjectById } from '../api/projectService';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import ExpenseService from '../api/expenseService';
import { PieChart } from 'react-native-chart-kit';

const ProjectCostScreen = ({ route, navigation }) => {
  const { projectId } = route.params || {};
  const { theme } = useTheme();
  const { user } = useAuth();

  const [project, setProject] = useState(null);
  const [expenses, setExpenses] = useState([]);
  const [loading, setLoading] = useState(true);
  const [totals, setTotals] = useState({
    total: 0,
    byType: {
      material: 0,
      labor: 0,
      other: 0,
    },
  });
  const screenWidth = Dimensions.get('window').width;

  // Load project data and expenses
  useEffect(() => {
    const loadProjectData = async () => {
      setLoading(true);
      try {
        if (!projectId) {
          console.error('No project ID provided');
          navigation.goBack();
          return;
        }

        // Load project details
        const projectData = await getProjectById(projectId);
        if (!projectData) {
          console.error('Project not found');
          navigation.goBack();
          return;
        }
        setProject(projectData);

        // Load project expenses
        const projectExpenses = await ExpenseService.getExpensesByProject(
          projectId
        );
        setExpenses(projectExpenses);

        // Calculate expense totals
        const expenseTotals = await ExpenseService.getProjectExpenseTotals(
          projectId
        );
        setTotals({
          total: expenseTotals.total,
          byType: {
            material: expenseTotals.byType.material || 0,
            labor: expenseTotals.byType.labor || 0,
            other: expenseTotals.byType.other || 0,
          },
        });
      } catch (error) {
        console.error('Error loading project data:', error);
      } finally {
        setLoading(false);
      }
    };

    loadProjectData();
  }, [projectId, navigation]);

  // Format currency for display
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
      minimumFractionDigits: 0,
    }).format(amount);
  };

  // Format date for display
  const formatDate = (timestamp) => {
    if (!timestamp) return '';

    const date = timestamp.seconds
      ? new Date(timestamp.seconds * 1000)
      : new Date(timestamp);

    return date.toLocaleDateString('vi-VN');
  };

  // Get type label for display
  const getTypeLabel = (type) => {
    switch (type) {
      case 'material':
        return 'V·∫≠t t∆∞';
      case 'labor':
        return 'Nh√¢n c√¥ng';
      case 'other':
        return 'Chi ph√≠ kh√°c';
      default:
        return type || 'Kh√¥ng x√°c ƒë·ªãnh';
    }
  };

  // Get color for expense type
  const getTypeColor = (type) => {
    switch (type) {
      case 'material':
        return '#FF6384';
      case 'labor':
        return '#36A2EB';
      case 'other':
        return '#FFCE56';
      default:
        return '#4BC0C0';
    }
  };

  // Render pie chart data
  const chartData = [
    {
      name: 'V·∫≠t t∆∞',
      amount: totals.byType.material,
      color: '#FF6384',
      legendFontColor: theme.text,
      legendFontSize: 12,
    },
    {
      name: 'Nh√¢n c√¥ng',
      amount: totals.byType.labor,
      color: '#36A2EB',
      legendFontColor: theme.text,
      legendFontSize: 12,
    },
    {
      name: 'Chi ph√≠ kh√°c',
      amount: totals.byType.other,
      color: '#FFCE56',
      legendFontColor: theme.text,
      legendFontSize: 12,
    },
  ].filter((item) => item.amount > 0); // Only include non-zero values

  // Render each expense item
  const renderExpenseItem = ({ item }) => (
    <View
      style={[styles.expenseItem, { backgroundColor: theme.cardBackground }]}
    >
      <View style={styles.expenseHeader}>
        <View style={styles.expenseTypeContainer}>
          <View
            style={[
              styles.expenseTypeIndicator,
              { backgroundColor: getTypeColor(item.type) },
            ]}
          />
          <Text style={[styles.expenseType, { color: theme.textSecondary }]}>
            {getTypeLabel(item.type)}
          </Text>
        </View>
        <Text style={[styles.expenseDate, { color: theme.textSecondary }]}>
          {formatDate(item.date)}
        </Text>
      </View>

      <Text style={[styles.expenseDescription, { color: theme.text }]}>
        {item.description}
      </Text>

      <View style={styles.expenseFooter}>
        {item.quantity && (
          <Text
            style={[styles.expenseQuantity, { color: theme.textSecondary }]}
          >
            SL: {item.quantity} {item.unit || ''}
          </Text>
        )}
        <Text style={[styles.expenseAmount, { color: theme.primary }]}>
          {formatCurrency(item.amount)}
        </Text>
      </View>
    </View>
  );

  if (loading) {
    return (
      <View
        style={[styles.loadingContainer, { backgroundColor: theme.background }]}
      >
        <ActivityIndicator size="large" color={theme.primary} />
        <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
          ƒêang t·∫£i d·ªØ li·ªáu...
        </Text>
      </View>
    );
  }

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={theme.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Chi ph√≠ d·ª± √°n
        </Text>
      </View>

      <ScrollView style={styles.content}>
        {/* Project Info */}
        <View
          style={[
            styles.projectInfoCard,
            { backgroundColor: theme.cardBackground },
          ]}
        >
          <Text style={[styles.projectName, { color: theme.text }]}>
            {project?.name}
          </Text>
          <Text style={[styles.projectInfo, { color: theme.textSecondary }]}>
            Kh√°ch h√†ng: {project?.customerName || 'Kh√¥ng x√°c ƒë·ªãnh'}
          </Text>
        </View>

        {/* Summary Cards */}
        <View style={styles.summaryContainer}>
          <View
            style={[
              styles.summaryCard,
              { backgroundColor: theme.cardBackground },
            ]}
          >
            <Ionicons name="cash-outline" size={24} color={theme.primary} />
            <Text style={[styles.summaryTitle, { color: theme.textSecondary }]}>
              T·ªïng chi ph√≠
            </Text>
            <Text style={[styles.summaryValue, { color: theme.text }]}>
              {formatCurrency(totals.total)}
            </Text>
          </View>

          <View style={styles.summaryRow}>
            <View
              style={[
                styles.summaryCard,
                styles.smallCard,
                { backgroundColor: theme.cardBackground },
              ]}
            >
              <View style={[styles.cardIcon, { backgroundColor: '#FF6384' }]}>
                <Ionicons name="cube-outline" size={18} color="#FFF" />
              </View>
              <Text
                style={[styles.summaryTitle, { color: theme.textSecondary }]}
              >
                V·∫≠t t∆∞
              </Text>
              <Text style={[styles.summaryValue, { color: theme.text }]}>
                {formatCurrency(totals.byType.material)}
              </Text>
            </View>

            <View
              style={[
                styles.summaryCard,
                styles.smallCard,
                { backgroundColor: theme.cardBackground },
              ]}
            >
              <View style={[styles.cardIcon, { backgroundColor: '#36A2EB' }]}>
                <Ionicons name="people-outline" size={18} color="#FFF" />
              </View>
              <Text
                style={[styles.summaryTitle, { color: theme.textSecondary }]}
              >
                Nh√¢n c√¥ng
              </Text>
              <Text style={[styles.summaryValue, { color: theme.text }]}>
                {formatCurrency(totals.byType.labor)}
              </Text>
            </View>

            <View
              style={[
                styles.summaryCard,
                styles.smallCard,
                { backgroundColor: theme.cardBackground },
              ]}
            >
              <View style={[styles.cardIcon, { backgroundColor: '#FFCE56' }]}>
                <Ionicons name="receipt-outline" size={18} color="#FFF" />
              </View>
              <Text
                style={[styles.summaryTitle, { color: theme.textSecondary }]}
              >
                Chi ph√≠ kh√°c
              </Text>
              <Text style={[styles.summaryValue, { color: theme.text }]}>
                {formatCurrency(totals.byType.other)}
              </Text>
            </View>
          </View>
        </View>

        {/* Chart Section */}
        {chartData.length > 0 && (
          <View
            style={[
              styles.chartContainer,
              { backgroundColor: theme.cardBackground },
            ]}
          >
            <Text style={[styles.sectionTitle, { color: theme.text }]}>
              Ph√¢n b·ªï chi ph√≠
            </Text>
            <PieChart
              data={chartData}
              width={screenWidth - 32}
              height={220}
              chartConfig={{
                backgroundColor: theme.cardBackground,
                backgroundGradientFrom: theme.cardBackground,
                backgroundGradientTo: theme.cardBackground,
                color: (opacity = 1) => `rgba(0, 0, 0, ${opacity})`,
                labelColor: (opacity = 1) => theme.text,
                style: {
                  borderRadius: 16,
                },
              }}
              accessor="amount"
              backgroundColor="transparent"
              paddingLeft="15"
              absolute
            />
          </View>
        )}

        {/* Expenses List */}
        <View style={styles.expensesContainer}>
          <Text style={[styles.sectionTitle, { color: theme.text }]}>
            Chi ti·∫øt chi ph√≠
          </Text>

          {expenses.length === 0 ? (
            <View
              style={[
                styles.emptyContainer,
                { backgroundColor: theme.cardBackground },
              ]}
            >
              <Ionicons
                name="receipt-outline"
                size={48}
                color={theme.textMuted}
              />
              <Text style={[styles.emptyText, { color: theme.textSecondary }]}>
                Ch∆∞a c√≥ chi ph√≠ n√†o cho d·ª± √°n n√†y
              </Text>
            </View>
          ) : (
            <FlatList
              data={expenses}
              renderItem={renderExpenseItem}
              keyExtractor={(item) => item.id}
              scrollEnabled={false}
              style={styles.expensesList}
            />
          )}
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  backButton: {
    marginRight: 16,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  content: {
    flex: 1,
  },
  projectInfoCard: {
    margin: 16,
    padding: 16,
    borderRadius: 8,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
  },
  projectName: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  projectInfo: {
    fontSize: 14,
  },
  summaryContainer: {
    paddingHorizontal: 16,
    marginBottom: 16,
  },
  summaryCard: {
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
  },
  summaryRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  smallCard: {
    flex: 1,
    marginHorizontal: 4,
    paddingVertical: 12,
    paddingHorizontal: 8,
  },
  cardIcon: {
    width: 36,
    height: 36,
    borderRadius: 18,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 8,
  },
  summaryTitle: {
    fontSize: 12,
    marginTop: 4,
    textAlign: 'center',
  },
  summaryValue: {
    fontSize: 14,
    fontWeight: 'bold',
    marginTop: 4,
    textAlign: 'center',
  },
  chartContainer: {
    margin: 16,
    padding: 16,
    borderRadius: 8,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    alignItems: 'center',
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  expensesContainer: {
    padding: 16,
    marginBottom: 32,
  },
  expensesList: {
    marginTop: 8,
  },
  expenseItem: {
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  expenseHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  expenseTypeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  expenseTypeIndicator: {
    width: 12,
    height: 12,
    borderRadius: 6,
    marginRight: 6,
  },
  expenseType: {
    fontSize: 12,
  },
  expenseDate: {
    fontSize: 12,
  },
  expenseDescription: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 8,
  },
  expenseFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  expenseQuantity: {
    fontSize: 14,
  },
  expenseAmount: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 32,
    borderRadius: 8,
  },
  emptyText: {
    marginTop: 16,
    fontSize: 16,
    textAlign: 'center',
  },
});

export default ProjectCostScreen;


--- END: src\screens\ProjectCostScreen.js ---


--- START: src\screens\ProjectDetailScreen.js ---
//src/screens/ProjectDetailScreen.js
import React, {
  useState,
  useEffect,
  useCallback,
  useLayoutEffect,
  useRef,
} from 'react';
import { useFocusEffect } from '@react-navigation/native';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  Modal,
  TextInput,
  ActionSheetIOS,
  Platform,
  FlatList,
  Linking,
  Share,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
// Google Signin imported once at top
import { httpsCallable, getFunctions } from 'firebase/functions';
import app, { db } from '../config/firebaseConfig';
import { collection, query, orderBy, limit, getDocs } from 'firebase/firestore';
import {
  updateTaskStatus,
  updateCustomTask,
  deleteProject,
  updateWorkflowStageStatus,
  assignWorkerToStage,
} from '../api/projectService';
import { useAuth } from '../contexts/AuthContext';
import StatusIndicator from '../components/StatusIndicator';
import { useProjectDetails } from '../hooks/useProjectDetails';
import { useAIChatIntegration } from '../hooks/useAIChatIntegration';
import * as Clipboard from 'expo-clipboard';
import ProjectService from '../api/projectService';
import { GoogleSignin } from '@react-native-google-signin/google-signin';
import { updateProject } from '../api/projectService';
import { serverTimestamp } from 'firebase/firestore';
import { useTheme } from '../contexts/ThemeContext';
import StageAssignmentModal from '../components/StageAssignmentModal';
import { getDiscussionCount } from '../api/projectDiscussionService';

// ƒê·ªãnh nghƒ©a danh s√°ch c√¥ng vi·ªác c·ªë ƒë·ªãnh
const TASK_DEFINITIONS = [
  { key: 'material_separation', label: 'B√≥c t√°ch v·∫≠t t∆∞' },
  { key: 'quotation', label: 'B√°o gi√°' },
  { key: 'material_cutting', label: 'C·∫Øt ph√¥i' },
  { key: 'assembly', label: 'L·∫Øp r√°p' },
  { key: 'painting', label: 'S∆°n' },
  { key: 'shipping', label: 'V·∫≠n chuy·ªÉn' },
  { key: 'other', label: 'C√¥ng vi·ªác kh√°c' },
];

// ƒê·ªãnh nghƒ©a c√°c tr·∫°ng th√°i c√¥ng vi·ªác
const TASK_STATUSES = [
  { value: 'pending', label: 'Ch∆∞a th·ª±c hi·ªán' },
  { value: 'in_progress', label: 'ƒêang th·ª±c hi·ªán' },
  { value: 'completed', label: 'Ho√†n th√†nh' },
];

const ProjectDetailScreen = ({ route, navigation }) => {
  const { projectId } = route.params;
  const { currentUser } = useAuth();
  const { project, loading, error, fetchProjectData } =
    useProjectDetails(projectId);
  const { theme } = useTheme();
  const { openAIChatWithProject } = useAIChatIntegration();

  // State cho qu·∫£n l√Ω c√¥ng vi·ªác
  const [customTaskModalVisible, setCustomTaskModalVisible] = useState(false);
  const [customTaskName, setCustomTaskName] = useState('');
  const [copySuccess, setCopySuccess] = useState(false);
  const [stageAssignmentModalVisible, setStageAssignmentModalVisible] =
    useState(false);
  const [selectedStageForAssignment, setSelectedStageForAssignment] =
    useState(null);
  const [isAssigning, setIsAssigning] = useState(false);
  const [discussionCount, setDiscussionCount] = useState(0);

  useEffect(() => {
    if (project?.tasks?.other?.name) {
      setCustomTaskName(project.tasks.other.name);
    }
  }, [project]);

  // Load discussion count
  const loadDiscussionCount = async () => {
    if (projectId) {
      try {
        const count = await getDiscussionCount(projectId);
        setDiscussionCount(count);
      } catch (error) {
        console.error('Error loading discussion count:', error);
      }
    }
  };

  useEffect(() => {
    loadDiscussionCount();
  }, [projectId]);

  // Reload discussion count when screen is focused
  useFocusEffect(
    useCallback(() => {
      loadDiscussionCount();
    }, [projectId])
  );

  // ·∫®n header m·∫∑c ƒë·ªãnh ƒë·ªÉ tr√°nh tr√πng l·∫∑p n√∫t back / ti√™u ƒë·ªÅ
  useLayoutEffect(() => {
    navigation.setOptions({ headerShown: false });
  }, [navigation]);

  // H√†m c·∫≠p nh·∫≠t tr·∫°ng th√°i c√¥ng vi·ªác
  const handleUpdateTaskStatus = async (taskKey) => {
    // Kh√¥ng cho ph√©p thay ƒë·ªïi tr·∫°ng th√°i "B√°o gi√°" v√† "B√≥c t√°ch" tr·ª±c ti·∫øp t·ª´ ƒë√¢y
    if (taskKey === 'quotation' || taskKey === 'material_separation') {
      Alert.alert(
        'Th√¥ng b√°o',
        `ƒê·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i "${getTaskDisplayName(
          taskKey
        )}", vui l√≤ng v√†o m·ª•c "Qu·∫£n l√Ω B√°o gi√°".`
      );
      return;
    }

    if (Platform.OS === 'ios') {
      // S·ª≠ d·ª•ng ActionSheetIOS cho iOS
      ActionSheetIOS.showActionSheetWithOptions(
        {
          options: [...TASK_STATUSES.map((s) => s.label), 'H·ªßy'],
          cancelButtonIndex: TASK_STATUSES.length,
          title: `C·∫≠p nh·∫≠t "${getTaskDisplayName(taskKey)}"`,
        },
        async (buttonIndex) => {
          if (buttonIndex < TASK_STATUSES.length) {
            try {
              await updateTaskStatus(
                projectId,
                taskKey,
                TASK_STATUSES[buttonIndex].value
              );
              fetchProjectData();
            } catch (err) {
              Alert.alert('L·ªói', err.message);
            }
          }
        }
      );
    } else {
      // S·ª≠ d·ª•ng Alert cho Android
      Alert.alert(
        'Ch·ªçn tr·∫°ng th√°i c√¥ng vi·ªác',
        `C·∫≠p nh·∫≠t tr·∫°ng th√°i cho "${getTaskDisplayName(taskKey)}"`,
        [
          ...TASK_STATUSES.map((status) => ({
            text: status.label,
            onPress: async () => {
              try {
                await updateTaskStatus(projectId, taskKey, status.value);
                fetchProjectData();
              } catch (err) {
                Alert.alert('L·ªói', err.message);
              }
            },
          })),
          { text: 'H·ªßy', style: 'cancel' },
        ]
      );
    }
  };

  // H√†m c·∫≠p nh·∫≠t t√™n c√¥ng vi·ªác kh√°c
  const handleUpdateCustomTask = async () => {
    if (!customTaskName.trim() && project?.tasks?.other?.name) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p t√™n c√¥ng vi·ªác');
      return;
    }

    try {
      await updateCustomTask(
        projectId,
        customTaskName.trim(),
        currentUser?.uid
      );
      setCustomTaskModalVisible(false);
      fetchProjectData();
    } catch (err) {
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t t√™n c√¥ng vi·ªác kh√°c');
    }
  };

  // ƒêi·ªÅu h∆∞·ªõng ƒë·∫øn trang chi ti·∫øt kh√°ch h√†ng
  const navigateToCustomerDetail = () => {
    if (project && project.customerId) {
      navigation.navigate('CustomerDetail', { customerId: project.customerId });
    } else {
      Alert.alert('Th√¥ng b√°o', 'D·ª± √°n n√†y ch∆∞a ƒë∆∞·ª£c g√°n cho kh√°ch h√†ng n√†o.');
    }
  };

  // H√†m xo√° d·ª± √°n
  const handleDeleteProject = async () => {
    Alert.alert(
      'X√°c nh·∫≠n X√≥a',
      'B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a d·ª± √°n n√†y kh√¥ng? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.',
      [
        { text: 'H·ªßy', style: 'cancel' },
        {
          text: 'X√≥a',
          style: 'destructive',
          onPress: async () => {
            try {
              await deleteProject(projectId);
              Alert.alert('Th√†nh c√¥ng', 'D·ª± √°n ƒë√£ ƒë∆∞·ª£c x√≥a.', [
                { text: 'OK', onPress: () => navigation.goBack() },
              ]);
            } catch (err) {
              Alert.alert('L·ªói', err.message);
            }
          },
        },
      ]
    );
  };

  // X·ª≠ l√Ω khi ch·ªçn kh√°ch h√†ng
  const handleCopyDriveLink = async () => {
    if (project?.driveFolderUrl) {
      try {
        await Clipboard.setStringAsync(project.driveFolderUrl);
        setCopySuccess(true);
        setTimeout(() => setCopySuccess(false), 2000);
      } catch (err) {
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ copy ƒë∆∞·ªùng d·∫´n.');
      }
    } else {
      Alert.alert(
        'Th√¥ng b√°o',
        'Kh√¥ng c√≥ ƒë∆∞·ªùng d·∫´n Drive ƒë·ªÉ copy. B·∫°n c√≥ mu·ªën t·∫°o th∆∞ m·ª•c Drive cho d·ª± √°n n√†y kh√¥ng?',
        [
          {
            text: 'Kh√¥ng',
            style: 'cancel',
          },
          {
            text: 'T·∫°o th∆∞ m·ª•c',
            onPress: handleCreateDriveFolders,
          },
        ]
      );
    }
  };

  // H√†m t·∫°o th∆∞ m·ª•c Drive cho d·ª± √°n
  const handleCreateDriveFolders = async () => {
    try {
      // Ki·ªÉm tra ƒë√£ ƒëƒÉng nh·∫≠p Google ch∆∞a
      const isSignedIn = await GoogleSignin.isSignedIn();
      if (!isSignedIn) {
        Alert.alert(
          'C·∫ßn ƒëƒÉng nh·∫≠p Google',
          'B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p t√†i kho·∫£n Google ƒë·ªÉ t·∫°o th∆∞ m·ª•c Drive'
        );
        return;
      }

      // L·∫•y token
      const { accessToken } = await GoogleSignin.getTokens();
      if (!accessToken) {
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ l·∫•y th√¥ng tin x√°c th·ª±c Google');
        return;
      }

      // Hi·ªán th√¥ng b√°o ƒëang t·∫°o
      Alert.alert('Th√¥ng b√°o', 'ƒêang t·∫°o th∆∞ m·ª•c Drive, vui l√≤ng ƒë·ª£i...');

      // G·ªçi Cloud Function
      const result = await ProjectService.createProjectFolders(
        projectId,
        accessToken
      );

      if (result) {
        fetchProjectData(); // L√†m m·ªõi d·ªØ li·ªáu d·ª± √°n
        Alert.alert('Th√†nh c√¥ng', 'ƒê√£ t·∫°o th∆∞ m·ª•c Drive cho d·ª± √°n th√†nh c√¥ng');
      }
    } catch (err) {
      console.error('L·ªói t·∫°o th∆∞ m·ª•c Drive:', err);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c Drive: ' + err.message);
    }
  };

  const handleStagePress = (stage) => {
    console.log('üéØ Stage pressed:', {
      stageId: stage.stageId,
      processName: stage.processName,
      status: stage.status,
      projectId,
    });

    try {
      navigation.navigate('StageDetail', { projectId, stage });
    } catch (error) {
      console.error('‚ùå Navigation error:', error);
      Alert.alert('L·ªói', `Kh√¥ng th·ªÉ m·ªü chi ti·∫øt c√¥ng ƒëo·∫°n: ${error.message}`);
    }
  };

  const changeStatus = async (stage, status) => {
    try {
      await updateWorkflowStageStatus(projectId, stage.stageId, status);
      fetchProjectData();
    } catch (e) {
      Alert.alert('L·ªói', e.message);
    }
  };

  // Handle stage assignment
  const handleStageAssignment = async (stageId, workerId, workerName) => {
    try {
      setIsAssigning(true);
      await assignWorkerToStage(projectId, stageId, workerId, workerName);
      setStageAssignmentModalVisible(false);
      Alert.alert('Th√†nh c√¥ng', `ƒê√£ ph√¢n c√¥ng ${workerName} v√†o c√¥ng ƒëo·∫°n n√†y`);
      fetchProjectData(); // Refresh project data
    } catch (error) {
      console.error('Error assigning worker to stage:', error);
      Alert.alert('L·ªói', `Kh√¥ng th·ªÉ ph√¢n c√¥ng c√¥ng vi·ªác: ${error.message}`);
    } finally {
      setIsAssigning(false);
    }
  };

  // Handle assign workers button press
  const handleAssignWorkers = (stage) => {
    console.log('Opening assignment modal for stage:', stage);
    console.log('Project workflowStages:', project?.workflowStages);
    console.log('All project data:', project);
    setSelectedStageForAssignment(stage);
    setStageAssignmentModalVisible(true);
  };

  // Single-flight guard for generating contract
  const isGeneratingContractRef = useRef(false);

  // Helper: safely get Google access token avoiding concurrent getTokens calls
  const getAccessTokenSafe = async () => {
    // Ensure signed in first
    const signedIn = await GoogleSignin.isSignedIn();
    if (!signedIn) {
      await GoogleSignin.signIn();
    }

    let lastErr = null;
    for (let attempt = 0; attempt < 3; attempt++) {
      try {
        const { accessToken } = await GoogleSignin.getTokens();
        if (accessToken) return accessToken;
      } catch (e) {
        lastErr = e;
        const msg = String(e?.message || '');
        if (msg.includes('previous promise did not settle')) {
          // Small backoff before retrying
          await new Promise((r) => setTimeout(r, 400));
          continue;
        }
        throw e;
      }
    }
    throw lastErr || new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c Google access token');
  };

  // Hi·ªÉn th·ªã khi ƒëang t·∫£i d·ªØ li·ªáu
  if (loading) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color="#0066cc" />
        <Text style={styles.loadingText}>ƒêang t·∫£i th√¥ng tin d·ª± √°n...</Text>
      </View>
    );
  }

  // Hi·ªÉn th·ªã khi c√≥ l·ªói
  if (error) {
    return (
      <View style={styles.centerContainer}>
        <Ionicons name="alert-circle-outline" size={50} color="#FF3B30" />
        <Text style={styles.errorText}>{error}</Text>
        <TouchableOpacity
          style={styles.retryButton}
          onPress={() => navigation.goBack()}
        >
          <Text style={styles.retryButtonText}>Quay l·∫°i</Text>
        </TouchableOpacity>
      </View>
    );
  }

  // Hi·ªÉn th·ªã khi kh√¥ng t√¨m th·∫•y d·ª± √°n
  if (!project) {
    return (
      <View style={styles.centerContainer}>
        <Ionicons name="briefcase-outline" size={50} color="#999" />
        <Text style={styles.errorText}>Kh√¥ng t√¨m th·∫•y th√¥ng tin d·ª± √°n</Text>
        <TouchableOpacity
          style={styles.retryButton}
          onPress={() => navigation.goBack()}
        >
          <Text style={styles.retryButtonText}>Quay l·∫°i</Text>
        </TouchableOpacity>
      </View>
    );
  }

  // ƒê·ªãnh d·∫°ng ng√†y th√°ng
  const formatDate = (timestamp) => {
    if (!timestamp) return 'Ch∆∞a x√°c ƒë·ªãnh';
    try {
      return new Date(timestamp.seconds * 1000).toLocaleDateString('vi-VN');
    } catch (e) {
      return 'Ng√†y kh√¥ng h·ª£p l·ªá';
    }
  };

  // ƒê·ªãnh d·∫°ng s·ªë ti·ªÅn
  const formatCurrency = (amount) => {
    if (!amount) return '0 ƒë';
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
      minimumFractionDigits: 0,
    }).format(amount);
  };

  // L·∫•y m√†u s·∫Øc theo tr·∫°ng th√°i d·ª± √°n
  const getStatusColor = (status) => {
    switch (status) {
      case 'pending':
        return '#FFA000'; // Orange
      case 'in_progress':
      case 'in-progress':
        return '#1E88E5'; // Blue
      case 'production_complete':
        return '#8E24AA'; // Purple
      case 'delivered':
        return '#43A047'; // Green
      case 'completed':
        return '#009688'; // Teal
      case 'cancelled':
        return '#E53935'; // Red
      default:
        return '#9E9E9E'; // Grey
    }
  };

  // L·∫•y nh√£n hi·ªÉn th·ªã cho tr·∫°ng th√°i d·ª± √°n
  const getStatusLabel = (status) => {
    switch (status) {
      case 'pending':
        return 'Ch·ªù x·ª≠ l√Ω';
      case 'in_progress':
      case 'in-progress':
        return 'ƒêang th·ª±c hi·ªán';
      case 'production_complete':
        return 'S·∫£n xu·∫•t ho√†n t·∫•t';
      case 'delivered':
        return 'ƒê√£ giao h√†ng';
      case 'completed':
        return 'Ho√†n th√†nh';
      case 'cancelled':
        return 'ƒê√£ h·ªßy';
      default:
        return 'Kh√¥ng x√°c ƒë·ªãnh';
    }
  };

  // L·∫•y m√†u s·∫Øc theo tr·∫°ng th√°i c√¥ng vi·ªác
  const getTaskStatusColor = (status) => {
    switch (status) {
      case 'completed':
        return '#4CAF50';
      case 'in_progress':
        return '#2196F3';
      default:
        return '#FF9800';
    }
  };

  // L·∫•y nh√£n hi·ªÉn th·ªã cho tr·∫°ng th√°i c√¥ng vi·ªác
  const getTaskStatusLabel = (status) => {
    switch (status) {
      case 'completed':
        return 'Ho√†n th√†nh';
      case 'in_progress':
        return 'ƒêang l√†m';
      default:
        return 'Ch·ªù x·ª≠ l√Ω';
    }
  };

  // L·∫•y t√™n hi·ªÉn th·ªã cho c√¥ng vi·ªác
  const getTaskDisplayName = (taskKey) => {
    const task = TASK_DEFINITIONS.find((t) => t.key === taskKey);
    return task ? task.label : 'C√¥ng vi·ªác kh√¥ng x√°c ƒë·ªãnh';
  };

  // Render ch√≠nh
  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Chi ti·∫øt d·ª± √°n</Text>
        {currentUser?.role === 'giam_doc' ||
        currentUser?.role === 'pho_giam_doc' ? (
          <TouchableOpacity
            style={styles.deleteButton}
            onPress={handleDeleteProject}
          >
            <Ionicons name="trash-outline" size={24} color="#d11a2a" />
          </TouchableOpacity>
        ) : (
          <View style={{ width: 24 }} />
        )}
      </View>

      <ScrollView contentContainerStyle={styles.contentContainer}>
        {/* Project Header */}
        <View style={styles.projectHeader}>
          <View style={styles.projectHeaderTop}>
            <Text style={styles.projectName}>
              {project.name || 'Ch∆∞a c√≥ t√™n'}
            </Text>
            <View
              style={[
                styles.statusChip,
                { backgroundColor: `${getStatusColor(project.status)}20` },
              ]}
            >
              <Text
                style={[
                  styles.statusChipText,
                  { color: getStatusColor(project.status) },
                ]}
              >
                {getStatusLabel(project.status)}
              </Text>
            </View>
          </View>

          {project.description ? (
            <Text style={styles.projectDescription}>{project.description}</Text>
          ) : null}
        </View>

        {/* Action Buttons Section - Grid tiles */}
        <View style={styles.actionsContainer}>
          <View style={styles.tileGrid}>
            <TouchableOpacity
              style={styles.tileButton}
              onPress={() =>
                navigation.navigate('Quotation', {
                  projectId: project.id,
                  projectName: project.name,
                  project: project,
                })
              }
            >
              <Ionicons name="calculator-outline" size={22} color="#2E7D32" />
              <Text style={styles.tileLabel}>Qu·∫£n l√Ω B√°o gi√°</Text>
            </TouchableOpacity>

            {project.status === 'in-progress' && (
              <TouchableOpacity
                style={styles.tileButton}
                onPress={() =>
                  navigation.navigate('MaterialPurchase', {
                    projectId: project.id,
                    projectName: project.name,
                    project: project,
                  })
                }
              >
                <Ionicons name="cart-outline" size={22} color="#2E7D32" />
                <Text style={styles.tileLabel}>Qu·∫£n l√Ω Mua V·∫≠t T∆∞</Text>
              </TouchableOpacity>
            )}

            <TouchableOpacity
              style={styles.tileButton}
              onPress={() =>
                navigation.navigate('CreateDeliveryNote', {
                  projectId: project.id,
                  materials: project.materials,
                })
              }
            >
              <Ionicons
                name="document-text-outline"
                size={22}
                color="#2E7D32"
              />
              <Text style={styles.tileLabel}>Bi√™n B·∫£n Giao H√†ng</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={styles.tileButton}
              onPress={() => openAIChatWithProject(project)}
            >
              <Ionicons name="chatbubble-ellipses" size={22} color="#2E7D32" />
              <Text style={styles.tileLabel}>T∆∞ v·∫•n AI</Text>
            </TouchableOpacity>

            {project.driveFolderUrl ? (
              <TouchableOpacity
                style={styles.tileButton}
                onPress={() =>
                  Linking.openURL(project.driveFolderUrl).catch(() =>
                    Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ m·ªü th∆∞ m·ª•c Google Drive')
                  )
                }
              >
                <Ionicons name="folder-open" size={22} color="#2E7D32" />
                <Text style={styles.tileLabel}>M·ªü th∆∞ m·ª•c Drive</Text>
              </TouchableOpacity>
            ) : (
              <TouchableOpacity
                style={styles.tileButton}
                onPress={handleCreateDriveFolders}
              >
                <Ionicons name="cloud-upload" size={22} color="#2E7D32" />
                <Text style={styles.tileLabel}>T·∫°o th∆∞ m·ª•c Drive</Text>
              </TouchableOpacity>
            )}

            <TouchableOpacity
              style={styles.tileButton}
              onPress={() =>
                navigation.navigate('ExpenseList', {
                  projectId: project.id,
                  projectName: project.name,
                })
              }
            >
              <Ionicons name="cash-outline" size={22} color="#2E7D32" />
              <Text style={styles.tileLabel}>Chi ph√≠ d·ª± √°n</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={styles.tileButton}
              onPress={() =>
                navigation.navigate('ProjectDiscussion', {
                  projectId: project.id,
                  projectName: project.name,
                })
              }
            >
              <View style={styles.tileIconContainer}>
                <Ionicons
                  name="chatbubbles-outline"
                  size={22}
                  color="#2E7D32"
                />
                {discussionCount > 0 && (
                  <View style={styles.discussionBadge}>
                    <Text style={styles.discussionBadgeText}>
                      {discussionCount > 99 ? '99+' : discussionCount}
                    </Text>
                  </View>
                )}
              </View>
              <Text style={styles.tileLabel}>Th·∫£o lu·∫≠n d·ª± √°n</Text>
            </TouchableOpacity>

            {/* Qu·∫£n l√Ω H·ª£p ƒë·ªìng: t·∫°o t·ª´ b√°o gi√° m·ªõi nh·∫•t */}
            <TouchableOpacity
              style={styles.tileButton}
              onPress={async () => {
                if (isGeneratingContractRef.current) return;
                isGeneratingContractRef.current = true;
                try {
                  // 1) L·∫•y b√°o gi√° m·ªõi nh·∫•t
                  const quotationsRef = collection(
                    db,
                    `projects/${project.id}/quotations`
                  );
                  const q = query(
                    quotationsRef,
                    orderBy('createdAt', 'desc'),
                    limit(1)
                  );
                  const snap = await getDocs(q);
                  const latestQuotation = snap.empty
                    ? null
                    : { id: snap.docs[0].id, ...snap.docs[0].data() };

                  const materials =
                    latestQuotation?.materials || project.materials || [];

                  // 2) L·∫•y access token Google
                  const accessToken = await getAccessTokenSafe();

                  // 3) Chu·∫©n b·ªã d·ªØ li·ªáu h·ª£p ƒë·ªìng
                  const customerData = {
                    name: project.customerName || '',
                    address: project.customerAddress || '',
                    phone: project.customerPhone || '',
                    taxCode: project.customerTaxCode || '',
                  };

                  const contractData = {
                    companyName: customerData.name,
                    customerAddress: customerData.address,
                    companyPhone: customerData.phone,
                    taxCode: customerData.taxCode,
                    day: String(new Date().getDate()),
                    month: String(new Date().getMonth() + 1),
                    deliveryTime: latestQuotation?.deliveryTime || '',
                    materials,
                  };

                  // 4) G·ªçi Cloud Function generateContract
                  const functions = getFunctions(app, 'us-central1');
                  const generateContract = httpsCallable(
                    functions,
                    'generateContract'
                  );
                  const result = await generateContract({
                    contractData,
                    fileName: `Hop_dong_${
                      project.name || 'du_an'
                    }_${Date.now()}`,
                    projectId: project.id,
                    accessToken,
                  });

                  const { docUrl } = result.data || {};
                  if (docUrl) {
                    Alert.alert('Th√†nh c√¥ng', 'ƒê√£ t·∫°o h·ª£p ƒë·ªìng. M·ªü t√†i li·ªáu?', [
                      { text: 'ƒê√≥ng', style: 'cancel' },
                      {
                        text: 'M·ªü',
                        onPress: () => Linking.openURL(docUrl).catch(() => {}),
                      },
                    ]);
                  } else {
                    Alert.alert(
                      'Th√¥ng b√°o',
                      'ƒê√£ t·∫°o h·ª£p ƒë·ªìng nh∆∞ng kh√¥ng l·∫•y ƒë∆∞·ª£c li√™n k·∫øt.'
                    );
                  }
                } catch (err) {
                  console.error(
                    'Generate contract from latest quotation failed:',
                    err
                  );
                  Alert.alert('L·ªói', err.message || 'Kh√¥ng th·ªÉ t·∫°o h·ª£p ƒë·ªìng');
                } finally {
                  isGeneratingContractRef.current = false;
                }
              }}
            >
              <Ionicons
                name="document-text-outline"
                size={22}
                color="#2E7D32"
              />
              <Text style={styles.tileLabel}>Qu·∫£n l√Ω H·ª£p ƒë·ªìng</Text>
            </TouchableOpacity>

            {/* Chia s·∫ª Link Theo d√µi */}
            <TouchableOpacity
              style={styles.tileButton}
              onPress={async () => {
                try {
                  if (!project.publicTrackingToken) {
                    Alert.alert(
                      'Th√¥ng b√°o',
                      'D·ª± √°n n√†y ch∆∞a c√≥ token theo d√µi. Vui l√≤ng li√™n h·ªá qu·∫£n tr·ªã vi√™n.'
                    );
                    return;
                  }

                  const trackingUrl = `https://tanhoaphat.netlify.app/track?token=${project.publicTrackingToken}`;

                  await Share.share({
                    message: `Theo d√µi ti·∫øn ƒë·ªô d·ª± √°n "${project.name}" c·ªßa THP:\n\n${trackingUrl}\n\nLink n√†y cho ph√©p b·∫°n xem ti·∫øn ƒë·ªô d·ª± √°n theo th·ªùi gian th·ª±c m√† kh√¥ng c·∫ßn ƒëƒÉng nh·∫≠p.`,
                    title: `Theo d√µi d·ª± √°n: ${project.name}`,
                    url: trackingUrl,
                  });
                } catch (error) {
                  console.error('Error sharing tracking link:', error);
                  Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ chia s·∫ª link theo d√µi');
                }
              }}
            >
              <Ionicons name="share-social-outline" size={22} color="#2E7D32" />
              <Text style={styles.tileLabel}>Chia s·∫ª Link Theo d√µi</Text>
            </TouchableOpacity>
          </View>
        </View>

        {/* Ph·∫ßn th√¥ng tin kh√°ch h√†ng v√† c√°c th√¥ng tin kh√°c */}
        <View style={styles.infoSection}>
          <Text style={styles.sectionTitle}>Th√¥ng tin kh√°ch h√†ng</Text>

          <TouchableOpacity
            style={styles.customerCard}
            onPress={navigateToCustomerDetail}
          >
            <View style={styles.customerInfo}>
              <Ionicons
                name="business"
                size={24}
                color="#0066cc"
                style={styles.customerIcon}
              />
              <View>
                <Text style={styles.customerName}>
                  {project.customerName || 'Kh√¥ng x√°c ƒë·ªãnh'}
                </Text>
                {project.customerContact && (
                  <Text style={styles.customerDetail}>
                    Ng∆∞·ªùi li√™n h·ªá: {project.customerContact}
                  </Text>
                )}
                {project.customerEmail && (
                  <Text style={styles.customerDetail}>
                    Email: {project.customerEmail}
                  </Text>
                )}
                {project.customerPhone && (
                  <Text style={styles.customerDetail}>
                    SƒêT: {project.customerPhone}
                  </Text>
                )}
              </View>
            </View>
            <Ionicons name="chevron-forward" size={20} color="#999" />
          </TouchableOpacity>
        </View>

        {/* Th√¥ng tin c∆° b·∫£n */}
        <View style={styles.infoSection}>
          <Text style={styles.sectionTitle}>Th√¥ng tin c∆° b·∫£n</Text>

          {/* C√°c th√¥ng tin hi·ªán c√≥ */}
          <View style={styles.infoRow}>
            <Text style={styles.infoLabel}>Ng√†y b·∫Øt ƒë·∫ßu:</Text>
            <Text style={styles.infoValue}>
              {project.startDate
                ? formatDate(project.startDate)
                : 'Ch∆∞a x√°c ƒë·ªãnh'}
            </Text>
          </View>

          {/* Hi·ªÉn th·ªã ƒë∆∞·ªùng d·∫´n Drive */}
          <View style={styles.infoRow}>
            <Text style={styles.infoLabel}>Google Drive:</Text>
            {project.driveFolderUrl ? (
              <TouchableOpacity
                style={styles.driveLink}
                onPress={handleCopyDriveLink}
              >
                <Ionicons name="link" size={16} color="#0066cc" />
                <Text style={styles.driveLinkText}>
                  {copySuccess ? 'ƒê√£ copy ƒë∆∞·ªùng d·∫´n!' : 'Copy ƒë∆∞·ªùng d·∫´n'}
                </Text>
              </TouchableOpacity>
            ) : (
              <TouchableOpacity
                style={styles.createFolderButton}
                onPress={handleCreateDriveFolders}
              >
                <Ionicons name="cloud-upload" size={16} color="#0066cc" />
                <Text style={styles.createFolderText}>T·∫°o th∆∞ m·ª•c Drive</Text>
              </TouchableOpacity>
            )}
          </View>

          <View style={styles.infoRow}>
            <Text style={styles.infoLabel}>Ng√†y k·∫øt th√∫c:</Text>
            <Text style={styles.infoValue}>
              {project.endDate ? formatDate(project.endDate) : 'Ch∆∞a x√°c ƒë·ªãnh'}
            </Text>
          </View>

          <View style={styles.infoRow}>
            <Text style={styles.infoLabel}>S·ªë ng√†y thi c√¥ng:</Text>
            <Text style={styles.infoValue}>
              {project.durationInDays
                ? `${project.durationInDays} ng√†y`
                : 'Ch∆∞a x√°c ƒë·ªãnh'}
            </Text>
          </View>

          <View style={styles.infoRow}>
            <Text style={styles.infoLabel}>V·ªã tr√≠ thi c√¥ng:</Text>
            <Text style={styles.infoValue}>
              {project.location === 'workshop'
                ? 'T·∫°i x∆∞·ªüng'
                : project.location === 'site'
                ? 'T·∫°i c√¥ng tr√¨nh'
                : 'Ch∆∞a x√°c ƒë·ªãnh'}
            </Text>
          </View>

          {/* Th√™m n√∫t t√≠nh to√°n chi ph√≠ */}
          <View style={[styles.infoRow, { marginTop: 15 }]}>
            <Text style={styles.infoLabel}>Ng√¢n s√°ch:</Text>
            <View style={styles.budgetContainer}>
              <Text style={styles.infoValue}>
                {project.budget?.grandTotal
                  ? formatCurrency(project.budget.grandTotal)
                  : project.budget && typeof project.budget === 'number'
                  ? formatCurrency(project.budget)
                  : 'Ch∆∞a x√°c ƒë·ªãnh'}
              </Text>
              {(currentUser?.role === 'ke_toan' ||
                currentUser?.role === 'giam_doc' ||
                currentUser?.role === 'pho_giam_doc') && (
                <TouchableOpacity
                  style={styles.budgetButton}
                  onPress={() =>
                    navigation.navigate('ProjectCost', {
                      projectId: project.id,
                    })
                  }
                >
                  <Ionicons name="calculator-outline" size={16} color="#fff" />
                  <Text style={styles.budgetButtonText}>T√≠nh chi ph√≠</Text>
                </TouchableOpacity>
              )}
            </View>
          </View>

          {/* Th√™m n√∫t Qu·∫£n l√Ω Thanh to√°n */}
          <View style={[styles.infoRow, { marginTop: 15 }]}>
            <Text style={styles.infoLabel}>Thanh to√°n:</Text>
            <View style={styles.budgetContainer}>
              <TouchableOpacity
                style={[styles.budgetButton, { backgroundColor: '#4CAF50' }]}
                onPress={() =>
                  navigation.navigate('PaymentRequestList', {
                    projectId: project.id,
                  })
                }
              >
                <Ionicons name="cash-outline" size={16} color="#fff" />
                <Text style={styles.budgetButtonText}>Qu·∫£n l√Ω Thanh to√°n</Text>
              </TouchableOpacity>
            </View>
          </View>

          {project.notes && (
            <>
              <Text style={styles.notesLabel}>Ghi ch√∫:</Text>
              <Text style={styles.notesText}>{project.notes}</Text>
            </>
          )}
        </View>

        {/* Status Change Section - Only visible for authorized roles */}
        {(currentUser?.role === 'pho_giam_doc' ||
          currentUser?.role === 'giam_doc' ||
          currentUser?.role === 'ke_toan') && (
          <View
            style={[
              styles.section,
              { backgroundColor: theme.cardBackground, marginTop: 10 },
            ]}
          >
            <Text style={[styles.sectionTitle, { color: theme.text }]}>
              Tr·∫°ng th√°i d·ª± √°n
            </Text>

            <View style={styles.statusActionsContainer}>
              {/* Current status display */}
              <View style={styles.currentStatusContainer}>
                <Text style={{ color: theme.textSecondary }}>
                  Tr·∫°ng th√°i hi·ªán t·∫°i:
                </Text>
                <View
                  style={[
                    styles.statusBadge,
                    { backgroundColor: getStatusColor(project?.status) },
                  ]}
                >
                  <Text style={styles.statusBadgeText}>
                    {getStatusLabel(project?.status)}
                  </Text>
                </View>
              </View>

              {/* Status transition buttons */}
              <View style={styles.statusButtonsContainer}>
                {/* Show "Mark as Production Complete" button only if the project is in progress */}
                {(project?.status === 'in_progress' ||
                  project?.status === 'in-progress') && (
                  <TouchableOpacity
                    style={[
                      styles.statusButton,
                      {
                        backgroundColor: getStatusColor('production_complete'),
                      },
                    ]}
                    onPress={() => {
                      Alert.alert(
                        'X√°c nh·∫≠n',
                        'ƒê√°nh d·∫•u d·ª± √°n ƒë√£ s·∫£n xu·∫•t xong?',
                        [
                          { text: 'H·ªßy', style: 'cancel' },
                          {
                            text: 'X√°c nh·∫≠n',
                            onPress: async () => {
                              try {
                                await updateProject(project.id, {
                                  status: 'production_complete',
                                  updatedAt: serverTimestamp(),
                                });

                                // Refresh project data
                                fetchProjectData();

                                Alert.alert(
                                  'Th√†nh c√¥ng',
                                  'ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i d·ª± √°n'
                                );
                              } catch (error) {
                                console.error(
                                  'Error updating project status:',
                                  error
                                );
                                Alert.alert(
                                  'L·ªói',
                                  'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i d·ª± √°n'
                                );
                              }
                            },
                          },
                        ]
                      );
                    }}
                  >
                    <Ionicons
                      name="checkmark-circle-outline"
                      size={20}
                      color="#fff"
                      style={styles.statusButtonIcon}
                    />
                    <Text style={styles.statusButtonText}>
                      ƒê√°nh d·∫•u ƒë√£ s·∫£n xu·∫•t xong
                    </Text>
                  </TouchableOpacity>
                )}

                {/* Show "Mark as Delivered" button only if the project is production_complete */}
                {project?.status === 'production_complete' && (
                  <TouchableOpacity
                    style={[
                      styles.statusButton,
                      { backgroundColor: getStatusColor('delivered') },
                    ]}
                    onPress={() => {
                      Alert.alert('X√°c nh·∫≠n', 'ƒê√°nh d·∫•u d·ª± √°n ƒë√£ giao h√†ng?', [
                        { text: 'H·ªßy', style: 'cancel' },
                        {
                          text: 'X√°c nh·∫≠n',
                          onPress: async () => {
                            try {
                              await updateProject(project.id, {
                                status: 'delivered',
                                updatedAt: serverTimestamp(),
                              });

                              // Refresh project data
                              fetchProjectData();

                              Alert.alert(
                                'Th√†nh c√¥ng',
                                'ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i d·ª± √°n'
                              );
                            } catch (error) {
                              console.error(
                                'Error updating project status:',
                                error
                              );
                              Alert.alert(
                                'L·ªói',
                                'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i d·ª± √°n'
                              );
                            }
                          },
                        },
                      ]);
                    }}
                  >
                    <Ionicons
                      name="paper-plane-outline"
                      size={20}
                      color="#fff"
                      style={styles.statusButtonIcon}
                    />
                    <Text style={styles.statusButtonText}>
                      ƒê√°nh d·∫•u ƒë√£ giao h√†ng
                    </Text>
                  </TouchableOpacity>
                )}

                {/* Show "Mark as Completed" button only if the project is delivered */}
                {project?.status === 'delivered' && (
                  <TouchableOpacity
                    style={[
                      styles.statusButton,
                      { backgroundColor: getStatusColor('completed') },
                    ]}
                    onPress={() => {
                      Alert.alert('X√°c nh·∫≠n', 'ƒê√°nh d·∫•u d·ª± √°n ho√†n th√†nh?', [
                        { text: 'H·ªßy', style: 'cancel' },
                        {
                          text: 'X√°c nh·∫≠n',
                          onPress: async () => {
                            try {
                              await updateProject(project.id, {
                                status: 'completed',
                                updatedAt: serverTimestamp(),
                              });

                              // Refresh project data
                              fetchProjectData();

                              Alert.alert(
                                'Th√†nh c√¥ng',
                                'ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i d·ª± √°n'
                              );
                            } catch (error) {
                              console.error(
                                'Error updating project status:',
                                error
                              );
                              Alert.alert(
                                'L·ªói',
                                'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i d·ª± √°n'
                              );
                            }
                          },
                        },
                      ]);
                    }}
                  >
                    <Ionicons
                      name="checkmark-done-outline"
                      size={20}
                      color="#fff"
                      style={styles.statusButtonIcon}
                    />
                    <Text style={styles.statusButtonText}>
                      ƒê√°nh d·∫•u ho√†n th√†nh
                    </Text>
                  </TouchableOpacity>
                )}
              </View>
            </View>
          </View>
        )}

        {/* Quy tr√¨nh S·∫£n xu·∫•t */}
        <View style={styles.tasksBoard}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>Quy tr√¨nh S·∫£n xu·∫•t</Text>
            {/* Remove the assignment button here */}
          </View>

          {project?.workflowStages?.length ? (
            project.workflowStages
              .sort((a, b) => a.order - b.order)
              .map((item) => {
                const color =
                  item.status === 'completed'
                    ? '#4CAF50'
                    : item.status === 'in_progress'
                    ? '#FFD54F'
                    : '#9E9E9E';
                return (
                  <View key={item.stageId} style={styles.stageContainer}>
                    <TouchableOpacity
                      style={styles.stageInfo}
                      onPress={() => handleStagePress(item)}
                    >
                      <Text style={styles.taskName}>{item.processName}</Text>
                      <Text
                        style={[
                          styles.taskStatusText,
                          { backgroundColor: color + '33', color: color },
                        ]}
                      >
                        {item.status === 'completed'
                          ? 'Ho√†n th√†nh'
                          : item.status === 'in_progress'
                          ? 'ƒêang l√†m'
                          : 'Ch·ªù x·ª≠ l√Ω'}
                      </Text>

                      {/* Show assigned workers */}
                      {item.assignedWorkers &&
                        item.assignedWorkers.length > 0 && (
                          <Text style={styles.assignedWorkersText}>
                            ƒê√£ giao: {item.assignedWorkers.length} ng∆∞·ªùi
                          </Text>
                        )}
                    </TouchableOpacity>

                    {/* Assign Workers Button */}
                    <TouchableOpacity
                      style={styles.assignButton}
                      onPress={() => handleAssignWorkers(item)}
                    >
                      <Ionicons name="person-add" size={20} color="#fff" />
                    </TouchableOpacity>
                  </View>
                );
              })
          ) : (
            <Text style={styles.emptyTasksText}>Ch∆∞a c√≥ c√¥ng ƒëo·∫°n.</Text>
          )}
        </View>
      </ScrollView>

      {/* Footer */}
      <View style={styles.footer}>
        <TouchableOpacity
          style={styles.editButton}
          onPress={() => navigation.navigate('EditProject', { project })}
        >
          <Ionicons name="create-outline" size={20} color="#fff" />
          <Text style={styles.editButtonText}>Ch·ªânh s·ª≠a</Text>
        </TouchableOpacity>

        {/* X√≥a n√∫t "Ph√¢n c√¥ng" th·ª´a ·ªü ƒë√¢y */}
      </View>

      {/* Modal c·∫≠p nh·∫≠t t√™n c√¥ng vi·ªác kh√°c */}
      <Modal
        visible={customTaskModalVisible}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setCustomTaskModalVisible(false)}
      >
        <TouchableOpacity
          style={styles.modalContainer}
          activeOpacity={1}
          onPress={() => setCustomTaskModalVisible(false)}
        >
          <TouchableOpacity
            style={styles.modalContent}
            activeOpacity={1}
            onPress={(e) => e.stopPropagation()}
          >
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>C·∫≠p nh·∫≠t c√¥ng vi·ªác kh√°c</Text>
              <TouchableOpacity
                style={styles.closeButton}
                onPress={() => setCustomTaskModalVisible(false)}
                hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
              >
                <Ionicons name="close" size={24} color="#333" />
              </TouchableOpacity>
            </View>

            <View style={styles.modalBody}>
              <Text style={styles.inputLabel}>T√™n c√¥ng vi·ªác:</Text>
              <TextInput
                style={styles.input}
                value={customTaskName}
                onChangeText={setCustomTaskName}
                placeholder="Nh·∫≠p t√™n c√¥ng vi·ªác kh√°c..."
              />

              <TouchableOpacity
                style={[styles.saveTaskButton, { marginTop: 20 }]}
                onPress={handleUpdateCustomTask}
              >
                <Text style={styles.saveTaskButtonText}>L∆∞u</Text>
              </TouchableOpacity>
            </View>
          </TouchableOpacity>
        </TouchableOpacity>
      </Modal>

      {/* Stage Assignment Modal */}
      <StageAssignmentModal
        visible={stageAssignmentModalVisible}
        onClose={() => {
          setStageAssignmentModalVisible(false);
          setSelectedStageForAssignment(null);
        }}
        onAssign={handleStageAssignment}
        projectId={projectId}
        selectedStage={selectedStageForAssignment}
        projectStages={project?.workflowStages || []}
        navigation={navigation}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
  },
  errorText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  retryButton: {
    marginTop: 16,
    backgroundColor: '#0066cc',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 6,
  },
  retryButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '500',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    position: 'absolute',
    left: 0,
    right: 0,
    textAlign: 'center',
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  deleteButton: {
    padding: 4,
  },
  contentContainer: {
    paddingBottom: 20,
  },
  projectHeader: {
    backgroundColor: '#fff',
    padding: 16,
    marginBottom: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#eef1f5',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.06,
    shadowRadius: 3,
    elevation: 1,
  },
  projectHeaderTop: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  projectName: {
    fontSize: 22,
    fontWeight: '800',
    color: '#111827',
    marginBottom: 8,
  },
  statusContainer: {
    flexDirection: 'row',
    marginBottom: 12,
  },
  statusTag: {
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 10,
    paddingVertical: 4,
  },
  statusChip: {
    borderRadius: 12,
    paddingHorizontal: 10,
    paddingVertical: 4,
    alignSelf: 'flex-start',
  },
  statusChipText: {
    fontSize: 13,
    fontWeight: '600',
  },
  statusText: {
    fontSize: 14,
    fontWeight: '500',
  },
  projectDescription: {
    fontSize: 15,
    color: '#4B5563',
    lineHeight: 22,
    marginTop: 8,
  },
  infoSection: {
    backgroundColor: '#fff',
    padding: 16,
    marginBottom: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#eef1f5',
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: '#111827',
    marginBottom: 12,
  },
  customerCard: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    padding: 12,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: '#eef1f5',
  },
  customerInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  customerIcon: {
    marginRight: 12,
  },
  customerName: {
    fontSize: 16,
    fontWeight: '700',
    color: '#111827',
    marginBottom: 2,
  },
  customerDetail: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  infoRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#eef1f5',
  },
  infoLabel: {
    fontSize: 15,
    color: '#6B7280',
    flex: 1,
  },
  infoValue: {
    fontSize: 15,
    color: '#111827',
    fontWeight: '600',
    flex: 1,
    textAlign: 'right',
  },
  notesLabel: {
    fontSize: 15,
    color: '#666',
    marginTop: 12,
    marginBottom: 6,
  },
  notesText: {
    fontSize: 15,
    color: '#333',
    lineHeight: 20,
  },
  footer: {
    backgroundColor: '#fff',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
    flexDirection: 'row',
    justifyContent: 'space-between', // Better alignment for multiple buttons
  },
  editButton: {
    backgroundColor: '#0066cc',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 8,
    flex: 1, // Make buttons take equal space
  },
  assignButton: {
    backgroundColor: '#4CAF50',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 8,
    flex: 1, // Make buttons take equal space
    marginLeft: 10,
  },
  editButtonText: {
    color: 'white',
    fontWeight: '600',
    marginLeft: 6,
  },
  assignButtonText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 14,
    marginLeft: 6,
  },
  tasksBoard: {
    backgroundColor: '#fff',
    padding: 16,
    marginBottom: 12,
  },
  taskRow: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  taskContent: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginLeft: 12,
  },
  taskName: {
    fontSize: 16,
    color: '#333',
    flex: 1,
    marginRight: 8,
  },
  taskNamePlaceholder: {
    fontSize: 16,
    color: '#999',
    fontStyle: 'italic',
  },
  taskStatusText: {
    fontSize: 14,
    fontWeight: '500',
    backgroundColor: '#f5f5f5',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    overflow: 'hidden',
    minWidth: 80,
    textAlign: 'center',
  },
  editTaskButton: {
    padding: 8,
  },
  emptyTasksContainer: {
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  emptyTasksText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  modalContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  modalContent: {
    backgroundColor: 'white',
    padding: 20,
    borderRadius: 10,
    width: '85%',
    maxWidth: 400,
  },
  modalHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingBottom: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    marginBottom: 16,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  closeButton: {
    padding: 4,
  },
  modalBody: {
    width: '100%',
  },
  inputLabel: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 12,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 12,
    borderRadius: 6,
    width: '100%',
    backgroundColor: '#fff',
    fontSize: 16,
  },
  saveTaskButton: {
    backgroundColor: '#0066cc',
    padding: 12,
    borderRadius: 6,
    alignItems: 'center',
  },
  saveTaskButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  quotationButton: {
    backgroundColor: '#4CAF50',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 14,
    borderRadius: 8,
    marginBottom: 10,
  },
  quotationButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
    marginLeft: 10,
  },
  driveLinkContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 10,
  },
  driveLinkButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#2196F3',
    paddingVertical: 12,
    borderRadius: 8,
  },
  buttonIcon: {
    marginRight: 10,
  },
  driveLinkText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  shareButton: {
    marginLeft: 12,
    width: 44,
    height: 44,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  driveNotAvailable: {
    textAlign: 'center',
    color: '#888',
    fontSize: 14,
    marginTop: 8,
    fontStyle: 'italic',
  },
  driveLink: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
    padding: 10,
    borderRadius: 6,
    marginTop: 4,
  },
  createFolderButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
    padding: 10,
    borderRadius: 6,
    marginTop: 4,
  },
  createFolderText: {
    marginLeft: 8,
    color: '#0066cc',
    fontSize: 14,
    fontWeight: '500',
  },
  actionsContainer: {
    backgroundColor: '#fff',
    padding: 16,
    marginBottom: 12,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#eee',
  },
  tileGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  tileButton: {
    width: '31%',
    aspectRatio: 1,
    borderRadius: 12,
    padding: 10,
    marginBottom: 12,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#eef1f5',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.06,
    shadowRadius: 3,
    elevation: 1,
  },
  tileLabel: {
    color: '#000',
    fontWeight: '600',
    fontSize: 12,
    textAlign: 'center',
    marginTop: 6,
  },
  tileIconContainer: {
    position: 'relative',
    alignItems: 'center',
    justifyContent: 'center',
  },
  discussionBadge: {
    position: 'absolute',
    top: -8,
    right: -8,
    backgroundColor: '#FF5722',
    borderRadius: 10,
    minWidth: 20,
    height: 20,
    alignItems: 'center',
    justifyContent: 'center',
    paddingHorizontal: 4,
  },
  discussionBadgeText: {
    color: '#fff',
    fontSize: 10,
    fontWeight: 'bold',
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    borderRadius: 8,
    marginTop: 10,
  },
  actionIcon: {
    marginRight: 10,
  },
  actionText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  budgetContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
    justifyContent: 'space-between',
  },
  budgetButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#0066cc',
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 6,
  },
  budgetButtonText: {
    color: '#fff',
    fontSize: 14,
    fontWeight: '500',
    marginLeft: 5,
  },
  driveButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  driveButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#1976D2',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 4,
    flex: 1,
    marginRight: 8,
    justifyContent: 'center',
  },
  budgetCalcButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#0066cc',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 4,
    flex: 1,
    marginLeft: 8,
    justifyContent: 'center',
  },
  driveButtonIcon: {
    marginRight: 8,
  },
  driveButtonText: {
    color: '#fff',
    fontWeight: 'bold',
  },
  expenseButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#FF9800', // Orange color for expense tracking
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 4,
    flex: 1,
    marginRight: 8,
    justifyContent: 'center',
  },

  currentStatusContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  statusBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
    marginLeft: 10,
  },
  statusBadgeText: {
    color: '#fff',
    fontWeight: 'bold',
    fontSize: 12,
  },
  statusActionsContainer: {
    marginTop: 10,
  },
  statusButtonsContainer: {
    marginTop: 8,
  },
  statusButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 12,
    borderRadius: 4,
    marginVertical: 5,
  },
  statusButtonIcon: {
    marginRight: 8,
  },
  statusButtonText: {
    color: '#ffffff',
    fontWeight: 'bold',
    fontSize: 14,
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },

  assignButtonText: {
    color: '#fff',
    fontWeight: '500',
    fontSize: 14,
    marginLeft: 4,
  },

  stageContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  stageInfo: {
    flex: 1,
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  assignedWorkersText: {
    fontSize: 12,
    color: '#666',
    marginTop: 4,
    fontStyle: 'italic',
  },
  assignButton: {
    padding: 12,
    marginRight: 16,
    borderRadius: 8,
    backgroundColor: '#2196F3',
    alignItems: 'center',
    justifyContent: 'center',
    minWidth: 44,
    minHeight: 44,
  },
});

export default ProjectDetailScreen;


--- END: src\screens\ProjectDetailScreen.js ---


--- START: src\screens\ProjectDiscussionScreen.js ---
import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TextInput,
  TouchableOpacity,
  Alert,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
  Image,
  Modal,
} from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import * as DocumentPicker from 'expo-document-picker';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import {
  getProjectDiscussions,
  addDiscussionMessage,
  updateDiscussionMessage,
  recallDiscussionMessage,
  subscribeToProjectDiscussions,
  uploadFileToStorage,
} from '../api/projectDiscussionService';

const ProjectDiscussionScreen = ({ route, navigation }) => {
  const { theme } = useTheme();
  const { user } = useAuth();
  const { projectId, projectName } = route.params;

  const [discussions, setDiscussions] = useState([]);
  const [newMessage, setNewMessage] = useState('');
  const [loading, setLoading] = useState(true);
  const [sending, setSending] = useState(false);
  const [editingMessage, setEditingMessage] = useState(null);
  const [editText, setEditText] = useState('');
  const [showAttachmentMenu, setShowAttachmentMenu] = useState(false);
  const [uploadingFile, setUploadingFile] = useState(false);
  const [selectedImage, setSelectedImage] = useState(null);

  const flatListRef = useRef(null);
  const unsubscribeRef = useRef(null);

  useEffect(() => {
    // Set up real-time listener
    unsubscribeRef.current = subscribeToProjectDiscussions(
      projectId,
      (discussions) => {
        setDiscussions(discussions);
        setLoading(false);
      }
    );

    return () => {
      if (unsubscribeRef.current) {
        unsubscribeRef.current();
      }
    };
  }, [projectId]);

  const handleSendMessage = async () => {
    if (!newMessage.trim()) return;

    try {
      setSending(true);
      await addDiscussionMessage(
        projectId,
        newMessage.trim(),
        user.uid,
        user.displayName || user.email,
        user.photoURL || null
      );
      setNewMessage('');
      flatListRef.current?.scrollToOffset({ offset: 0, animated: true });
    } catch (error) {
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn. Vui l√≤ng th·ª≠ l·∫°i.');
    } finally {
      setSending(false);
    }
  };

  const handleEditMessage = (message) => {
    setEditingMessage(message.id);
    setEditText(message.message);
  };

  const handleSaveEdit = async () => {
    if (!editText.trim()) return;

    try {
      await updateDiscussionMessage(editingMessage, editText.trim());
      setEditingMessage(null);
      setEditText('');
    } catch (error) {
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tin nh·∫Øn. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  };

  const handleCancelEdit = () => {
    setEditingMessage(null);
    setEditText('');
  };

  const handleRecallMessage = (messageId) => {
    Alert.alert(
      'X√°c nh·∫≠n thu h·ªìi',
      'B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën thu h·ªìi tin nh·∫Øn n√†y?',
      [
        { text: 'H·ªßy', style: 'cancel' },
        {
          text: 'Thu h·ªìi',
          style: 'destructive',
          onPress: async () => {
            try {
              await recallDiscussionMessage(messageId);
            } catch (error) {
              Alert.alert(
                'L·ªói',
                'Kh√¥ng th·ªÉ thu h·ªìi tin nh·∫Øn. Vui l√≤ng th·ª≠ l·∫°i.'
              );
            }
          },
        },
      ]
    );
  };

  const handlePickImage = async () => {
    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        aspect: [4, 3],
        quality: 0.8,
      });

      if (!result.canceled && result.assets[0]) {
        await handleUploadFile(
          {
            uri: result.assets[0].uri,
            name: `image_${Date.now()}.jpg`,
            type: 'image/jpeg',
            size: result.assets[0].fileSize || 0,
          },
          'image'
        );
      }
    } catch (error) {
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ch·ªçn ·∫£nh. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  };

  const handlePickDocument = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: [
          'application/pdf',
          'application/msword',
          'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        ],
        copyToCacheDirectory: true,
      });

      if (!result.canceled && result.assets[0]) {
        await handleUploadFile(
          {
            uri: result.assets[0].uri,
            name: result.assets[0].name,
            type: result.assets[0].mimeType,
            size: result.assets[0].size,
          },
          'pdf'
        );
      }
    } catch (error) {
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ch·ªçn t√†i li·ªáu. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  };

  const handleUploadFile = async (file, messageType) => {
    try {
      setUploadingFile(true);

      // Upload file to Firebase Storage instead of Google Drive
      const uploadedFile = await uploadFileToStorage(file, projectId);

      // Add message with attachment
      await addDiscussionMessage(
        projectId,
        messageType === 'image' ? '' : 'üìÑ T√†i li·ªáu',
        user.uid,
        user.displayName || user.email,
        user.photoURL || null,
        messageType,
        [uploadedFile]
      );

      setShowAttachmentMenu(false);
      // B·ªè notification th√†nh c√¥ng
    } catch (error) {
      console.error('Upload error:', error);
      Alert.alert('L·ªói', `Kh√¥ng th·ªÉ upload file: ${error.message}`);
    } finally {
      setUploadingFile(false);
    }
  };

  // H√†m test notification
  const handleTestNotification = async () => {
    try {
      // G·ª≠i tin nh·∫Øn test ƒë·ªÉ trigger notification
      await addDiscussionMessage(
        projectId,
        'üîî TEST NOTIFICATION - Ki·ªÉm tra push notification!',
        user.uid,
        user.displayName || user.email,
        user.photoURL || null
      );

      Alert.alert(
        'Test Notification',
        'ƒê√£ g·ª≠i tin nh·∫Øn test! B√¢y gi·ªù h√£y:\n\n1. Nh·∫•n Home ƒë·ªÉ ƒë∆∞a app v·ªÅ background\n2. Ho·∫∑c t·∫Øt app ho√†n to√†n\n3. Ch·ªù notification xu·∫•t hi·ªán',
        [{ text: 'OK' }]
      );
    } catch (error) {
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn test. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  };

  const renderMessage = ({ item }) => {
    const isOwnMessage = item.userId === user.uid;
    const isEditing = editingMessage === item.id;
    // Ki·ªÉm tra xem tin nh·∫Øn c√≥ ph·∫£i ch·ªâ l√† h√¨nh ·∫£nh kh√¥ng
    const isImageOnly =
      !item.message &&
      item.attachments &&
      item.attachments.length > 0 &&
      item.attachments[0].type?.startsWith('image/');

    if (item.isRecalled) {
      return (
        <View
          style={[styles.messageContainer, isOwnMessage && styles.ownMessage]}
        >
          <Text style={styles.recalledText}>Tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c thu h·ªìi</Text>
        </View>
      );
    }

    return (
      <View
        style={[styles.messageContainer, isOwnMessage && styles.ownMessage]}
      >
        {!isOwnMessage && (
          <View style={styles.userInfo}>
            {item.userPhotoURL ? (
              <Image
                source={{ uri: item.userPhotoURL }}
                style={styles.avatar}
              />
            ) : (
              <View style={styles.avatarPlaceholder}>
                <Ionicons name="person" size={20} color={theme.text} />
              </View>
            )}
            <Text style={styles.userName}>{item.userName}</Text>
          </View>
        )}

        {isEditing ? (
          <View style={styles.editContainer}>
            <TextInput
              style={styles.editInput}
              value={editText}
              onChangeText={setEditText}
              multiline
              placeholder="Ch·ªânh s·ª≠a tin nh·∫Øn..."
            />
            <View style={styles.editActions}>
              <TouchableOpacity
                onPress={handleSaveEdit}
                style={styles.editButton}
              >
                <Text style={styles.editButtonText}>L∆∞u</Text>
              </TouchableOpacity>
              <TouchableOpacity
                onPress={handleCancelEdit}
                style={styles.cancelButton}
              >
                <Text style={styles.cancelButtonText}>H·ªßy</Text>
              </TouchableOpacity>
            </View>
          </View>
        ) : (
          <View
            style={[
              isOwnMessage ? styles.ownMessageContent : styles.messageContent,
              // Ghi ƒë√® style n·∫øu ch·ªâ c√≥ h√¨nh ·∫£nh
              isImageOnly && {
                padding: 0,
                backgroundColor: 'transparent',
                borderWidth: 0,
                shadowOpacity: 0,
                elevation: 0,
                borderRadius: 15,
              },
            ]}
          >
            {/* Timestamp ·ªü tr√™n ƒë·∫ßu */}
            <Text style={styles.timestamp}>
              {item.createdAt?.toDate?.()?.toLocaleString('vi-VN', {
                hour: '2-digit',
                minute: '2-digit',
                day: '2-digit',
                month: '2-digit',
              }) || 'V·ª´a xong'}
            </Text>

            {item.message && (
              <Text
                style={[
                  styles.messageText,
                  isOwnMessage && styles.ownMessageText,
                ]}
              >
                {item.message}
              </Text>
            )}

            {/* Render attachments */}
            {item.attachments && item.attachments.length > 0 && (
              <View style={isImageOnly ? {} : styles.attachmentsContainer}>
                {item.attachments.map((attachment, index) => (
                  <View key={index} style={styles.attachment}>
                    {attachment.type?.startsWith('image/') ? (
                      <TouchableOpacity
                        onPress={() => setSelectedImage(attachment.url)}
                        style={styles.imageTouchable}
                      >
                        <Image
                          source={{ uri: attachment.url }}
                          style={[
                            styles.attachmentImage,
                            isImageOnly && { borderRadius: 15 },
                          ]}
                          resizeMode="cover"
                        />
                      </TouchableOpacity>
                    ) : (
                      <TouchableOpacity
                        style={styles.documentAttachment}
                        onPress={() => {
                          // Handle document opening
                          Alert.alert('M·ªü t√†i li·ªáu', `M·ªü ${attachment.name}?`);
                        }}
                      >
                        <Ionicons
                          name="document"
                          size={24}
                          color={theme.primary}
                        />
                        <Text style={styles.documentName}>
                          {attachment.name}
                        </Text>
                      </TouchableOpacity>
                    )}
                  </View>
                ))}
              </View>
            )}
          </View>
        )}

        {!isEditing && (
          <View style={styles.messageActions}>
            {isOwnMessage && (
              <>
                <TouchableOpacity
                  onPress={() => handleEditMessage(item)}
                  style={styles.actionButton}
                >
                  <Ionicons
                    name="create-outline"
                    size={16}
                    color={theme.text}
                  />
                </TouchableOpacity>
                <TouchableOpacity
                  onPress={() => handleRecallMessage(item.id)}
                  style={styles.actionButton}
                >
                  <Ionicons
                    name="trash-outline"
                    size={16}
                    color={theme.danger}
                  />
                </TouchableOpacity>
              </>
            )}
          </View>
        )}
      </View>
    );
  };

  if (loading) {
    return (
      <SafeAreaView
        style={[styles.container, { backgroundColor: theme.background }]}
      >
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.text }]}>
            ƒêang t·∫£i th·∫£o lu·∫≠n...
          </Text>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      {/* Header */}
      <View style={styles.header}>
        <TouchableOpacity
          onPress={() => navigation.goBack()}
          style={styles.backButton}
        >
          <Ionicons name="arrow-back" size={24} color={theme.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Th·∫£o lu·∫≠n d·ª± √°n: {projectName}
        </Text>
        <TouchableOpacity
          onPress={handleTestNotification}
          style={styles.testNotificationButton}
        >
          <Ionicons name="notifications" size={24} color={theme.primary} />
        </TouchableOpacity>
      </View>

      {/* Messages List */}
      <FlatList
        ref={flatListRef}
        data={discussions}
        renderItem={renderMessage}
        keyExtractor={(item) => item.id}
        style={styles.messagesList}
        inverted
        showsVerticalScrollIndicator={false}
      />

      {/* Input Area */}
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.inputContainer}
      >
        <View style={styles.inputRow}>
          <TouchableOpacity
            onPress={() => setShowAttachmentMenu(true)}
            style={styles.attachmentButton}
          >
            <Ionicons
              name="add-circle-outline"
              size={24}
              color={theme.primary}
            />
          </TouchableOpacity>

          <TextInput
            style={[
              styles.textInput,
              { color: theme.text, borderColor: theme.border },
            ]}
            value={newMessage}
            onChangeText={setNewMessage}
            placeholder="Nh·∫≠p tin nh·∫Øn..."
            placeholderTextColor={theme.textSecondary}
            multiline
            maxLength={1000}
          />

          <TouchableOpacity
            onPress={handleSendMessage}
            disabled={sending || !newMessage.trim()}
            style={[
              styles.sendButton,
              (!newMessage.trim() || sending) && styles.sendButtonDisabled,
            ]}
          >
            {sending ? (
              <ActivityIndicator size="small" color={theme.background} />
            ) : (
              <Ionicons name="send" size={20} color={theme.background} />
            )}
          </TouchableOpacity>
        </View>
      </KeyboardAvoidingView>

      {/* Attachment Menu Modal */}
      <Modal
        visible={showAttachmentMenu}
        transparent
        animationType="slide"
        onRequestClose={() => setShowAttachmentMenu(false)}
      >
        <TouchableOpacity
          style={styles.modalOverlay}
          activeOpacity={1}
          onPress={() => setShowAttachmentMenu(false)}
        >
          <View
            style={[styles.attachmentMenu, { backgroundColor: theme.card }]}
          >
            <TouchableOpacity
              style={styles.attachmentOption}
              onPress={() => {
                setShowAttachmentMenu(false);
                handlePickImage();
              }}
            >
              <Ionicons name="image" size={24} color={theme.primary} />
              <Text
                style={[styles.attachmentOptionText, { color: theme.text }]}
              >
                Ch·ªçn ·∫£nh
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={styles.attachmentOption}
              onPress={() => {
                setShowAttachmentMenu(false);
                handlePickDocument();
              }}
            >
              <Ionicons name="document" size={24} color={theme.primary} />
              <Text
                style={[styles.attachmentOptionText, { color: theme.text }]}
              >
                Ch·ªçn t√†i li·ªáu
              </Text>
            </TouchableOpacity>
          </View>
        </TouchableOpacity>
      </Modal>

      {/* Image Preview Modal */}
      <Modal
        visible={!!selectedImage}
        transparent
        animationType="fade"
        onRequestClose={() => setSelectedImage(null)}
      >
        <TouchableOpacity
          style={styles.imagePreviewOverlay}
          activeOpacity={1}
          onPress={() => setSelectedImage(null)}
        >
          <Image
            source={{ uri: selectedImage }}
            style={styles.imagePreview}
            resizeMode="contain"
          />
        </TouchableOpacity>
      </Modal>

      {/* Upload Progress */}
      {uploadingFile && (
        <View style={styles.uploadProgress}>
          <ActivityIndicator size="small" color={theme.primary} />
          <Text style={[styles.uploadText, { color: theme.text }]}>
            ƒêang upload file...
          </Text>
        </View>
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  backButton: {
    marginRight: 16,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    flex: 1,
  },
  testNotificationButton: {
    marginLeft: 16,
    padding: 8,
    backgroundColor: '#F3F4F6',
    borderRadius: 20,
    borderWidth: 1,
    borderColor: '#E5E7EB',
  },
  messagesList: {
    flex: 1,
    paddingHorizontal: 16,
  },
  messageContainer: {
    marginVertical: 8,
    maxWidth: '80%',
    alignSelf: 'flex-start',
  },
  ownMessage: {
    alignSelf: 'flex-end',
  },
  ownMessageContent: {
    backgroundColor: '#7C1FFD',
    padding: 16,
    borderRadius: 20,
    borderBottomRightRadius: 6,
    borderWidth: 1,
    borderColor: '#6B1FD1',
    shadowColor: '#7C1FFD',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
  },
  userInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
  },
  avatar: {
    width: 24,
    height: 24,
    borderRadius: 12,
    marginRight: 8,
  },
  avatarPlaceholder: {
    width: 24,
    height: 24,
    borderRadius: 12,
    backgroundColor: '#E5E7EB',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 8,
  },
  userName: {
    fontSize: 12,
    color: '#6B7280',
    fontWeight: '500',
  },
  messageContent: {
    backgroundColor: '#F1F0F1',
    padding: 16,
    borderRadius: 20,
    borderBottomLeftRadius: 6,
    borderWidth: 1,
    borderColor: '#E5E5E5',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.08,
    shadowRadius: 4,
    elevation: 2,
  },
  ownMessageText: {
    color: '#FFFFFF',
    fontWeight: '500',
  },
  messageText: {
    fontSize: 16,
    lineHeight: 24,
    color: '#000000',
    fontWeight: '400',
  },
  attachmentsContainer: {
    marginTop: 8, // Th√™m m·ªôt ch√∫t kho·∫£ng c√°ch n·∫øu c√≥ c·∫£ text v√† ·∫£nh
  },
  attachment: {
    // ƒê·ªÉ tr·ªëng
  },
  attachmentImage: {
    width: 200,
    height: 150,
    // borderRadius n√™n ƒë∆∞·ª£c √°p d·ª•ng ·ªü ƒë√¢y n·∫øu b·∫°n mu·ªën ·∫£nh c√≥ g√≥c bo tr√≤n
  },
  imageTouchable: {
    // ƒê·ªÉ tr·ªëng
  },
  documentAttachment: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 8,
    backgroundColor: '#f8f8f8',
    borderRadius: 8,
  },
  documentName: {
    marginLeft: 8,
    fontSize: 14,
    color: '#333',
  },
  timestamp: {
    fontSize: 11,
    color: '#666666',
    marginBottom: 8,
    alignSelf: 'flex-start',
    fontWeight: '400',
  },
  messageActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    marginTop: 4,
  },
  actionButton: {
    marginLeft: 8,
    padding: 4,
  },
  editContainer: {
    backgroundColor: '#F1F0F1',
    padding: 16,
    borderRadius: 20,
    borderBottomLeftRadius: 6,
    borderWidth: 1,
    borderColor: '#E5E5E5',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.08,
    shadowRadius: 4,
    elevation: 2,
  },
  editInput: {
    fontSize: 16,
    lineHeight: 24,
    marginBottom: 8,
    color: '#000000',
    fontWeight: '400',
  },
  editActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
  },
  editButton: {
    backgroundColor: '#007AFF',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 8,
    marginRight: 8,
  },
  editButtonText: {
    color: '#fff',
    fontSize: 14,
    fontWeight: '500',
  },
  cancelButton: {
    backgroundColor: '#FF3B30',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 8,
  },
  cancelButtonText: {
    color: '#fff',
    fontSize: 14,
    fontWeight: '500',
  },
  recalledText: {
    fontSize: 14,
    color: '#666666',
    fontStyle: 'italic',
    textAlign: 'center',
    padding: 16,
    backgroundColor: '#F8F8F8',
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#E5E5E5',
  },
  inputContainer: {
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: '#E5E7EB',
    backgroundColor: '#FFFFFF',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: -2,
    },
    shadowOpacity: 0.08,
    shadowRadius: 4,
    elevation: 8,
  },
  inputRow: {
    flexDirection: 'row',
    alignItems: 'flex-end',
  },
  attachmentButton: {
    padding: 8,
    marginRight: 8,
  },
  textInput: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 20,
    paddingHorizontal: 16,
    paddingVertical: 12,
    maxHeight: 100,
    fontSize: 16,
    backgroundColor: '#F9FAFB',
    borderColor: '#E5E7EB',
    color: '#1F2937',
  },
  sendButton: {
    backgroundColor: '#007AFF',
    width: 36,
    height: 36,
    borderRadius: 18,
    alignItems: 'center',
    justifyContent: 'center',
    marginLeft: 8,
  },
  sendButtonDisabled: {
    backgroundColor: '#ccc',
  },
  attachmentMenu: {
    position: 'absolute',
    bottom: 100,
    left: 20,
    right: 20,
    borderRadius: 16,
    padding: 20,
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  attachmentOption: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
  },
  attachmentOptionText: {
    fontSize: 16,
    marginLeft: 12,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  imagePreviewOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.9)',
    alignItems: 'center',
    justifyContent: 'center',
  },
  imagePreview: {
    width: '90%',
    height: '80%',
  },
  uploadProgress: {
    position: 'absolute',
    top: 100,
    alignSelf: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.8)',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 20,
    flexDirection: 'row',
    alignItems: 'center',
  },
  uploadText: {
    color: '#fff',
    marginLeft: 8,
    fontSize: 14,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
  },
});

export default ProjectDiscussionScreen;


--- END: src\screens\ProjectDiscussionScreen.js ---


--- START: src\screens\ProjectManagementScreen.js ---
//src/screens/ProjectManagementScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  FlatList,
  StyleSheet,
  ActivityIndicator,
  Pressable,
  TouchableOpacity,
  SafeAreaView,
  StatusBar,
  TextInput,
  LayoutAnimation,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { getProjectsByStatus } from '../api/projectService';
import { useTheme } from '../contexts/ThemeContext';

// Component hi·ªÉn th·ªã t·ª´ng d·ª± √°n trong danh s√°ch
const ProjectListItem = ({ project, onPress }) => {
  const { theme } = useTheme();
  // X√°c ƒë·ªãnh m√†u s·∫Øc theo tr·∫°ng th√°i d·ª± √°n
  const getStatusColor = (status) => {
    switch (status) {
      case 'completed':
        return '#4CAF50'; // xanh l√°
      case 'in-progress':
        return '#1E88E5'; // xanh d∆∞∆°ng
      case 'pending':
        return '#FFA000'; // v√†ng
      case 'production-complete':
        return '#8E24AA'; // t√≠m
      case 'delivered':
        return '#43A047'; // xanh l√° nh·∫°t
      default:
        return theme.textMuted; // S·ª≠ d·ª•ng m√†u t·ª´ theme
    }
  };

  // L·∫•y nh√£n hi·ªÉn th·ªã cho tr·∫°ng th√°i d·ª± √°n
  const getStatusLabel = (status) => {
    switch (status) {
      case 'completed':
        return 'Ho√†n th√†nh';
      case 'in-progress':
        return 'ƒêang th·ª±c hi·ªán';
      case 'pending':
        return 'Ch·ªù x·ª≠ l√Ω';
      case 'production-complete':
        return 'Ch·ªù giao h√†ng';
      case 'delivered':
        return 'ƒê√£ giao h√†ng';
      default:
        return status || 'Kh√¥ng x√°c ƒë·ªãnh';
    }
  };

  return (
    <Pressable
      style={({ pressed }) => [
        styles.projectCard,
        { backgroundColor: theme.card },
        pressed && styles.cardPressed,
      ]}
      onPress={() => onPress(project)}
    >
      <View style={styles.projectInfo}>
        <Text style={[styles.projectName, { color: theme.text }]}>
          {project.name || 'Ch∆∞a c√≥ t√™n'}
        </Text>

        {project.customerName && (
          <View style={styles.infoRow}>
            <Ionicons
              name="business-outline"
              size={14}
              color={theme.textSecondary}
            />
            <Text style={[styles.infoText, { color: theme.textSecondary }]}>
              {project.customerName}
            </Text>
          </View>
        )}

        {project.startDate && (
          <View style={styles.infoRow}>
            <Ionicons
              name="calendar-outline"
              size={14}
              color={theme.textSecondary}
            />
            <Text style={[styles.infoText, { color: theme.textSecondary }]}>
              {new Date(project.startDate.seconds * 1000).toLocaleDateString(
                'vi-VN'
              )}
            </Text>
          </View>
        )}

        {project.endDate && (
          <View style={styles.infoRow}>
            <Ionicons
              name="flag-outline"
              size={14}
              color={theme.textSecondary}
            />
            <Text style={[styles.infoText, { color: theme.textSecondary }]}>
              {new Date(project.endDate.seconds * 1000).toLocaleDateString(
                'vi-VN'
              )}
            </Text>
          </View>
        )}
      </View>

      <View style={styles.projectStatusContainer}>
        <View
          style={[
            styles.projectStatusTag,
            { borderColor: getStatusColor(project.status) },
          ]}
        >
          <Text
            style={[
              styles.projectStatusText,
              { color: getStatusColor(project.status) },
            ]}
          >
            {getStatusLabel(project.status)}
          </Text>
        </View>
      </View>
    </Pressable>
  );
};

const ProjectManagementScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const [projects, setProjects] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [refreshing, setRefreshing] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [filteredProjects, setFilteredProjects] = useState([]);

  // Status filters
  const FILTERS = [
    { key: 'all', label: 'T·∫•t c·∫£', color: '#6c757d', textColor: '#fff' },
    { key: 'pending', label: 'Ch·ªù x·ª≠ l√Ω', color: '#FFA000', textColor: '#fff' },
    {
      key: 'in_progress',
      label: 'ƒêang th·ª±c hi·ªán',
      color: '#1E88E5',
      textColor: '#fff',
    },
    {
      key: 'production_complete',
      label: 'Ch·ªù giao h√†ng',
      color: '#8E24AA',
      textColor: '#fff',
    },
    {
      key: 'delivered',
      label: 'ƒê√£ giao h√†ng',
      color: '#43A047',
      textColor: '#fff',
    },
    {
      key: 'completed',
      label: 'Ho√†n th√†nh',
      color: '#009688',
      textColor: '#fff',
    },
  ];

  const [activeFilter, setActiveFilter] = useState('in_progress');
  const [cacheByStatus, setCacheByStatus] = useState({});

  // H√†m t·∫£i danh s√°ch d·ª± √°n
  const loadProjectsByStatus = async (statusKey, forceRefresh = false) => {
    try {
      setLoading(true);
      setError(null);

      if (!forceRefresh && cacheByStatus[statusKey]) {
        setProjects(cacheByStatus[statusKey]);
        return;
      }

      if (forceRefresh) {
        setCacheByStatus((prev) => ({ ...prev, [statusKey]: undefined }));
      }

      const data = await getProjectsByStatus(statusKey);

      // L∆∞u cache m·ªõi
      setCacheByStatus((prev) => ({ ...prev, [statusKey]: data }));

      // Th√™m animation khi c·∫≠p nh·∫≠t danh s√°ch
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);

      setProjects(data);
      setFilteredProjects(data); // Kh·ªüi t·∫°o danh s√°ch l·ªçc ban ƒë·∫ßu
    } catch (err) {
      console.error('L·ªói khi t·∫£i danh s√°ch d·ª± √°n:', err);
      setError('Kh√¥ng th·ªÉ t·∫£i danh s√°ch d·ª± √°n. Vui l√≤ng th·ª≠ l·∫°i sau.');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  // T·∫£i d·ªØ li·ªáu khi m√†n h√¨nh ƒë∆∞·ª£c m·ªü
  useEffect(() => {
    loadProjectsByStatus(activeFilter);

    // Th√™m listener ƒë·ªÉ l√†m m·ªõi danh s√°ch khi quay l·∫°i t·ª´ m√†n h√¨nh kh√°c
    const unsubscribe = navigation.addListener('focus', () => {
      loadProjectsByStatus(activeFilter, true); // force refresh ƒë·ªÉ c·∫≠p nh·∫≠t n·∫øu tr·∫°ng th√°i d·ª± √°n thay ƒë·ªïi
    });

    return unsubscribe;
  }, [navigation, activeFilter]);

  // L·ªçc danh s√°ch d·ª± √°n theo t·ª´ kh√≥a t√¨m ki·∫øm
  useEffect(() => {
    if (!searchQuery.trim()) {
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
      setFilteredProjects(projects);
      return;
    }

    const query = searchQuery.toLowerCase().trim();
    const filtered = projects.filter((project) => {
      const name = (project.name || '').toLowerCase();
      const customerName = (project.customerName || '').toLowerCase();
      const description = (project.description || '').toLowerCase();

      return (
        name.includes(query) ||
        customerName.includes(query) ||
        description.includes(query)
      );
    });

    // Th√™m animation khi c·∫≠p nh·∫≠t k·∫øt qu·∫£ t√¨m ki·∫øm
    LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);

    setFilteredProjects(filtered);
  }, [searchQuery, projects]);

  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng k√©o ƒë·ªÉ l√†m m·ªõi
  const handleRefresh = () => {
    setRefreshing(true);
    // clear cache for current status then reload
    setCacheByStatus((prev) => ({ ...prev, [activeFilter]: undefined }));
    loadProjectsByStatus(activeFilter);
  };

  // X·ª≠ l√Ω khi thay ƒë·ªïi b·ªô l·ªçc
  const handleFilterChange = (statusKey) => {
    // Lu√¥n refetch ƒë·ªÉ ƒë·∫£m b·∫£o d·ªØ li·ªáu m·ªõi nh·∫•t
    loadProjectsByStatus(statusKey, true);
    setActiveFilter(statusKey);
    setSearchQuery('');
  };

  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng nh·∫•n v√†o m·ªôt d·ª± √°n
  const handleProjectPress = (project) => {
    navigation.navigate('ProjectDetail', { projectId: project.id });
  };

  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng mu·ªën th√™m d·ª± √°n m·ªõi
  const handleAddProject = () => {
    navigation.navigate('AddProject');
  };

  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng nh·∫≠p t·ª´ kh√≥a t√¨m ki·∫øm
  const handleSearch = (text) => {
    setSearchQuery(text);
  };

  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng mu·ªën x√≥a t·ª´ kh√≥a t√¨m ki·∫øm
  const handleClearSearch = () => {
    setSearchQuery('');
  };

  // Render filter buttons
  const renderFilterButtons = () => (
    <View style={styles.filterContainer}>
      {FILTERS.map((f) => (
        <TouchableOpacity
          key={f.key}
          style={[
            styles.filterButton,
            {
              backgroundColor: activeFilter === f.key ? f.color : 'transparent',
              borderWidth: 1.5,
              borderColor: activeFilter === f.key ? f.color : theme.border,
            },
          ]}
          onPress={() => handleFilterChange(f.key)}
        >
          <Text
            style={[
              styles.filterText,
              {
                color: activeFilter === f.key ? f.textColor : theme.textPrimary,
              },
            ]}
          >
            {f.label}
          </Text>
        </TouchableOpacity>
      ))}
    </View>
  );

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <StatusBar
        barStyle={theme.dark ? 'light-content' : 'dark-content'}
        backgroundColor={theme.background}
      />

      <View style={[styles.header, { borderBottomColor: theme.border }]}>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Qu·∫£n l√Ω d·ª± √°n
        </Text>
        <TouchableOpacity onPress={handleAddProject}>
          <Ionicons name="add-circle" size={28} color={theme.primary} />
        </TouchableOpacity>
      </View>

      {renderFilterButtons()}

      {/* Search Bar */}
      <View style={styles.searchContainer}>
        <Ionicons
          name="search-outline"
          size={20}
          color={theme.textMuted}
          style={styles.searchIcon}
        />
        <TextInput
          style={[
            styles.searchInput,
            { color: theme.text, borderColor: theme.border },
          ]}
          placeholder="T√¨m theo t√™n, kh√°ch h√†ng..."
          placeholderTextColor={theme.textMuted}
          value={searchQuery}
          onChangeText={handleSearch}
        />
        {searchQuery.length > 0 && (
          <TouchableOpacity
            onPress={handleClearSearch}
            style={styles.clearSearchButton}
          >
            <Ionicons name="close-circle" size={20} color={theme.textMuted} />
          </TouchableOpacity>
        )}
      </View>

      {/* Project List */}
      {loading && !refreshing ? (
        <View style={styles.centerContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
        </View>
      ) : error ? (
        <View style={styles.centerContainer}>
          <Ionicons
            name="alert-circle-outline"
            size={50}
            color={theme.danger}
          />
          <Text style={[styles.errorText, { color: theme.textSecondary }]}>
            {error}
          </Text>
          <TouchableOpacity
            onPress={handleRefresh}
            style={[styles.button, { backgroundColor: theme.primary }]}
          >
            <Text style={styles.buttonText}>Th·ª≠ l·∫°i</Text>
          </TouchableOpacity>
        </View>
      ) : filteredProjects.length === 0 ? (
        <View style={styles.centerContainer}>
          <Ionicons
            name="file-tray-outline"
            size={60}
            color={theme.textMuted}
          />
          <Text style={[styles.emptyText, { color: theme.textSecondary }]}>
            {searchQuery
              ? 'Kh√¥ng t√¨m th·∫•y d·ª± √°n ph√π h·ª£p v·ªõi t·ª´ kh√≥a'
              : activeFilter === 'all'
              ? 'Ch∆∞a c√≥ d·ª± √°n n√†o'
              : `Kh√¥ng c√≥ d·ª± √°n n√†o ·ªü tr·∫°ng th√°i "${
                  FILTERS.find((f) => f.key === activeFilter)?.label ||
                  activeFilter
                }"`}
          </Text>
          <TouchableOpacity
            onPress={handleAddProject}
            style={[styles.button, { backgroundColor: theme.primary }]}
          >
            <Text style={styles.buttonText}>Th√™m d·ª± √°n m·ªõi</Text>
          </TouchableOpacity>
        </View>
      ) : (
        <FlatList
          data={filteredProjects}
          renderItem={({ item }) => (
            <ProjectListItem project={item} onPress={handleProjectPress} />
          )}
          keyExtractor={(item) => item.id.toString()}
          contentContainerStyle={[
            styles.listContainer,
            { backgroundColor: theme.background },
          ]}
          onRefresh={handleRefresh}
          refreshing={refreshing}
        />
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f9fa',
  },
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
    backgroundColor: '#fff',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: 'bold',
  },
  addButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    position: 'absolute',
    right: 16,
    bottom: 24,
    zIndex: 1,
    elevation: 4,
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    margin: 12,
    paddingHorizontal: 12,
    paddingVertical: 0,
    backgroundColor: 'white',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#E0E0E0',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  searchIcon: {
    marginRight: 10,
  },
  searchInput: {
    flex: 1,
    height: 48,
    fontSize: 16,
    color: '#333',
    paddingVertical: 8,
  },
  clearButton: {
    padding: 4,
  },
  listContainer: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    backgroundColor: '#f8f9fa',
  },
  resultCount: {
    marginHorizontal: 16,
    marginBottom: 8,
    fontSize: 14,
  },
  projectCard: {
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 16,
    marginTop: 8,
    marginBottom: 8,
    flexDirection: 'row',
    justifyContent: 'space-between',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.15,
    shadowRadius: 3,
  },
  cardPressed: {
    opacity: 0.7,
    backgroundColor: '#f5f5f5',
  },
  projectInfo: {
    flex: 1,
    paddingRight: 12,
  },
  projectName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333333',
    marginBottom: 6,
  },
  infoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 4,
  },
  infoText: {
    fontSize: 14,
    color: '#666666',
    marginLeft: 6,
  },
  projectStatusContainer: {
    justifyContent: 'center',
    alignItems: 'flex-end',
  },
  projectStatusTag: {
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 10,
    paddingVertical: 4,
    alignItems: 'center',
    justifyContent: 'center',
  },
  projectStatusText: {
    fontSize: 12,
    fontWeight: 'bold',
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666666',
  },
  errorText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666666',
    textAlign: 'center',
  },
  retryButton: {
    marginTop: 16,
    backgroundColor: '#0066cc',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 6,
  },
  retryButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '500',
  },
  emptyText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666666',
    marginBottom: 20,
  },
  addProjectButton: {
    backgroundColor: '#0066cc',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 6,
  },
  addProjectButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  emptySearchContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 40,
  },
  emptySearchText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666666',
    textAlign: 'center',
  },
  button: {
    marginTop: 16,
    backgroundColor: '#0066cc',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 6,
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '500',
  },
  clearSearchButton: {
    padding: 4,
  },
  filterContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    padding: 12,
    backgroundColor: 'white',
  },
  filterButton: {
    paddingVertical: 8,
    paddingHorizontal: 10,
    borderRadius: 6,
    alignItems: 'center',
    marginHorizontal: 4,
    marginVertical: 4,
    minWidth: '30%', // Ensure buttons have a minimum width
    elevation: 1,
  },
  filterText: {
    fontSize: 12,
    fontWeight: 'bold',
    textAlign: 'center',
  },
});

export default ProjectManagementScreen;


--- END: src\screens\ProjectManagementScreen.js ---


--- START: src\screens\ProjectsScreen.js ---
//src/screens/ProjectsScreen.js
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  SafeAreaView,
  StatusBar,
  FlatList,
  TouchableOpacity,
  ActivityIndicator,
  Dimensions,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { getProjectsByStatus } from '../api/projectService';
import { useFocusEffect } from '@react-navigation/native';

// Responsive breakpoints
const BREAKPOINTS = {
  SMALL: 480, // Small phones
  MEDIUM: 768, // Large phones / Small tablets
  LARGE: 1024, // Tablets
  XLARGE: 1200, // Large tablets / Desktop
};

// Hook ƒë·ªÉ ph√°t hi·ªán k√≠ch th∆∞·ªõc m√†n h√¨nh v√† responsive breakpoints
const useScreenDimensions = () => {
  const [screenData, setScreenData] = useState(Dimensions.get('window'));

  useEffect(() => {
    const onChange = (result) => {
      setScreenData(result.window);
    };

    const subscription = Dimensions.addEventListener('change', onChange);
    return () => subscription?.remove();
  }, []);

  const isLandscape = screenData.width > screenData.height;
  const { width } = screenData;

  // Determine device type and layout
  const deviceType =
    width >= BREAKPOINTS.LARGE
      ? 'tablet'
      : width >= BREAKPOINTS.MEDIUM
      ? 'large-phone'
      : 'phone';

  const isTablet = deviceType === 'tablet';
  const isLargePhone = deviceType === 'large-phone';

  // Calculate responsive columns
  const getColumns = () => {
    if (isTablet && isLandscape) return 4; // 4 columns for tablet landscape
    if (isTablet) return 3; // 3 columns for tablet portrait
    if (isLargePhone && isLandscape) return 3; // 3 columns for large phone landscape
    if (isLargePhone) return 2; // 2 columns for large phone portrait
    if (isLandscape) return 2; // 2 columns for phone landscape
    return 1; // 1 column for phone portrait
  };

  // Calculate responsive spacing
  const getSpacing = () => {
    if (isTablet) return { horizontal: 20, vertical: 16, card: 12 };
    if (isLargePhone) return { horizontal: 16, vertical: 12, card: 10 };
    return { horizontal: 12, vertical: 10, card: 8 };
  };

  // Calculate responsive font sizes
  const getFontSizes = () => {
    const baseSize = isTablet ? 16 : isLargePhone ? 15 : 14;
    return {
      small: baseSize - 3,
      medium: baseSize - 1,
      large: baseSize + 1,
      xlarge: baseSize + 3,
      title: baseSize + 4,
    };
  };

  // Calculate responsive card dimensions
  const getCardDimensions = () => {
    const spacing = getSpacing();
    const columns = getColumns();
    const totalHorizontalPadding = spacing.horizontal * 2;
    const totalCardSpacing = spacing.card * (columns - 1);
    const availableWidth = width - totalHorizontalPadding - totalCardSpacing;
    const cardWidth = availableWidth / columns;

    return {
      width: cardWidth,
      minHeight: isTablet ? 140 : isLargePhone ? 120 : 100,
      padding: isTablet ? 16 : isLargePhone ? 14 : 12,
    };
  };

  return {
    ...screenData,
    isLandscape,
    deviceType,
    isTablet,
    isLargePhone,
    columns: getColumns(),
    spacing: getSpacing(),
    fontSizes: getFontSizes(),
    cardDimensions: getCardDimensions(),
  };
};

const ProjectsScreen = ({ navigation }) => {
  const [projects, setProjects] = useState([]); // projects hi·ªÉn th·ªã theo b·ªô l·ªçc hi·ªán h√†nh
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [refreshing, setRefreshing] = useState(false);

  // S·ª≠ d·ª•ng hook ƒë·ªÉ ph√°t hi·ªán k√≠ch th∆∞·ªõc m√†n h√¨nh v√† responsive values
  const {
    width,
    height,
    isLandscape,
    deviceType,
    isTablet,
    isLargePhone,
    columns,
    spacing,
    fontSizes,
    cardDimensions,
  } = useScreenDimensions();

  // L·ªçc theo tr·∫°ng th√°i d·ª± √°n
  const FILTERS = [
    {
      key: 'pending',
      label: 'Ch·ªù x·ª≠ l√Ω',
      color: 'transparent',
      textColor: '#333',
    },
    {
      key: 'in-progress',
      label: 'ƒêang th·ª±c hi·ªán',
      color: '#FFF9C4',
      textColor: '#333',
    }, // v√†ng nh·∫°t
    {
      key: 'completed',
      label: 'Ho√†n th√†nh',
      color: '#4CAF50',
      textColor: '#fff',
    },
  ];

  const [activeFilter, setActiveFilter] = useState('pending');
  // Cache d·ª± √°n theo tr·∫°ng th√°i ƒë·ªÉ kh√¥ng ph·∫£i g·ªçi l·∫°i
  const [cacheByStatus, setCacheByStatus] = useState({});

  // H√†m t·∫£i danh s√°ch d·ª± √°n
  const loadProjectsByStatus = async (statusKey) => {
    // N·∫øu ƒë√£ c√≥ trong cache th√¨ d√πng lu√¥n
    if (cacheByStatus[statusKey]) {
      setProjects(cacheByStatus[statusKey]);
      return;
    }

    try {
      setLoading(true);
      setError(null);
      const data = await getProjectsByStatus(statusKey);
      // L∆∞u cache
      setCacheByStatus((prev) => ({ ...prev, [statusKey]: data }));
      setProjects(data);
    } catch (err) {
      console.error('L·ªói khi t·∫£i danh s√°ch d·ª± √°n:', err);
      setError('Kh√¥ng th·ªÉ t·∫£i danh s√°ch d·ª± √°n. Vui l√≤ng th·ª≠ l·∫°i sau.');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  // T·∫£i d·ªØ li·ªáu khi m√†n h√¨nh ƒë∆∞·ª£c m·ªü
  useEffect(() => {
    loadProjectsByStatus(activeFilter);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [activeFilter]);

  // L√†m m·ªõi d·ªØ li·ªáu khi m√†n h√¨nh ƒë∆∞·ª£c focus
  useFocusEffect(
    React.useCallback(() => {
      loadProjectsByStatus(activeFilter);
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [activeFilter])
  );

  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng k√©o ƒë·ªÉ l√†m m·ªõi
  const handleRefresh = () => {
    setRefreshing(true);
    // X√≥a cache c·ªßa b·ªô l·ªçc hi·ªán h√†nh ƒë·ªÉ bu·ªôc refetch
    setCacheByStatus((prev) => ({ ...prev, [activeFilter]: undefined }));
    loadProjectsByStatus(activeFilter);
  };

  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng nh·∫•n v√†o n√∫t qu·∫£n l√Ω d·ª± √°n
  const handleManageProjects = () => {
    navigation.navigate('ProjectManagement');
  };

  // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng nh·∫•n v√†o m·ªôt d·ª± √°n
  const handleProjectPress = (project) => {
    navigation.navigate('ProjectDetail', { projectId: project.id });
  };

  // N√∫t l·ªçc tr·∫°ng th√°i
  const renderFilterButtons = () => (
    <View
      style={[
        styles.filterContainer,
        {
          paddingHorizontal: spacing.horizontal,
          paddingVertical: spacing.vertical / 2, // Gi·∫£m padding vertical
        },
      ]}
    >
      {FILTERS.map((f) => (
        <TouchableOpacity
          key={f.key}
          style={[
            styles.filterButton,
            {
              backgroundColor: activeFilter === f.key ? f.color : '#fff',
              paddingHorizontal: isTablet ? 16 : 12, // Gi·∫£m padding
              paddingVertical: isTablet ? 8 : 6, // Gi·∫£m padding
              borderRadius: isTablet ? 16 : 12, // Gi·∫£m border radius
              borderWidth: 1,
              borderColor:
                activeFilter === f.key
                  ? f.color === 'transparent'
                    ? '#ccc'
                    : f.color
                  : '#ccc',
            },
          ]}
          onPress={() => setActiveFilter(f.key)}
        >
          <Text
            style={[
              styles.filterText,
              {
                color: activeFilter === f.key ? f.textColor : '#333',
                fontSize: fontSizes.small, // Gi·∫£m font size
                fontWeight: activeFilter === f.key ? '600' : '500',
              },
            ]}
          >
            {f.label}
          </Text>
        </TouchableOpacity>
      ))}
    </View>
  );

  // Hi·ªÉn th·ªã t·ª´ng d·ª± √°n trong danh s√°ch
  const renderProjectItem = ({ item, index }) => {
    const getStatusColor = (status) => {
      switch (status) {
        case 'completed':
          return '#4CAF50';
        case 'in-progress':
          return '#FFD54F'; // v√†ng nh·∫°t
        case 'pending':
          return '#9E9E9E';
        case 'cancelled':
          return '#F44336';
        default:
          return '#9E9E9E';
      }
    };

    const getStatusLabel = (status) => {
      switch (status) {
        case 'completed':
          return 'Ho√†n th√†nh';
        case 'in-progress':
          return 'ƒêang th·ª±c hi·ªán';
        case 'pending':
          return 'Ch·ªù x·ª≠ l√Ω';
        case 'cancelled':
          return 'ƒê√£ h·ªßy';
        default:
          return status || 'Kh√¥ng x√°c ƒë·ªãnh';
      }
    };

    // T√≠nh to√°n style cho responsive layout
    const getItemStyle = () => {
      const baseStyle = {
        ...styles.projectCard,
        minHeight: cardDimensions.minHeight,
        padding: cardDimensions.padding,
        marginBottom: spacing.vertical,
        flex: columns > 1 ? 1 : undefined, // Use flex for multi-column
      };

      // Width v√† margin cho multi-column layout
      if (columns > 1) {
        baseStyle.marginRight = (index + 1) % columns === 0 ? 0 : spacing.card;
        baseStyle.maxWidth = cardDimensions.width; // Set max width instead of fixed width
      } else {
        baseStyle.width = '100%'; // Full width for single column
      }

      return baseStyle;
    };

    return (
      <TouchableOpacity
        style={getItemStyle()}
        onPress={() => handleProjectPress(item)}
      >
        <View style={styles.projectHeader}>
          <Text
            style={[
              styles.projectName,
              {
                fontSize: fontSizes.large,
                lineHeight: fontSizes.large * 1.3,
              },
            ]}
            numberOfLines={columns > 1 ? 2 : undefined}
          >
            {item.name || 'Ch∆∞a c√≥ t√™n'}
          </Text>
          <View
            style={[
              styles.statusBadge,
              {
                backgroundColor: getStatusColor(item.status),
                paddingHorizontal: isTablet ? 10 : 8,
                paddingVertical: isTablet ? 6 : 4,
              },
            ]}
          >
            <Text style={[styles.statusText, { fontSize: fontSizes.small }]}>
              {getStatusLabel(item.status)}
            </Text>
          </View>
        </View>

        {item.customerName && (
          <View style={[styles.infoRow, { marginTop: spacing.vertical / 2 }]}>
            <Ionicons
              name="business-outline"
              size={isTablet ? 16 : 14}
              color="#666"
            />
            <Text
              style={[
                styles.infoText,
                {
                  fontSize: fontSizes.medium,
                  marginLeft: spacing.card / 2,
                },
              ]}
              numberOfLines={columns > 1 ? 1 : undefined}
            >
              {item.customerName}
            </Text>
          </View>
        )}

        {/* Th√™m th√¥ng tin ng√†y th√°ng n·∫øu c√≥ */}
        {(item.startDate || item.endDate) && (
          <View style={[styles.infoRow, { marginTop: spacing.vertical / 3 }]}>
            <Ionicons
              name="calendar-outline"
              size={isTablet ? 16 : 14}
              color="#666"
            />
            <Text
              style={[
                styles.infoText,
                {
                  fontSize: fontSizes.small,
                  marginLeft: spacing.card / 2,
                },
              ]}
              numberOfLines={1}
            >
              {item.startDate &&
                `B·∫Øt ƒë·∫ßu: ${new Date(item.startDate).toLocaleDateString(
                  'vi-VN'
                )}`}
              {item.startDate && item.endDate && ' ‚Ä¢ '}
              {item.endDate &&
                `K·∫øt th√∫c: ${new Date(item.endDate).toLocaleDateString(
                  'vi-VN'
                )}`}
            </Text>
          </View>
        )}
      </TouchableOpacity>
    );
  };

  if (loading && !refreshing) {
    return (
      <SafeAreaView style={[styles.container, { flex: 1 }]}>
        <StatusBar barStyle="dark-content" backgroundColor="#f8f8f8" />
        <View
          style={[styles.header, { paddingHorizontal: 16, paddingVertical: 8 }]}
        >
          <Text style={[styles.headerTitle, { fontSize: fontSizes.large }]}>
            D·ª± √Ån
          </Text>
        </View>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#0066cc" />
          <Text style={styles.loadingText}>ƒêang t·∫£i d·ª± √°n...</Text>
        </View>
      </SafeAreaView>
    );
  }

  if (error) {
    return (
      <SafeAreaView style={[styles.container, { flex: 1 }]}>
        <StatusBar barStyle="dark-content" backgroundColor="#f8f8f8" />
        <View
          style={[styles.header, { paddingHorizontal: 16, paddingVertical: 8 }]}
        >
          <Text style={[styles.headerTitle, { fontSize: fontSizes.large }]}>
            D·ª± √Ån
          </Text>
        </View>
        <View style={styles.errorContainer}>
          <Ionicons name="alert-circle-outline" size={50} color="#FF3B30" />
          <Text style={styles.errorText}>{error}</Text>
          <TouchableOpacity
            style={styles.retryButton}
            onPress={() => loadProjectsByStatus(activeFilter)}
          >
            <Text style={styles.retryButtonText}>Th·ª≠ l·∫°i</Text>
          </TouchableOpacity>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={[styles.container, { flex: 1 }]}>
      <StatusBar barStyle="dark-content" backgroundColor="#f8f8f8" />

      <View
        style={[
          styles.header,
          {
            paddingHorizontal: spacing.horizontal,
            paddingVertical: spacing.vertical / 2, // Gi·∫£m padding vertical
            minHeight: isTablet ? 60 : 50, // Gi·∫£m chi·ªÅu cao t·ªëi thi·ªÉu
          },
        ]}
      >
        <Text
          style={[
            styles.headerTitle,
            {
              fontSize: fontSizes.large, // Gi·∫£m font size t·ª´ title xu·ªëng large
              fontWeight: '600',
            },
          ]}
        >
          D·ª± √Ån
        </Text>
        <View style={styles.headerRight}>
          {/* ·∫®n debug info trong production ƒë·ªÉ ti·∫øt ki·ªám kh√¥ng gian */}
          {__DEV__ && (
            <View style={[styles.debugInfo, { marginRight: 6 }]}>
              <Text
                style={[styles.debugText, { fontSize: fontSizes.small - 1 }]}
              >
                {columns}Col{isLandscape ? 'üîÑ' : '‚¨ÜÔ∏è'}
              </Text>
            </View>
          )}
          <TouchableOpacity
            style={[
              styles.manageButton,
              {
                paddingHorizontal: isTablet ? 12 : 8, // Gi·∫£m padding
                paddingVertical: isTablet ? 6 : 4, // Gi·∫£m padding
              },
            ]}
            onPress={handleManageProjects}
          >
            <Ionicons
              name="settings-outline"
              size={isTablet ? 16 : 14} // Gi·∫£m icon size
              color="#0066cc"
            />
          </TouchableOpacity>
        </View>
      </View>

      {renderFilterButtons()}

      {projects.length > 0 ? (
        <FlatList
          data={projects}
          keyExtractor={(item) => item.id}
          renderItem={renderProjectItem}
          contentContainerStyle={[
            styles.listContent,
            {
              paddingHorizontal: spacing.horizontal,
              paddingVertical: spacing.vertical,
            },
          ]}
          refreshing={refreshing}
          onRefresh={handleRefresh}
          numColumns={columns}
          key={`${columns}-${deviceType}-${isLandscape}`} // Force re-render khi layout thay ƒë·ªïi
          columnWrapperStyle={columns > 1 ? styles.row : null}
          showsVerticalScrollIndicator={false}
          scrollEnabled={true}
          nestedScrollEnabled={true}
          removeClippedSubviews={false}
          initialNumToRender={10}
          maxToRenderPerBatch={5}
          windowSize={10}
          getItemLayout={null} // Disable for dynamic heights
        />
      ) : (
        <View style={styles.emptyContainer}>
          <Ionicons name="briefcase" size={80} color="#0066cc" />
          <Text style={styles.emptyTitle}>Ch∆∞a c√≥ d·ª± √°n n√†o</Text>
          <Text style={styles.emptySubtitle}>
            B·∫°n ch∆∞a c√≥ d·ª± √°n n√†o. H√£y t·∫°o d·ª± √°n m·ªõi trong m·ª•c qu·∫£n l√Ω d·ª± √°n.
          </Text>
          <TouchableOpacity
            style={styles.manageFullButton}
            onPress={handleManageProjects}
          >
            <Text style={styles.manageFullButtonText}>Qu·∫£n l√Ω d·ª± √°n</Text>
          </TouchableOpacity>
        </View>
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: 'white',
    borderBottomWidth: 1,
    borderBottomColor: '#EEEEEE',
    elevation: 1, // Gi·∫£m elevation
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05, // Gi·∫£m shadow opacity
    shadowRadius: 1,
    // Dynamic padding will be applied inline
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333333',
  },
  headerRight: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  debugInfo: {
    backgroundColor: '#FFF3E0',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    marginRight: 8,
  },
  debugText: {
    fontSize: 10,
    color: '#E65100',
    fontWeight: '500',
  },
  manageButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 6,
    paddingHorizontal: 10,
    borderRadius: 16,
    backgroundColor: '#E6F0FF',
  },
  manageButtonText: {
    fontSize: 14,
    fontWeight: '500',
    color: '#0066cc',
    marginRight: 4,
  },
  listContent: {
    flexGrow: 1,
    paddingBottom: 20, // Ensure bottom padding for scroll
  },
  projectCard: {
    backgroundColor: 'white',
    borderRadius: 12,
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    // Dynamic values will be applied inline
  },
  projectHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  projectName: {
    fontWeight: 'bold',
    color: '#333',
    flex: 1,
    // Dynamic fontSize will be applied inline
  },
  statusBadge: {
    borderRadius: 12,
    alignSelf: 'flex-start',
    // Dynamic padding will be applied inline
  },
  statusText: {
    fontWeight: '500',
    color: 'white',
    // Dynamic fontSize will be applied inline
  },
  infoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    // Dynamic marginTop will be applied inline
  },
  infoText: {
    color: '#666',
    flex: 1,
    // Dynamic fontSize and marginLeft will be applied inline
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  errorText: {
    marginTop: 12,
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  retryButton: {
    marginTop: 16,
    paddingVertical: 8,
    paddingHorizontal: 16,
    backgroundColor: '#0066cc',
    borderRadius: 8,
  },
  retryButtonText: {
    fontSize: 14,
    fontWeight: '500',
    color: 'white',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  emptyTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
    marginTop: 20,
    textAlign: 'center',
  },
  emptySubtitle: {
    fontSize: 16,
    color: '#666',
    marginTop: 10,
    textAlign: 'center',
    paddingHorizontal: 30,
  },
  manageFullButton: {
    marginTop: 24,
    paddingVertical: 12,
    paddingHorizontal: 24,
    backgroundColor: '#0066cc',
    borderRadius: 8,
  },
  manageFullButtonText: {
    fontSize: 16,
    fontWeight: '500',
    color: 'white',
  },
  filterContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    // Dynamic padding will be applied inline
  },
  filterButton: {
    // Dynamic padding and borderRadius will be applied inline
  },
  filterText: {
    fontWeight: '500',
    // Dynamic fontSize will be applied inline
  },

  // Responsive Layout Styles
  row: {
    flex: 1,
    justifyContent: 'space-between',
    paddingHorizontal: 0, // Remove extra padding that might cause issues
  },
});

export default ProjectsScreen;


--- END: src\screens\ProjectsScreen.js ---


--- START: src\screens\ProposalListScreen.js ---
// src/screens/ProposalListScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  Alert,
  Modal,
  TextInput,
  ActivityIndicator,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useAuth } from '../contexts/AuthContext';
import {
  getProposalsByStatus,
  updateProposalStatus,
  canApproveProposal,
  updateProposalMaterialPrices,
} from '../api/proposalService';

const ProposalListScreen = ({ navigation }) => {
  const { currentUser } = useAuth();
  const [loading, setLoading] = useState(true);
  const [proposals, setProposals] = useState([]);
  const [selectedTab, setSelectedTab] = useState('pending');
  const [refreshing, setRefreshing] = useState(false);
  const [showApproveModal, setShowApproveModal] = useState(false);
  const [showRejectModal, setShowRejectModal] = useState(false);
  const [selectedProposal, setSelectedProposal] = useState(null);
  const [comment, setComment] = useState('');
  const [showMaterialsModal, setShowMaterialsModal] = useState(false);
  const [selectedMaterials, setSelectedMaterials] = useState([]);
  const [showPriceModal, setShowPriceModal] = useState(false);
  const [editableMaterials, setEditableMaterials] = useState([]);
  const [currentProposalId, setCurrentProposalId] = useState(null);

  const canApprove = canApproveProposal(currentUser?.role);

  useEffect(() => {
    loadProposals();
  }, [selectedTab]);

  const loadProposals = async () => {
    setLoading(true);
    try {
      const data = await getProposalsByStatus(selectedTab);
      console.log(`Loaded ${selectedTab} proposals:`, data.length);
      setProposals(data);
    } catch (error) {
      console.error('Error loading proposals:', error);
      Alert.alert(
        'L·ªói',
        'Kh√¥ng th·ªÉ t·∫£i danh s√°ch ƒë·ªÅ xu·∫•t. Vui l√≤ng t·∫°o ch·ªâ m·ª•c theo h∆∞·ªõng d·∫´n trong Firebase Console.'
      );
      setProposals([]);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  const handleRefresh = () => {
    setRefreshing(true);
    loadProposals();
  };

  const formatDate = (timestamp) => {
    if (!timestamp) return 'N/A';
    try {
      if (timestamp.toDate) {
        return timestamp.toDate().toLocaleDateString('vi-VN');
      } else if (timestamp instanceof Date) {
        return timestamp.toLocaleDateString('vi-VN');
      }
      return 'N/A';
    } catch (e) {
      return 'N/A';
    }
  };

  const handleApprove = (proposal) => {
    setSelectedProposal(proposal);
    setComment('');
    setShowApproveModal(true);
  };

  const handleReject = (proposal) => {
    setSelectedProposal(proposal);
    setComment('');
    setShowRejectModal(true);
  };

  const confirmApprove = async () => {
    if (!selectedProposal) return;

    try {
      await updateProposalStatus(
        selectedProposal.id,
        'approved',
        currentUser.uid,
        currentUser.displayName || currentUser.email,
        comment
      );
      setShowApproveModal(false);
      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ ph√™ duy·ªát ƒë·ªÅ xu·∫•t');
      loadProposals();
    } catch (error) {
      console.error('Error approving proposal:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ph√™ duy·ªát ƒë·ªÅ xu·∫•t');
    }
  };

  const confirmReject = async () => {
    if (!selectedProposal) return;

    if (!comment.trim()) {
      return Alert.alert('Thi·∫øu th√¥ng tin', 'Vui l√≤ng nh·∫≠p l√Ω do t·ª´ ch·ªëi');
    }

    try {
      await updateProposalStatus(
        selectedProposal.id,
        'rejected',
        currentUser.uid,
        currentUser.displayName || currentUser.email,
        comment
      );
      setShowRejectModal(false);
      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ t·ª´ ch·ªëi ƒë·ªÅ xu·∫•t');
      loadProposals();
    } catch (error) {
      console.error('Error rejecting proposal:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·ª´ ch·ªëi ƒë·ªÅ xu·∫•t');
    }
  };

  const showMaterialDetails = (materials) => {
    setSelectedMaterials(materials || []);
    setShowMaterialsModal(true);
  };

  const openPriceEditor = (proposal) => {
    // Create a deep copy of materials with price fields
    const materialsWithPrices = proposal.items
      ? JSON.parse(JSON.stringify(proposal.items))
      : [];

    // Ensure each material has price and totalPrice fields
    materialsWithPrices.forEach((item) => {
      if (!item.price) item.price = '';
      if (!item.totalPrice) item.totalPrice = '';
    });

    setEditableMaterials(materialsWithPrices);
    setCurrentProposalId(proposal.id);
    setShowPriceModal(true);
  };

  const handlePriceChange = (index, price) => {
    const updatedMaterials = [...editableMaterials];
    updatedMaterials[index].price = price;

    // Calculate total price if both price and quantity exist
    const quantity = parseFloat(updatedMaterials[index].quantity);
    const priceValue = parseFloat(price);

    if (!isNaN(quantity) && !isNaN(priceValue)) {
      updatedMaterials[index].totalPrice = (quantity * priceValue).toString();
    }

    setEditableMaterials(updatedMaterials);
  };

  const savePriceUpdates = async () => {
    if (!currentProposalId) return;

    try {
      await updateProposalMaterialPrices(currentProposalId, editableMaterials);
      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ c·∫≠p nh·∫≠t gi√° v·∫≠t t∆∞');
      setShowPriceModal(false);
      loadProposals(); // Reload to get updated data
    } catch (error) {
      console.error('Error updating prices:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t gi√° v·∫≠t t∆∞');
    }
  };

  const navigateToProject = (projectId) => {
    if (projectId) {
      navigation.navigate('ProjectDetail', { projectId });
    } else {
      Alert.alert('Th√¥ng b√°o', 'Kh√¥ng t√¨m th·∫•y th√¥ng tin d·ª± √°n.');
    }
  };

  // Add function to navigate to CreatePO screen
  const navigateToCreatePO = (proposal) => {
    if (!proposal.projectId) {
      Alert.alert('Th√¥ng b√°o', 'C·∫ßn c√≥ th√¥ng tin d·ª± √°n ƒë·ªÉ t·∫°o ƒë∆°n ƒë·∫∑t h√†ng.');
      return;
    }

    // Check if materials have prices
    const missingPrices = proposal.items?.some(
      (item) => !item.price || item.price === '0' || item.price === ''
    );
    if (missingPrices) {
      Alert.alert(
        'C·∫ßn c·∫≠p nh·∫≠t gi√°',
        'M·ªôt s·ªë v·∫≠t t∆∞ ch∆∞a c√≥ gi√°. Vui l√≤ng c·∫≠p nh·∫≠t gi√° tr∆∞·ªõc khi t·∫°o ƒë∆°n ƒë·∫∑t h√†ng.',
        [
          { text: 'ƒê√≥ng', style: 'cancel' },
          { text: 'C·∫≠p nh·∫≠t gi√°', onPress: () => openPriceEditor(proposal) },
        ]
      );
      return;
    }

    // Prepare data for PO creation
    const poData = {
      projectId: proposal.projectId,
      projectName: proposal.projectName,
      materials:
        proposal.items?.map((item) => ({
          name: item.name,
          specs: item.specification || '',
          unit: item.unit || '',
          quantity: item.quantity || '0',
          unitPrice: item.price || '0',
        })) || [],
      vatPercentage: 10,
      proposalId: proposal.id,
      proposalCode: proposal.proposalCode,
    };

    navigation.navigate('CreatePO', poData);
  };

  const getPriorityColor = (priority) => {
    switch (priority) {
      case 'urgent':
        return '#FF3B30';
      case 'normal':
        return '#007AFF';
      default:
        return '#007AFF';
    }
  };

  const getPriorityLabel = (priority) => {
    switch (priority) {
      case 'urgent':
        return 'G·∫•p';
      case 'normal':
        return 'B√¨nh th∆∞·ªùng';
      default:
        return priority || 'B√¨nh th∆∞·ªùng';
    }
  };

  const getStatusColor = (status) => {
    switch (status) {
      case 'approved':
        return '#4CAF50';
      case 'rejected':
        return '#FF3B30';
      case 'pending':
        return '#FF9500';
      default:
        return '#999';
    }
  };

  const getStatusLabel = (status) => {
    switch (status) {
      case 'approved':
        return 'ƒê√£ duy·ªát';
      case 'rejected':
        return 'T·ª´ ch·ªëi';
      case 'pending':
        return 'Ch·ªù duy·ªát';
      default:
        return status || 'Kh√¥ng x√°c ƒë·ªãnh';
    }
  };

  const renderItem = ({ item }) => (
    <View style={styles.card}>
      <View style={styles.cardHeader}>
        <Text style={styles.proposalCode}>{item.proposalCode}</Text>
        <View
          style={[
            styles.statusBadge,
            { backgroundColor: getStatusColor(item.status) },
          ]}
        >
          <Text style={styles.statusText}>{getStatusLabel(item.status)}</Text>
        </View>
      </View>

      <Text style={styles.projectName}>{item.projectName}</Text>

      <View style={styles.infoRow}>
        <View style={styles.infoItem}>
          <Text style={styles.infoLabel}>Ng∆∞·ªùi ƒë·ªÅ xu·∫•t:</Text>
          <Text style={styles.infoValue}>{item.createdByName || 'N/A'}</Text>
        </View>
        <View style={styles.infoItem}>
          <Text style={styles.infoLabel}>Ng√†y t·∫°o:</Text>
          <Text style={styles.infoValue}>{formatDate(item.createdAt)}</Text>
        </View>
      </View>

      <View style={styles.infoRow}>
        <View style={styles.infoItem}>
          <Text style={styles.infoLabel}>Ng√†y c·∫ßn cung c·∫•p:</Text>
          <Text style={styles.infoValue}>{formatDate(item.requiredDate)}</Text>
        </View>
        <View style={styles.infoItem}>
          <Text style={styles.infoLabel}>M·ª©c ƒë·ªô:</Text>
          {item.priority === 'normal' ? (
            <Text style={styles.infoValue}>
              {getPriorityLabel(item.priority)}
            </Text>
          ) : (
            <View
              style={[
                styles.priorityBadge,
                { backgroundColor: getPriorityColor(item.priority) },
              ]}
            >
              <Text style={styles.priorityText}>
                {getPriorityLabel(item.priority)}
              </Text>
            </View>
          )}
        </View>
      </View>

      <View style={styles.purposeContainer}>
        <Text style={styles.purposeLabel}>M·ª•c ƒë√≠ch:</Text>
        <Text style={styles.purposeText}>
          {item.purpose || 'Kh√¥ng c√≥ m√¥ t·∫£'}
        </Text>
      </View>

      <View style={styles.cardActions}>
        <Text style={styles.itemsCount}>
          S·ªë l∆∞·ª£ng v·∫≠t t∆∞: {item.items?.length || 0}
        </Text>
        <View style={styles.actionButtonsRow}>
          <TouchableOpacity
            style={styles.viewButton}
            onPress={() => showMaterialDetails(item.items)}
          >
            <Ionicons name="list" size={16} color="#0066cc" />
            <Text style={styles.viewButtonText}>Xem v·∫≠t t∆∞</Text>
          </TouchableOpacity>

          {item.projectId && (
            <TouchableOpacity
              style={styles.viewButton}
              onPress={() => navigateToProject(item.projectId)}
            >
              <Ionicons name="open-outline" size={16} color="#0066cc" />
              <Text style={styles.viewButtonText}>Xem d·ª± √°n</Text>
            </TouchableOpacity>
          )}

          <TouchableOpacity
            style={[styles.viewButton, styles.priceButton]}
            onPress={() => openPriceEditor(item)}
          >
            <Ionicons name="cash-outline" size={16} color="#28a745" />
            <Text style={[styles.viewButtonText, { color: '#28a745' }]}>
              C·∫≠p nh·∫≠t gi√°
            </Text>
          </TouchableOpacity>

          {/* Add PO list button for approved proposals */}
          {item.status === 'approved' && (
            <TouchableOpacity
              style={styles.viewButton}
              onPress={() =>
                navigation.navigate('POList', { projectId: item.projectId })
              }
            >
              <Ionicons
                name="document-text-outline"
                size={16}
                color="#0066cc"
              />
              <Text style={styles.viewButtonText}>PO</Text>
            </TouchableOpacity>
          )}
        </View>
      </View>

      {item.status === 'pending' && canApprove && (
        <View style={styles.actionButtons}>
          <TouchableOpacity
            style={[styles.actionButton, styles.approveButton]}
            onPress={() => handleApprove(item)}
          >
            <Ionicons name="checkmark-circle" size={16} color="#fff" />
            <Text style={styles.actionButtonText}>Ph√™ duy·ªát</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={[styles.actionButton, styles.rejectButton]}
            onPress={() => handleReject(item)}
          >
            <Ionicons name="close-circle" size={16} color="#fff" />
            <Text style={styles.actionButtonText}>T·ª´ ch·ªëi</Text>
          </TouchableOpacity>
        </View>
      )}

      {item.status !== 'pending' && item.comment && (
        <View style={styles.commentContainer}>
          <Text style={styles.commentLabel}>Ghi ch√∫:</Text>
          <Text style={styles.commentText}>{item.comment}</Text>
        </View>
      )}
    </View>
  );

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Danh s√°ch ƒë·ªÅ xu·∫•t mua v·∫≠t t∆∞</Text>

      {/* Tab navigation */}
      <View style={styles.tabContainer}>
        <TouchableOpacity
          style={[styles.tab, selectedTab === 'pending' && styles.activeTab]}
          onPress={() => setSelectedTab('pending')}
        >
          <Text
            style={[
              styles.tabText,
              selectedTab === 'pending' && styles.activeTabText,
            ]}
          >
            Ch·ªù duy·ªát
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.tab, selectedTab === 'approved' && styles.activeTab]}
          onPress={() => setSelectedTab('approved')}
        >
          <Text
            style={[
              styles.tabText,
              selectedTab === 'approved' && styles.activeTabText,
            ]}
          >
            ƒê√£ duy·ªát
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.tab, selectedTab === 'rejected' && styles.activeTab]}
          onPress={() => setSelectedTab('rejected')}
        >
          <Text
            style={[
              styles.tabText,
              selectedTab === 'rejected' && styles.activeTabText,
            ]}
          >
            T·ª´ ch·ªëi
          </Text>
        </TouchableOpacity>
      </View>

      {loading && !refreshing ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#0066cc" />
          <Text style={styles.loadingText}>ƒêang t·∫£i d·ªØ li·ªáu...</Text>
        </View>
      ) : (
        <FlatList
          data={proposals}
          renderItem={renderItem}
          keyExtractor={(item) => item.id}
          contentContainerStyle={styles.listContent}
          refreshing={refreshing}
          onRefresh={handleRefresh}
          ListEmptyComponent={
            <View style={styles.emptyContainer}>
              <Ionicons name="document-text-outline" size={48} color="#ccc" />
              <Text style={styles.emptyText}>
                {selectedTab === 'pending'
                  ? 'Kh√¥ng c√≥ ƒë·ªÅ xu·∫•t n√†o ƒëang ch·ªù duy·ªát'
                  : selectedTab === 'approved'
                  ? 'Kh√¥ng c√≥ ƒë·ªÅ xu·∫•t n√†o ƒë√£ ƒë∆∞·ª£c duy·ªát'
                  : 'Kh√¥ng c√≥ ƒë·ªÅ xu·∫•t n√†o b·ªã t·ª´ ch·ªëi'}
              </Text>
            </View>
          }
        />
      )}

      {/* Approve Modal */}
      <Modal visible={showApproveModal} transparent animationType="slide">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContainer}>
            <Text style={styles.modalTitle}>Ph√™ duy·ªát ƒë·ªÅ xu·∫•t</Text>
            <Text style={styles.modalSubtitle}>
              {selectedProposal?.proposalCode} - {selectedProposal?.projectName}
            </Text>

            <TextInput
              style={styles.commentInput}
              placeholder="Ghi ch√∫ (kh√¥ng b·∫Øt bu·ªôc)"
              value={comment}
              onChangeText={setComment}
              multiline
            />

            <View style={styles.modalActions}>
              <TouchableOpacity
                style={[styles.modalButton, styles.cancelButton]}
                onPress={() => setShowApproveModal(false)}
              >
                <Text style={styles.cancelButtonText}>H·ªßy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.modalButton, styles.confirmButton]}
                onPress={confirmApprove}
              >
                <Text style={styles.confirmButtonText}>X√°c nh·∫≠n</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Reject Modal */}
      <Modal visible={showRejectModal} transparent animationType="slide">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContainer}>
            <Text style={styles.modalTitle}>T·ª´ ch·ªëi ƒë·ªÅ xu·∫•t</Text>
            <Text style={styles.modalSubtitle}>
              {selectedProposal?.proposalCode} - {selectedProposal?.projectName}
            </Text>

            <TextInput
              style={styles.commentInput}
              placeholder="L√Ω do t·ª´ ch·ªëi (b·∫Øt bu·ªôc)"
              value={comment}
              onChangeText={setComment}
              multiline
            />

            <View style={styles.modalActions}>
              <TouchableOpacity
                style={[styles.modalButton, styles.cancelButton]}
                onPress={() => setShowRejectModal(false)}
              >
                <Text style={styles.cancelButtonText}>H·ªßy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.modalButton, styles.rejectConfirmButton]}
                onPress={confirmReject}
              >
                <Text style={styles.confirmButtonText}>X√°c nh·∫≠n</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* Materials Modal */}
      <Modal visible={showMaterialsModal} transparent animationType="slide">
        <View style={styles.modalOverlay}>
          <View style={[styles.modalContainer, styles.materialsModalContainer]}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Chi ti·∫øt v·∫≠t t∆∞</Text>
              <TouchableOpacity onPress={() => setShowMaterialsModal(false)}>
                <Ionicons name="close" size={24} color="#666" />
              </TouchableOpacity>
            </View>

            <ScrollView style={styles.materialsScrollView}>
              {selectedMaterials && selectedMaterials.length > 0 ? (
                selectedMaterials.map((item, index) => (
                  <View key={index} style={styles.materialItem}>
                    <Text style={styles.materialName}>
                      {index + 1}. {item.name || 'Kh√¥ng c√≥ t√™n'}
                    </Text>
                    <View style={styles.materialDetails}>
                      {item.specification ? (
                        <Text style={styles.materialSpec}>
                          Quy c√°ch: {item.specification}
                        </Text>
                      ) : null}
                      <Text style={styles.materialQuantity}>
                        S·ªë l∆∞·ª£ng: {item.quantity || 0} {item.unit || ''}
                      </Text>
                      {item.price && (
                        <Text style={styles.materialPrice}>
                          ƒê∆°n gi√°: {item.price} VNƒê
                        </Text>
                      )}
                      {item.totalPrice && (
                        <Text style={styles.materialTotalPrice}>
                          Th√†nh ti·ªÅn: {item.totalPrice} VNƒê
                        </Text>
                      )}
                    </View>
                  </View>
                ))
              ) : (
                <Text style={styles.emptyMaterialsText}>
                  Kh√¥ng c√≥ v·∫≠t t∆∞ n√†o.
                </Text>
              )}
            </ScrollView>

            <TouchableOpacity
              style={styles.closeButton}
              onPress={() => setShowMaterialsModal(false)}
            >
              <Text style={styles.closeButtonText}>ƒê√≥ng</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Price Update Modal */}
      <Modal visible={showPriceModal} transparent animationType="slide">
        <KeyboardAvoidingView
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={styles.modalOverlay}
        >
          <View style={[styles.modalContainer, styles.priceModalContainer]}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>C·∫≠p nh·∫≠t gi√° v·∫≠t t∆∞</Text>
              <TouchableOpacity onPress={() => setShowPriceModal(false)}>
                <Ionicons name="close" size={24} color="#666" />
              </TouchableOpacity>
            </View>

            <ScrollView style={styles.priceScrollView}>
              {editableMaterials && editableMaterials.length > 0 ? (
                editableMaterials.map((item, index) => (
                  <View key={index} style={styles.priceItem}>
                    <Text style={styles.materialName}>
                      {index + 1}. {item.name || 'Kh√¥ng c√≥ t√™n'}
                    </Text>
                    <View style={styles.materialDetails}>
                      {item.specification ? (
                        <Text style={styles.materialSpec}>
                          Quy c√°ch: {item.specification}
                        </Text>
                      ) : null}
                      <Text style={styles.materialQuantity}>
                        S·ªë l∆∞·ª£ng: {item.quantity || 0} {item.unit || ''}
                      </Text>

                      <View style={styles.priceInputContainer}>
                        <Text style={styles.priceLabel}>ƒê∆°n gi√° (VNƒê):</Text>
                        <TextInput
                          style={styles.priceInput}
                          value={item.price}
                          onChangeText={(text) =>
                            handlePriceChange(index, text)
                          }
                          keyboardType="numeric"
                          placeholder="Nh·∫≠p ƒë∆°n gi√°"
                        />
                      </View>

                      {item.totalPrice && (
                        <Text style={styles.materialTotalPrice}>
                          Th√†nh ti·ªÅn: {item.totalPrice} VNƒê
                        </Text>
                      )}
                    </View>
                  </View>
                ))
              ) : (
                <Text style={styles.emptyMaterialsText}>
                  Kh√¥ng c√≥ v·∫≠t t∆∞ n√†o.
                </Text>
              )}
            </ScrollView>

            <View style={styles.modalActions}>
              <TouchableOpacity
                style={[styles.modalButton, styles.cancelButton]}
                onPress={() => setShowPriceModal(false)}
              >
                <Text style={styles.cancelButtonText}>H·ªßy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.modalButton, styles.saveButton]}
                onPress={savePriceUpdates}
              >
                <Text style={styles.confirmButtonText}>L∆∞u gi√°</Text>
              </TouchableOpacity>
            </View>
          </View>
        </KeyboardAvoidingView>
      </Modal>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: '#f5f5f5',
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 16,
    color: '#333',
  },
  tabContainer: {
    flexDirection: 'row',
    marginBottom: 16,
    backgroundColor: '#fff',
    borderRadius: 8,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  tab: {
    flex: 1,
    paddingVertical: 12,
    alignItems: 'center',
  },
  activeTab: {
    borderBottomWidth: 2,
    borderBottomColor: '#0066cc',
  },
  tabText: {
    color: '#666',
    fontWeight: '500',
  },
  activeTabText: {
    color: '#0066cc',
    fontWeight: '600',
  },
  listContent: {
    paddingBottom: 20,
  },
  card: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  cardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  proposalCode: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  statusBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  statusText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
  projectName: {
    fontSize: 15,
    fontWeight: '500',
    marginBottom: 12,
    color: '#444',
  },
  infoRow: {
    flexDirection: 'row',
    marginBottom: 8,
    alignItems: 'flex-start', // Align items to the top
  },
  infoItem: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    flexWrap: 'wrap', // Allow content to wrap
  },
  infoLabel: {
    fontSize: 13,
    color: '#666',
    marginRight: 4,
  },
  infoValue: {
    fontSize: 13,
    color: '#333',
    fontWeight: '500',
  },
  priorityBadge: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 12,
  },
  priorityText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
  purposeContainer: {
    marginTop: 4,
    marginBottom: 8,
    padding: 8,
    backgroundColor: '#f9f9f9',
    borderRadius: 4,
  },
  purposeLabel: {
    fontSize: 13,
    fontWeight: '500',
    color: '#555',
    marginBottom: 4,
  },
  purposeText: {
    fontSize: 13,
    color: '#333',
  },
  cardActions: {
    marginTop: 8,
    borderTopWidth: 1,
    borderTopColor: '#f0f0f0',
    paddingTop: 8,
  },
  itemsCount: {
    fontSize: 13,
    color: '#666',
    marginBottom: 8,
  },
  actionButtonsRow: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
  },
  viewButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 6,
    paddingHorizontal: 12,
    backgroundColor: '#f0f7ff',
    borderRadius: 20,
    marginRight: 8,
  },
  viewButtonText: {
    color: '#0066cc',
    fontSize: 12,
    fontWeight: '500',
    marginLeft: 4,
  },
  actionButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 12,
    borderTopWidth: 1,
    borderTopColor: '#eee',
    paddingTop: 12,
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 4,
    flex: 1,
    marginHorizontal: 4,
  },
  approveButton: {
    backgroundColor: '#4CAF50',
  },
  rejectButton: {
    backgroundColor: '#E74C3C', // Softer red color
  },
  actionButtonText: {
    color: '#fff',
    fontWeight: '600',
    marginLeft: 4,
  },
  commentContainer: {
    marginTop: 12,
    padding: 8,
    backgroundColor: '#f5f5f5',
    borderRadius: 4,
    borderLeftWidth: 3,
    borderLeftColor: '#ccc',
  },
  commentLabel: {
    fontSize: 12,
    fontWeight: '500',
    color: '#666',
    marginBottom: 2,
  },
  commentText: {
    fontSize: 13,
    color: '#333',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 8,
    color: '#666',
  },
  emptyContainer: {
    padding: 40,
    alignItems: 'center',
    justifyContent: 'center',
  },
  emptyText: {
    marginTop: 8,
    color: '#666',
    textAlign: 'center',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    width: '90%',
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 20,
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 4,
    color: '#333',
  },
  modalSubtitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 16,
  },
  commentInput: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 4,
    padding: 10,
    height: 100,
    textAlignVertical: 'top',
    marginBottom: 16,
  },
  modalActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
  },
  modalButton: {
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 4,
    marginLeft: 8,
  },
  cancelButton: {
    backgroundColor: '#f5f5f5',
  },
  cancelButtonText: {
    color: '#333',
  },
  confirmButton: {
    backgroundColor: '#4CAF50',
  },
  rejectConfirmButton: {
    backgroundColor: '#E74C3C', // Softer red color
  },
  confirmButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
  materialsModalContainer: {
    maxHeight: '80%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    paddingBottom: 8,
  },
  materialsScrollView: {
    maxHeight: '80%', // Limit height to allow button to be visible
  },
  materialItem: {
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  materialName: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 4,
  },
  materialDetails: {
    marginLeft: 16,
  },
  materialSpec: {
    fontSize: 13,
    color: '#666',
    marginBottom: 2,
  },
  materialQuantity: {
    fontSize: 13,
    color: '#333',
  },
  emptyMaterialsText: {
    textAlign: 'center',
    padding: 20,
    color: '#666',
  },
  closeButton: {
    backgroundColor: '#0066cc',
    padding: 12,
    borderRadius: 4,
    alignItems: 'center',
    marginTop: 16,
  },
  closeButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
  priceModalContainer: {
    maxHeight: '85%',
    width: '92%',
  },
  priceScrollView: {
    maxHeight: '75%',
  },
  priceItem: {
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  priceInputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 6,
    marginBottom: 4,
  },
  priceLabel: {
    fontSize: 13,
    color: '#555',
    width: 100,
  },
  priceInput: {
    flex: 1,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 4,
    paddingHorizontal: 8,
    paddingVertical: 4,
    fontSize: 13,
  },
  materialPrice: {
    fontSize: 13,
    color: '#28a745',
    marginTop: 2,
  },
  materialTotalPrice: {
    fontSize: 13,
    color: '#28a745',
    fontWeight: '500',
    marginTop: 2,
  },
  saveButton: {
    backgroundColor: '#28a745',
  },
  poButton: {
    backgroundColor: '#fff5e6',
    marginLeft: 8,
    borderColor: '#FF9500',
    borderWidth: 1,
  },
});

export default ProposalListScreen;


--- END: src\screens\ProposalListScreen.js ---


--- START: src\screens\QuotationScreen.js ---
// src/screens/QuotationScreen.js

import React, { useState, useEffect, useCallback, memo } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  ActivityIndicator,
  Modal,
  TextInput,
  TouchableOpacity,
  Alert,
  SafeAreaView,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';
import { useMaterialsProcessor } from '../hooks/useMaterialsProcessor';
import { getQuotationsByProject } from '../api/quotationService';
import * as Sharing from 'expo-sharing';
import * as FileSystem from 'expo-file-system';
import { db } from '../config/firebaseConfig';
import { collection, query, where, getDocs } from 'firebase/firestore';

// --- C√°c Component v√† H√†m Helper ƒë∆∞·ª£c chuy·ªÉn t·ª´ ProjectDetailScreen ---

// Memoized row component for the materials list
const MaterialRow = memo(
  ({
    item,
    index,
    onPriceChange,
    formatNumber,
    onToggleSelect,
    inventoryStatus,
  }) => {
    // Debug log r√µ r√†ng h∆°n ƒë·ªÉ ki·ªÉm tra d·ªØ li·ªáu STT
    console.log(`Rendering row ${index}:`, {
      stt: item.stt,
      sttType: typeof item.stt,
      sttEmpty: !item.stt,
      name: item.name?.substring(0, 20) + '...',
    });

    // Check if the STT is a Roman numeral to apply special styling
    const isRoman = item.stt && /^[IVXLCDM]+$/i.test(item.stt.trim());

    // If the item is a note, render it differently
    if (item.isNote) {
      return (
        <View style={[styles.tableRow, styles.noteRow]}>
          <View style={styles.noteCell}>
            <Text style={styles.noteText}>{item.name}</Text>
          </View>
        </View>
      );
    }
    return (
      <View style={styles.tableRow}>
        <TouchableOpacity
          style={styles.checkbox}
          onPress={() => onToggleSelect(index)}
        >
          <Ionicons
            name={item.selected ? 'checkbox' : 'square-outline'}
            size={18}
            color={item.selected ? '#0066CC' : '#999'}
          />
        </TouchableOpacity>
        <View style={[styles.tableCell, { flex: 0.5, alignItems: 'center' }]}>
          {inventoryStatus === 'found' && (
            <Ionicons name="checkmark-circle" size={18} color="green" />
          )}
          {inventoryStatus === 'notFound' && (
            <Ionicons name="close-circle" size={18} color="red" />
          )}
        </View>
        <View
          style={[
            styles.tableCell,
            styles.sttCell,
            {
              flex: 0.8,
              justifyContent: 'center',
              backgroundColor: isRoman ? '#E8D5F7' : '#f8f8f8', // Light purple background for Roman numerals
              borderRightWidth: 1,
              borderRightColor: '#ddd',
              marginRight: 2,
            },
          ]}
        >
          <Text
            style={{
              fontSize: 13,
              fontWeight: 'bold',
              color: '#333', // Keep text color consistent
              textAlign: 'center',
            }}
          >
            {item.stt || ''}
          </Text>
        </View>
        <View style={[styles.tableCell, { flex: 2.2 }]}>
          <Text style={styles.materialName}>{item.name}</Text>
          {item.material ? (
            <Text style={styles.materialType}>{item.material}</Text>
          ) : null}
          {item.quyCach ? (
            <Text style={styles.materialType}>Quy c√°ch: {item.quyCach}</Text>
          ) : null}
        </View>
        <Text style={[styles.tableCell, { flex: 1, textAlign: 'center' }]}>
          {formatNumber(item.quantity)}
        </Text>
        <Text style={[styles.tableCell, { flex: 1, textAlign: 'center' }]}>
          {formatNumber(item.weight)}
        </Text>
        <Text style={[styles.tableCell, { flex: 0.8, textAlign: 'center' }]}>
          {item.unit}
        </Text>
        <View style={[styles.tableCell, { flex: 1.2 }]}>
          <TextInput
            style={styles.priceInput}
            value={item.unitPrice > 0 ? item.unitPrice.toString() : ''}
            onChangeText={(text) => onPriceChange(text, index)}
            placeholder="Nh·∫≠p..."
            keyboardType="numeric"
            selectTextOnFocus
          />
        </View>
        <Text style={[styles.tableCell, styles.totalPrice, { flex: 1.5 }]}>
          {item.totalPrice > 0 ? item.totalPrice.toLocaleString('vi-VN') : ''}
        </Text>
      </View>
    );
  }
);

// H√†m format ti·ªÅn
const formatCurrency = (amount) => {
  if (!amount) return '0 VNƒê';
  return new Intl.NumberFormat('vi-VN', {
    style: 'currency',
    currency: 'VND',
    minimumFractionDigits: 0,
  }).format(amount);
};

const formatAppNumber = (num) => {
  if (typeof num !== 'number' || isNaN(num)) return '0';
  const roundedNum = Math.round(num * 10) / 10;
  return roundedNum.toString().replace('.', ',');
};
// --------------------------------------------------------------------

const QuotationScreen = ({ route, navigation }) => {
  const { projectId, projectName, project } = route.params;

  const {
    materials,
    showMaterialsTable,
    driveFiles,
    isPickerVisible,
    isLoadingFiles,
    isGoogleDriveLoading,
    handleImportFromGoogleDrive,
    handleFileSelect,
    handlePriceChange,
    handleRequote,
    setIsPickerVisible,
    setMaterials,
  } = useMaterialsProcessor(project);

  const [quotations, setQuotations] = useState([]);
  const [isLoadingQuotations, setIsLoadingQuotations] = useState(true);
  const [showBulkPriceModal, setShowBulkPriceModal] = useState(false);
  const [bulkPrice, setBulkPrice] = useState('');
  const [hasSelections, setHasSelections] = useState(false);
  const [isCheckingInventory, setIsCheckingInventory] = useState(false);

  // L·∫•y l·ªãch s·ª≠ b√°o gi√°
  useFocusEffect(
    useCallback(() => {
      const loadQuotations = async () => {
        setIsLoadingQuotations(true);
        try {
          const pastQuotations = await getQuotationsByProject(projectId);
          setQuotations(pastQuotations);
        } catch (error) {
          console.error('L·ªói khi t·∫£i l·ªãch s·ª≠ b√°o gi√°:', error);
        } finally {
          setIsLoadingQuotations(false);
        }
      };
      if (projectId) {
        loadQuotations();
      }
    }, [projectId])
  );

  const handleCheckInventory = async () => {
    const selectedMaterials = materials.filter((m) => m.selected);
    if (selectedMaterials.length === 0) {
      Alert.alert('Th√¥ng b√°o', 'Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt v·∫≠t t∆∞ ƒë·ªÉ ki·ªÉm tra.');
      return;
    }

    setIsCheckingInventory(true);

    try {
      const inventoryRef = collection(db, 'inventory');
      const updatedMaterials = [...materials];

      for (let i = 0; i < updatedMaterials.length; i++) {
        const material = updatedMaterials[i];
        if (!material.selected) continue;

        const name = (material.name || '').trim();
        const code = (material.code || '').trim();

        if (!name && !code) {
          material.inventoryStatus = 'notFound';
          continue;
        }

        let q;
        if (code) {
          q = query(inventoryRef, where('code', '==', code));
        } else {
          q = query(inventoryRef, where('name', '==', name));
        }

        const querySnapshot = await getDocs(q);
        if (!querySnapshot.empty) {
          material.inventoryStatus = 'found';
        } else {
          material.inventoryStatus = 'notFound';
        }
      }
      setMaterials(updatedMaterials);
    } catch (error) {
      console.error('L·ªói khi ki·ªÉm tra kho:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ki·ªÉm tra kho. Vui l√≤ng th·ª≠ l·∫°i.');
    } finally {
      setIsCheckingInventory(false);
    }
  };

  const handleViewPdf = async (pdfUrl, quotationNumber) => {
    if (!pdfUrl) {
      Alert.alert('L·ªói', 'Kh√¥ng t√¨m th·∫•y ƒë∆∞·ªùng d·∫´n PDF cho b√°o gi√° n√†y.');
      return;
    }
    Alert.alert('ƒêang x·ª≠ l√Ω', 'ƒêang t·∫£i file PDF ƒë·ªÉ xem...');
    try {
      const fileUri =
        FileSystem.documentDirectory + `${quotationNumber || 'quotation'}.pdf`;
      const { uri } = await FileSystem.downloadAsync(pdfUrl, fileUri);
      if (await Sharing.isAvailableAsync()) {
        await Sharing.shareAsync(uri, { dialogTitle: 'M·ªü ho·∫∑c chia s·∫ª PDF' });
      } else {
        Alert.alert(
          'Kh√¥ng th·ªÉ chia s·∫ª',
          'Thi·∫øt b·ªã c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ ch·ª©c nƒÉng n√†y.'
        );
      }
    } catch (error) {
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ m·ªü file PDF. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  };

  const handleNavigateToFinalize = () => {
    const subTotal = materials.reduce(
      (sum, item) => sum + (item.totalPrice || 0),
      0
    );
    const customerData = {
      id: project.customerId || '',
      name: project.customerName || 'Kh√°ch h√†ng',
      address: project.customerAddress || '',
      phone: project.customerPhone || '',
      email: project.customerEmail || '',
      contactPerson: project.customerContactPerson || '',
      taxCode: project.customerTaxCode || '',
    };
    navigation.navigate('FinalizeQuotation', {
      materials,
      subTotal,
      projectId,
      projectName: project.name || 'D·ª± √°n m·ªõi',
      customerData,
    });
  };

  const handleToggleSelect = (index) => {
    setMaterials((prev) => {
      const updated = [...prev];
      updated[index] = {
        ...updated[index],
        selected: !updated[index].selected,
      };

      // Update hasSelections state
      const anySelected = updated.some((item) => item.selected);
      setHasSelections(anySelected);

      return updated;
    });
  };

  const toggleSelectAll = (value) => {
    setMaterials((prev) =>
      prev.map((item) => ({
        ...item,
        selected: value,
      }))
    );
    setHasSelections(value);
  };

  const handleApplyBulkPrice = () => {
    if (!bulkPrice || isNaN(parseFloat(bulkPrice))) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p gi√° h·ª£p l·ªá');
      return;
    }

    const price = parseFloat(bulkPrice);

    setMaterials((prev) => {
      return prev.map((item) => {
        if (item.selected) {
          const weight = parseFloat(item.weight || 0);
          const quantity = parseFloat(item.quantity || 0);

          let totalPrice;
          if (weight > 0) {
            // N·∫øu c√≥ tr·ªçng l∆∞·ª£ng: th√†nh ti·ªÅn = s·ªë l∆∞·ª£ng √ó tr·ªçng l∆∞·ª£ng √ó ƒë∆°n gi√°
            totalPrice = quantity * weight * price;
          } else {
            // N·∫øu kh√¥ng c√≥ tr·ªçng l∆∞·ª£ng: th√†nh ti·ªÅn = s·ªë l∆∞·ª£ng √ó ƒë∆°n gi√°
            totalPrice = quantity * price;
          }

          return {
            ...item,
            unitPrice: price,
            totalPrice: totalPrice,
          };
        }
        return item;
      });
    });

    setShowBulkPriceModal(false);
    setBulkPrice('');
  };

  const renderHeader = () => (
    <View style={styles.section}>
      <Text style={styles.sectionTitle}>1. Nh·∫≠p V·∫≠t T∆∞</Text>
      <TouchableOpacity
        style={[
          styles.importButton,
          isGoogleDriveLoading && styles.importButtonDisabled,
        ]}
        onPress={handleImportFromGoogleDrive}
        disabled={isGoogleDriveLoading}
      >
        {isGoogleDriveLoading ? (
          <ActivityIndicator size="small" color="#fff" />
        ) : (
          <Ionicons name="cloud-download-outline" size={24} color="#fff" />
        )}
        <Text style={styles.importButtonText}>Nh·∫≠p t·ª´ Google Drive</Text>
      </TouchableOpacity>

      <TouchableOpacity
        style={[styles.manualButton]}
        onPress={() =>
          navigation.navigate('ManualQuotation', {
            projectId,
            projectName,
            project,
          })
        }
      >
        <Ionicons name="create-outline" size={24} color="#fff" />
        <Text style={styles.importButtonText}>Nh·∫≠p th·ªß c√¥ng</Text>
      </TouchableOpacity>
    </View>
  );

  const renderMaterialsSection = () =>
    showMaterialsTable && (
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>2. B·∫£ng T√≠nh V·∫≠t T∆∞</Text>

        {materials.length > 0 && (
          <View style={styles.bulkActionContainer}>
            <TouchableOpacity
              style={styles.bulkActionButton}
              onPress={() => toggleSelectAll(true)}
            >
              <Ionicons name="checkbox-outline" size={18} color="#fff" />
              <Text style={styles.bulkActionButtonText}>Ch·ªçn t·∫•t c·∫£</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.bulkActionButton, styles.unselectButton]}
              onPress={() => toggleSelectAll(false)}
            >
              <Ionicons name="square-outline" size={18} color="#fff" />
              <Text style={styles.bulkActionButtonText}>B·ªè ch·ªçn</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.bulkActionButton,
                styles.priceButton,
                !hasSelections && styles.disabledButton,
              ]}
              disabled={!hasSelections}
              onPress={() => setShowBulkPriceModal(true)}
            >
              <Ionicons name="pricetag-outline" size={18} color="#fff" />
              <Text style={styles.bulkActionButtonText}>√Åp d·ª•ng gi√°</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[
                styles.bulkActionButton,
                styles.checkInventoryButton,
                !hasSelections && styles.disabledButton,
              ]}
              disabled={!hasSelections || isCheckingInventory}
              onPress={handleCheckInventory}
            >
              {isCheckingInventory ? (
                <ActivityIndicator size="small" color="#fff" />
              ) : (
                <Ionicons name="storefront-outline" size={18} color="#fff" />
              )}
              <Text style={styles.bulkActionButtonText}>Ki·ªÉm tra kho</Text>
            </TouchableOpacity>
          </View>
        )}

        <View style={styles.tableHeader}>
          <View style={{ width: 30 }}></View>
          <View style={{ width: 25 }} />
          <View
            style={[
              styles.headerCell,
              {
                flex: 0.8,
                justifyContent: 'center',
                backgroundColor: '#f0f0f0',
                borderRightWidth: 1,
                borderRightColor: '#ddd',
                marginRight: 2,
              },
            ]}
          >
            <Text
              style={{
                fontSize: 13,
                fontWeight: 'bold',
                color: '#333',
                textAlign: 'center',
              }}
            >
              STT
            </Text>
          </View>
          <Text style={[styles.headerCell, { flex: 2.2 }]}>T√™n v·∫≠t t∆∞</Text>
          <Text style={[styles.headerCell, { flex: 1, textAlign: 'center' }]}>
            SL
          </Text>
          <Text style={[styles.headerCell, { flex: 1, textAlign: 'center' }]}>
            KL
          </Text>
          <Text style={[styles.headerCell, { flex: 0.8, textAlign: 'center' }]}>
            ƒêVT
          </Text>
          <Text style={[styles.headerCell, { flex: 1.2, textAlign: 'right' }]}>
            ƒê∆°n gi√°
          </Text>
          <Text style={[styles.headerCell, { flex: 1.5, textAlign: 'right' }]}>
            Th√†nh ti·ªÅn
          </Text>
        </View>
        <FlatList
          data={materials}
          keyExtractor={(item, index) => `material-row-${index}`}
          renderItem={({ item, index }) => (
            <MaterialRow
              item={item}
              index={index}
              onPriceChange={handlePriceChange}
              formatNumber={formatAppNumber}
              onToggleSelect={handleToggleSelect}
              inventoryStatus={item.inventoryStatus}
            />
          )}
        />
      </View>
    );

  const renderFooter = () => (
    <>
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>3. L·ªãch s·ª≠ b√°o gi√°</Text>
        {isLoadingQuotations ? (
          <ActivityIndicator />
        ) : quotations.length === 0 ? (
          <Text style={styles.emptyText}>Ch∆∞a c√≥ b√°o gi√° n√†o.</Text>
        ) : (
          <View style={styles.historyContainer}>
            {quotations.map((item, index) => (
              <View
                key={item.id}
                style={[
                  styles.historyItem,
                  index > 0 && styles.historyItemBorder,
                ]}
              >
                <View style={styles.historyInfo}>
                  <Text style={styles.historyNumber}>
                    {item.quotationNumber ||
                      `B√°o gi√° #${item.id.substring(0, 5)}`}
                  </Text>
                  <Text style={styles.historyDate}>
                    Ng√†y t·∫°o:{' '}
                    {item.createdAt
                      ? new Date(
                          item.createdAt.seconds * 1000
                        ).toLocaleDateString('vi-VN')
                      : 'Kh√¥ng r√µ'}
                  </Text>
                  <Text style={styles.historyTotal}>
                    T·ªïng c·ªông: {formatCurrency(item.grandTotal)}
                  </Text>
                </View>
                <View style={styles.historyActions}>
                  <TouchableOpacity
                    style={styles.historyActionButton}
                    onPress={() =>
                      handleViewPdf(item.pdfUrl, item.quotationNumber)
                    }
                  >
                    <Ionicons
                      name="document-text-outline"
                      size={20}
                      color="#fff"
                    />
                    <Text style={styles.historyActionButtonText}>Xem PDF</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[styles.historyActionButton, styles.requoteButton]}
                    onPress={() =>
                      handleRequote(
                        item,
                        navigation,
                        projectId,
                        projectName,
                        project
                      )
                    }
                  >
                    <Ionicons name="copy-outline" size={20} color="#fff" />
                    <Text style={styles.historyActionButtonText}>
                      B√°o gi√° l·∫°i
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>
            ))}
          </View>
        )}
      </View>
    </>
  );

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>B√°o gi√°: {projectName}</Text>
        <View style={{ width: 24 }} />
      </View>

      <FlatList
        data={[{ key: 'main' }]}
        renderItem={() => <>{renderMaterialsSection()}</>}
        keyExtractor={(item) => item.key}
        ListHeaderComponent={renderHeader}
        ListFooterComponent={renderFooter}
        contentContainerStyle={{ padding: 12 }}
        ListEmptyComponent={
          !showMaterialsTable ? (
            <View>
              <Text style={styles.emptyText}>
                Vui l√≤ng nh·∫≠p v·∫≠t t∆∞ ƒë·ªÉ b·∫Øt ƒë·∫ßu.
              </Text>
            </View>
          ) : null
        }
      />

      {showMaterialsTable && materials.length > 0 && (
        <View style={styles.footer}>
          <View style={styles.summaryContainer}>
            <Text style={styles.summaryLabel}>T·ªïng c·ªông:</Text>
            <Text style={styles.summaryValue}>
              {formatCurrency(
                materials.reduce((sum, item) => sum + (item.totalPrice || 0), 0)
              )}
            </Text>
          </View>
          <TouchableOpacity
            style={styles.continueButton}
            onPress={handleNavigateToFinalize}
          >
            <Text style={styles.continueButtonText}>
              Ti·∫øp t·ª•c ho√†n thi·ªán b√°o gi√°
            </Text>
            <Ionicons name="arrow-forward" size={20} color="#fff" />
          </TouchableOpacity>
        </View>
      )}

      <Modal
        animationType="slide"
        transparent={true}
        visible={isPickerVisible}
        onRequestClose={() => setIsPickerVisible(false)}
      >
        <View style={styles.modalContainer}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>
              Ch·ªçn file Excel t·ª´ Google Drive
            </Text>
            {isLoadingFiles ? (
              <ActivityIndicator size="large" />
            ) : (
              <FlatList
                data={driveFiles}
                keyExtractor={(item) => item.id}
                renderItem={({ item }) => (
                  <TouchableOpacity
                    style={styles.fileItem}
                    onPress={() => handleFileSelect(item)}
                  >
                    <Ionicons
                      name="document-text-outline"
                      size={24}
                      color="#4F8EF7"
                    />
                    <Text style={styles.fileName}>{item.name}</Text>
                  </TouchableOpacity>
                )}
                ListEmptyComponent={<Text>Kh√¥ng t√¨m th·∫•y file n√†o.</Text>}
              />
            )}
            <TouchableOpacity
              style={styles.closeButton}
              onPress={() => setIsPickerVisible(false)}
            >
              <Text style={styles.closeButtonText}>ƒê√≥ng</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Bulk Price Modal */}
      <Modal
        transparent={true}
        visible={showBulkPriceModal}
        animationType="slide"
        onRequestClose={() => setShowBulkPriceModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>√Åp d·ª•ng gi√° cho m·ª•c ƒë√£ ch·ªçn</Text>

            <TextInput
              style={styles.bulkPriceInput}
              placeholder="Nh·∫≠p ƒë∆°n gi√° √°p d·ª•ng"
              keyboardType="numeric"
              value={bulkPrice}
              onChangeText={setBulkPrice}
              autoFocus
            />

            <View style={styles.bulkPriceActions}>
              <TouchableOpacity
                style={[styles.bulkPriceActionButton, styles.cancelButton]}
                onPress={() => setShowBulkPriceModal(false)}
              >
                <Text style={styles.cancelButtonText}>H·ªßy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.bulkPriceActionButton, styles.applyButton]}
                onPress={handleApplyBulkPrice}
              >
                <Text style={styles.applyButtonText}>√Åp d·ª•ng</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#f0f2f5' },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  backButton: { padding: 4 },
  headerTitle: { fontSize: 18, fontWeight: 'bold', color: '#333' },
  section: {
    backgroundColor: '#fff',
    padding: 16,
    borderRadius: 8,
    marginBottom: 12,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginBottom: 12,
  },
  emptyText: { textAlign: 'center', color: '#666', marginTop: 20 },
  importButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#0066cc',
    padding: 12,
    borderRadius: 8,
  },
  importButtonDisabled: { backgroundColor: '#a0a0a0' },
  importButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '500',
    marginLeft: 8,
  },
  manualButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#4CAF50',
    padding: 12,
    borderRadius: 8,
    marginTop: 10,
  },
  tableHeader: {
    flexDirection: 'row',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
    backgroundColor: '#f8f8f8',
    alignItems: 'center',
  },
  headerCell: { fontWeight: 'bold', color: '#333' },
  sttHeaderCell: {
    width: 30,
    alignItems: 'center',
    justifyContent: 'center',
    borderRightWidth: 1,
    borderRightColor: '#eee',
  },
  tableRow: {
    flexDirection: 'row',
    alignItems: 'center',
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
    paddingVertical: 8,
  },
  noteRow: {
    backgroundColor: '#f5f5f5', // Light gray background
    opacity: 0.8, // Slightly faded
  },
  tableCell: { fontSize: 12, color: '#333' },
  noteCell: {
    flex: 1,
    paddingHorizontal: 10,
    justifyContent: 'center',
  },
  noteText: {
    fontStyle: 'italic',
    color: '#555',
    fontSize: 13,
  },
  materialName: { fontWeight: '500', fontSize: 13 },
  materialType: { fontSize: 11, color: '#666' },
  priceInput: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 4,
    padding: 6,
    textAlign: 'right',
    fontSize: 12,
  },
  totalPrice: { fontWeight: '500', textAlign: 'right', fontSize: 13 },
  footer: {
    backgroundColor: '#fff',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
    paddingBottom: 30,
  },
  summaryContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  summaryLabel: { fontSize: 16, fontWeight: '500' },
  summaryValue: { fontSize: 18, fontWeight: 'bold', color: '#d9534f' },
  continueButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#4CAF50',
    padding: 14,
    borderRadius: 8,
  },
  continueButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
    marginRight: 8,
  },
  modalContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  modalContent: {
    backgroundColor: 'white',
    padding: 20,
    borderRadius: 10,
    width: '90%',
    maxHeight: '80%',
  },
  modalTitle: { fontSize: 18, fontWeight: 'bold', marginBottom: 15 },
  fileItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  fileName: { marginLeft: 10, fontSize: 16 },
  closeButton: {
    marginTop: 20,
    backgroundColor: '#d9534f',
    padding: 10,
    borderRadius: 5,
    alignItems: 'center',
  },
  closeButtonText: { color: 'white', fontWeight: 'bold' },
  historyContainer: { marginTop: 8 },
  historyItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 2,
  },
  historyItemBorder: {
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  historyInfo: {
    flex: 1,
    paddingRight: 12,
  },
  historyNumber: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 3,
  },
  historyDate: {
    color: '#666',
    fontSize: 12,
    marginBottom: 3,
  },
  historyTotal: {
    color: '#d9534f',
    fontWeight: '600',
    fontSize: 13,
  },
  historyActions: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  historyActionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 6,
    backgroundColor: '#0066CC',
  },
  historyActionButtonText: {
    color: '#fff',
    marginLeft: 6,
    fontWeight: '500',
    fontSize: 14,
  },
  requoteButton: {
    backgroundColor: '#4CAF50',
  },
  checkbox: {
    width: 30,
    alignItems: 'center',
    justifyContent: 'center',
    paddingRight: 4,
  },

  bulkActionContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    alignItems: 'center',
    marginBottom: 10,
  },
  bulkActionRow: {
    flexDirection: 'row',
    marginBottom: 8,
    flexWrap: 'wrap',
  },
  bulkActionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#007AFF',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 6,
    marginRight: 8,
    marginBottom: 8,
  },
  unselectButton: {
    backgroundColor: '#555',
  },
  priceButton: {
    backgroundColor: '#4CAF50',
  },
  checkInventoryButton: {
    backgroundColor: '#9B59B6',
  },
  disabledButton: {
    backgroundColor: '#a0a0a0',
  },
  bulkActionButtonText: {
    color: '#fff',
    marginLeft: 6,
    fontWeight: '500',
    fontSize: 14,
  },

  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.5)',
    padding: 20,
  },

  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 15,
    textAlign: 'center',
  },

  bulkPriceInput: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 4,
    padding: 12,
    fontSize: 16,
    marginTop: 10,
    marginBottom: 20,
  },

  bulkPriceActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },

  bulkPriceActionButton: {
    paddingVertical: 10,
    paddingHorizontal: 15,
    borderRadius: 4,
    flex: 1,
    marginHorizontal: 5,
    alignItems: 'center',
  },

  cancelButton: {
    backgroundColor: '#f8f9fa',
    borderWidth: 1,
    borderColor: '#ccc',
  },

  cancelButtonText: {
    color: '#333',
  },

  applyButton: {
    backgroundColor: '#28a745',
  },

  applyButtonText: {
    color: '#fff',
    fontWeight: 'bold',
  },

  sttCell: {
    paddingLeft: 10,
    paddingRight: 10,
    borderRightWidth: 1,
    borderRightColor: '#eee',
    fontWeight: '500',
  },
  sttText: {
    fontSize: 13,
    fontWeight: 'bold',
    color: '#333',
  },
});

export default QuotationScreen;


--- END: src\screens\QuotationScreen.js ---


--- START: src\screens\SalarySlipCreationScreen.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Alert,
  TextInput,
  ActivityIndicator,
  Modal,
  Linking,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import salaryService from '../api/salaryService';
import { getUsers } from '../api/userService';
import * as Clipboard from 'expo-clipboard';
import { GoogleSignin } from '@react-native-google-signin/google-signin';

// Helper function to format currency
const formatCurrency = (amount) => {
  if (typeof amount !== 'number' || isNaN(amount)) return '0 VNƒê';
  return new Intl.NumberFormat('vi-VN', {
    style: 'currency',
    currency: 'VND',
  }).format(amount);
};

const SalarySlipCreationScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const [loading, setLoading] = useState(false);
  const [exporting, setExporting] = useState(false);
  const [employees, setEmployees] = useState([]);
  const [selectedEmployee, setSelectedEmployee] = useState(null);
  const [employeeInfo, setEmployeeInfo] = useState(null); // salary, insurance base, leave balance
  const [attendanceInfo, setAttendanceInfo] = useState(null); // attendance summary
  const [autoDeductions, setAutoDeductions] = useState([]);
  const [advancePayments, setAdvancePayments] = useState([]);
  const [systemSettings, setSystemSettings] = useState(null);

  // Modal k·∫øt qu·∫£ sau khi t·∫°o
  const [resultModalVisible, setResultModalVisible] = useState(false);
  const [lastCreatedSlip, setLastCreatedSlip] = useState(null);

  // Qu·∫£n l√Ω slip hi·ªán t·∫°i theo k·ª≥ l∆∞∆°ng ƒëang ch·ªçn
  const [currentSlip, setCurrentSlip] = useState(null);
  const [monthPickerVisible, setMonthPickerVisible] = useState(false);
  const [exportLink, setExportLink] = useState('');

  const formatDateVN = (d) => {
    try {
      const date = d?.toDate ? d.toDate() : new Date(d);
      if (isNaN(date)) return '';
      return date.toLocaleDateString('vi-VN', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
      });
    } catch (e) {
      return '';
    }
  };

  const [formData, setFormData] = useState({
    month: new Date().getMonth() + 1,
    year: new Date().getFullYear(),
    allowances: [],
    bonuses: [],
    deductions: [], // Manual deductions only
    notes: '',
  });

  const [showEmployeeModal, setShowEmployeeModal] = useState(false);
  const [showFeeModal, setShowFeeModal] = useState(false);
  const [feeModalType, setFeeModalType] = useState(''); // 'allowance' | 'bonus' | 'deduction'
  const [newFee, setNewFee] = useState({ name: '', amount: '' });
  const [otModalVisible, setOtModalVisible] = useState(false);

  // Map fee type to localized label
  const feeTypeLabel = (type) => {
    switch (type) {
      case 'allowance':
        return 'ph·ª• c·∫•p'; // y√™u c·∫ßu: "th√™m ph·ª• c·∫•p"
      case 'bonus':
        return 'Th∆∞·ªüng'; // y√™u c·∫ßu: "th√™m Th∆∞·ªüng"
      case 'deduction':
        return 'kh·∫•u tr·ª´';
      default:
        return type || '';
    }
  };

  // Load employees
  useEffect(() => {
    const loadEmployees = async () => {
      try {
        setLoading(true);
        const users = await getUsers();
        setEmployees(users);
      } catch (error) {
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch nh√¢n vi√™n.');
      } finally {
        setLoading(false);
      }
    };
    loadEmployees();
  }, []);

  const resetForm = () => {
    setSelectedEmployee(null);
    setEmployeeInfo(null);
    setAttendanceInfo(null);
    setAutoDeductions([]);
    setSystemSettings(null);
    setFormData({
      month: new Date().getMonth() + 1,
      year: new Date().getFullYear(),
      allowances: [],
      bonuses: [],
      deductions: [],
      notes: '',
    });
  };

  // Load employee details and attendance when an employee is selected
  const handleEmployeeSelect = async (employee) => {
    setSelectedEmployee(employee);
    setShowEmployeeModal(false);
    await fetchEmployeeData(employee.id, formData.month, formData.year);
  };

  // Fetch all necessary data for the selected employee and period
  const fetchEmployeeData = async (employeeId, month, year) => {
    try {
      setLoading(true);
      // L·∫•y ƒë·ªìng th·ªùi t·∫•t c·∫£ d·ªØ li·ªáu c·∫ßn thi·∫øt
      const [details, attendance, settings, advances] = await Promise.all([
        salaryService.getEmployeeDetails(employeeId),
        salaryService.getEmployeeAttendance(employeeId, month, year),
        salaryService.getSystemSettings(),
        salaryService.getAdvancePayments(employeeId, month, year),
      ]);

      console.log('DEBUG fetchEmployeeData advances:', advances);

      // T√≠nh kh·∫•u tr·ª´ t·ª± ƒë·ªông ƒë·ªÉ hi·ªÉn th·ªã (d√πng l∆∞∆°ng ƒë√≥ng BHXH c·ªë ƒë·ªãnh)
      const autoDeds = await salaryService.getAutoDeductions(
        details.insuranceContributionBase || 0
      );

      setEmployeeInfo(details);
      setAttendanceInfo(attendance);
      setSystemSettings(settings);
      setAutoDeductions(autoDeds);
      setAdvancePayments(Array.isArray(advances) ? advances : []);
    } catch (error) {
      Alert.alert(
        'L·ªói',
        `Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu cho nh√¢n vi√™n: ${error.message}`
      );
      resetForm();
    } finally {
      setLoading(false);
    }
  };

  // Refetch data when month/year changes
  useEffect(() => {
    if (selectedEmployee) {
      fetchEmployeeData(selectedEmployee.id, formData.month, formData.year);
    }
  }, [formData.month, formData.year]);

  // Fetch current slip for selected employee & period and clear previous export state
  const refreshCurrentSlip = async () => {
    if (!selectedEmployee) return;
    try {
      const slips = await salaryService.getSalarySlips({
        employeeId: selectedEmployee.id,
        month: formData.month,
        year: formData.year,
      });
      setCurrentSlip(slips && slips.length > 0 ? slips[0] : null);
      setExportLink('');
    } catch (e) {
      setCurrentSlip(null);
    }
  };

  useEffect(() => {
    refreshCurrentSlip();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedEmployee, formData.month, formData.year]);

  // Main function to create the salary slip
  // Sao ch√©p link m·ªü phi·∫øu l∆∞∆°ng trong ·ª©ng d·ª•ng (deep link) t·ª´ lastCreatedSlip
  const handleCopyAppLink = async () => {
    try {
      if (!lastCreatedSlip?.id) return;
      const appLink = `thpapp://salary-slips/${lastCreatedSlip.id}`;
      await Clipboard.setStringAsync(appLink);
      Alert.alert('ƒê√£ sao ch√©p', 'Link trong ·ª©ng d·ª•ng ƒë√£ ƒë∆∞·ª£c sao ch√©p.');
    } catch (e) {
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ sao ch√©p link ·ª©ng d·ª•ng.');
    }
  };

  // Xu·∫•t Excel v√† cho ph√©p m·ªü/copy link Google Drive
  const handleExportToExcel = async (specificSlipId) => {
    // ∆Øu ti√™n k·ª≥ ƒëang xem (currentSlip) ƒë·ªÉ tr√°nh nh·∫ßm th√°ng tr∆∞·ªõc ƒë√≥
    const targetSlipId =
      specificSlipId || currentSlip?.id || lastCreatedSlip?.id;
    if (
      !targetSlipId ||
      typeof targetSlipId !== 'string' ||
      targetSlipId.trim().length === 0
    ) {
      Alert.alert(
        'Th√¥ng b√°o',
        'Kh√¥ng t√¨m th·∫•y ho·∫∑c ID phi·∫øu l∆∞∆°ng kh√¥ng h·ª£p l·ªá cho k·ª≥ n√†y. Vui l√≤ng t·∫°o tr∆∞·ªõc.'
      );
      return;
    }
    try {
      setExporting(true);
      const signedIn = await GoogleSignin.isSignedIn();
      if (!signedIn) {
        await GoogleSignin.hasPlayServices();
        await GoogleSignin.signIn();
      }
      const { accessToken } = await GoogleSignin.getTokens();
      if (!accessToken) throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c quy·ªÅn truy c·∫≠p Google');

      const { getFunctions, httpsCallable } = require('firebase/functions');
      const functions = getFunctions(undefined, 'asia-southeast1');
      const exportSalarySlip = httpsCallable(
        functions,
        'exportSalarySlipToDrive'
      );
      const result = await exportSalarySlip({
        salarySlipId: targetSlipId,
        accessToken,
      });

      const fileUrl = result?.data?.fileUrl;
      if (fileUrl) {
        if (resultModalVisible) {
          setExportLink(fileUrl);
        } else {
          Alert.alert('Xu·∫•t th√†nh c√¥ng', 'B·∫°n mu·ªën l√†m g√¨ v·ªõi link?', [
            { text: 'M·ªü link', onPress: () => Linking.openURL(fileUrl) },
            {
              text: 'Sao ch√©p',
              onPress: async () => {
                await Clipboard.setStringAsync(fileUrl);
                Alert.alert('ƒê√£ sao ch√©p');
              },
            },
            { text: 'ƒê√≥ng', style: 'cancel' },
          ]);
        }
      } else {
        Alert.alert(
          'Th√¥ng b√°o',
          'Xu·∫•t Excel th√†nh c√¥ng nh∆∞ng kh√¥ng nh·∫≠n ƒë∆∞·ª£c link.'
        );
      }
    } catch (error) {
      Alert.alert(
        'L·ªói',
        `Kh√¥ng th·ªÉ xu·∫•t Excel: ${error?.message || 'Unknown'}`
      );
    } finally {
      setExporting(false);
    }
  };

  const handleCreateSalarySlip = async () => {
    if (!selectedEmployee) {
      Alert.alert('L·ªói', 'Vui l√≤ng ch·ªçn m·ªôt nh√¢n vi√™n.');
      return;
    }

    try {
      setLoading(true);
      // Frontend only collects manual inputs
      const payload = {
        employeeId: selectedEmployee.id,
        month: formData.month,
        year: formData.year,
        allowances: formData.allowances,
        bonuses: formData.bonuses,
        deductions: formData.deductions, // Manual deductions only
        notes: formData.notes,
      };

      // Backend handles all calculations
      const created = await salaryService.createSalarySlipAuto(payload);
      setLastCreatedSlip(created);
      setResultModalVisible(true);
      resetForm();
    } catch (error) {
      Alert.alert('L·ªói', `Kh√¥ng th·ªÉ t·∫°o phi·∫øu l∆∞∆°ng: ${error.message}`);
    } finally {
      setLoading(false);
    }
  };

  // --- UI Helper Functions for Modals ---
  const addFee = (type) => {
    setFeeModalType(type);
    setNewFee({ name: '', amount: '' });
    setShowFeeModal(true);
  };

  const handleSaveFee = () => {
    if (!newFee.name.trim() || !newFee.amount.trim()) {
      Alert.alert('L·ªói', 'Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin.');
      return;
    }
    const fee = {
      id: Date.now().toString(),
      name: newFee.name,
      amount: parseFloat(newFee.amount),
    };
    setFormData((prev) => ({
      ...prev,
      [`${feeModalType}s`]: [...prev[`${feeModalType}s`], fee],
    }));
    setShowFeeModal(false);
  };

  const removeFee = (type, feeId) => {
    setFormData((prev) => ({
      ...prev,
      [`${type}s`]: prev[`${type}s`].filter((f) => f.id !== feeId),
    }));
  };

  // --- RENDER FUNCTIONS ---

  const renderEmployeeInfo = () =>
    selectedEmployee && employeeInfo ? (
      <View style={styles.autoInfoContainer}>
        <View style={styles.autoInfoGrid}>
          <InfoBox
            label={
              employeeInfo?.salaryType === 'daily'
                ? 'L∆∞∆°ng Theo Ng√†y'
                : 'L∆∞∆°ng H·ª£p ƒê·ªìng'
            }
            value={formatCurrency(
              employeeInfo?.salaryType === 'daily'
                ? employeeInfo?.dailySalary || 0
                : employeeInfo?.monthlySalary || 0
            )}
          />
          <InfoBox
            label="L∆∞∆°ng ƒê√≥ng BH"
            value={formatCurrency(employeeInfo.insuranceContributionBase)}
          />
          <InfoBox
            label="Ph√©p NƒÉm C√≤n L·∫°i"
            value={`${employeeInfo.annualLeaveBalance} ng√†y`}
          />
        </View>
      </View>
    ) : null;

  const handleDebugOT = async () => {
    try {
      if (!selectedEmployee) return;
      const res = await salaryService.getEmployeeAttendance(
        selectedEmployee.id,
        formData.month,
        formData.year
      );
      console.log('DEBUG OT MONTH (frontend echo)', res);
      Alert.alert(
        'Debug OT',
        `K·ª≥ ${formData.month}/${formData.year}\nNg√†y c√¥ng: ${res.actualWorkDays}\nOT Th∆∞·ªùng/CN/L·ªÖ: ${res.overtimeHours.normal} / ${res.overtimeHours.sunday} / ${res.overtimeHours.holiday}`
      );
    } catch (e) {
      Alert.alert('Debug OT l·ªói', e?.message || 'Unknown');
    }
  };

  const renderAttendanceInfo = () =>
    selectedEmployee && attendanceInfo ? (
      <View style={styles.attendanceInfoContainer}>
        <Text style={[styles.attendanceInfoTitle, { color: theme.primary }]}>
          Th√¥ng tin ch·∫•m c√¥ng th√°ng {formData.month}/{formData.year}
        </Text>
        <View style={styles.attendanceInfoGrid}>
          <InfoBox
            label="Ng√†y c√¥ng th·ª±c t·∫ø"
            value={`${attendanceInfo.actualWorkDays} ng√†y`}
          />
          <InfoBox
            label="Ngh·ªâ ph√©p"
            value={`${attendanceInfo.paidLeaveDays} ng√†y`}
          />
          <InfoBox
            label="Gi·ªù OT (Th∆∞·ªùng/CN/L·ªÖ)"
            value={`${attendanceInfo.overtimeHours.normal} / ${attendanceInfo.overtimeHours.sunday} / ${attendanceInfo.overtimeHours.holiday}`}
          />
        </View>
        <TouchableOpacity
          style={[
            styles.modalButton,
            {
              marginTop: 8,
              alignSelf: 'flex-end',
              backgroundColor: theme.primary,
            },
          ]}
          onPress={handleDebugOT}
        >
          <Text style={{ color: '#fff' }}>Debug OT</Text>
        </TouchableOpacity>
      </View>
    ) : null;

  const renderSalaryPreview = () => {
    if (!employeeInfo || !attendanceInfo || !systemSettings) return null;

    // B∆∞·ªõc 1: L·∫•y t·∫•t c·∫£ c√°c bi·∫øn c·∫ßn thi·∫øt t·ª´ state.
    const { salaryType, dailySalary, monthlySalary } = employeeInfo;
    const { actualWorkDays, paidLeaveDays, overtimeHours } = attendanceInfo;
    const { standardWorkingDays, overtimeMultipliers } = systemSettings;

    // B∆∞·ªõc 2: T√≠nh to√°n c√°c gi√° tr·ªã c∆° b·∫£n.
    const effectiveDays = actualWorkDays + paidLeaveDays;

    // ----- S·ª¨A L·ªñI LOGIC C·ªêT L√ïI N·∫∞M ·ªû ƒê√ÇY -----
    let baseSalary = 0;
    let hourlyRate = 0;

    if (salaryType === 'daily') {
      // √Åp d·ª•ng c√¥ng th·ª©c cho l∆∞∆°ng ng√†y
      baseSalary = (dailySalary || 0) * effectiveDays;
      hourlyRate = (dailySalary || 0) / 8;
    } else {
      // √Åp d·ª•ng c√¥ng th·ª©c cho l∆∞∆°ng th√°ng (m·∫∑c ƒë·ªãnh)
      baseSalary = (monthlySalary / standardWorkingDays) * effectiveDays;
      hourlyRate = monthlySalary / standardWorkingDays / 8;
    }
    // ---------------------------------------------

    // B∆∞·ªõc 3: Ti·∫øp t·ª•c c√°c ph√©p t√≠nh c√≤n l·∫°i v·ªõi baseSalary v√† hourlyRate ƒë√£ ch√≠nh x√°c.
    // ƒê∆°n gi√° gi·ªù OT (hi·ªÉn th·ªã xem tr∆∞·ªõc) theo h·ªá s·ªë t·ª´ settings, v·ªõi fallback an to√†n
    const mNormal = overtimeMultipliers?.normal ?? 1.5;
    const mSunday = mNormal; // CN c√πng ƒë∆°n gi√° nh∆∞ ng√†y th∆∞·ªùng theo y√™u c·∫ßu
    const mHoliday = overtimeMultipliers?.holiday ?? 3.0;

    const overtimeHourlyRate = {
      normal: hourlyRate * mNormal,
      sunday: hourlyRate * mSunday,
      holiday: hourlyRate * mHoliday,
    };

    // Chu·∫©n h√≥a OT ng√†y th∆∞·ªùng theo b·ªôi s·ªë 3 gi·ªù (t·ªëi ƒëa 3h/ng√†y) ‚Äì hi·ªÉn th·ªã preview an to√†n
    const normalHoursRaw = overtimeHours.normal || 0;
    const normalizedNormalHours = Math.floor(normalHoursRaw / 3) * 3;

    const totalOvertimePay =
      normalizedNormalHours * overtimeHourlyRate.normal +
      (overtimeHours.sunday || 0) * overtimeHourlyRate.sunday +
      (overtimeHours.holiday || 0) * overtimeHourlyRate.holiday;

    const totalAllowances = formData.allowances.reduce(
      (sum, item) => sum + (item.amount || 0),
      0
    );
    const totalBonuses = formData.bonuses.reduce(
      (sum, item) => sum + (item.amount || 0),
      0
    );

    const grossSalary =
      baseSalary + totalOvertimePay + totalAllowances + totalBonuses;

    const totalAuto = autoDeductions.reduce(
      (sum, item) => sum + (item.amount || 0),
      0
    );
    const totalManual = formData.deductions.reduce(
      (sum, item) => sum + (item.amount || 0),
      0
    );
    const totalAdvances = advancePayments.reduce(
      (sum, item) => sum + (item.amount || 0),
      0
    );
    const totalDeductions = totalAuto + totalManual + totalAdvances;

    const netSalary = grossSalary - totalDeductions;

    // B∆∞·ªõc 4: Render giao di·ªán v·ªõi k·∫øt qu·∫£ ƒë√∫ng.
    return (
      <View style={[styles.section, { backgroundColor: theme.card }]}>
        <Text style={[styles.sectionTitle, { color: theme.text }]}>
          Xem tr∆∞·ªõc (∆Ø·ªõc t√≠nh)
        </Text>
        <SummaryRow
          label="L∆∞∆°ng c∆° b·∫£n (theo ng√†y c√¥ng)"
          value={formatCurrency(baseSalary)}
        />
        <SummaryRow
          label="T·ªïng l∆∞∆°ng tƒÉng ca"
          value={formatCurrency(totalOvertimePay)}
          isAddition={true}
        />
        <SummaryRow
          label="ƒê∆°n gi√° gi·ªù OT (Th/CN/L·ªÖ)"
          value={`${formatCurrency(
            overtimeHourlyRate.normal
          )} / ${formatCurrency(overtimeHourlyRate.sunday)} / ${formatCurrency(
            overtimeHourlyRate.holiday
          )}`}
        />
        <SummaryRow
          label={`Chi ti·∫øt OT Th∆∞·ªùng (${overtimeHours.normal || 0}h)`}
          value={formatCurrency(
            (overtimeHours.normal || 0) * overtimeHourlyRate.normal
          )}
        />
        <SummaryRow
          label={`Chi ti·∫øt OT Ch·ªß nh·∫≠t (${overtimeHours.sunday || 0}h)`}
          value={formatCurrency(
            (overtimeHours.sunday || 0) * overtimeHourlyRate.sunday
          )}
        />
        <SummaryRow
          label={`Chi ti·∫øt OT Ng√†y l·ªÖ (${overtimeHours.holiday || 0}h)`}
          value={formatCurrency(
            (overtimeHours.holiday || 0) * overtimeHourlyRate.holiday
          )}
        />
        <SummaryRow
          label="T·ªïng Ph·ª• C·∫•p"
          value={formatCurrency(totalAllowances)}
          isAddition={true}
        />
        <SummaryRow
          label="T·ªïng Th∆∞·ªüng"
          value={formatCurrency(totalBonuses)}
          isAddition={true}
        />
        <SummaryRow
          label="T·ªîNG THU NH·∫¨P (GROSS)"
          value={formatCurrency(grossSalary)}
          isTotal={true}
        />
        <SummaryRow
          label="T·ªïng kh·∫•u tr·ª´ (BH + kh√°c)"
          value={formatCurrency(-totalDeductions)}
        />
        <SummaryRow
          label="TH·ª∞C NH·∫¨N (∆Ø·ªöC T√çNH)"
          value={formatCurrency(netSalary)}
          isTotal={true}
        />
        <Text style={[styles.previewNote, { color: theme.textMuted }]}>
          *ƒê√¢y l√† ∆∞·ªõc t√≠nh hi·ªÉn th·ªã. S·ªë li·ªáu ch√≠nh x√°c s·∫Ω do backend t√≠nh to√°n.
        </Text>
      </View>
    );
  };

  if (loading) {
    return (
      <ActivityIndicator
        size="large"
        color={theme.primary}
        style={{ flex: 1 }}
      />
    );
  }

  return (
    <View style={[styles.container, { backgroundColor: theme.background }]}>
      <View style={[styles.header, { backgroundColor: theme.primary }]}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back" size={24} color="#fff" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>T·∫°o Phi·∫øu L∆∞∆°ng M·ªõi</Text>
        <View style={{ width: 24 }} />
      </View>

      <ScrollView contentContainerStyle={styles.content}>
        {/* Employee Selection */}
        <View style={[styles.section, { backgroundColor: theme.card }]}>
          <Text style={[styles.sectionTitle, { color: theme.text }]}>
            1. Ch·ªçn nh√¢n vi√™n
          </Text>
          <TouchableOpacity
            style={[styles.selector, { borderColor: theme.border }]}
            onPress={() => setShowEmployeeModal(true)}
          >
            <Text style={{ color: theme.text }}>
              {selectedEmployee
                ? selectedEmployee.displayName || selectedEmployee.name || 'N/A'
                : 'Ch·ªçn nh√¢n vi√™n'}
            </Text>
            <Ionicons name="chevron-down" size={20} color={theme.textMuted} />
          </TouchableOpacity>
          {renderEmployeeInfo()}
        </View>

        {/* Period and Attendance */}
        {selectedEmployee && (
          <View style={[styles.section, { backgroundColor: theme.card }]}>
            <Text style={[styles.sectionTitle, { color: theme.text }]}>
              2. Ch·ªçn k·ª≥ l∆∞∆°ng
            </Text>
            <View style={styles.formRow}>
              {/* Month dropdown trigger */}
              <TouchableOpacity
                style={[
                  styles.formInput,
                  { justifyContent: 'center', borderColor: theme.border },
                ]}
                onPress={() => setMonthPickerVisible(true)}
              >
                <Text style={{ color: theme.text }}>
                  Th√°ng {formData.month}
                </Text>
              </TouchableOpacity>
              {/* Year numeric input remains */}
              <TextInput
                style={[
                  styles.formInput,
                  { color: theme.text, borderColor: theme.border },
                ]}
                value={formData.year.toString()}
                onChangeText={(text) =>
                  setFormData({
                    ...formData,
                    year: parseInt(text) || new Date().getFullYear(),
                  })
                }
                keyboardType="numeric"
              />
            </View>
            {renderAttendanceInfo()}

            {/* Export current period's slip if exists */}
            {currentSlip ? (
              <TouchableOpacity
                style={[
                  styles.createButton,
                  { backgroundColor: theme.primary, marginTop: 8 },
                ]}
                onPress={() => handleExportToExcel()}
                disabled={exporting}
              >
                {exporting ? (
                  <ActivityIndicator color="#fff" />
                ) : (
                  <Text style={styles.createButtonText}>
                    Xu·∫•t Excel k·ª≥ {formData.month}/{formData.year}
                  </Text>
                )}
              </TouchableOpacity>
            ) : (
              <Text style={{ color: theme.textSecondary, marginTop: 8 }}>
                Ch∆∞a c√≥ phi·∫øu l∆∞∆°ng c·ªßa k·ª≥ n√†y.
              </Text>
            )}
          </View>
        )}

        {/* Manual Inputs */}
        {selectedEmployee && (
          <>
            <FeeSection
              type="allowance"
              title="3. Ph·ª• c·∫•p (Nh·∫≠p tay)"
              data={formData.allowances}
              onAdd={() => addFee('allowance')}
              onRemove={(id) => removeFee('allowance', id)}
              theme={theme}
            />
            <FeeSection
              type="bonus"
              title="4. Th∆∞·ªüng (Nh·∫≠p tay)"
              data={formData.bonuses}
              onAdd={() => addFee('bonus')}
              onRemove={(id) => removeFee('bonus', id)}
              theme={theme}
            />

            {/* Approved Advance Payments (read-only) */}
            <View style={[styles.section, { backgroundColor: theme.card }]}>
              <View style={styles.sectionHeader}>
                <Text style={[styles.sectionTitle, { color: theme.text }]}>
                  5. ·ª®ng l∆∞∆°ng ƒë√£ duy·ªát (t·ª± tr·ª´)
                </Text>
              </View>
              {advancePayments && advancePayments.length > 0 ? (
                <>
                  {advancePayments.map((item) => (
                    <View key={item.id} style={styles.feeItem}>
                      <Text style={{ color: theme.text }}>
                        {formatDateVN(item.requestDate)} -{' '}
                        {item.reason || 'Kh√¥ng c√≥ l√Ω do'}
                      </Text>
                      <Text style={{ color: theme.text }}>
                        {formatCurrency(item.amount || 0)}
                      </Text>
                    </View>
                  ))}
                  <View style={[styles.feeItem, { borderBottomWidth: 0 }]}>
                    <Text style={{ color: theme.text, fontWeight: '600' }}>
                      T·ªïng ·ª©ng l∆∞∆°ng
                    </Text>
                    <Text style={{ color: theme.text, fontWeight: '600' }}>
                      {formatCurrency(
                        advancePayments.reduce((s, x) => s + (x.amount || 0), 0)
                      )}
                    </Text>
                  </View>
                </>
              ) : (
                <View>
                  <Text style={{ color: theme.textSecondary }}>
                    Kh√¥ng c√≥ y√™u c·∫ßu ·ª©ng l∆∞∆°ng ƒë√£ duy·ªát.
                  </Text>
                  <Text
                    style={{
                      color: theme.textMuted,
                      fontSize: 12,
                      marginTop: 4,
                    }}
                  >
                    Debug: {JSON.stringify(advancePayments)}
                  </Text>
                </View>
              )}
            </View>

            {/* Auto Deductions (read-only) */}
            <View style={[styles.section, { backgroundColor: theme.card }]}>
              <View style={styles.sectionHeader}>
                <Text style={[styles.sectionTitle, { color: theme.text }]}>
                  6. Kh·∫•u tr·ª´ t·ª± ƒë·ªông (BHXH, BHYT, BHTN)
                </Text>
              </View>
              {autoDeductions && autoDeductions.length > 0 ? (
                autoDeductions.map((item, idx) => (
                  <View key={idx} style={styles.feeItem}>
                    <Text style={{ color: theme.text }}>{item.name}</Text>
                    <Text style={{ color: theme.text }}>
                      {formatCurrency(item.amount)}
                    </Text>
                  </View>
                ))
              ) : (
                <Text style={{ color: theme.textSecondary }}>
                  Kh√¥ng c√≥ kh·∫•u tr·ª´ t·ª± ƒë·ªông.
                </Text>
              )}
            </View>

            <FeeSection
              type="deduction"
              title="7. Kh·∫•u tr·ª´ kh√°c (VD: ph·∫°t, vi·∫øng tang...)"
              data={formData.deductions}
              onAdd={() => addFee('deduction')}
              onRemove={(id) => removeFee('deduction', id)}
              theme={theme}
            />
          </>
        )}

        {/* Notes */}
        {selectedEmployee && (
          <View style={[styles.section, { backgroundColor: theme.card }]}>
            <Text style={[styles.sectionTitle, { color: theme.text }]}>
              7. Ghi ch√∫
            </Text>
            <TextInput
              style={[
                styles.notesInput,
                { color: theme.text, borderColor: theme.border },
              ]}
              value={formData.notes}
              onChangeText={(text) => setFormData({ ...formData, notes: text })}
              multiline
            />
          </View>
        )}

        {/* Salary Preview */}
        {renderSalaryPreview()}

        {/* Submit Button */}
        <TouchableOpacity
          style={[styles.createButton, { backgroundColor: theme.primary }]}
          onPress={handleCreateSalarySlip}
          disabled={!selectedEmployee}
        >
          <Text style={styles.createButtonText}>T·∫°o Phi·∫øu L∆∞∆°ng</Text>
        </TouchableOpacity>
      </ScrollView>

      {/* Employee Modal */}
      <Modal
        visible={showEmployeeModal}
        transparent={true}
        onRequestClose={() => setShowEmployeeModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={[styles.modalContent, { backgroundColor: theme.card }]}>
            <Text style={[styles.modalTitle, { color: theme.text }]}>
              Ch·ªçn Nh√¢n Vi√™n
            </Text>
            <ScrollView>
              {employees.map((emp) => (
                <TouchableOpacity
                  key={emp.id}
                  style={styles.employeeItem}
                  onPress={() => handleEmployeeSelect(emp)}
                >
                  <Text style={{ color: theme.text }}>
                    {emp.displayName || emp.name || emp.email}
                  </Text>
                </TouchableOpacity>
              ))}
            </ScrollView>
            <TouchableOpacity
              style={styles.closeButton}
              onPress={() => setShowEmployeeModal(false)}
            >
              <Text style={{ color: theme.text }}>ƒê√≥ng</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Month Picker Modal */}
      <Modal
        visible={monthPickerVisible}
        transparent={true}
        onRequestClose={() => setMonthPickerVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View
            style={[
              styles.modalContent,
              { backgroundColor: theme.card, width: '90%', maxHeight: '70%' },
            ]}
          >
            <Text style={[styles.modalTitle, { color: theme.text }]}>
              Ch·ªçn Th√°ng
            </Text>
            <ScrollView>
              {Array.from({ length: 12 }, (_, i) => i + 1).map((m) => (
                <TouchableOpacity
                  key={m}
                  style={[
                    styles.employeeItem,
                    {
                      backgroundColor:
                        m === formData.month
                          ? theme.primary + '20'
                          : 'transparent',
                    },
                  ]}
                  onPress={() => {
                    setFormData((prev) => ({ ...prev, month: m }));
                    setMonthPickerVisible(false);
                  }}
                >
                  <Text style={{ color: theme.text }}>Th√°ng {m}</Text>
                </TouchableOpacity>
              ))}
            </ScrollView>
            <TouchableOpacity
              style={styles.modalButton}
              onPress={() => setMonthPickerVisible(false)}
            >
              <Text style={{ color: theme.text }}>ƒê√≥ng</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Fee Modal */}
      <Modal
        visible={showFeeModal}
        transparent={true}
        onRequestClose={() => setShowFeeModal(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={[styles.modalContent, { backgroundColor: theme.card }]}>
            <Text style={[styles.modalTitle, { color: theme.text }]}>
              Th√™m {feeTypeLabel(feeModalType)}
            </Text>
            <TextInput
              style={[
                styles.modalInput,
                { color: theme.text, borderColor: theme.border, marginTop: 12 },
              ]}
              placeholder="T√™n"
              placeholderTextColor={theme.textMuted}
              selectionColor={theme.primary}
              value={newFee.name}
              onChangeText={(text) => setNewFee({ ...newFee, name: text })}
              returnKeyType="next"
              underlineColorAndroid="transparent"
            />
            <TextInput
              style={[
                styles.modalInput,
                { color: theme.text, borderColor: theme.border },
              ]}
              placeholder="S·ªë ti·ªÅn"
              placeholderTextColor={theme.textMuted}
              selectionColor={theme.primary}
              value={newFee.amount}
              onChangeText={(text) => setNewFee({ ...newFee, amount: text })}
              keyboardType={
                Platform.OS === 'ios'
                  ? 'numbers-and-punctuation'
                  : 'decimal-pad'
              }
              returnKeyType="done"
            />
            <View style={styles.formRow}>
              <TouchableOpacity
                style={styles.modalButton}
                onPress={() => setShowFeeModal(false)}
              >
                <Text style={{ color: theme.text }}>H·ªßy</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.modalButton, { backgroundColor: theme.primary }]}
                onPress={handleSaveFee}
              >
                <Text style={{ color: '#fff' }}>L∆∞u</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>

      {/* OT Breakdown Modal */}
      <Modal
        visible={otModalVisible}
        transparent={true}
        onRequestClose={() => setOtModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View
            style={[
              styles.modalContent,
              { backgroundColor: theme.card, width: '92%', maxHeight: '80%' },
            ]}
          >
            <Text style={[styles.modalTitle, { color: theme.text }]}>
              Danh s√°ch ng√†y OT
            </Text>
            <ScrollView>
              {attendanceInfo?.overtimeDetails &&
              attendanceInfo.overtimeDetails.length > 0 ? (
                attendanceInfo.overtimeDetails.map((d, idx) => (
                  <View key={idx} style={styles.feeItem}>
                    <View style={{ flex: 1 }}>
                      <Text style={{ color: theme.text, fontWeight: '600' }}>
                        {d.date} ‚Ä¢ {d.type.toUpperCase()}
                      </Text>
                      <Text
                        style={{ color: theme.textSecondary, fontSize: 12 }}
                      >
                        Gi·ªù: {d.hours}h ‚Ä¢ V√†o: {d.clockIn || '-'} ‚Ä¢ Ra:{' '}
                        {d.clockOut || '-'} ‚Ä¢ C√¥ng: {d.workedHours || 0}h
                      </Text>
                      {d.reason ? (
                        <Text
                          style={{ color: theme.textSecondary, fontSize: 12 }}
                        >
                          L√Ω do: {d.reason}
                        </Text>
                      ) : null}
                    </View>
                    <Text style={{ color: theme.text, fontWeight: '600' }}>
                      {d.hours}
                    </Text>
                  </View>
                ))
              ) : (
                <Text style={{ color: theme.text }}>
                  Kh√¥ng c√≥ ng√†y OT trong k·ª≥.
                </Text>
              )}
            </ScrollView>
            <TouchableOpacity
              style={styles.modalButton}
              onPress={() => setOtModalVisible(false)}
            >
              <Text style={{ color: theme.text }}>ƒê√≥ng</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Result Modal: hi·ªÉn th·ªã sau khi t·∫°o phi·∫øu l∆∞∆°ng th√†nh c√¥ng */}
      <Modal
        visible={resultModalVisible}
        transparent={true}
        onRequestClose={() => setResultModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View
            style={[
              styles.modalContent,
              { backgroundColor: theme.card, width: '92%' },
            ]}
          >
            <Text style={[styles.modalTitle, { color: theme.text }]}>
              T·∫°o Phi·∫øu L∆∞∆°ng Th√†nh C√¥ng
            </Text>
            {lastCreatedSlip?.employeeName ? (
              <Text
                style={{
                  color: theme.text,
                  textAlign: 'center',
                  marginBottom: 12,
                }}
              >
                Phi·∫øu c·ªßa {lastCreatedSlip.employeeName}
              </Text>
            ) : null}

            {/* N√∫t xu·∫•t Excel */}
            <TouchableOpacity
              style={[
                styles.modalButton,
                { backgroundColor: theme.primary, marginBottom: 12 },
              ]}
              onPress={() => handleExportToExcel(lastCreatedSlip?.id)}
              disabled={exporting}
            >
              {exporting ? (
                <ActivityIndicator color="#fff" />
              ) : (
                <Text style={{ color: '#fff' }}>
                  Xu·∫•t Excel & L·∫•y Link Drive
                </Text>
              )}
            </TouchableOpacity>

            {/* Hi·ªÉn th·ªã link Drive sau khi export th√†nh c√¥ng */}
            {exportLink ? (
              <View style={{ marginBottom: 12 }}>
                <Text style={{ color: theme.textSecondary, marginBottom: 6 }}>
                  Link Google Drive:
                </Text>
                <Text
                  style={{ color: theme.text, marginBottom: 10 }}
                  numberOfLines={2}
                >
                  {exportLink}
                </Text>
                <View style={styles.formRow}>
                  <TouchableOpacity
                    style={[
                      styles.modalButton,
                      { backgroundColor: theme.primary },
                    ]}
                    onPress={async () => {
                      await Clipboard.setStringAsync(exportLink);
                    }}
                  >
                    <Text style={{ color: '#fff' }}>Copy link Drive</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={[
                      styles.modalButton,
                      { backgroundColor: theme.primary },
                    ]}
                    onPress={() => Linking.openURL(exportLink)}
                  >
                    <Text style={{ color: '#fff' }}>M·ªü link</Text>
                  </TouchableOpacity>
                </View>
              </View>
            ) : null}

            {/* N√∫t sao ch√©p link ·ª©ng d·ª•ng */}
            <TouchableOpacity
              style={[
                styles.modalButton,
                { backgroundColor: theme.primary, marginBottom: 12 },
              ]}
              onPress={handleCopyAppLink}
            >
              <Text style={{ color: '#fff' }}>Sao ch√©p Link trong App</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={styles.modalButton}
              onPress={() => setResultModalVisible(false)}
            >
              <Text style={{ color: theme.text }}>ƒê√≥ng</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
    </View>
  );
};

// --- Reusable Components ---
const InfoBox = ({ label, value }) => {
  const { theme } = useTheme();
  return (
    <View style={styles.autoInfoItem}>
      <Text style={[styles.autoInfoLabel, { color: theme.textSecondary }]}>
        {label}
      </Text>
      <Text style={[styles.autoInfoValue, { color: theme.text }]}>{value}</Text>
    </View>
  );
};

const FeeSection = ({ type, title, data, onAdd, onRemove, theme }) => (
  <View style={[styles.section, { backgroundColor: theme.card }]}>
    <View style={styles.sectionHeader}>
      <Text style={[styles.sectionTitle, { color: theme.text }]}>{title}</Text>
      <TouchableOpacity onPress={onAdd}>
        <Ionicons name="add-circle" size={28} color={theme.primary} />
      </TouchableOpacity>
    </View>
    {data.map((item) => (
      <View key={item.id} style={styles.feeItem}>
        <Text style={{ color: theme.text }}>{item.name}</Text>
        <Text style={{ color: theme.text }}>{formatCurrency(item.amount)}</Text>
        <TouchableOpacity onPress={() => onRemove(item.id)}>
          <Ionicons name="remove-circle" size={24} color={theme.error} />
        </TouchableOpacity>
      </View>
    ))}
  </View>
);

const SummaryRow = ({ label, value, isAddition = false, isTotal = false }) => {
  const { theme } = useTheme();
  return (
    <View style={[styles.summaryRow, isTotal && styles.summaryDivider]}>
      <Text
        style={[
          styles.summaryLabel,
          { color: theme.text, fontWeight: isTotal ? 'bold' : 'normal' },
        ]}
      >
        {label}
      </Text>
      <Text
        style={[
          styles.summaryValue,
          {
            color: isAddition ? theme.success : theme.text,
            fontWeight: isTotal ? 'bold' : 'normal',
          },
        ]}
      >
        {value}
      </Text>
    </View>
  );
};

// --- Styles ---
const styles = StyleSheet.create({
  container: { flex: 1 },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingTop: 50,
    paddingBottom: 16,
    paddingHorizontal: 16,
  },
  headerTitle: { color: '#fff', fontSize: 18, fontWeight: 'bold' },
  content: { padding: 16 },
  section: { padding: 16, borderRadius: 12, marginBottom: 16 },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  sectionTitle: { fontSize: 16, fontWeight: 'bold' },
  selector: {
    borderWidth: 1,
    borderRadius: 8,
    padding: 12,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  formRow: { flexDirection: 'row', gap: 12 },
  // Dedicated style for modal inputs to avoid clipping
  modalInput: {
    height: 52,
    paddingVertical: 14,
    paddingHorizontal: 12,
    borderWidth: 1,
    borderRadius: 8,
    textAlignVertical: 'center',
    marginBottom: 12,
    fontSize: 16,
    lineHeight: 24,
  },
  formInput: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
  },
  autoInfoContainer: {
    marginTop: 16,
    padding: 12,
    backgroundColor: 'rgba(76, 175, 80, 0.1)',
    borderRadius: 8,
  },
  autoInfoGrid: { flexDirection: 'row', justifyContent: 'space-around' },
  autoInfoItem: { flex: 1, alignItems: 'center', paddingHorizontal: 4 },
  autoInfoLabel: { fontSize: 12, marginBottom: 4, textAlign: 'center' },
  autoInfoValue: { fontSize: 14, fontWeight: '600', textAlign: 'center' },
  attendanceInfoContainer: {
    marginTop: 16,
    padding: 12,
    backgroundColor: 'rgba(33, 150, 243, 0.1)',
    borderRadius: 8,
  },
  attendanceInfoTitle: { fontSize: 14, fontWeight: '600', marginBottom: 12 },
  attendanceInfoGrid: { flexDirection: 'row', justifyContent: 'space-around' },
  feeItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  notesInput: {
    borderWidth: 1,
    borderRadius: 8,
    padding: 12,
    minHeight: 80,
    textAlignVertical: 'top',
  },
  previewNote: { fontSize: 12, fontStyle: 'italic', marginTop: 8 },
  summaryRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingVertical: 6,
  },
  summaryLabel: { fontSize: 14 },
  summaryValue: { fontSize: 14, fontWeight: '500' },
  summaryDivider: { borderTopWidth: 1, paddingTop: 8, marginTop: 8 },
  createButton: {
    paddingVertical: 16,
    borderRadius: 12,
    alignItems: 'center',
    marginTop: 16,
  },
  createButtonText: { color: '#fff', fontSize: 16, fontWeight: 'bold' },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.6)',
    justifyContent: 'center',
    padding: 24,
  },
  modalContent: { padding: 16, borderRadius: 12 },
  modalTitle: { fontSize: 18, fontWeight: 'bold', marginBottom: 16 },
  employeeItem: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  closeButton: { marginTop: 16, padding: 12, alignItems: 'center' },
  modalButton: { flex: 1, padding: 12, borderRadius: 8, alignItems: 'center' },
});

export default SalarySlipCreationScreen;


--- END: src\screens\SalarySlipCreationScreen.js ---


--- START: src\screens\StageDetailScreen.js ---
import React, { useState, useLayoutEffect, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  ScrollView,
  Alert,
  ActivityIndicator,
  Image,
  Platform,
  Modal,
  Linking,
  FlatList,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import * as ImagePicker from 'expo-image-picker';
import * as DocumentPicker from 'expo-document-picker';
import { Audio } from 'expo-av';
import { httpsCallable } from 'firebase/functions';
import { functions } from '../config/firebaseConfig';
import { GoogleSignin } from '@react-native-google-signin/google-signin';
import { updateStageDetails, getProjectById } from '../api/projectService';
import uuid from 'react-native-uuid';
import * as FileSystem from 'expo-file-system';
import {
  getTaskDisplayLabel,
  getStatusColor,
  getStatusDisplayLabel,
} from '../utils/taskHelpers';
import {
  requestAudioPermission,
  checkAudioPermission,
  setupAudioMode,
} from '../utils/audioPermissionHelper';
import { checkAllPermissions } from '../utils/permissionChecker';
import { useTheme } from '../contexts/ThemeContext';
import { listFiles, createFolder } from '../api/googleDriveService';

const STATUS_OPTIONS = [
  { value: 'pending', label: 'Ch·ªù x·ª≠ l√Ω', color: '#9E9E9E' },
  { value: 'in_progress', label: 'ƒêang l√†m', color: '#FFD54F' },
  { value: 'completed', label: 'Ho√†n th√†nh', color: '#4CAF50' },
  { value: 'failed', label: 'Kh√¥ng ƒë·∫°t', color: '#F44336' },
];

const StageDetailScreen = ({ route, navigation }) => {
  const { theme } = useTheme(); // üÜï Add theme context

  console.log('üéØ StageDetailScreen mounted with params:', {
    projectId: route.params?.projectId,
    stage: route.params?.stage,
  });

  const { projectId, stage } = route.params; // stage object passed in

  // Add error boundary for stage data
  if (!stage) {
    console.error('‚ùå No stage data provided to StageDetailScreen');
    Alert.alert('L·ªói', 'Kh√¥ng c√≥ d·ªØ li·ªáu c√¥ng ƒëo·∫°n');
    navigation.goBack();
    return null;
  }

  const [status, setStatus] = useState(stage.status);
  const [notes, setNotes] = useState(stage.notes || '');
  const [project, setProject] = useState(null);
  const [loading, setLoading] = useState(false);

  const computePreview = (f) => {
    if (f.preview) return f.preview;
    if (f.mimeType && f.mimeType.startsWith('image/')) {
      return `https://drive.google.com/uc?export=download&id=${f.id}`;
    }
    return undefined;
  };

  const initialFiles = (stage.files || []).map((f) => ({
    ...f,
    preview: computePreview(f),
  }));

  const [files, setFiles] = useState(initialFiles);
  const [imagePreviewUri, setImagePreviewUri] = useState(null);
  const [saving, setSaving] = useState(false);

  // Media Instructions States
  const [instructionImages, setInstructionImages] = useState(
    stage.instructionImages || []
  );
  const [instructionNotes, setInstructionNotes] = useState(
    stage.instructionNotes || ''
  );
  const [instructionAudio, setInstructionAudio] = useState(
    stage.instructionAudio || null
  );
  const [instructionFiles, setInstructionFiles] = useState(
    stage.instructionFiles || []
  );
  const [recording, setRecording] = useState(null);
  const [isRecording, setIsRecording] = useState(false);
  const [sound, setSound] = useState(null);
  const [isPlaying, setIsPlaying] = useState(false);

  useLayoutEffect(() => {
    navigation.setOptions({ headerTitle: stage.processName });
  }, [navigation]);

  useEffect(() => {
    const fetchProject = async () => {
      try {
        setLoading(true);
        console.log('üîÑ Fetching project data for:', projectId);
        const projectData = await getProjectById(projectId);
        console.log('‚úÖ Project data loaded:', {
          id: projectData?.id,
          name: projectData?.name,
          workflowStagesCount: projectData?.workflowStages?.length,
        });
        setProject(projectData);
      } catch (error) {
        console.error('‚ùå Error fetching project details:', error);
        Alert.alert('L·ªói', `Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu d·ª± √°n: ${error.message}`);
      } finally {
        setLoading(false);
      }
    };

    if (projectId) {
      fetchProject();
    } else {
      console.error('‚ùå No projectId provided');
      Alert.alert('L·ªói', 'Kh√¥ng c√≥ ID d·ª± √°n');
      navigation.goBack();
    }
  }, [projectId]);

  // Ki·ªÉm tra quy·ªÅn ghi √¢m khi component mount
  useEffect(() => {
    const checkPermission = async () => {
      try {
        const hasPermission = await checkAudioPermission();
        if (!hasPermission) {
          console.log('Audio permission not granted');
        }
      } catch (error) {
        console.error('Error checking audio permission:', error);
      }
    };

    checkPermission();
  }, []);

  const pickFile = async () => {
    const { status: perm } =
      await ImagePicker.requestMediaLibraryPermissionsAsync();
    if (perm !== 'granted') {
      Alert.alert('L·ªói', 'C·∫ßn quy·ªÅn truy c·∫≠p th∆∞ vi·ªán ·∫£nh.');
      return;
    }
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.All,
      quality: 0.7,
    });
    if (!result.canceled) {
      uploadPickedFile(result.assets[0]);
    }
  };

  const takePhoto = async () => {
    const { status: perm } = await ImagePicker.requestCameraPermissionsAsync();
    if (perm !== 'granted') {
      Alert.alert('L·ªói', 'C·∫ßn quy·ªÅn truy c·∫≠p camera.');
      return;
    }
    const result = await ImagePicker.launchCameraAsync({ quality: 0.7 });
    if (!result.canceled) {
      uploadPickedFile(result.assets[0]);
    }
  };

  const pickDocument = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: [
          'application/pdf',
          'application/msword',
          'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
          'application/vnd.ms-excel',
          'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
          'text/plain',
          'image/*',
        ],
        copyToCacheDirectory: true,
      });

      if (!result.canceled) {
        uploadPickedFile(result.assets[0]);
      }
    } catch (err) {
      console.error('Error picking document:', err);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ch·ªçn t√†i li·ªáu.');
    }
  };

  const pickInstructionDocument = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: [
          'application/pdf',
          'application/msword',
          'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
          'application/vnd.ms-excel',
          'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
          'text/plain',
          'image/*',
        ],
        copyToCacheDirectory: true,
      });

      if (!result.canceled) {
        uploadInstructionFile(result.assets[0]);
      }
    } catch (err) {
      console.error('Error picking instruction document:', err);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ch·ªçn t√†i li·ªáu h∆∞·ªõng d·∫´n.');
    }
  };

  const uploadInstructionFile = async (asset) => {
    try {
      setSaving(true);

      if (!asset || !asset.uri) {
        Alert.alert('L·ªói', 'T·∫≠p tin kh√¥ng h·ª£p l·ªá.');
        return;
      }

      const ext = (asset.fileName || asset.uri).split('.').pop();
      const filename = `${uuid.v4()}.${ext}`;

      console.log('Starting upload for instruction file:', asset.uri);

      try {
        // Get file info using FileSystem from expo
        const fileInfo = await FileSystem.getInfoAsync(asset.uri);
        console.log('File info:', fileInfo);

        if (!fileInfo.exists || fileInfo.size === 0) {
          throw new Error('File r·ªóng ho·∫∑c kh√¥ng t·ªìn t·∫°i');
        }

        console.log('File size:', fileInfo.size, 'bytes');

        // ƒê·ªçc file base64 b·∫±ng expo-file-system
        const base64Data = await FileSystem.readAsStringAsync(asset.uri, {
          encoding: FileSystem.EncodingType.Base64,
        });

        // L·∫•y accessToken Google c·ªßa ng∆∞·ªùi d√πng
        const accessToken = await getGoogleAccessToken();
        if (!accessToken) {
          return; // User cancelled or error occurred
        }

        // G·ªçi Cloud Function uploadFileToDriveUser
        const uploadFn = httpsCallable(functions, 'uploadInstructionFile');
        const result = await uploadFn({
          accessToken,
          projectId,
          fileName: filename,
          mimeType: asset.mimeType || asset.type || 'application/octet-stream',
          base64Data,
        });

        const {
          fileId,
          webViewLink,
          thumbnailLink,
          mimeType: returnedMime,
        } = result.data;

        const preview = webViewLink;

        setInstructionFiles((prev) => [
          ...prev,
          { name: filename, id: fileId, url: webViewLink, preview },
        ]);
      } catch (uploadError) {
        console.error('Upload error:', uploadError);
        throw new Error(`L·ªói khi t·∫£i l√™n: ${uploadError.message}`);
      }
    } catch (err) {
      console.error('Error uploading instruction file:', err);
      Alert.alert('L·ªói', `Kh√¥ng th·ªÉ t·∫£i l√™n t√†i li·ªáu: ${err.message}`);
    } finally {
      setSaving(false);
    }
  };

  const removeInstructionFile = (index) => {
    setInstructionFiles((prev) => prev.filter((_, i) => i !== index));
  };

  const viewInstructionFile = (file) => {
    if (file.url) {
      Linking.openURL(file.url);
    } else {
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ m·ªü t√†i li·ªáu n√†y.');
    }
  };

  const uploadPickedFile = async (asset) => {
    try {
      setSaving(true);

      if (!asset || !asset.uri) {
        Alert.alert('L·ªói', 'T·∫≠p tin kh√¥ng h·ª£p l·ªá.');
        return;
      }

      const ext = (asset.fileName || asset.uri).split('.').pop();
      const filename = `${uuid.v4()}.${ext}`;

      console.log('Starting upload for:', asset.uri);

      try {
        // Get file info using FileSystem from expo
        const fileInfo = await FileSystem.getInfoAsync(asset.uri);
        console.log('File info:', fileInfo);

        if (!fileInfo.exists || fileInfo.size === 0) {
          throw new Error('File r·ªóng ho·∫∑c kh√¥ng t·ªìn t·∫°i');
        }

        console.log('File size:', fileInfo.size, 'bytes');

        // ƒê·ªçc file base64 b·∫±ng expo-file-system
        const base64Data = await FileSystem.readAsStringAsync(asset.uri, {
          encoding: FileSystem.EncodingType.Base64,
        });

        // L·∫•y accessToken Google c·ªßa ng∆∞·ªùi d√πng
        const accessToken = await getGoogleAccessToken();
        if (!accessToken) {
          return; // User cancelled or error occurred
        }

        // G·ªçi Cloud Function uploadFileToDriveUser
        const uploadFn = httpsCallable(functions, 'uploadFileToDriveUser');
        const result = await uploadFn({
          accessToken,
          projectId,
          fileName: filename,
          mimeType: asset.mimeType || asset.type || 'image/jpeg',
          base64Data,
        });

        const {
          fileId,
          webViewLink,
          thumbnailLink,
          mimeType: returnedMime,
        } = result.data;
        const preview =
          returnedMime && returnedMime.startsWith('image/')
            ? thumbnailLink ||
              `https://drive.google.com/uc?export=download&id=${fileId}`
            : webViewLink;
        setFiles((prev) => [
          ...prev,
          { name: filename, id: fileId, url: webViewLink, preview },
        ]);
      } catch (uploadError) {
        console.error('Upload error:', uploadError);
        throw new Error(`L·ªói khi t·∫£i l√™n: ${uploadError.message}`);
      }
    } catch (err) {
      console.error('Error uploading file:', err);
      Alert.alert(
        'L·ªói',
        `Kh√¥ng th·ªÉ t·∫£i t·ªáp: ${err.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh'}`
      );
    } finally {
      setSaving(false);
    }
  };

  const removeFile = (file) => {
    Alert.alert('X√°c nh·∫≠n', 'X√≥a t·ªáp ƒë√≠nh k√®m n√†y?', [
      { text: 'H·ªßy', style: 'cancel' },
      {
        text: 'X√≥a',
        style: 'destructive',
        onPress: async () => {
          try {
            // C·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n ƒë·ªÉ kh·ªõp v·ªõi khi t·∫£i l√™n
            const delFn = httpsCallable(functions, 'deleteFileFromDrive');
            await delFn({ fileId: file.id });
          } catch (e) {
            console.log('Cannot delete from storage, maybe already removed');
          }
          setFiles((prev) => prev.filter((f) => f.name !== file.name));
        },
      },
    ]);
  };

  const viewFile = (file) => {
    if (file.preview && file.preview.startsWith('http')) {
      setImagePreviewUri(file.preview);
    } else if (file.url) {
      Linking.openURL(file.url).catch(() =>
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ m·ªü t·ªáp.')
      );
    }
  };

  // Get Google access token using GoogleSignin - same approach as other screens
  const getGoogleAccessToken = async () => {
    try {
      const isSignedIn = await GoogleSignin.isSignedIn();
      if (!isSignedIn) {
        Alert.alert(
          'Ch∆∞a ƒëƒÉng nh·∫≠p Google',
          'Vui l√≤ng ƒëƒÉng nh·∫≠p v·ªõi Google ƒë·ªÉ upload ·∫£nh.',
          [
            { text: 'ƒê√≥ng', style: 'cancel' },
            {
              text: 'ƒêƒÉng nh·∫≠p',
              onPress: async () => {
                try {
                  await GoogleSignin.hasPlayServices();
                  await GoogleSignin.signIn();
                  Alert.alert(
                    'Th√†nh c√¥ng',
                    'ƒê√£ ƒëƒÉng nh·∫≠p Google. Vui l√≤ng th·ª≠ l·∫°i.'
                  );
                } catch (error) {
                  console.error('Google Sign In Error:', error);
                  Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ƒëƒÉng nh·∫≠p v·ªõi Google.');
                }
              },
            },
          ]
        );
        return null;
      }

      // User is signed in, get token
      const tokens = await GoogleSignin.getTokens();
      if (!tokens || !tokens.accessToken) {
        throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c token Google');
      }

      console.log('ƒê√£ l·∫•y Google access token th√†nh c√¥ng');
      return tokens.accessToken;
    } catch (error) {
      console.error('Google token error:', error);
      Alert.alert(
        'L·ªói x√°c th·ª±c',
        'Kh√¥ng l·∫•y ƒë∆∞·ª£c token Google: ' + error.message
      );
      return null;
    }
  };

  // Upload media to Google Drive
  const uploadMediaToDrive = async (mediaItem, folder) => {
    try {
      console.log('Uploading media to Google Drive:', mediaItem.name);

      // Get file info
      const fileInfo = await FileSystem.getInfoAsync(mediaItem.uri);
      if (!fileInfo.exists || fileInfo.size === 0) {
        throw new Error('File r·ªóng ho·∫∑c kh√¥ng t·ªìn t·∫°i');
      }

      // Read file as base64
      const base64Data = await FileSystem.readAsStringAsync(mediaItem.uri, {
        encoding: FileSystem.EncodingType.Base64,
      });

      // Get Google access token
      const accessToken = await getGoogleAccessToken();
      if (!accessToken) {
        return; // User cancelled or error occurred
      }

      // Call Cloud Function to upload to Google Drive
      const uploadFn = httpsCallable(functions, 'uploadInstructionMedia');
      const result = await uploadFn({
        accessToken,
        projectId,
        fileName: mediaItem.name,
        mimeType: mediaItem.type || 'application/octet-stream',
        base64Data,
      });

      const { fileId, publicUrl, webViewLink, thumbnailLink } = result.data;

      return {
        id: fileId,
        name: mediaItem.name,
        url: publicUrl,
        webViewLink,
        thumbnailLink,
        type: mediaItem.type,
      };
    } catch (error) {
      console.error('Error uploading media to Google Drive:', error);
      throw error;
    }
  };

  // Ensure project has Drive root; create if missing
  const ensureProjectDriveFolder = async () => {
    if (project?.driveFolderId) return project;
    const tokens = await GoogleSignin.getTokens();
    const accessToken = tokens?.accessToken;
    if (!accessToken) {
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ l·∫•y access token Google.');
      return null;
    }
    try {
      const createFn = httpsCallable(functions, 'createProjectFolders');
      const res = await createFn({ projectId });
      const updated = {
        ...(project || {}),
        driveFolderId: res?.data?.driveFolderId,
        driveFolderUrl: res?.data?.driveFolderUrl,
      };
      setProject(updated);
      return updated;
    } catch (e) {
      console.error('createProjectFolders error:', e);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c Drive cho d·ª± √°n.');
      return null;
    }
  };

  // Find or create QC_Reports folder inside project root and return its ID
  const getQcReportsFolderId = async (accessToken, projectDriveFolderId) => {
    try {
      const children = await listFiles(accessToken, projectDriveFolderId);
      const qcFolder = (children || []).find(
        (f) =>
          f.mimeType === 'application/vnd.google-apps.folder' &&
          (f.name === 'QC_Reports' || f.name.toLowerCase() === 'qc-reports')
      );
      if (qcFolder) return qcFolder.id;
      const created = await createFolder(
        accessToken,
        'QC_Reports',
        projectDriveFolderId
      );
      return created?.id;
    } catch (err) {
      console.error('Error ensuring QC_Reports folder:', err);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ truy c·∫≠p th∆∞ m·ª•c QC_Reports tr√™n Drive.');
      return null;
    }
  };

  // Open QC_Reports folder in Google Drive for the user to upload manually
  const openQcReportsFolder = async () => {
    try {
      // Ensure Google token
      const isSignedIn = await GoogleSignin.isSignedIn();
      if (!isSignedIn) {
        await GoogleSignin.hasPlayServices();
        await GoogleSignin.signIn();
      }
      const tokens = await GoogleSignin.getTokens();
      const accessToken = tokens?.accessToken;
      if (!accessToken) {
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ l·∫•y access token Google.');
        return;
      }

      // Ensure project Drive root
      const ensuredProject = await ensureProjectDriveFolder();
      if (!ensuredProject?.driveFolderId) return;

      // Ensure QC_Reports folder and open it
      const qcId = await getQcReportsFolderId(
        accessToken,
        ensuredProject.driveFolderId
      );
      if (!qcId) return;
      const folderUrl = `https://drive.google.com/drive/folders/${qcId}`;
      Linking.openURL(folderUrl).catch(() =>
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ m·ªü Google Drive.')
      );
    } catch (err) {
      console.error('openQcReportsFolder error:', err);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ m·ªü th∆∞ m·ª•c QC_Reports tr√™n Drive.');
    }
  };

  const handleSave = async () => {
    try {
      setSaving(true);

      // Ch·ªâ l∆∞u c√°c tr∆∞·ªùng c·∫ßn thi·∫øt ƒë·ªÉ Firestore g·ªçn nh·∫π
      const filesToSave = files.map(({ name, id, url, mimeType }) => {
        const obj = { name, id, url };
        if (mimeType) obj.mimeType = mimeType;
        return obj;
      });

      // Upload instruction images to Google Drive
      const uploadedImages = [];
      for (const image of instructionImages) {
        if (image.uri && !image.url) {
          const uploadedImage = await uploadMediaToDrive(
            image,
            'instruction_images'
          );
          uploadedImages.push(uploadedImage);
        } else {
          uploadedImages.push(image);
        }
      }

      // Upload instruction audio to Google Drive
      let uploadedAudio = null;
      if (instructionAudio && instructionAudio.uri && !instructionAudio.url) {
        uploadedAudio = await uploadMediaToDrive(
          instructionAudio,
          'instruction_audio'
        );
      } else if (instructionAudio) {
        uploadedAudio = instructionAudio;
      }

      await updateStageDetails(projectId, stage.stageId, {
        status,
        notes,
        files: filesToSave,
        instructionImages: uploadedImages,
        instructionNotes,
        instructionAudio: uploadedAudio,
      });

      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ l∆∞u thay ƒë·ªïi', [
        { text: 'OK', onPress: () => navigation.goBack() },
      ]);
    } catch (err) {
      console.error(err);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ l∆∞u.');
    } finally {
      setSaving(false);
    }
  };

  // Media Instructions Functions
  const pickInstructionImage = async () => {
    try {
      const { status } =
        await ImagePicker.requestMediaLibraryPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert('L·ªói', 'C·∫ßn quy·ªÅn truy c·∫≠p th∆∞ vi·ªán ·∫£nh');
        return;
      }

      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        aspect: [4, 3],
        quality: 0.8,
      });

      if (!result.canceled && result.assets[0]) {
        await uploadInstructionImage(result.assets[0]);
      }
    } catch (error) {
      console.error('Error picking instruction image:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ch·ªçn ·∫£nh');
    }
  };

  const takeInstructionPhoto = async () => {
    try {
      const { status } = await ImagePicker.requestCameraPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert('L·ªói', 'C·∫ßn quy·ªÅn truy c·∫≠p camera');
        return;
      }

      const result = await ImagePicker.launchCameraAsync({
        allowsEditing: true,
        aspect: [4, 3],
        quality: 0.8,
      });

      if (!result.canceled && result.assets[0]) {
        await uploadInstructionImage(result.assets[0]);
      }
    } catch (error) {
      console.error('Error taking instruction photo:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ch·ª•p ·∫£nh');
    }
  };

  // Upload instruction image to Google Drive
  const uploadInstructionImage = async (asset) => {
    try {
      setSaving(true);

      if (!asset || !asset.uri) {
        Alert.alert('L·ªói', 'T·∫≠p tin kh√¥ng h·ª£p l·ªá.');
        return;
      }

      const ext = (asset.fileName || asset.uri).split('.').pop();
      const filename = `instruction_${Date.now()}.${ext}`;

      console.log('Starting instruction image upload:', asset.uri);

      // Get file info
      const fileInfo = await FileSystem.getInfoAsync(asset.uri);
      console.log('File info:', fileInfo);

      if (!fileInfo.exists || fileInfo.size === 0) {
        throw new Error('File r·ªóng ho·∫∑c kh√¥ng t·ªìn t·∫°i');
      }

      // Read file as base64
      const base64Data = await FileSystem.readAsStringAsync(asset.uri, {
        encoding: FileSystem.EncodingType.Base64,
      });

      // Get Google access token
      const accessToken = await getGoogleAccessToken();
      if (!accessToken) {
        return; // User cancelled or error occurred
      }

      // Call Cloud Function to upload to Google Drive
      const uploadFn = httpsCallable(functions, 'uploadInstructionMedia');
      const result = await uploadFn({
        accessToken,
        projectId,
        fileName: filename,
        mimeType: asset.mimeType || asset.type || 'image/jpeg',
        base64Data,
      });

      const { fileId, publicUrl, webViewLink, thumbnailLink } = result.data;

      // Add to instruction images
      const newImage = {
        id: fileId,
        name: filename,
        url: publicUrl,
        webViewLink,
        thumbnailLink,
        type: 'image/jpeg',
      };

      setInstructionImages([...instructionImages, newImage]);
      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ t·∫£i ·∫£nh h∆∞·ªõng d·∫´n l√™n Google Drive');
    } catch (error) {
      console.error('Error uploading instruction image:', error);
      Alert.alert('L·ªói', `Kh√¥ng th·ªÉ t·∫£i ·∫£nh l√™n: ${error.message}`);
    } finally {
      setSaving(false);
    }
  };

  const removeInstructionImage = (index) => {
    const updatedImages = instructionImages.filter((_, i) => i !== index);
    setInstructionImages(updatedImages);
  };

  // Audio Functions
  const startRecording = async () => {
    try {
      // Xin quy·ªÅn ghi √¢m
      const hasPermission = await requestAudioPermission();
      if (!hasPermission) {
        return;
      }

      // C·∫•u h√¨nh audio mode cho ghi √¢m
      const audioModeSet = await setupAudioMode();
      if (!audioModeSet) {
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ c·∫•u h√¨nh audio mode');
        return;
      }

      const { recording } = await Audio.Recording.createAsync({
        android: {
          extension: '.mp3',
          outputFormat: Audio.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4,
          audioEncoder: Audio.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC,
          sampleRate: 44100,
          numberOfChannels: 2,
          bitRate: 128000,
        },
        ios: {
          extension: '.wav',
          outputFormat: Audio.RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM,
          audioQuality: Audio.RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH,
          sampleRate: 44100,
          numberOfChannels: 2,
          bitRate: 128000,
          linearPCMBitDepth: 16,
          linearPCMIsBigEndian: false,
          linearPCMIsFloat: false,
        },
      });
      setRecording(recording);
      setIsRecording(true);

      // Th√¥ng b√°o b·∫Øt ƒë·∫ßu ghi √¢m
      Alert.alert('Ghi √¢m', 'ƒê√£ b·∫Øt ƒë·∫ßu ghi √¢m. Nh·∫•n n√∫t d·ª´ng ƒë·ªÉ k·∫øt th√∫c.');
    } catch (error) {
      console.error('Error starting recording:', error);
      Alert.alert(
        'L·ªói',
        'Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu ghi √¢m. Vui l√≤ng ki·ªÉm tra quy·ªÅn microphone.'
      );
    }
  };

  const stopRecording = async () => {
    try {
      setIsRecording(false);
      await recording.stopAndUnloadAsync();
      const uri = recording.getURI();
      // X√°c ƒë·ªãnh extension v√† type d·ª±a tr√™n platform
      const isAndroid = Platform.OS === 'android';
      const extension = isAndroid ? '.mp3' : '.wav';
      const mimeType = isAndroid ? 'audio/mpeg' : 'audio/wav';

      setInstructionAudio({
        uri,
        name: `instruction_audio_${Date.now()}${extension}`,
        type: mimeType,
      });
      setRecording(null);

      // Th√¥ng b√°o ghi √¢m th√†nh c√¥ng
      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ ghi √¢m xong. B·∫°n c√≥ th·ªÉ ph√°t ƒë·ªÉ nghe l·∫°i.');
    } catch (error) {
      console.error('Error stopping recording:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ d·ª´ng ghi √¢m. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  };

  const playAudio = async () => {
    try {
      if (!instructionAudio) {
        Alert.alert('L·ªói', 'Kh√¥ng c√≥ file audio ƒë·ªÉ ph√°t');
        return;
      }

      // Ki·ªÉm tra URI
      let audioUri = instructionAudio.uri;

      // N·∫øu kh√¥ng c√≥ URI local, s·ª≠ d·ª•ng URL t·ª´ Google Drive
      if (!audioUri && instructionAudio.url) {
        audioUri = instructionAudio.url;
      }

      // N·∫øu c√≥ ID file t·ª´ Google Drive, t·∫°o direct download URL
      if (!audioUri && instructionAudio.id) {
        audioUri = `https://drive.google.com/uc?export=download&id=${instructionAudio.id}`;
      }

      if (!audioUri) {
        Alert.alert('L·ªói', 'Kh√¥ng t√¨m th·∫•y ƒë∆∞·ªùng d·∫´n file audio');
        return;
      }

      console.log('Playing audio from:', audioUri);
      console.log('Audio object:', instructionAudio);

      // Setup audio mode tr∆∞·ªõc khi ph√°t
      await Audio.setAudioModeAsync({
        allowsRecordingIOS: false,
        staysActiveInBackground: false,
        playsInSilentModeIOS: true,
        shouldDuckAndroid: true,
        playThroughEarpieceAndroid: false,
      });

      // N·∫øu ƒëang ph√°t th√¨ d·ª´ng tr∆∞·ªõc
      if (sound) {
        await sound.unloadAsync();
        setSound(null);
        setIsPlaying(false);
      }

      // Ki·ªÉm tra file c√≥ t·ªìn t·∫°i kh√¥ng (ch·ªâ cho local file)
      if (audioUri.startsWith('file://')) {
        const fileInfo = await FileSystem.getInfoAsync(audioUri);
        console.log('Local file info:', fileInfo);
        if (!fileInfo.exists) {
          Alert.alert('L·ªói', 'File audio kh√¥ng t·ªìn t·∫°i tr√™n thi·∫øt b·ªã');
          return;
        }
        if (fileInfo.size === 0) {
          Alert.alert('L·ªói', 'File audio r·ªóng');
          return;
        }
      }

      const { sound: newSound } = await Audio.Sound.createAsync(
        { uri: audioUri },
        { shouldPlay: true }
      );

      setSound(newSound);
      setIsPlaying(true);

      newSound.setOnPlaybackStatusUpdate((status) => {
        console.log('Playback status:', status);
        if (status.didJustFinish) {
          setIsPlaying(false);
          newSound.unloadAsync();
          setSound(null);
        }
        if (status.error) {
          console.error('Playback error:', status.error);
          setIsPlaying(false);
          newSound.unloadAsync();
          setSound(null);
          Alert.alert('L·ªói ph√°t audio', status.error);
        }
      });

      console.log('Audio playback started successfully');
    } catch (error) {
      console.error('Error playing audio:', error);
      setIsPlaying(false);
      if (sound) {
        sound.unloadAsync();
        setSound(null);
      }

      let errorMessage = 'Kh√¥ng th·ªÉ ph√°t audio';
      if (error.message.includes('Unable to load')) {
        errorMessage =
          'File audio kh√¥ng th·ªÉ t·∫£i. C√≥ th·ªÉ file b·ªã l·ªói ho·∫∑c kh√¥ng t·ªìn t·∫°i.';
      } else if (error.message.includes('Network')) {
        errorMessage = 'L·ªói m·∫°ng. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi internet.';
      }

      Alert.alert('L·ªói ph√°t audio', errorMessage);
    }
  };

  const stopAudio = async () => {
    try {
      if (sound) {
        await sound.stopAsync();
        await sound.unloadAsync();
        setSound(null);
        setIsPlaying(false);
      }
    } catch (error) {
      console.error('Error stopping audio:', error);
    }
  };

  const deleteAudio = () => {
    Alert.alert('X√°c nh·∫≠n', 'B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a file ghi √¢m n√†y?', [
      { text: 'H·ªßy', style: 'cancel' },
      {
        text: 'X√≥a',
        style: 'destructive',
        onPress: () => {
          setInstructionAudio(null);
          if (sound) {
            sound.unloadAsync();
            setSound(null);
            setIsPlaying(false);
          }
        },
      },
    ]);
  };

  // Function to navigate to task details
  const navigateToTaskDetail = (taskKey) => {
    navigation.navigate('TaskDetail', { projectId, taskKey });
  };

  // Function to render task items
  const renderTaskItem = ({ item }) => {
    const { key, task } = item;
    const taskLabel = getTaskDisplayLabel(key, task);
    const statusLabel = getStatusDisplayLabel(task.status);
    const statusColor = getStatusColor(task.status);

    return (
      <TouchableOpacity
        style={styles.taskItem}
        onPress={() => navigateToTaskDetail(key)}
      >
        <View style={styles.taskHeader}>
          <Text style={styles.taskName}>{taskLabel}</Text>
          <View style={[styles.statusBadge, { backgroundColor: statusColor }]}>
            <Text style={styles.statusText}>{statusLabel}</Text>
          </View>
        </View>

        {task.assignedTo && (
          <View style={styles.assigneeContainer}>
            <View style={styles.assigneeAvatar}>
              <Text style={styles.avatarInitial}>
                {(task.assignedToName || '?').charAt(0).toUpperCase()}
              </Text>
            </View>
            <Text style={styles.assigneeName}>
              {task.assignedToName || 'Ng∆∞·ªùi d√πng kh√¥ng x√°c ƒë·ªãnh'}
            </Text>
          </View>
        )}

        <View style={styles.taskActions}>
          <TouchableOpacity
            style={styles.taskButton}
            onPress={() => navigateToTaskDetail(key)}
          >
            <Ionicons name="eye-outline" size={18} color="#0066cc" />
            <Text style={styles.taskButtonText}>Chi ti·∫øt</Text>
          </TouchableOpacity>
        </View>
      </TouchableOpacity>
    );
  };

  // Filter tasks related to this stage
  const getStageTasks = () => {
    if (!project || !project.tasks) return [];

    // Convert tasks object to array of {key, task} objects
    const taskArray = Object.entries(project.tasks)
      .filter(([_, task]) => task.stageId === stage.stageId) // Filter tasks for this stage
      .map(([key, task]) => ({ key, task }));

    return taskArray;
  };

  const stageTasks = project ? getStageTasks() : [];

  // Ê£ÄÊü•Ê≠§Èò∂ÊÆµÊòØÂê¶ÊúâÂÖ≥ËÅî‰ªªÂä°
  const hasAssignedTasks = stageTasks.length > 0;

  return (
    <ScrollView
      style={styles.container}
      contentContainerStyle={{ padding: 16 }}
    >
      {/* QA/QC Check Section */}
      <View style={styles.sectionContainer}>
        <View style={styles.sectionHeader}>
          <Ionicons name="checkmark-circle-outline" size={24} color="#4CAF50" />
          <Text style={styles.sectionTitle}>Ki·ªÉm tra QA/QC</Text>
        </View>

        <View style={styles.sectionContent}>
          <Text style={styles.label}>Tr·∫°ng th√°i</Text>
          <View style={styles.statusRow}>
            {STATUS_OPTIONS.map((opt) => (
              <TouchableOpacity
                key={opt.value}
                style={[
                  styles.statusBtn,
                  status === opt.value && { backgroundColor: opt.color },
                ]}
                onPress={() => setStatus(opt.value)}
              >
                <Text
                  style={[
                    styles.statusBtnText,
                    status === opt.value && { color: '#fff' },
                  ]}
                >
                  {opt.label}
                </Text>
              </TouchableOpacity>
            ))}
          </View>

          <Text style={styles.label}>Ghi ch√∫ / M√¥ t·∫£ k·∫øt qu·∫£</Text>
          <TextInput
            style={styles.textArea}
            multiline
            value={notes}
            onChangeText={setNotes}
            placeholder="Nh·∫≠p ghi ch√∫ ..."
          />

          {/* File Attachments for QA/QC */}
          <Text style={styles.label}>T·∫£i l√™n t·ªáp ƒë√≠nh k√®m</Text>
          {files.map((f) => (
            <View key={f.name} style={styles.fileRow}>
              <TouchableOpacity
                style={{ flexDirection: 'row', alignItems: 'center', flex: 1 }}
                onPress={() => viewFile(f)}
              >
                {f.preview && f.preview.startsWith('http') ? (
                  <Image source={{ uri: f.preview }} style={styles.thumb} />
                ) : (
                  <Ionicons name="document-outline" size={24} color="#666" />
                )}
                <Text style={styles.fileName}>{f.name}</Text>
              </TouchableOpacity>
              <TouchableOpacity
                onPress={() => removeFile(f)}
                style={{ padding: 4 }}
              >
                <Ionicons name="trash-outline" size={20} color="#d11a2a" />
              </TouchableOpacity>
            </View>
          ))}

          <View style={styles.attachActions}>
            <TouchableOpacity
              style={styles.attachBtn}
              onPress={openQcReportsFolder}
            >
              <Ionicons name="folder-open" size={20} color="#fff" />
              <Text style={styles.attachBtnText}>T·∫£i l√™n t·ªáp ƒë√≠nh k√®m</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>

      {/* PGD & Engineer Guidance Section */}
      <View style={styles.sectionContainer}>
        <View style={styles.sectionHeader}>
          <Ionicons name="school-outline" size={24} color="#2196F3" />
          <Text style={styles.sectionTitle}>H∆∞·ªõng d·∫´n PGD & K·ªπ s∆∞</Text>
        </View>

        <View style={styles.sectionContent}>
          <Text style={styles.label}>Ghi ch√∫ h∆∞·ªõng d·∫´n</Text>
          <TextInput
            style={styles.textArea}
            multiline
            value={instructionNotes}
            onChangeText={setInstructionNotes}
            placeholder="Nh·∫≠p h∆∞·ªõng d·∫´n chi ti·∫øt cho ng∆∞·ªùi th·ª±c hi·ªán..."
          />

          <Text style={styles.label}>·∫¢nh h∆∞·ªõng d·∫´n</Text>
          <View style={styles.instructionImagesContainer}>
            {instructionImages.map((image, index) => (
              <View key={index} style={styles.instructionImageItem}>
                <Image
                  source={{ uri: image.uri }}
                  style={styles.instructionImage}
                />
                <TouchableOpacity
                  onPress={() => removeInstructionImage(index)}
                  style={styles.removeImageBtn}
                >
                  <Ionicons name="close-circle" size={24} color="#d11a2a" />
                </TouchableOpacity>
              </View>
            ))}
          </View>

          <View style={styles.mediaActions}>
            <TouchableOpacity
              style={styles.mediaBtn}
              onPress={pickInstructionImage}
            >
              <Ionicons name="images-outline" size={20} color="#fff" />
              <Text style={styles.mediaBtnText}>Ch·ªçn ·∫£nh</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.mediaBtn}
              onPress={takeInstructionPhoto}
            >
              <Ionicons name="camera-outline" size={20} color="#fff" />
              <Text style={styles.mediaBtnText}>Ch·ª•p ·∫£nh</Text>
            </TouchableOpacity>
          </View>

          {/* Instruction Files */}
          <Text style={styles.label}>T·∫£i l√™n t·ªáp ƒë√≠nh k√®m</Text>
          <View style={styles.instructionFilesContainer}>
            {instructionFiles &&
              instructionFiles.map((f, index) => (
                <View key={index} style={styles.fileRow}>
                  <TouchableOpacity
                    style={{
                      flexDirection: 'row',
                      alignItems: 'center',
                      flex: 1,
                    }}
                    onPress={() => viewInstructionFile(f)}
                  >
                    <Ionicons name="document-outline" size={24} color="#666" />
                    <Text style={styles.fileName}>{f.name}</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    onPress={() => removeInstructionFile(index)}
                    style={{ padding: 4 }}
                  >
                    <Ionicons name="trash-outline" size={20} color="#d11a2a" />
                  </TouchableOpacity>
                </View>
              ))}
          </View>

          <View style={styles.attachActions}>
            <TouchableOpacity
              style={styles.attachBtn}
              onPress={openQcReportsFolder}
            >
              <Ionicons name="folder-open" size={20} color="#fff" />
              <Text style={styles.attachBtnText}>T·∫£i l√™n t·ªáp ƒë√≠nh k√®m</Text>
            </TouchableOpacity>
          </View>

          {/* Audio Instructions */}
          <Text style={styles.label}>H∆∞·ªõng d·∫´n b·∫±ng gi·ªçng n√≥i</Text>
          <View style={styles.audioContainer}>
            {instructionAudio && (
              <View style={styles.audioPlayer}>
                <TouchableOpacity
                  style={styles.playBtn}
                  onPress={isPlaying ? stopAudio : playAudio}
                >
                  <Ionicons
                    name={isPlaying ? 'pause' : 'play'}
                    size={24}
                    color="#fff"
                  />
                </TouchableOpacity>
                <Text style={styles.audioText}>
                  {isPlaying ? 'ƒêang ph√°t...' : 'Nh·∫•n ƒë·ªÉ ph√°t'}
                </Text>
                <TouchableOpacity
                  style={styles.deleteAudioBtn}
                  onPress={deleteAudio}
                >
                  <Ionicons name="trash-outline" size={20} color="#d11a2a" />
                </TouchableOpacity>
              </View>
            )}

            <View style={styles.recordingActions}>
              <TouchableOpacity
                style={[styles.recordBtn, isRecording && styles.recordingBtn]}
                onPress={isRecording ? stopRecording : startRecording}
              >
                <Ionicons
                  name={isRecording ? 'stop' : 'mic'}
                  size={24}
                  color="#fff"
                />
                <Text style={styles.recordBtnText}>
                  {isRecording ? 'D·ª´ng ghi √¢m' : 'Ghi √¢m'}
                </Text>
              </TouchableOpacity>

              {/* Th√¥ng b√°o v·ªÅ quy·ªÅn ghi √¢m */}
              <Text style={styles.permissionNote}>
                üí° ƒê·ªÉ ghi √¢m, ·ª©ng d·ª•ng c·∫ßn quy·ªÅn truy c·∫≠p microphone
              </Text>

              {/* N√∫t ki·ªÉm tra quy·ªÅn (ch·ªâ hi·ªÉn th·ªã trong development) */}
              <TouchableOpacity
                style={styles.checkPermissionBtn}
                onPress={checkAllPermissions}
              >
                <Ionicons
                  name="shield-checkmark-outline"
                  size={16}
                  color="#0066cc"
                />
                <Text style={styles.checkPermissionText}>Ki·ªÉm tra quy·ªÅn</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </View>

      {/* Related Tasks Section */}
      <View style={styles.sectionContainer}>
        <View style={styles.sectionHeader}>
          <Ionicons name="list-outline" size={24} color="#FF9800" />
          <Text style={styles.sectionTitle}>C√¥ng vi·ªác li√™n quan</Text>
        </View>

        <View style={styles.sectionContent}>
          {loading ? (
            <ActivityIndicator
              size="small"
              color="#0066cc"
              style={{ marginVertical: 20 }}
            />
          ) : stageTasks.length > 0 ? (
            <FlatList
              data={stageTasks}
              keyExtractor={(item) => item.key}
              renderItem={renderTaskItem}
              scrollEnabled={false}
              style={styles.taskList}
            />
          ) : (
            <Text style={styles.noTasksText}>
              Kh√¥ng c√≥ c√¥ng vi·ªác n√†o ƒë∆∞·ª£c g√°n cho giai ƒëo·∫°n n√†y.
            </Text>
          )}
        </View>
      </View>

      <TouchableOpacity
        style={styles.saveButton}
        onPress={handleSave}
        disabled={saving}
      >
        {saving ? (
          <ActivityIndicator color="#fff" />
        ) : (
          <Text style={styles.saveButtonText}>L∆∞u</Text>
        )}
      </TouchableOpacity>

      {/* Image preview modal */}
      <Modal
        visible={!!imagePreviewUri}
        transparent={true}
        animationType="fade"
      >
        <View style={styles.modalBackdrop}>
          <TouchableOpacity
            style={styles.modalCloseArea}
            onPress={() => setImagePreviewUri(null)}
          />
          <Image
            source={{ uri: imagePreviewUri }}
            style={styles.modalImage}
            resizeMode="contain"
          />
          <TouchableOpacity
            style={styles.modalCloseBtn}
            onPress={() => setImagePreviewUri(null)}
          >
            <Ionicons name="close-circle" size={36} color="#fff" />
          </TouchableOpacity>
        </View>
      </Modal>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f9f9f9',
  },
  label: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 8,
    color: '#333',
  },
  statusRow: {
    flexDirection: 'row',
    marginBottom: 16,
    flexWrap: 'wrap',
  },
  statusBtn: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    backgroundColor: '#f1f1f1',
    marginRight: 8,
    marginBottom: 8,
  },
  statusBtnText: {
    color: '#333',
    fontWeight: '500',
  },
  textArea: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 12,
    minHeight: 100,
    borderWidth: 1,
    borderColor: '#ddd',
    marginBottom: 16,
    textAlignVertical: 'top',
  },
  fileRow: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#fff',
    padding: 10,
    borderRadius: 8,
    marginBottom: 10,
    borderWidth: 1,
    borderColor: '#eee',
  },
  thumb: {
    width: 40,
    height: 40,
    borderRadius: 4,
    marginRight: 10,
  },
  fileName: {
    flex: 1,
    fontSize: 14,
    color: '#333',
  },
  attachActions: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginTop: 10,
    marginBottom: 24,
    gap: 10,
  },
  attachBtn: {
    backgroundColor: '#0066cc',
    borderRadius: 20,
    paddingVertical: 8,
    paddingHorizontal: 16,
    flexDirection: 'row',
    alignItems: 'center',
    minWidth: 120,
    justifyContent: 'center',
  },
  attachBtnText: {
    color: '#fff',
    marginLeft: 8,
    fontWeight: '500',
  },
  saveButton: {
    backgroundColor: '#0066cc',
    borderRadius: 8,
    padding: 14,
    alignItems: 'center',
    marginTop: 16,
    marginBottom: 32,
  },
  saveButtonText: {
    color: '#fff',
    fontWeight: 'bold',
    fontSize: 16,
  },
  // New styles for tasks
  sectionHeaderContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 24,
    marginBottom: 12,
  },
  sectionHeader: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },

  taskList: {
    marginTop: 8,
  },
  noTasksText: {
    textAlign: 'center',
    color: '#666',
    fontStyle: 'italic',
    marginTop: 16,
    marginBottom: 16,
  },
  taskItem: {
    backgroundColor: '#fff',
    borderRadius: 8,
    marginBottom: 10,
    padding: 12,
    borderWidth: 1,
    borderColor: '#eee',
  },
  taskHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  taskName: {
    fontSize: 15,
    fontWeight: '500',
    color: '#333',
    flex: 1,
  },
  statusBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    marginLeft: 8,
  },
  statusText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
  assigneeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    borderTopWidth: 1,
    borderTopColor: '#f0f0f0',
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
    marginBottom: 8,
  },
  assigneeAvatar: {
    width: 28,
    height: 28,
    borderRadius: 14,
    backgroundColor: '#0066cc',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 8,
  },
  avatarInitial: {
    color: '#fff',
    fontWeight: 'bold',
    fontSize: 14,
  },
  assigneeName: {
    fontSize: 14,
    color: '#333',
  },
  taskActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
  },
  taskButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 6,
    paddingHorizontal: 12,
    borderRadius: 16,
    backgroundColor: '#f0f7ff',
  },
  taskButtonText: {
    color: '#0066cc',
    marginLeft: 4,
    fontSize: 14,
    fontWeight: '500',
  },
  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  modalContainer: {
    width: '90%',
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    maxHeight: '80%',
  },
  modalClose: {
    position: 'absolute',
    right: 16,
    top: 16,
  },
  imagePreview: {
    width: '100%',
    height: 300,
    resizeMode: 'contain',
    marginVertical: 20,
  },

  // Section Container Styles
  sectionContainer: {
    backgroundColor: '#fff',
    borderRadius: 12,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: '#e0e0e0',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  sectionHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
    backgroundColor: '#fafafa',
    borderTopLeftRadius: 12,
    borderTopRightRadius: 12,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginLeft: 12,
  },
  sectionContent: {
    padding: 16,
  },

  // Media Instructions Styles
  instructionImagesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 16,
  },
  instructionFilesContainer: {
    marginBottom: 16,
  },
  instructionImageItem: {
    position: 'relative',
    marginRight: 12,
    marginBottom: 12,
  },
  instructionImage: {
    width: 100,
    height: 100,
    borderRadius: 8,
    backgroundColor: '#f0f0f0',
  },
  removeImageBtn: {
    position: 'absolute',
    top: -8,
    right: -8,
    backgroundColor: '#fff',
    borderRadius: 12,
  },
  mediaActions: {
    flexDirection: 'row',
    marginBottom: 16,
  },
  mediaBtn: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#0066cc',
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 8,
    marginRight: 12,
  },
  mediaBtnText: {
    color: '#fff',
    marginLeft: 8,
    fontWeight: '500',
  },
  audioContainer: {
    marginBottom: 16,
  },
  audioPlayer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f8f9fa',
    padding: 12,
    borderRadius: 8,
    marginBottom: 12,
  },
  playBtn: {
    backgroundColor: '#28a745',
    width: 40,
    height: 40,
    borderRadius: 20,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  audioText: {
    flex: 1,
    fontSize: 14,
    color: '#333',
  },
  deleteAudioBtn: {
    padding: 8,
  },
  recordingActions: {
    alignItems: 'center',
  },
  recordBtn: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#dc3545',
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
  },
  recordingBtn: {
    backgroundColor: '#ff6b6b',
  },
  recordBtnText: {
    color: '#fff',
    marginLeft: 8,
    fontWeight: '500',
    fontSize: 16,
  },
  permissionNote: {
    fontSize: 12,
    color: '#666',
    textAlign: 'center',
    marginTop: 8,
    fontStyle: 'italic',
  },
  checkPermissionBtn: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#f0f7ff',
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 16,
    marginTop: 8,
    alignSelf: 'center',
  },
  checkPermissionText: {
    color: '#0066cc',
    marginLeft: 4,
    fontSize: 12,
    fontWeight: '500',
  },
});

export default StageDetailScreen;


--- END: src\screens\StageDetailScreen.js ---


--- START: src\screens\StarboardScreen.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  RefreshControl,
  Alert,
  Dimensions,
  Image,
  StatusBar,
  BackHandler,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import ProductionService from '../api/productionService';
import { getProjects } from '../api/projectService';

const { width } = Dimensions.get('window');

// Hook ƒë·ªÉ ph√°t hi·ªán k√≠ch th∆∞·ªõc m√†n h√¨nh v√† orientation
const useScreenDimensions = () => {
  const [screenData, setScreenData] = useState(Dimensions.get('window'));

  useEffect(() => {
    const onChange = (result) => {
      setScreenData(result.window);
    };

    const subscription = Dimensions.addEventListener('change', onChange);
    return () => subscription?.remove();
  }, []);

  return {
    ...screenData,
    isLandscape: screenData.width > screenData.height,
  };
};

const StarboardScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const { currentUser } = useAuth();

  // S·ª≠ d·ª•ng hook ƒë·ªÉ ph√°t hi·ªán k√≠ch th∆∞·ªõc m√†n h√¨nh
  const {
    width: screenWidth,
    height: screenHeight,
    isLandscape,
  } = useScreenDimensions();

  // State management
  const [projects, setProjects] = useState([]);
  const [factoryStatus, setFactoryStatus] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);

  // Toggle fullscreen mode
  const toggleFullscreen = () => {
    setIsFullscreen(!isFullscreen);
  };

  // Handle back button - exit fullscreen first, then navigate back
  const handleBackPress = () => {
    if (isFullscreen) {
      // N·∫øu ƒëang fullscreen, tho√°t fullscreen tr∆∞·ªõc
      setIsFullscreen(false);
    } else {
      // N·∫øu kh√¥ng fullscreen, navigate back b√¨nh th∆∞·ªùng
      navigation.goBack();
    }
  };

  // Manage StatusBar based on fullscreen state
  useEffect(() => {
    if (isFullscreen) {
      // Fullscreen mode: Hide status bar (like gaming apps)
      StatusBar.setHidden(true, 'slide');
      StatusBar.setBackgroundColor('transparent', true);
      StatusBar.setTranslucent(true);
    } else {
      // Normal mode: Show status bar
      StatusBar.setHidden(false, 'slide');
      StatusBar.setBackgroundColor(theme.primary || '#2196F3', true);
      StatusBar.setTranslucent(false);
    }

    // Cleanup when component unmounts
    return () => {
      StatusBar.setHidden(false, 'slide');
      StatusBar.setTranslucent(false);
    };
  }, [isFullscreen, theme.primary]);

  // Handle Android hardware back button
  useEffect(() => {
    const backAction = () => {
      handleBackPress();
      return true; // Prevent default behavior
    };

    const backHandler = BackHandler.addEventListener(
      'hardwareBackPress',
      backAction
    );

    return () => backHandler.remove();
  }, [isFullscreen]);

  // Real-time subscription
  useEffect(() => {
    let unsubscribe = null;

    const setupRealtimeUpdates = async () => {
      try {
        // Load initial data
        await loadData();

        // Setup real-time subscription for factory status
        unsubscribe = ProductionService.subscribeLiveFactoryStatus((status) => {
          console.log(
            'Real-time factory status update:',
            status.length,
            'workers'
          );
          setFactoryStatus(status);
          setLoading(false);
        });
      } catch (error) {
        console.error('Error setting up real-time updates:', error);
        setLoading(false);
      }
    };

    setupRealtimeUpdates();

    // Cleanup subscription on unmount
    return () => {
      if (unsubscribe) {
        unsubscribe();
      }
    };
  }, []);

  // Load initial data
  const loadData = async () => {
    try {
      const [projectsData, factoryStatusData] = await Promise.all([
        getProjects(),
        ProductionService.getLiveFactoryStatus(),
      ]);

      console.log(
        'StarboardScreen - Total projects loaded:',
        projectsData.length
      );
      console.log(
        'StarboardScreen - All project statuses:',
        projectsData.map((p) => ({ name: p.name, status: p.status }))
      );

      // T·∫°m th·ªùi hi·ªÉn th·ªã t·∫•t c·∫£ d·ª± √°n ƒë·ªÉ debug
      console.log('StarboardScreen - Showing ALL projects for debugging');

      // Ch·ªâ hi·ªÉn th·ªã c√°c d·ª± √°n ƒëang th·ª±c hi·ªán - ki·ªÉm tra nhi·ªÅu tr·∫°ng th√°i c√≥ th·ªÉ
      const activeProjects = projectsData.filter((project) => {
        const status = project.status?.toLowerCase();
        return (
          status === 'in_progress' ||
          status === 'dang_thuc_hien' ||
          status === 'ƒëang th·ª±c hi·ªán' ||
          status === 'in-progress' ||
          status === 'active' ||
          status === 'ongoing'
        );
      });

      console.log(
        'StarboardScreen - Active projects (filtered):',
        activeProjects.length
      );
      console.log(
        'StarboardScreen - Active projects details:',
        activeProjects.map((p) => ({ name: p.name, status: p.status }))
      );

      // T·∫°m th·ªùi hi·ªÉn th·ªã t·∫•t c·∫£ d·ª± √°n ƒë·ªÉ debug
      setProjects(projectsData);
      setFactoryStatus(factoryStatusData);
    } catch (error) {
      console.error('Error loading data:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu');
    }
  };

  // Handle refresh
  const handleRefresh = async () => {
    setRefreshing(true);
    await loadData();
    setRefreshing(false);
  };

  // Get stage status based on factory status
  const getStageStatus = (projectId, stageId) => {
    // Check if any worker is currently working on this stage
    const workingWorker = factoryStatus.find(
      (worker) =>
        worker.status === 'working' &&
        worker.currentTask?.projectId === projectId &&
        worker.currentTask?.stageId === stageId
    );

    if (workingWorker) {
      return 'in_progress';
    }

    // For now, we'll assume other stages are pending
    // In a real app, you'd check completion status from project data
    return 'pending';
  };

  // Get workers for a project
  const getProjectWorkers = (projectId) => {
    // T√¨m project ƒë·ªÉ l·∫•y t√™n d·ª± √°n
    const project = projects.find((p) => p.id === projectId);
    const projectName = project?.name;

    console.log('=== DEBUG getProjectWorkers ===');
    console.log('Looking for projectId:', projectId);
    console.log('Project name:', projectName);
    console.log('factoryStatus:', factoryStatus);

    const workingWorkers = factoryStatus.filter(
      (worker) => worker.status === 'working'
    );
    console.log('Working workers:', workingWorkers);

    const projectWorkers = factoryStatus.filter((worker) => {
      const isWorking = worker.status === 'working';
      const hasCurrentTask = worker.currentTask;

      // So s√°nh theo nhi·ªÅu c√°ch kh√°c nhau
      const projectMatches =
        worker.currentTask?.projectId === projectId ||
        worker.currentTask?.projectName === projectId ||
        worker.currentTask?.project === projectId ||
        worker.currentTask?.projectName === projectName ||
        worker.currentTask?.project === projectName;

      console.log(`Worker ${worker.workerName || worker.workerId}:`, {
        isWorking,
        hasCurrentTask,
        currentTask: worker.currentTask,
        projectMatches,
        'currentTask.projectName': worker.currentTask?.projectName,
        'looking for projectName': projectName,
      });

      return isWorking && hasCurrentTask && projectMatches;
    });

    console.log('Final project workers:', projectWorkers);
    console.log('=== END DEBUG ===');

    return projectWorkers;
  };

  // Calculate project progress
  const calculateProgress = (project) => {
    if (!project.workflowStages || project.workflowStages.length === 0) {
      return 0;
    }

    const completedStages = project.workflowStages.filter(
      (stage) => getStageStatus(project.id, stage.stageId) === 'completed'
    ).length;

    return Math.round((completedStages / project.workflowStages.length) * 100);
  };

  // Get icon for process type
  const getProcessIcon = (processKey) => {
    const iconMap = {
      // C·∫Øt
      laser_cutting: 'flash',
      plasma_cutting: 'flash-outline',
      cutting: 'cut',

      // H√†n
      welding: 'flame',
      arc_welding: 'flame-outline',
      han: 'flame',

      // S∆°n
      painting: 'brush',
      spray_painting: 'brush-outline',
      son: 'brush',

      // Gia c√¥ng
      machining: 'build',
      drilling: 'ellipse',
      milling: 'settings',

      // L·∫Øp r√°p
      assembly: 'construct',
      lap_rap: 'construct-outline',

      // Ki·ªÉm tra
      inspection: 'checkmark-circle',
      quality_check: 'shield-checkmark',

      // M·∫∑c ƒë·ªãnh
      default: 'ellipse',
    };

    return iconMap[processKey] || iconMap['default'];
  };

  // Render task icon v·ªõi responsive sizing
  const renderTaskIcon = (stage, projectId, isLandscapeMode = false) => {
    const status = getStageStatus(projectId, stage.stageId);

    let iconColor = '#9E9E9E'; // Default gray
    let borderColor = '#9E9E9E';
    let showTick = false;

    switch (status) {
      case 'completed':
        iconColor = '#4CAF50';
        borderColor = '#4CAF50';
        showTick = true;
        break;
      case 'in_progress':
        iconColor = '#FFC107';
        borderColor = '#FFC107';
        break;
      case 'pending':
      default:
        iconColor = '#9E9E9E';
        borderColor = '#E0E0E0';
        break;
    }

    const iconName = getProcessIcon(stage.processKey);

    // Responsive sizing
    const iconSize = isLandscapeMode ? 32 : 40;
    const iconIconSize = isLandscapeMode ? 16 : 20;

    return (
      <View
        key={stage.stageId}
        style={[
          styles.taskIconContainer,
          isLandscapeMode && styles.taskIconContainerLandscape,
        ]}
      >
        <View
          style={[
            styles.taskIcon,
            {
              borderColor: borderColor,
              borderWidth: status === 'in_progress' ? 3 : 1,
              width: iconSize,
              height: iconSize,
              borderRadius: iconSize / 2,
            },
            isLandscapeMode && styles.taskIconLandscape,
          ]}
        >
          <Ionicons name={iconName} size={iconIconSize} color={iconColor} />
          {showTick && (
            <View
              style={[
                styles.tickContainer,
                isLandscapeMode && styles.tickContainerLandscape,
              ]}
            >
              <Ionicons
                name="checkmark"
                size={isLandscapeMode ? 6 : 8}
                color="#fff"
              />
            </View>
          )}
        </View>
        {/* Hi·ªÉn th·ªã t√™n stage trong landscape mode */}
        {isLandscapeMode && (
          <Text style={styles.stageNameText} numberOfLines={1}>
            {stage.processName || stage.processKey}
          </Text>
        )}
      </View>
    );
  };

  // Render worker avatar v·ªõi responsive sizing
  const renderWorkerAvatar = (worker, index, isLandscapeMode = false) => {
    // Responsive sizing
    const avatarSize = isLandscapeMode ? 28 : 32;
    const iconSize = isLandscapeMode ? 16 : 20;

    return (
      <View
        key={worker.workerId}
        style={[
          styles.workerAvatar,
          index === 0 ? { marginLeft: 0 } : {},
          {
            width: avatarSize,
            height: avatarSize,
            borderRadius: avatarSize / 2,
          },
          isLandscapeMode && styles.workerAvatarLandscape,
        ]}
      >
        {worker.avatar ? (
          <Image
            source={{ uri: worker.avatar }}
            style={[
              styles.workerAvatarImage,
              {
                width: avatarSize,
                height: avatarSize,
                borderRadius: avatarSize / 2,
              },
            ]}
          />
        ) : (
          <View
            style={[
              styles.workerAvatarPlaceholder,
              {
                width: avatarSize,
                height: avatarSize,
                borderRadius: avatarSize / 2,
              },
            ]}
          >
            <Ionicons name="person" size={iconSize} color="#fff" />
          </View>
        )}
      </View>
    );
  };

  // Render project row v·ªõi responsive layout
  const renderProjectRow = ({ item: project }) => {
    const workers = getProjectWorkers(project.id);

    // T√≠nh to√°n layout d·ª±a tr√™n orientation
    const getResponsiveLayout = () => {
      if (isLandscape) {
        // Landscape: T·ªëi ∆∞u cho m√†n h√¨nh r·ªông
        return {
          projectNameFlex: 0.25, // 25% cho t√™n d·ª± √°n
          taskIconsFlex: 0.5, // 50% cho icons c√¥ng ƒëo·∫°n
          workersFlex: 0.25, // 25% cho c√¥ng nh√¢n
          showMoreIcons: true, // Hi·ªÉn th·ªã nhi·ªÅu icons h∆°n
          maxWorkers: 5, // Hi·ªÉn th·ªã nhi·ªÅu workers h∆°n
        };
      } else {
        // Portrait: Layout g·ªçn g√†ng cho m√†n h√¨nh d·ªçc
        return {
          projectNameFlex: 0.3, // 30% cho t√™n d·ª± √°n
          taskIconsFlex: 0.4, // 40% cho icons c√¥ng ƒëo·∫°n
          workersFlex: 0.3, // 30% cho c√¥ng nh√¢n
          showMoreIcons: false, // Gi·ªõi h·∫°n icons
          maxWorkers: 3, // Gi·ªõi h·∫°n workers
        };
      }
    };

    const layout = getResponsiveLayout();

    return (
      <View
        style={[
          styles.projectRow,
          { backgroundColor: theme.cardBackground, borderColor: theme.border },
          isLandscape && styles.projectRowLandscape,
        ]}
      >
        {/* Project Name */}
        <View
          style={[
            styles.projectNameContainer,
            { flex: layout.projectNameFlex },
          ]}
        >
          <Text
            style={[
              styles.projectName,
              { color: theme.text },
              isLandscape && styles.projectNameLandscape,
            ]}
            numberOfLines={isLandscape ? 1 : 2}
            ellipsizeMode="tail"
          >
            {project.name}
          </Text>
          {/* Hi·ªÉn th·ªã customer name trong landscape mode */}
          {isLandscape && project.customerName && (
            <Text
              style={[styles.customerName, { color: theme.textSecondary }]}
              numberOfLines={1}
            >
              {project.customerName}
            </Text>
          )}
        </View>

        {/* Task Icons */}
        <View
          style={[
            styles.taskIconsContainer,
            { flex: layout.taskIconsFlex },
            isLandscape && styles.taskIconsContainerLandscape,
          ]}
        >
          {project.workflowStages?.length > 0 ? (
            project.workflowStages
              .sort((a, b) => a.order - b.order)
              .slice(0, layout.showMoreIcons ? 8 : 4) // Hi·ªÉn th·ªã nhi·ªÅu icons h∆°n trong landscape
              .map((stage) => renderTaskIcon(stage, project.id, isLandscape))
          ) : (
            <Text style={[styles.noStagesText, { color: theme.textSecondary }]}>
              Ch∆∞a c√≥ c√¥ng ƒëo·∫°n
            </Text>
          )}
          {/* Hi·ªÉn th·ªã s·ªë l∆∞·ª£ng stages c√≤n l·∫°i n·∫øu c√≥ */}
          {project.workflowStages?.length > (layout.showMoreIcons ? 8 : 4) && (
            <View style={styles.moreStagesIndicator}>
              <Text style={styles.moreStagesText}>
                +
                {project.workflowStages.length - (layout.showMoreIcons ? 8 : 4)}
              </Text>
            </View>
          )}
        </View>

        {/* Worker Avatars */}
        <View style={[styles.workersContainer, { flex: layout.workersFlex }]}>
          {workers.length > 0 ? (
            workers
              .slice(0, layout.maxWorkers)
              .map((worker, index) =>
                renderWorkerAvatar(worker, index, isLandscape)
              )
          ) : (
            <Text
              style={[styles.noWorkersText, { color: theme.textSecondary }]}
            >
              Ch∆∞a c√≥ CN
            </Text>
          )}
          {workers.length > layout.maxWorkers && (
            <View
              style={[
                styles.moreWorkersIndicator,
                isLandscape && styles.moreWorkersIndicatorLandscape,
              ]}
            >
              <Text style={styles.moreWorkersText}>
                +{workers.length - layout.maxWorkers}
              </Text>
            </View>
          )}
        </View>
      </View>
    );
  };

  return (
    <View
      style={[
        styles.container,
        { backgroundColor: theme.background },
        isFullscreen && styles.fullscreenContainer,
      ]}
    >
      {/* Header - ·∫®n trong fullscreen mode */}
      {!isFullscreen && (
        <View
          style={[styles.header, { backgroundColor: theme.cardBackground }]}
        >
          <View style={styles.headerLeft}>
            <Text style={[styles.headerTitle, { color: theme.text }]}>
              B·∫£ng Ti·∫øn ƒê·ªô D·ª± √Ån
            </Text>
          </View>

          <View style={styles.headerRight}>
            {/* Debug info - c√≥ th·ªÉ ·∫©n trong production */}
            <View style={styles.debugInfo}>
              <Text style={styles.debugText}>
                {isLandscape ? 'üì± Ngang' : 'üì± D·ªçc'} | Workers:{' '}
                {factoryStatus.filter((w) => w.status === 'working').length}
              </Text>
            </View>

            {/* Fullscreen Toggle Button */}
            <TouchableOpacity
              style={[
                styles.fullscreenButton,
                {
                  backgroundColor: isFullscreen ? '#FF5722' : theme.primary,
                  marginRight: 8,
                },
              ]}
              onPress={toggleFullscreen}
            >
              <Ionicons
                name={isFullscreen ? 'contract' : 'expand'}
                size={18}
                color="#fff"
              />
            </TouchableOpacity>

            <TouchableOpacity
              style={[styles.refreshButton, { backgroundColor: theme.primary }]}
              onPress={handleRefresh}
              disabled={refreshing}
            >
              <Ionicons
                name="refresh"
                size={20}
                color="#fff"
                style={refreshing ? { opacity: 0.5 } : {}}
              />
            </TouchableOpacity>
          </View>
        </View>
      )}

      {/* Projects List */}
      <FlatList
        data={projects}
        renderItem={renderProjectRow}
        keyExtractor={(item) => item.id}
        contentContainerStyle={[
          styles.listContainer,
          isLandscape && styles.listContainerLandscape,
        ]}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={[theme.primary]}
            tintColor={theme.primary}
          />
        }
        key={`starboard-${isLandscape}`} // Force re-render khi orientation thay ƒë·ªïi
        ListEmptyComponent={
          <View style={styles.emptyContainer}>
            <Ionicons
              name="folder-outline"
              size={64}
              color={theme.textSecondary}
            />
            <Text style={[styles.emptyText, { color: theme.textSecondary }]}>
              {loading ? 'ƒêang t·∫£i...' : 'Kh√¥ng c√≥ d·ª± √°n n√†o'}
            </Text>
          </View>
        }
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  headerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },

  headerTitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  headerRight: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  refreshButton: {
    padding: 8,
    borderRadius: 20,
  },
  listContainer: {
    padding: 16,
  },
  projectRow: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 20,
    marginBottom: 2,
    borderWidth: 1,
    borderRadius: 8,
  },
  projectNameContainer: {
    flex: 0.3,
    paddingRight: 20,
  },
  projectName: {
    fontSize: 16,
    fontWeight: '600',
  },
  taskIconsContainer: {
    flex: 0.4,
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 10,
  },
  taskIconContainer: {
    marginRight: 12,
    position: 'relative',
  },
  taskIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
  },
  tickContainer: {
    position: 'absolute',
    top: -2,
    right: -2,
    width: 12,
    height: 12,
    borderRadius: 6,
    backgroundColor: '#4CAF50',
    justifyContent: 'center',
    alignItems: 'center',
  },
  noStagesText: {
    fontSize: 12,
    fontStyle: 'italic',
  },
  workersContainer: {
    flex: 0.3,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'flex-end',
  },
  workerAvatar: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#2196F3',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#fff',
    overflow: 'hidden',
    marginLeft: -8,
  },
  workerAvatarImage: {
    width: '100%',
    height: '100%',
    borderRadius: 20,
  },
  workerAvatarPlaceholder: {
    width: '100%',
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#2196F3',
  },
  moreWorkersIndicator: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#9E9E9E',
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: -8,
    borderWidth: 2,
    borderColor: '#fff',
  },
  moreWorkersText: {
    color: '#fff',
    fontSize: 8,
    fontWeight: 'bold',
  },
  noWorkersText: {
    fontSize: 12,
    fontStyle: 'italic',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 64,
  },
  emptyText: {
    fontSize: 16,
    marginTop: 16,
    textAlign: 'center',
  },

  // Responsive Layout Styles
  debugInfo: {
    backgroundColor: '#FFF3E0',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    marginRight: 8,
  },
  debugText: {
    fontSize: 10,
    color: '#E65100',
    fontWeight: '500',
  },

  // Project Row Landscape Styles
  projectRowLandscape: {
    paddingVertical: 8,
    minHeight: 60,
  },
  projectNameLandscape: {
    fontSize: 14,
    fontWeight: '600',
  },
  customerName: {
    fontSize: 11,
    marginTop: 2,
    fontStyle: 'italic',
  },

  // Task Icons Landscape Styles
  taskIconContainerLandscape: {
    marginRight: 6,
    alignItems: 'center',
  },
  taskIconLandscape: {
    marginBottom: 2,
  },
  tickContainerLandscape: {
    width: 12,
    height: 12,
    borderRadius: 6,
  },
  stageNameText: {
    fontSize: 8,
    color: '#666',
    textAlign: 'center',
    maxWidth: 32,
  },
  moreStagesIndicator: {
    backgroundColor: '#E0E0E0',
    borderRadius: 16,
    paddingHorizontal: 6,
    paddingVertical: 2,
    marginLeft: 4,
  },
  moreStagesText: {
    fontSize: 10,
    color: '#666',
    fontWeight: '500',
  },
  taskIconsContainerLandscape: {
    flexWrap: 'wrap',
    justifyContent: 'flex-start',
  },

  // Worker Avatar Landscape Styles
  workerAvatarLandscape: {
    marginLeft: -4,
  },
  moreWorkersIndicatorLandscape: {
    width: 28,
    height: 28,
    borderRadius: 14,
  },

  // List Container Landscape Styles
  listContainerLandscape: {
    paddingHorizontal: 8,
  },

  // Fullscreen Mode Styles
  fullscreenContainer: {
    paddingTop: 0, // Remove status bar padding
  },
  fullscreenButton: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
});

export default StarboardScreen;


--- END: src\screens\StarboardScreen.js ---


--- START: src\screens\SupplierDetailScreen.js ---
// src/screens/SupplierDetailScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  SafeAreaView,
  Linking,
  Share,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import {
  getSupplierById,
  deleteSupplier,
  addSupplierRating,
} from '../api/supplierService';
import { useAuth } from '../contexts/AuthContext';

const SupplierDetailScreen = ({ route, navigation }) => {
  const { supplierId } = route.params;
  const { currentUser } = useAuth();
  const [supplier, setSupplier] = useState(null);
  const [loading, setLoading] = useState(true);
  const [showRatingModal, setShowRatingModal] = useState(false);

  useEffect(() => {
    const loadSupplierData = async () => {
      try {
        const data = await getSupplierById(supplierId);
        setSupplier(data);
      } catch (error) {
        console.error('L·ªói khi t·∫£i th√¥ng tin nh√† cung c·∫•p:', error);
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i th√¥ng tin nh√† cung c·∫•p');
        navigation.goBack();
      } finally {
        setLoading(false);
      }
    };

    loadSupplierData();
  }, [supplierId, navigation]);

  const handleCall = () => {
    if (!supplier?.phone) return;

    Linking.openURL(`tel:${supplier.phone}`);
  };

  const handleEmail = () => {
    if (!supplier?.email) return;

    Linking.openURL(`mailto:${supplier.email}`);
  };

  const handleShare = async () => {
    if (!supplier) return;

    try {
      const message = `
Th√¥ng tin nh√† cung c·∫•p:
T√™n: ${supplier.name}
Li√™n h·ªá: ${supplier.contactName || 'N/A'}
SƒêT: ${supplier.phone || 'N/A'}
Email: ${supplier.email || 'N/A'}
ƒê·ªãa ch·ªâ: ${supplier.address || 'N/A'}
      `;

      await Share.share({
        message,
        title: `Th√¥ng tin nh√† cung c·∫•p: ${supplier.name}`,
      });
    } catch (error) {
      console.error('L·ªói khi chia s·∫ª:', error);
    }
  };

  const handleEdit = () => {
    navigation.navigate('EditSupplier', { supplierId, supplier });
  };

  const handleDelete = () => {
    Alert.alert(
      'X√°c nh·∫≠n x√≥a',
      `B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a nh√† cung c·∫•p "${supplier?.name}" kh√¥ng?`,
      [
        { text: 'H·ªßy', style: 'cancel' },
        {
          text: 'X√≥a',
          style: 'destructive',
          onPress: async () => {
            try {
              await deleteSupplier(supplierId);
              Alert.alert('Th√†nh c√¥ng', 'ƒê√£ x√≥a nh√† cung c·∫•p');
              navigation.goBack();
            } catch (error) {
              console.error('L·ªói khi x√≥a nh√† cung c·∫•p:', error);
              Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ x√≥a nh√† cung c·∫•p');
            }
          },
        },
      ]
    );
  };

  if (loading) {
    return (
      <SafeAreaView style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#0066cc" />
        <Text style={styles.loadingText}>ƒêang t·∫£i d·ªØ li·ªáu...</Text>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Chi ti·∫øt nh√† cung c·∫•p</Text>
        <TouchableOpacity onPress={handleShare}>
          <Ionicons name="share-outline" size={24} color="#333" />
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.content}>
        <View style={styles.supplierHeader}>
          <View style={styles.supplierNameContainer}>
            <Text style={styles.supplierName}>{supplier?.name}</Text>
            {supplier?.verified && (
              <View style={styles.verifiedBadge}>
                <Ionicons name="checkmark-circle" size={16} color="#fff" />
                <Text style={styles.verifiedText}>ƒê√£ x√°c minh</Text>
              </View>
            )}
          </View>

          {supplier?.categories && supplier.categories.length > 0 && (
            <View style={styles.categoriesContainer}>
              {supplier.categories.map((category, index) => (
                <View key={index} style={styles.categoryTag}>
                  <Text style={styles.categoryText}>{category}</Text>
                </View>
              ))}
            </View>
          )}
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Th√¥ng tin li√™n h·ªá</Text>

          {supplier?.contactName && (
            <View style={styles.infoRow}>
              <Ionicons name="person-outline" size={20} color="#666" />
              <Text style={styles.infoLabel}>Ng∆∞·ªùi li√™n h·ªá:</Text>
              <Text style={styles.infoText}>{supplier.contactName}</Text>
            </View>
          )}

          {supplier?.phone && (
            <TouchableOpacity style={styles.infoRow} onPress={handleCall}>
              <Ionicons name="call-outline" size={20} color="#666" />
              <Text style={styles.infoLabel}>S·ªë ƒëi·ªán tho·∫°i:</Text>
              <Text style={[styles.infoText, styles.linkText]}>
                {supplier.phone}
              </Text>
            </TouchableOpacity>
          )}

          {supplier?.email && (
            <TouchableOpacity style={styles.infoRow} onPress={handleEmail}>
              <Ionicons name="mail-outline" size={20} color="#666" />
              <Text style={styles.infoLabel}>Email:</Text>
              <Text style={[styles.infoText, styles.linkText]}>
                {supplier.email}
              </Text>
            </TouchableOpacity>
          )}

          {supplier?.address && (
            <View style={styles.infoRow}>
              <Ionicons name="location-outline" size={20} color="#666" />
              <Text style={styles.infoLabel}>ƒê·ªãa ch·ªâ:</Text>
              <Text style={styles.infoText}>{supplier.address}</Text>
            </View>
          )}
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Th√¥ng tin thanh to√°n</Text>

          {supplier?.taxCode ? (
            <View style={styles.infoRow}>
              <Ionicons name="document-text-outline" size={20} color="#666" />
              <Text style={styles.infoLabel}>M√£ s·ªë thu·∫ø:</Text>
              <Text style={styles.infoText}>{supplier.taxCode}</Text>
            </View>
          ) : (
            <Text style={styles.emptyText}>Ch∆∞a c√≥ th√¥ng tin m√£ s·ªë thu·∫ø</Text>
          )}

          {supplier?.bankAccount && (
            <View style={styles.infoRow}>
              <Ionicons name="card-outline" size={20} color="#666" />
              <Text style={styles.infoLabel}>T√†i kho·∫£n:</Text>
              <Text style={styles.infoText}>{supplier.bankAccount}</Text>
            </View>
          )}

          {supplier?.bankName && (
            <View style={styles.infoRow}>
              <Ionicons name="business-outline" size={20} color="#666" />
              <Text style={styles.infoLabel}>Ng√¢n h√†ng:</Text>
              <Text style={styles.infoText}>{supplier.bankName}</Text>
            </View>
          )}
        </View>

        {supplier?.description && (
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>M√¥ t·∫£</Text>
            <Text style={styles.descriptionText}>{supplier.description}</Text>
          </View>
        )}

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>ƒê√°nh gi√°</Text>
          <View style={styles.ratingContainer}>
            <View style={styles.ratingStars}>
              {supplier?.averageRating ? (
                <>
                  <Text style={styles.ratingValue}>
                    {supplier.averageRating.toFixed(1)}
                  </Text>
                  <View style={styles.starsContainer}>
                    {[1, 2, 3, 4, 5].map((star) => (
                      <Ionicons
                        key={star}
                        name={
                          star <= Math.round(supplier.averageRating)
                            ? 'star'
                            : 'star-outline'
                        }
                        size={16}
                        color="#FFD700"
                      />
                    ))}
                  </View>
                  <Text style={styles.ratingCount}>
                    ({supplier.ratings?.length || 0} ƒë√°nh gi√°)
                  </Text>
                </>
              ) : (
                <Text style={styles.emptyText}>Ch∆∞a c√≥ ƒë√°nh gi√° n√†o</Text>
              )}
            </View>
          </View>
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Th√¥ng tin kh√°c</Text>

          <View style={styles.infoRow}>
            <Ionicons name="time-outline" size={20} color="#666" />
            <Text style={styles.infoLabel}>Ng√†y t·∫°o:</Text>
            <Text style={styles.infoText}>
              {supplier?.createdAt
                ? new Date(
                    supplier.createdAt.seconds * 1000
                  ).toLocaleDateString('vi-VN')
                : 'N/A'}
            </Text>
          </View>

          {supplier?.updatedAt && (
            <View style={styles.infoRow}>
              <Ionicons name="refresh-outline" size={20} color="#666" />
              <Text style={styles.infoLabel}>C·∫≠p nh·∫≠t:</Text>
              <Text style={styles.infoText}>
                {new Date(supplier.updatedAt.seconds * 1000).toLocaleDateString(
                  'vi-VN'
                )}
              </Text>
            </View>
          )}

          {supplier?.createdByName && (
            <View style={styles.infoRow}>
              <Ionicons name="person-add-outline" size={20} color="#666" />
              <Text style={styles.infoLabel}>Ng∆∞·ªùi t·∫°o:</Text>
              <Text style={styles.infoText}>{supplier.createdByName}</Text>
            </View>
          )}
        </View>

        <View style={styles.actionButtons}>
          <TouchableOpacity
            style={[styles.actionButton, styles.editButton]}
            onPress={handleEdit}
          >
            <Ionicons name="create-outline" size={20} color="#fff" />
            <Text style={styles.actionButtonText}>Ch·ªânh s·ª≠a</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={[styles.actionButton, styles.deleteButton]}
            onPress={handleDelete}
          >
            <Ionicons name="trash-outline" size={20} color="#fff" />
            <Text style={styles.actionButtonText}>X√≥a</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  loadingText: {
    marginTop: 12,
    color: '#666',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#fff',
    paddingVertical: 16,
    paddingHorizontal: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  content: {
    flex: 1,
    padding: 16,
  },
  supplierHeader: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  supplierNameContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 12,
  },
  supplierName: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
    flex: 1,
  },
  verifiedBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#4caf50',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  verifiedText: {
    color: '#fff',
    fontSize: 12,
    marginLeft: 4,
  },
  categoriesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  categoryTag: {
    backgroundColor: '#f0f0f0',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    marginRight: 8,
    marginBottom: 8,
  },
  categoryText: {
    color: '#666',
    fontSize: 12,
  },
  section: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    marginBottom: 16,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
    paddingBottom: 8,
  },
  infoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  infoLabel: {
    width: 100,
    color: '#666',
    fontSize: 14,
    marginLeft: 8,
  },
  infoText: {
    flex: 1,
    color: '#333',
    fontSize: 14,
  },
  linkText: {
    color: '#0066cc',
  },
  descriptionText: {
    color: '#333',
    fontSize: 14,
    lineHeight: 20,
  },
  emptyText: {
    color: '#999',
    fontStyle: 'italic',
    textAlign: 'center',
    marginVertical: 8,
  },
  ratingContainer: {
    alignItems: 'center',
  },
  ratingStars: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  ratingValue: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginRight: 8,
  },
  starsContainer: {
    flexDirection: 'row',
    marginRight: 8,
  },
  ratingCount: {
    color: '#666',
    fontSize: 12,
  },
  actionButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 30,
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    borderRadius: 8,
    flex: 1,
    marginHorizontal: 4,
  },
  editButton: {
    backgroundColor: '#0066cc',
  },
  deleteButton: {
    backgroundColor: '#ff3b30',
  },
  actionButtonText: {
    color: '#fff',
    fontWeight: '600',
    marginLeft: 8,
  },
});

export default SupplierDetailScreen;


--- END: src\screens\SupplierDetailScreen.js ---


--- START: src\screens\SupplierManagementScreen.js ---
// src/screens/SupplierManagementScreen.js
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  TextInput,
  Alert,
  ActivityIndicator,
  SafeAreaView,
  Modal,
  ScrollView,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';
import {
  getAllSuppliers,
  deleteSupplier,
  searchSuppliers,
} from '../api/supplierService';
import { useAuth } from '../contexts/AuthContext';

const SupplierManagementScreen = ({ navigation }) => {
  const { currentUser } = useAuth();
  const [suppliers, setSuppliers] = useState([]);
  const [filteredSuppliers, setFilteredSuppliers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState('');
  const [refreshing, setRefreshing] = useState(false);
  const [showFilterModal, setShowFilterModal] = useState(false);
  const [selectedCategory, setSelectedCategory] = useState(null);
  const [categories, setCategories] = useState([]);

  // L·∫•y danh s√°ch nh√† cung c·∫•p
  const loadSuppliers = useCallback(async () => {
    try {
      setLoading(true);
      const data = await getAllSuppliers();
      setSuppliers(data);
      setFilteredSuppliers(data);

      // Tr√≠ch xu·∫•t danh s√°ch c√°c danh m·ª•c t·ª´ nh√† cung c·∫•p
      const allCategories = new Set();
      data.forEach((supplier) => {
        if (supplier.categories && Array.isArray(supplier.categories)) {
          supplier.categories.forEach((category) =>
            allCategories.add(category)
          );
        }
      });
      setCategories(Array.from(allCategories));
    } catch (error) {
      console.error('L·ªói khi t·∫£i danh s√°ch nh√† cung c·∫•p:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch nh√† cung c·∫•p');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  }, []);

  // T·∫£i l·∫°i danh s√°ch khi m√†n h√¨nh ƒë∆∞·ª£c focus
  useFocusEffect(
    useCallback(() => {
      loadSuppliers();
    }, [loadSuppliers])
  );

  // X·ª≠ l√Ω t√¨m ki·∫øm
  const handleSearch = async (text) => {
    setSearchQuery(text);

    if (!text.trim()) {
      setFilteredSuppliers(suppliers);
      return;
    }

    try {
      const results = await searchSuppliers(text);
      setFilteredSuppliers(results);
    } catch (error) {
      console.error('L·ªói khi t√¨m ki·∫øm:', error);
    }
  };

  // X·ª≠ l√Ω refresh
  const handleRefresh = () => {
    setRefreshing(true);
    loadSuppliers();
  };

  // X·ª≠ l√Ω x√≥a nh√† cung c·∫•p
  const handleDeleteSupplier = (supplier) => {
    Alert.alert(
      'X√°c nh·∫≠n x√≥a',
      `B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a nh√† cung c·∫•p "${supplier.name}" kh√¥ng?`,
      [
        { text: 'H·ªßy', style: 'cancel' },
        {
          text: 'X√≥a',
          style: 'destructive',
          onPress: async () => {
            try {
              await deleteSupplier(supplier.id);
              Alert.alert('Th√†nh c√¥ng', 'ƒê√£ x√≥a nh√† cung c·∫•p');
              loadSuppliers();
            } catch (error) {
              console.error('L·ªói khi x√≥a nh√† cung c·∫•p:', error);
              Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ x√≥a nh√† cung c·∫•p');
            }
          },
        },
      ]
    );
  };

  // X·ª≠ l√Ω l·ªçc theo danh m·ª•c
  const handleFilterByCategory = (category) => {
    setSelectedCategory(category);
    setShowFilterModal(false);

    if (!category) {
      setFilteredSuppliers(suppliers);
      return;
    }

    const filtered = suppliers.filter(
      (supplier) =>
        supplier.categories &&
        Array.isArray(supplier.categories) &&
        supplier.categories.includes(category)
    );

    setFilteredSuppliers(filtered);
  };

  // Hi·ªÉn th·ªã item nh√† cung c·∫•p
  const renderSupplierItem = ({ item }) => (
    <TouchableOpacity
      style={styles.supplierCard}
      onPress={() =>
        navigation.navigate('SupplierDetail', { supplierId: item.id })
      }
    >
      <View style={styles.supplierHeader}>
        <Text style={styles.supplierName}>{item.name}</Text>
        {item.verified && (
          <View style={styles.verifiedBadge}>
            <Ionicons name="checkmark-circle" size={16} color="#fff" />
            <Text style={styles.verifiedText}>ƒê√£ x√°c minh</Text>
          </View>
        )}
      </View>

      <View style={styles.supplierInfo}>
        {item.contactName && (
          <View style={styles.infoRow}>
            <Ionicons name="person-outline" size={16} color="#666" />
            <Text style={styles.infoText}>{item.contactName}</Text>
          </View>
        )}

        {item.phone && (
          <View style={styles.infoRow}>
            <Ionicons name="call-outline" size={16} color="#666" />
            <Text style={styles.infoText}>{item.phone}</Text>
          </View>
        )}

        {item.email && (
          <View style={styles.infoRow}>
            <Ionicons name="mail-outline" size={16} color="#666" />
            <Text style={styles.infoText}>{item.email}</Text>
          </View>
        )}

        {item.address && (
          <View style={styles.infoRow}>
            <Ionicons name="location-outline" size={16} color="#666" />
            <Text style={styles.infoText} numberOfLines={1}>
              {item.address}
            </Text>
          </View>
        )}
      </View>

      {item.categories && item.categories.length > 0 && (
        <View style={styles.categoriesContainer}>
          {item.categories.map((category, index) => (
            <View key={index} style={styles.categoryTag}>
              <Text style={styles.categoryText}>{category}</Text>
            </View>
          ))}
        </View>
      )}

      <View style={styles.supplierActions}>
        <TouchableOpacity
          style={styles.actionButton}
          onPress={() =>
            navigation.navigate('EditSupplier', { supplier: item })
          }
        >
          <Ionicons name="create-outline" size={18} color="#0066cc" />
          <Text style={[styles.actionText, { color: '#0066cc' }]}>S·ª≠a</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.actionButton}
          onPress={() => handleDeleteSupplier(item)}
        >
          <Ionicons name="trash-outline" size={18} color="#ff3b30" />
          <Text style={[styles.actionText, { color: '#ff3b30' }]}>X√≥a</Text>
        </TouchableOpacity>
      </View>
    </TouchableOpacity>
  );

  // Hi·ªÉn th·ªã modal l·ªçc
  const renderFilterModal = () => (
    <Modal
      visible={showFilterModal}
      transparent
      animationType="slide"
      onRequestClose={() => setShowFilterModal(false)}
    >
      <View style={styles.modalOverlay}>
        <View style={styles.modalContainer}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>L·ªçc theo danh m·ª•c</Text>
            <TouchableOpacity onPress={() => setShowFilterModal(false)}>
              <Ionicons name="close" size={24} color="#666" />
            </TouchableOpacity>
          </View>

          <ScrollView style={styles.modalContent}>
            <TouchableOpacity
              style={[
                styles.categoryItem,
                !selectedCategory && styles.selectedCategoryItem,
              ]}
              onPress={() => handleFilterByCategory(null)}
            >
              <Text
                style={[
                  styles.categoryItemText,
                  !selectedCategory && styles.selectedCategoryText,
                ]}
              >
                T·∫•t c·∫£ danh m·ª•c
              </Text>
              {!selectedCategory && (
                <Ionicons name="checkmark" size={18} color="#0066cc" />
              )}
            </TouchableOpacity>

            {categories.map((category, index) => (
              <TouchableOpacity
                key={index}
                style={[
                  styles.categoryItem,
                  selectedCategory === category && styles.selectedCategoryItem,
                ]}
                onPress={() => handleFilterByCategory(category)}
              >
                <Text
                  style={[
                    styles.categoryItemText,
                    selectedCategory === category &&
                      styles.selectedCategoryText,
                  ]}
                >
                  {category}
                </Text>
                {selectedCategory === category && (
                  <Ionicons name="checkmark" size={18} color="#0066cc" />
                )}
              </TouchableOpacity>
            ))}
          </ScrollView>
        </View>
      </View>
    </Modal>
  );

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.headerTitle}>Qu·∫£n l√Ω nh√† cung c·∫•p</Text>
      </View>

      <View style={styles.searchContainer}>
        <View style={styles.searchBar}>
          <Ionicons
            name="search"
            size={20}
            color="#999"
            style={styles.searchIcon}
          />
          <TextInput
            style={styles.searchInput}
            placeholder="T√¨m ki·∫øm nh√† cung c·∫•p..."
            value={searchQuery}
            onChangeText={handleSearch}
          />
          {searchQuery ? (
            <TouchableOpacity onPress={() => handleSearch('')}>
              <Ionicons name="close-circle" size={20} color="#999" />
            </TouchableOpacity>
          ) : null}
        </View>

        <TouchableOpacity
          style={styles.filterButton}
          onPress={() => setShowFilterModal(true)}
        >
          <Ionicons name="filter" size={20} color="#fff" />
        </TouchableOpacity>
      </View>

      {selectedCategory && (
        <View style={styles.activeFilterContainer}>
          <Text style={styles.activeFilterText}>
            ƒêang l·ªçc: {selectedCategory}
          </Text>
          <TouchableOpacity onPress={() => handleFilterByCategory(null)}>
            <Ionicons name="close-circle" size={18} color="#666" />
          </TouchableOpacity>
        </View>
      )}

      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#0066cc" />
          <Text style={styles.loadingText}>ƒêang t·∫£i d·ªØ li·ªáu...</Text>
        </View>
      ) : (
        <FlatList
          data={filteredSuppliers}
          renderItem={renderSupplierItem}
          keyExtractor={(item) => item.id}
          contentContainerStyle={styles.listContainer}
          refreshing={refreshing}
          onRefresh={handleRefresh}
          ListEmptyComponent={
            <View style={styles.emptyContainer}>
              <Ionicons name="business-outline" size={48} color="#ccc" />
              <Text style={styles.emptyText}>
                {searchQuery
                  ? 'Kh√¥ng t√¨m th·∫•y nh√† cung c·∫•p n√†o ph√π h·ª£p'
                  : 'Ch∆∞a c√≥ nh√† cung c·∫•p n√†o'}
              </Text>
            </View>
          }
        />
      )}

      <TouchableOpacity
        style={styles.addButton}
        onPress={() => navigation.navigate('AddSupplier')}
      >
        <Ionicons name="add" size={24} color="#fff" />
      </TouchableOpacity>

      {renderFilterModal()}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  header: {
    backgroundColor: '#fff',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  searchContainer: {
    flexDirection: 'row',
    padding: 12,
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  searchBar: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
    borderRadius: 8,
    paddingHorizontal: 12,
    marginRight: 8,
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    height: 40,
    fontSize: 16,
  },
  filterButton: {
    backgroundColor: '#0066cc',
    width: 40,
    height: 40,
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center',
  },
  activeFilterContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#e6f2ff',
    padding: 8,
    marginHorizontal: 12,
    marginTop: 8,
    borderRadius: 4,
    justifyContent: 'space-between',
  },
  activeFilterText: {
    color: '#0066cc',
    fontSize: 14,
  },
  listContainer: {
    padding: 12,
  },
  supplierCard: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 16,
    marginBottom: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  supplierHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  supplierName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    flex: 1,
  },
  verifiedBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#4caf50',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  verifiedText: {
    color: '#fff',
    fontSize: 12,
    marginLeft: 4,
  },
  supplierInfo: {
    marginBottom: 12,
  },
  infoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 6,
  },
  infoText: {
    marginLeft: 8,
    color: '#666',
    fontSize: 14,
  },
  categoriesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 12,
  },
  categoryTag: {
    backgroundColor: '#f0f0f0',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    marginRight: 8,
    marginBottom: 8,
  },
  categoryText: {
    color: '#666',
    fontSize: 12,
  },
  supplierActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    borderTopWidth: 1,
    borderTopColor: '#f0f0f0',
    paddingTop: 12,
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 6,
    marginLeft: 8,
  },
  actionText: {
    marginLeft: 4,
    fontSize: 14,
    fontWeight: '500',
  },
  addButton: {
    position: 'absolute',
    right: 20,
    bottom: 20,
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: '#0066cc',
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 12,
    color: '#666',
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 40,
  },
  emptyText: {
    marginTop: 12,
    color: '#666',
    textAlign: 'center',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    width: '80%',
    backgroundColor: '#fff',
    borderRadius: 8,
    overflow: 'hidden',
    maxHeight: '70%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  modalTitle: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  modalContent: {
    padding: 16,
    maxHeight: 300,
  },
  categoryItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  selectedCategoryItem: {
    backgroundColor: '#e6f2ff',
  },
  categoryItemText: {
    fontSize: 14,
    color: '#333',
  },
  selectedCategoryText: {
    color: '#0066cc',
    fontWeight: '500',
  },
});

export default SupplierManagementScreen;


--- END: src\screens\SupplierManagementScreen.js ---


--- START: src\screens\TaskDetailScreen.js ---
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  SafeAreaView,
  ActivityIndicator,
  Alert,
  ScrollView,
  Linking,
  Share,
} from 'react-native';
import {
  useRoute,
  useNavigation,
  useFocusEffect,
} from '@react-navigation/native';
import { doc, getDoc } from 'firebase/firestore';
import { db } from '../config/firebaseConfig';
import { useTheme } from '../contexts/ThemeContext';
import { updateTaskStatus, assignTaskToUser } from '../api/projectService'; // Added assignTaskToUser import
import { Ionicons } from '@expo/vector-icons';
import {
  getTaskDisplayLabel,
  getStatusDisplayLabel,
  getStatusColor,
} from '../utils/taskHelpers';
import TaskAssignmentModal from '../components/TaskAssignmentModal'; // Import the modal component
import MediaInstructionsViewer from '../components/MediaInstructionsViewer';

const TaskDetailScreen = () => {
  const route = useRoute();
  const navigation = useNavigation();
  const { theme } = useTheme();
  const { projectId, taskKey } = route.params;

  const [project, setProject] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isUpdating, setIsUpdating] = useState(false);
  const [shareSuccess, setShareSuccess] = useState(false);
  const [isAssignmentModalVisible, setIsAssignmentModalVisible] =
    useState(false); // New state for modal visibility

  const fetchProjectDetails = useCallback(async () => {
    try {
      setLoading(true);
      const projectRef = doc(db, 'projects', projectId);
      const projectSnap = await getDoc(projectRef);

      if (projectSnap.exists()) {
        setProject({ id: projectSnap.id, ...projectSnap.data() });
      } else {
        setError('Kh√¥ng t√¨m th·∫•y th√¥ng tin d·ª± √°n.');
      }
    } catch (err) {
      console.error('Error fetching project details for task:', err);
      setError('L·ªói khi t·∫£i d·ªØ li·ªáu d·ª± √°n.');
    } finally {
      setLoading(false);
    }
  }, [projectId]);

  useEffect(() => {
    fetchProjectDetails();
  }, [fetchProjectDetails]);

  // Refresh project data when screen comes into focus to ensure media instructions are up to date
  useFocusEffect(
    useCallback(() => {
      fetchProjectDetails();
    }, [fetchProjectDetails])
  );

  const handleCompleteTask = async () => {
    setIsUpdating(true);
    try {
      await updateTaskStatus(projectId, taskKey, 'completed');
      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i c√¥ng vi·ªác.', [
        { text: 'OK', onPress: () => navigation.goBack() },
      ]);
    } catch (err) {
      console.error('Error updating task status:', err);
      Alert.alert(
        'L·ªói',
        err.message || 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i c√¥ng vi·ªác.'
      );
    } finally {
      setIsUpdating(false);
    }
  };

  const handleOpenDriveFolder = () => {
    if (project?.driveFolderUrl) {
      Linking.openURL(project.driveFolderUrl);
    } else {
      Alert.alert('Th√¥ng b√°o', 'Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c Drive cho d·ª± √°n n√†y.');
    }
  };

  const handleShareDriveLink = async () => {
    if (project?.driveFolderUrl) {
      try {
        await Share.share({
          message: project.driveFolderUrl,
        });
        setShareSuccess(true);

        // Reset success message after 2 seconds
        setTimeout(() => {
          setShareSuccess(false);
        }, 2000);
      } catch (error) {
        console.error('Error sharing link:', error);
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ chia s·∫ª ƒë∆∞·ªùng d·∫´n.');
      }
    } else {
      Alert.alert('Th√¥ng b√°o', 'Kh√¥ng c√≥ ƒë∆∞·ªùng d·∫´n Drive ƒë·ªÉ chia s·∫ª.');
    }
  };

  // New function to handle task assignment
  const handleAssignTask = (userId, userName) => {
    setIsUpdating(true);
    assignTaskToUser(projectId, taskKey, userId, userName)
      .then(() => {
        // Update the local project state to reflect the change
        setProject((prevProject) => {
          if (!prevProject || !prevProject.tasks) return prevProject;

          const updatedTasks = { ...prevProject.tasks };
          updatedTasks[taskKey] = {
            ...updatedTasks[taskKey],
            assignedTo: userId,
            assignedToName: userName,
          };

          return {
            ...prevProject,
            tasks: updatedTasks,
          };
        });

        Alert.alert('Th√†nh c√¥ng', 'ƒê√£ ph√¢n c√¥ng c√¥ng vi·ªác cho ' + userName);
      })
      .catch((error) => {
        console.error('Error assigning task:', error);
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ph√¢n c√¥ng c√¥ng vi·ªác: ' + error.message);
      })
      .finally(() => {
        setIsAssignmentModalVisible(false);
        setIsUpdating(false);
      });
  };

  if (loading) {
    return (
      <View
        style={[styles.centerContainer, { backgroundColor: theme.background }]}
      >
        <ActivityIndicator size="large" color={theme.primary} />
      </View>
    );
  }

  if (error) {
    return (
      <View
        style={[styles.centerContainer, { backgroundColor: theme.background }]}
      >
        <Text style={{ color: theme.text }}>{error}</Text>
      </View>
    );
  }

  const task = project?.tasks?.[taskKey];
  const taskLabel = getTaskDisplayLabel(taskKey, task);
  const statusLabel = getStatusDisplayLabel(task?.status);
  const statusColor = getStatusColor(task?.status, theme);

  // Find the related workflow stage for this task
  const relatedStage = project?.workflowStages?.find(
    (stage) =>
      stage.stageId === task?.stageId ||
      stage.processKey === taskKey ||
      stage.processName?.toLowerCase().includes(taskKey.replace('_', ' '))
  );

  // Extract media instructions from the related stage
  const hasMediaInstructions =
    relatedStage &&
    (relatedStage.instructionNotes ||
      (relatedStage.instructionImages &&
        relatedStage.instructionImages.length > 0) ||
      relatedStage.instructionAudio);

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <View style={styles.header}>
        <TouchableOpacity
          onPress={() => navigation.goBack()}
          style={styles.backButton}
        >
          <Ionicons name="arrow-back" size={28} color={theme.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Chi ti·∫øt C√¥ng vi·ªác
        </Text>
      </View>

      <ScrollView style={styles.content}>
        <View style={[styles.card, { backgroundColor: theme.card }]}>
          <Text style={[styles.sectionTitle, { color: theme.textSecondary }]}>
            C√¥ng vi·ªác
          </Text>
          <Text style={[styles.taskName, { color: theme.text }]}>
            {taskLabel}
          </Text>
          <View style={styles.statusContainer}>
            <Text style={[styles.detailText, { color: theme.textSecondary }]}>
              Tr·∫°ng th√°i:{' '}
            </Text>
            <Text style={[styles.statusText, { color: statusColor }]}>
              {statusLabel}
            </Text>
          </View>

          {/* Display assigned user if available */}
          {task?.assignedTo && (
            <View style={styles.assignedContainer}>
              <Text style={[styles.detailText, { color: theme.textSecondary }]}>
                ƒê√£ giao cho:{' '}
              </Text>
              <View style={styles.assignedUser}>
                <View style={styles.userAvatar}>
                  <Text style={styles.avatarText}>
                    {(task.assignedToName || '?').charAt(0).toUpperCase()}
                  </Text>
                </View>
                <Text style={[styles.assignedUserName, { color: theme.text }]}>
                  {task.assignedToName || 'Ng∆∞·ªùi d√πng kh√¥ng x√°c ƒë·ªãnh'}
                </Text>
              </View>
            </View>
          )}

          {/* Add assign task button */}
          <TouchableOpacity
            style={[styles.assignButton, { backgroundColor: theme.primary }]}
            onPress={() => setIsAssignmentModalVisible(true)}
          >
            <Ionicons
              name="person-add"
              size={18}
              color="#fff"
              style={styles.buttonIcon}
            />
            <Text style={styles.assignButtonText}>
              {task?.assignedTo ? 'Thay ƒë·ªïi ng∆∞·ªùi th·ª±c hi·ªán' : 'Giao c√¥ng vi·ªác'}
            </Text>
          </TouchableOpacity>
        </View>

        <View style={[styles.card, { backgroundColor: theme.card }]}>
          <Text style={[styles.sectionTitle, { color: theme.textSecondary }]}>
            Thu·ªôc d·ª± √°n
          </Text>
          <Text style={[styles.detailText, { color: theme.text }]}>
            T√™n d·ª± √°n: {project?.name}
          </Text>
          <Text style={[styles.detailText, { color: theme.text }]}>
            Kh√°ch h√†ng: {project?.customerName || 'Kh√¥ng c√≥'}
          </Text>

          {project?.driveFolderUrl && (
            <View style={styles.driveLinkContainer}>
              <TouchableOpacity
                style={[
                  styles.driveLinkButton,
                  { backgroundColor: theme.primary },
                ]}
                onPress={handleOpenDriveFolder}
              >
                <Ionicons
                  name="folder-open"
                  size={18}
                  color="#fff"
                  style={styles.buttonIcon}
                />
                <Text style={styles.driveLinkText}>M·ªü th∆∞ m·ª•c Drive</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[
                  styles.shareButton,
                  {
                    backgroundColor: shareSuccess
                      ? theme.success
                      : theme.secondary,
                  },
                ]}
                onPress={handleShareDriveLink}
                accessibilityLabel="Chia s·∫ª ƒë∆∞·ªùng d·∫´n th∆∞ m·ª•c"
              >
                <Ionicons
                  name={shareSuccess ? 'checkmark' : 'share'}
                  size={20}
                  color="#fff"
                />
              </TouchableOpacity>
            </View>
          )}
        </View>

        {/* Media Instructions Section */}
        {hasMediaInstructions && (
          <MediaInstructionsViewer
            instructionImages={relatedStage.instructionImages || []}
            instructionNotes={relatedStage.instructionNotes || ''}
            instructionAudio={relatedStage.instructionAudio || null}
            visible={true}
          />
        )}
      </ScrollView>

      <View style={styles.footer}>
        <TouchableOpacity
          style={[
            styles.completeButton,
            {
              backgroundColor:
                task?.status === 'completed' || isUpdating
                  ? theme.textMuted
                  : theme.success || '#28a745',
            },
          ]}
          onPress={handleCompleteTask}
          disabled={task?.status === 'completed' || isUpdating}
        >
          {isUpdating ? (
            <ActivityIndicator color="#fff" />
          ) : (
            <Text style={styles.buttonText}>
              {task?.status === 'completed'
                ? 'ƒê√£ ho√†n th√†nh'
                : 'Ho√†n th√†nh c√¥ng vi·ªác'}
            </Text>
          )}
        </TouchableOpacity>
      </View>

      {/* Task Assignment Modal */}
      <TaskAssignmentModal
        visible={isAssignmentModalVisible}
        onClose={() => setIsAssignmentModalVisible(false)}
        onAssign={handleAssignTask}
        taskName={taskLabel}
        currentAssignee={task?.assignedTo}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1 },
  centerContainer: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#333',
  },
  backButton: { padding: 5 },
  headerTitle: { fontSize: 22, fontWeight: 'bold', marginLeft: 16 },
  content: { flex: 1, padding: 16 },
  card: {
    padding: 20,
    borderRadius: 12,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: '#333',
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 12,
    color: '#888',
  },
  taskName: { fontSize: 26, fontWeight: 'bold', marginBottom: 10 },
  statusContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  statusText: { fontSize: 16, fontWeight: 'bold' },
  detailText: { fontSize: 16, lineHeight: 24 },
  footer: { padding: 16, borderTopWidth: 1, borderTopColor: '#333' },
  completeButton: {
    paddingVertical: 15,
    borderRadius: 12,
    alignItems: 'center',
  },
  buttonText: { color: '#fff', fontSize: 18, fontWeight: 'bold' },
  driveLinkContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 16,
  },
  driveLinkButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 8,
    flex: 1,
  },
  driveLinkText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 16,
  },
  buttonIcon: {
    marginRight: 8,
  },
  shareButton: {
    marginLeft: 12,
    width: 44,
    height: 44,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  // New styles for assigned user
  assignedContainer: {
    marginTop: 8,
    marginBottom: 16,
  },
  assignedUser: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 8,
    backgroundColor: 'rgba(0, 102, 204, 0.05)',
    padding: 12,
    borderRadius: 8,
  },
  userAvatar: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: '#0066cc',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  avatarText: {
    color: '#fff',
    fontWeight: 'bold',
    fontSize: 16,
  },
  assignedUserName: {
    fontSize: 16,
    fontWeight: '500',
  },
  assignButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    borderRadius: 8,
    marginTop: 8,
  },
  assignButtonText: {
    color: '#fff',
    fontWeight: '600',
    fontSize: 16,
  },
});

export default TaskDetailScreen;


--- END: src\screens\TaskDetailScreen.js ---


--- START: src\screens\TaskReportScreen.js ---
//src/screens/TaskReportScreen.js
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  FlatList,
  StyleSheet,
  ActivityIndicator,
  TouchableOpacity,
  SafeAreaView,
  ScrollView,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';
import {
  collection,
  query,
  where,
  getDocs,
  orderBy,
  doc,
  getDoc,
  onSnapshot,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';
import {
  fetchPendingLeaveRequests,
  fetchPendingAdvanceRequests,
  updateLeaveRequestStatus,
  updateAdvanceRequestStatus,
} from '../api/requestService';
import { useAuth } from '../contexts/AuthContext';
import { useTheme } from '../contexts/ThemeContext';

const TaskCard = ({ item, onPress, theme }) => {
  const getStatusColor = (status) => {
    switch (status) {
      case 'completed':
        return { bg: 'rgba(46, 204, 113, 0.2)', text: '#27AE60' };
      case 'in_progress':
        return { bg: 'rgba(52, 152, 219, 0.2)', text: '#2980B9' };
      case 'pending':
        return { bg: 'rgba(241, 196, 15, 0.2)', text: '#F39C12' };
      default:
        return { bg: theme.border, text: theme.textSecondary };
    }
  };

  const getStatusLabel = (status) => {
    switch (status) {
      case 'completed':
        return 'Ho√†n th√†nh';
      case 'in_progress':
        return 'ƒêang th·ª±c hi·ªán';
      case 'pending':
        return 'Ch·ªù x·ª≠ l√Ω';
      default:
        return 'Kh√¥ng x√°c ƒë·ªãnh';
    }
  };

  const statusStyle = getStatusColor(item.status);

  return (
    <TouchableOpacity
      style={[styles.card, { backgroundColor: theme.card }]}
      onPress={onPress}
    >
      <View style={styles.cardHeader}>
        <Text
          style={[styles.taskLabel, { color: theme.text }]}
          numberOfLines={1}
        >
          {item.taskLabel}
        </Text>
        <View style={[styles.statusBadge, { backgroundColor: statusStyle.bg }]}>
          <Text style={[styles.statusText, { color: statusStyle.text }]}>
            {getStatusLabel(item.status)}
          </Text>
        </View>
      </View>
      <View style={styles.cardBody}>
        <Text style={[styles.projectName, { color: theme.textSecondary }]}>
          D·ª± √°n: {item.projectName}
        </Text>
        <Text style={[styles.assignedTo, { color: theme.textSecondary }]}>
          Ph·ª• tr√°ch: {item.assignedToName}
        </Text>

        {/* Media Instructions Indicators */}
        {(item.hasInstructions || item.hasImages || item.hasAudio) && (
          <View style={styles.mediaIndicators}>
            <Text style={[styles.mediaLabel, { color: theme.textSecondary }]}>
              H∆∞·ªõng d·∫´n:
            </Text>
            {item.hasInstructions && (
              <View style={styles.mediaIcon}>
                <Ionicons name="document-text" size={16} color="#0066cc" />
              </View>
            )}
            {item.hasImages && (
              <View style={styles.mediaIcon}>
                <Ionicons name="image" size={16} color="#0066cc" />
              </View>
            )}
            {item.hasAudio && (
              <View style={styles.mediaIcon}>
                <Ionicons name="volume-high" size={16} color="#0066cc" />
              </View>
            )}
          </View>
        )}
      </View>
    </TouchableOpacity>
  );
};

const TaskReportScreen = ({ navigation }) => {
  const { currentUser } = useAuth();
  const { theme } = useTheme();

  // Common states
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // States for Manager View
  const [myTasks, setMyTasks] = useState([]);
  const [staffPendingTasks, setStaffPendingTasks] = useState([]);
  const [staffCompletedTasks, setStaffCompletedTasks] = useState([]);
  const [pendingRequests, setPendingRequests] = useState([]);
  const [pendingLeave, setPendingLeave] = useState([]);
  const [pendingAdvance, setPendingAdvance] = useState([]);

  // State for manager tabs
  const [activeManagerView, setActiveManagerView] = useState('my_tasks'); // 'my_tasks', 'staff_pending', 'staff_completed', 'requests'

  // States for Staff View
  const [tasks, setTasks] = useState([]);
  const [filteredTasks, setFilteredTasks] = useState([]);
  const [activeFilter, setActiveFilter] = useState('all');

  const isManager = ['giam_doc', 'pho_giam_doc', 'admin'].includes(
    currentUser?.role
  );

  const formatDateSafe = (value) => {
    if (!value) return '';
    const d = value.toDate ? value.toDate() : new Date(value);
    if (isNaN(d.getTime())) return '';
    return d.toLocaleDateString('vi-VN');
  };

  const fetchManagerTasks = async () => {
    setLoading(true);
    setError(null);
    try {
      const tasksCollection = collection(db, 'tasks');

      // 1. My tasks (pending or in-progress)
      const myTasksQuery = query(
        tasksCollection,
        where('assignedToId', '==', currentUser.uid),
        where('status', 'in', ['pending', 'in_progress'])
      );
      const myTasksSnapshot = await getDocs(myTasksQuery);
      setMyTasks(
        myTasksSnapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }))
      );

      // 2. Staff pending tasks
      const staffPendingQuery = query(
        tasksCollection,
        where('assignedToId', '!=', currentUser.uid),
        where('status', 'in', ['pending', 'in_progress'])
      );
      const staffPendingSnapshot = await getDocs(staffPendingQuery);
      setStaffPendingTasks(
        staffPendingSnapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }))
      );

      // 3. Staff completed tasks
      const staffCompletedQuery = query(
        tasksCollection,
        where('assignedToId', '!=', currentUser.uid),
        where('status', '==', 'completed')
      );
      const staffCompletedSnapshot = await getDocs(staffCompletedQuery);
      setStaffCompletedTasks(
        staffCompletedSnapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        }))
      );

      // 4. Initial pending requests (leave + advance)
      const [leaveReqs, advanceReqs] = await Promise.all([
        fetchPendingLeaveRequests(),
        fetchPendingAdvanceRequests(),
      ]);
      setPendingLeave(leaveReqs);
      setPendingAdvance(advanceReqs);
      setPendingRequests([...leaveReqs, ...advanceReqs]);
    } catch (err) {
      console.error('Error fetching manager tasks:', err);
      setError('Kh√¥ng th·ªÉ t·∫£i b√°o c√°o c√¥ng vi·ªác.');
    } finally {
      setLoading(false);
    }
  };

  // Realtime badges for pending requests
  useEffect(() => {
    if (!isManager) return;
    const leaveQ = query(
      collection(db, 'leave_requests'),
      where('status', '==', 'pending')
    );
    const advQ = query(
      collection(db, 'advance_requests'),
      where('status', '==', 'pending')
    );

    const un1 = onSnapshot(leaveQ, (snap) => {
      const items = snap.docs.map((d) => ({
        id: d.id,
        ...d.data(),
        requestType: 'leave',
      }));
      setPendingLeave(items);
    });
    const un2 = onSnapshot(advQ, (snap) => {
      const items = snap.docs.map((d) => ({
        id: d.id,
        ...d.data(),
        requestType: 'advance',
      }));
      setPendingAdvance(items);
    });
    return () => {
      un1();
      un2();
    };
  }, [isManager]);

  useEffect(() => {
    if (isManager) {
      setPendingRequests([...(pendingLeave || []), ...(pendingAdvance || [])]);
    }
  }, [pendingLeave, pendingAdvance, isManager]);

  const fetchStaffTasks = async () => {
    setLoading(true);
    setError(null);
    try {
      const tasksCollection = collection(db, 'tasks');
      const tasksQuery = query(
        tasksCollection,
        where('assignedToId', '==', currentUser.uid),
        orderBy('updatedAt', 'desc')
      );

      const querySnapshot = await getDocs(tasksQuery);
      const fetchedTasks = await Promise.all(
        querySnapshot.docs.map(async (taskDoc) => {
          const taskData = { id: taskDoc.id, ...taskDoc.data() };

          // Fetch project data to get workflow stage instructions
          if (taskData.projectId) {
            try {
              const projectRef = doc(db, 'projects', taskData.projectId);
              const projectSnap = await getDoc(projectRef);

              if (projectSnap.exists()) {
                const projectData = projectSnap.data();

                // Find related workflow stage
                const relatedStage = projectData.workflowStages?.find(
                  (stage) =>
                    stage.stageId === taskData.stageId ||
                    stage.processKey === taskData.taskKey ||
                    stage.processName
                      ?.toLowerCase()
                      .includes(taskData.taskKey?.replace('_', ' '))
                );

                if (relatedStage) {
                  // Add media instruction flags
                  taskData.hasInstructions = !!relatedStage.instructionNotes;
                  taskData.hasImages = !!(
                    relatedStage.instructionImages &&
                    relatedStage.instructionImages.length > 0
                  );
                  taskData.hasAudio = !!relatedStage.instructionAudio;
                }
              }
            } catch (projectError) {
              console.error(
                'Error fetching project for task:',
                taskData.id,
                projectError
              );
            }
          }

          return taskData;
        })
      );

      setTasks(fetchedTasks);
      setFilteredTasks(fetchedTasks);
    } catch (err) {
      console.error('Error fetching tasks:', err);
      setError('Kh√¥ng th·ªÉ t·∫£i danh s√°ch c√¥ng vi·ªác.');
    } finally {
      setLoading(false);
    }
  };

  useFocusEffect(
    useCallback(() => {
      if (isManager) {
        fetchManagerTasks();
      } else {
        fetchStaffTasks();
      }
    }, [currentUser, isManager])
  );

  useEffect(() => {
    if (!isManager) {
      if (activeFilter === 'all') {
        setFilteredTasks(tasks);
      } else {
        const filtered = tasks.filter((task) => task.status === activeFilter);
        setFilteredTasks(filtered);
      }
    }
  }, [activeFilter, tasks, isManager]);

  const handleTaskPress = (item) => {
    if (isManager) {
      // Managers go to the full project detail screen
      navigation.navigate('ProjectDetail', { projectId: item.projectId });
    } else {
      // Staff go to the dedicated, simplified task detail screen
      navigation.navigate('TaskDetail', {
        projectId: item.projectId,
        taskKey: item.taskKey,
      });
    }
  };

  // -- RENDER METHODS --

  if (loading) {
    return (
      <View
        style={[styles.centerContainer, { backgroundColor: theme.background }]}
      >
        <ActivityIndicator size="large" color={theme.primary} />
      </View>
    );
  }

  if (error) {
    return (
      <View
        style={[styles.centerContainer, { backgroundColor: theme.background }]}
      >
        <Text style={{ color: theme.text }}>{error}</Text>
      </View>
    );
  }

  const renderTaskList = (data) => {
    if (data.length === 0) {
      return (
        <View style={styles.emptySection}>
          <Text style={{ color: theme.textSecondary }}>
            Kh√¥ng c√≥ c√¥ng vi·ªác n√†o.
          </Text>
        </View>
      );
    }
    return data.map((item) => (
      <TaskCard
        key={item.id}
        item={item}
        onPress={() => handleTaskPress(item)}
        theme={theme}
      />
    ));
  };

  // Manager View
  if (isManager) {
    const renderManagerContent = () => {
      switch (activeManagerView) {
        case 'requests':
          return (
            <View>
              {pendingRequests.length === 0 ? (
                <View style={styles.emptySection}>
                  <Text style={{ color: theme.textSecondary }}>
                    Kh√¥ng c√≥ y√™u c·∫ßu n√†o ƒëang ch·ªù.
                  </Text>
                </View>
              ) : (
                pendingRequests.map((req) => (
                  <View
                    key={req.id}
                    style={[styles.card, { backgroundColor: theme.card }]}
                  >
                    <View style={styles.cardHeader}>
                      <Text style={[styles.taskLabel, { color: theme.text }]}>
                        {req.requestType === 'leave'
                          ? 'Xin ngh·ªâ ph√©p'
                          : 'Xin ·ª©ng l∆∞∆°ng'}
                      </Text>
                      <View
                        style={[
                          styles.statusBadge,
                          { backgroundColor: 'rgba(241, 196, 15, 0.2)' },
                        ]}
                      >
                        <Text style={[styles.statusText, { color: '#F39C12' }]}>
                          Ch·ªù duy·ªát
                        </Text>
                      </View>
                    </View>
                    <View>
                      <Text
                        style={{ color: theme.textSecondary, marginBottom: 4 }}
                      >
                        Nh√¢n vi√™n: {req.userName || req.userId}
                      </Text>
                      {req.requestType === 'leave' ? (
                        <Text style={{ color: theme.textSecondary }}>
                          T·ª´ ng√†y {formatDateSafe(req.startDate)} ƒë·∫øn{' '}
                          {formatDateSafe(req.endDate)} - L√Ω do: {req.reason}
                        </Text>
                      ) : (
                        <Text style={{ color: theme.textSecondary }}>
                          S·ªë ti·ªÅn:{' '}
                          {Intl.NumberFormat('vi-VN', {
                            style: 'currency',
                            currency: 'VND',
                          }).format(req.amount)}{' '}
                          - L√Ω do: {req.reason}
                        </Text>
                      )}
                    </View>
                    <View style={{ flexDirection: 'row', marginTop: 12 }}>
                      <TouchableOpacity
                        style={[
                          styles.managerTab,
                          { backgroundColor: '#27AE60', flex: 0 },
                        ]}
                        onPress={async () => {
                          try {
                            // Optimistic remove to tr√°nh full-screen reload
                            setPendingRequests((list) =>
                              list.filter((r) => r.id !== req.id)
                            );
                            if (req.requestType === 'leave') {
                              await updateLeaveRequestStatus(
                                req.id,
                                'approved'
                              );
                            } else {
                              await updateAdvanceRequestStatus(
                                req.id,
                                'approved'
                              );
                            }
                          } catch (e) {
                            console.warn('Approve failed', e);
                          }
                        }}
                      >
                        <Text style={{ color: '#fff', fontWeight: 'bold' }}>
                          Duy·ªát
                        </Text>
                      </TouchableOpacity>
                      <TouchableOpacity
                        style={[
                          styles.managerTab,
                          { backgroundColor: '#E74C3C', flex: 0 },
                        ]}
                        onPress={async () => {
                          try {
                            setPendingRequests((list) =>
                              list.filter((r) => r.id !== req.id)
                            );
                            if (req.requestType === 'leave') {
                              await updateLeaveRequestStatus(
                                req.id,
                                'rejected'
                              );
                            } else {
                              await updateAdvanceRequestStatus(
                                req.id,
                                'rejected'
                              );
                            }
                          } catch (e) {
                            console.warn('Reject failed', e);
                          }
                        }}
                      >
                        <Text style={{ color: '#fff', fontWeight: 'bold' }}>
                          T·ª´ ch·ªëi
                        </Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                ))
              )}
            </View>
          );
        case 'staff_pending':
          return renderTaskList(staffPendingTasks);
        case 'staff_completed':
          return renderTaskList(staffCompletedTasks);
        case 'my_tasks':
        default:
          return renderTaskList(myTasks);
      }
    };

    return (
      <SafeAreaView
        style={[styles.container, { backgroundColor: theme.background }]}
      >
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          B√°o c√°o C√¥ng vi·ªác
        </Text>

        {/* Manager Tabs */}
        <View style={styles.managerTabContainer}>
          <TouchableOpacity
            style={[
              styles.managerTab,
              { backgroundColor: theme.card },
              activeManagerView === 'my_tasks' && {
                backgroundColor: theme.primary,
              },
            ]}
            onPress={() => setActiveManagerView('my_tasks')}
          >
            <Text
              style={[
                styles.managerTabText,
                { color: theme.text },
                activeManagerView === 'my_tasks' && { color: '#FFFFFF' },
              ]}
            >
              Vi·ªác c·ªßa t√¥i
            </Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={[
              styles.managerTab,
              { backgroundColor: theme.card },
              activeManagerView === 'staff_pending' && {
                backgroundColor: theme.primary,
              },
            ]}
            onPress={() => setActiveManagerView('staff_pending')}
          >
            <Text
              style={[
                styles.managerTabText,
                { color: theme.text },
                activeManagerView === 'staff_pending' && { color: '#FFFFFF' },
              ]}
            >
              NV ƒêang L√†m
            </Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={[
              styles.managerTab,
              { backgroundColor: theme.card },
              activeManagerView === 'staff_completed' && {
                backgroundColor: theme.primary,
              },
            ]}
            onPress={() => setActiveManagerView('staff_completed')}
          >
            <Text
              style={[
                styles.managerTabText,
                { color: theme.text },
                activeManagerView === 'staff_completed' && { color: '#FFFFFF' },
              ]}
            >
              ƒê√£ Ho√†n Th√†nh
            </Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={[
              styles.managerTab,
              { backgroundColor: theme.card },
              activeManagerView === 'requests' && {
                backgroundColor: theme.primary,
              },
            ]}
            onPress={() => setActiveManagerView('requests')}
          >
            <View style={{ flexDirection: 'row', alignItems: 'center' }}>
              <Text
                style={[
                  styles.managerTabText,
                  { color: theme.text },
                  activeManagerView === 'requests' && { color: '#FFFFFF' },
                ]}
              >
                Y√™u c·∫ßu
              </Text>
              {pendingRequests.length > 0 && (
                <View
                  style={{
                    marginLeft: 6,
                    minWidth: 20,
                    paddingHorizontal: 6,
                    height: 20,
                    borderRadius: 10,
                    backgroundColor: '#E53935',
                    alignItems: 'center',
                    justifyContent: 'center',
                  }}
                >
                  <Text
                    style={{ color: '#fff', fontSize: 12, fontWeight: 'bold' }}
                  >
                    {pendingRequests.length}
                  </Text>
                </View>
              )}
            </View>
          </TouchableOpacity>
        </View>

        <ScrollView contentContainerStyle={styles.listContainer}>
          {renderManagerContent()}
        </ScrollView>
      </SafeAreaView>
    );
  }

  // Staff View
  const renderFilterButtons = () => {
    const filters = [
      { key: 'all', label: 'T·∫•t c·∫£' },
      { key: 'in_progress', label: 'ƒêang l√†m' },
      { key: 'completed', label: 'Ho√†n th√†nh' },
      { key: 'pending', label: 'Ch·ªù x·ª≠ l√Ω' },
    ];

    return (
      <View style={styles.filterContainer}>
        {filters.map((filter) => (
          <TouchableOpacity
            key={filter.key}
            style={[
              styles.filterButton,
              {
                backgroundColor:
                  activeFilter === filter.key ? theme.primary : theme.card,
              },
            ]}
            onPress={() => setActiveFilter(filter.key)}
          >
            <Text
              style={[
                styles.filterText,
                { color: activeFilter === filter.key ? '#fff' : theme.text },
              ]}
            >
              {filter.label}
            </Text>
          </TouchableOpacity>
        ))}
      </View>
    );
  };

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <Text style={[styles.headerTitle, { color: theme.text }]}>
        C√¥ng vi·ªác c·ªßa b·∫°n
      </Text>
      {renderFilterButtons()}
      <FlatList
        data={filteredTasks}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <TaskCard
            item={item}
            onPress={() => handleTaskPress(item)}
            theme={theme}
          />
        )}
        contentContainerStyle={styles.listContainer}
        ListEmptyComponent={() => (
          <View style={styles.centerContainer}>
            <Text style={{ color: theme.textSecondary }}>
              Kh√¥ng c√≥ c√¥ng vi·ªác n√†o.
            </Text>
          </View>
        )}
      />
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1 },
  centerContainer: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  headerTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    padding: 16,
    paddingBottom: 8,
  },
  listContainer: { paddingHorizontal: 16, paddingBottom: 16 },
  card: {
    padding: 16,
    borderRadius: 12,
    marginVertical: 8,
    borderWidth: 1,
    borderColor: '#eee',
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
  },
  cardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  taskLabel: { fontSize: 18, fontWeight: 'bold', flexShrink: 1 },
  statusBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 10,
    marginLeft: 8,
  },
  statusText: { fontSize: 12, fontWeight: '600' },
  cardBody: {},
  projectName: { fontSize: 14, marginBottom: 4 },
  assignedTo: { fontSize: 14 },
  mediaIndicators: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 8,
    paddingTop: 8,
    borderTopWidth: 1,
    borderTopColor: '#f0f0f0',
  },
  mediaLabel: {
    fontSize: 12,
    marginRight: 8,
    fontWeight: '500',
  },
  mediaIcon: {
    marginRight: 8,
    padding: 2,
  },
  filterContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    paddingHorizontal: 16,
    marginBottom: 8,
  },
  filterButton: {
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 16,
  },
  filterText: {
    fontWeight: '500',
  },
  // Styles for Manager View
  managerTabContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    paddingHorizontal: 16,
    marginBottom: 16,
  },
  managerTab: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 20,
    alignItems: 'center',
    marginHorizontal: 4,
  },
  managerTabText: {
    fontWeight: 'bold',
  },
  section: {
    marginBottom: 24,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  emptySection: {
    padding: 16,
    alignItems: 'center',
    backgroundColor: '#f9f9f9',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#eee',
  },
});

export default TaskReportScreen;


--- END: src\screens\TaskReportScreen.js ---


--- START: src\screens\TotalSalaryReportScreen.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  FlatList,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import salaryService from '../api/salaryService';

const TotalSalaryReportScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const [loading, setLoading] = useState(false);
  const [reportData, setReportData] = useState(null);
  const [date, setDate] = useState({
    month: new Date().getMonth() + 1,
    year: new Date().getFullYear(),
  });

  useEffect(() => {
    // T·ª± ƒë·ªông t·∫£i (∆∞u ti√™n cache) khi m·ªü m√†n h√¨nh
    handleGenerateReport(false);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleGenerateReport = async (forceRefresh = false) => {
    setLoading(true);
    try {
      const data = await salaryService.getTotalSalaryReport(
        date.month,
        date.year,
        { forceRefresh }
      );
      setReportData(data);
    } catch (error) {
      console.error('Error generating salary report:', error);
    } finally {
      setLoading(false);
    }
  };

  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND',
    }).format(amount);
  };

  const renderSalarySlipItem = ({ item }) => (
    <View style={[styles.slipItem, { backgroundColor: theme.card }]}>
      <View style={styles.employeeInfo}>
        <Text style={[styles.employeeName, { color: theme.text }]}>
          {item.employeeName}
        </Text>
        <Text style={[styles.employeePosition, { color: theme.textSecondary }]}>
          {item.position}
        </Text>
      </View>
      <Text style={[styles.netSalary, { color: theme.primary }]}>
        {formatCurrency(item.calculatedSalary.netSalary)}
      </Text>
    </View>
  );

  return (
    <View style={[styles.container, { backgroundColor: theme.background }]}>
      <View style={[styles.header, { backgroundColor: theme.primary }]}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back" size={24} color="#fff" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>B√°o c√°o t·ªïng l∆∞∆°ng</Text>
        <View style={{ width: 20 }} />
      </View>

      <View style={styles.content}>
        <View style={[styles.card, { backgroundColor: theme.card }]}>
          <Text style={[styles.cardTitle, { color: theme.text }]}>
            Ch·ªçn th√°ng v√† nƒÉm
          </Text>
          {/* Simple month/year selectors for now */}
          <View style={styles.dateSelector}>
            <TouchableOpacity
              onPress={() => setDate({ ...date, month: date.month - 1 })}
            >
              <Ionicons name="chevron-back" size={24} color={theme.primary} />
            </TouchableOpacity>
            <Text style={[styles.dateText, { color: theme.text }]}>
              {date.month} / {date.year}
            </Text>
            <TouchableOpacity
              onPress={() => setDate({ ...date, month: date.month + 1 })}
            >
              <Ionicons
                name="chevron-forward"
                size={24}
                color={theme.primary}
              />
            </TouchableOpacity>
          </View>
          <View style={styles.buttonContainer}>
            <TouchableOpacity
              style={[styles.button, { backgroundColor: theme.primary }]}
              onPress={() => handleGenerateReport(false)}
            >
              <Text style={styles.buttonText}>Xem b√°o c√°o</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.buttonOutline, { borderColor: theme.primary }]}
              onPress={() => handleGenerateReport(true)}
            >
              <Text
                style={[styles.buttonTextOutline, { color: theme.primary }]}
              >
                L√†m m·ªõi
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        {loading && (
          <ActivityIndicator
            size="large"
            color={theme.primary}
            style={{ marginTop: 20 }}
          />
        )}

        {reportData && (
          <View
            style={[
              styles.card,
              { backgroundColor: theme.card, marginTop: 20 },
            ]}
          >
            <Text style={[styles.cardTitle, { color: theme.text }]}>
              K·∫øt qu·∫£ b√°o c√°o th√°ng {reportData.month}/{reportData.year}
            </Text>

            {/* Th·ªëng k√™ t·ªïng quan */}
            <View style={styles.statsContainer}>
              <View style={styles.statItem}>
                <Text
                  style={[styles.statLabel, { color: theme.textSecondary }]}
                >
                  S·ªë nh√¢n vi√™n
                </Text>
                <Text style={[styles.statValue, { color: theme.text }]}>
                  {reportData.totalSalarySlips}
                </Text>
              </View>

              <View style={styles.statItem}>
                <Text
                  style={[styles.statLabel, { color: theme.textSecondary }]}
                >
                  T·ªïng l∆∞∆°ng gross
                </Text>
                <Text style={[styles.statValue, { color: theme.text }]}>
                  {formatCurrency(reportData.totalGrossSalary)}
                </Text>
              </View>

              <View style={styles.statItem}>
                <Text
                  style={[styles.statLabel, { color: theme.textSecondary }]}
                >
                  T·ªïng kh·∫•u tr·ª´
                </Text>
                <Text style={[styles.statValue, { color: theme.text }]}>
                  {formatCurrency(reportData.totalDeductions)}
                </Text>
              </View>
            </View>

            {/* T·ªïng l∆∞∆°ng ph·∫£i tr·∫£ */}
            <View style={styles.summaryContainer}>
              <Text
                style={[styles.summaryText, { color: theme.textSecondary }]}
              >
                T·ªïng l∆∞∆°ng ph·∫£i tr·∫£ (th·ª±c lƒ©nh)
              </Text>
              <Text style={[styles.totalAmount, { color: theme.primary }]}>
                {formatCurrency(reportData.totalNetSalary)}
              </Text>
            </View>

            <Text style={[styles.listHeader, { color: theme.text }]}>
              Chi ti·∫øt phi·∫øu l∆∞∆°ng
            </Text>
            <FlatList
              data={reportData.salarySlips}
              renderItem={renderSalarySlipItem}
              keyExtractor={(item, index) =>
                item.employeeId || `employee-${index}`
              }
              style={{ maxHeight: 400 }}
            />
          </View>
        )}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1 },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 12,
    paddingTop: 20,
  },
  headerTitle: { color: '#fff', fontSize: 18, fontWeight: 'bold' },
  content: { padding: 16 },
  card: { padding: 16, borderRadius: 8, marginBottom: 16 },
  cardTitle: { fontSize: 16, fontWeight: 'bold', marginBottom: 12 },
  dateSelector: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
    marginBottom: 12,
  },
  dateText: { fontSize: 18, fontWeight: 'bold' },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 10,
  },
  button: {
    paddingVertical: 10,
    paddingHorizontal: 14,
    borderRadius: 8,
    alignItems: 'center',
  },
  buttonText: { color: '#fff', fontSize: 16, fontWeight: 'bold' },
  buttonOutline: {
    paddingVertical: 9,
    paddingHorizontal: 14,
    borderRadius: 8,
    alignItems: 'center',
    borderWidth: 1,
    marginTop: 8,
  },
  buttonTextOutline: { fontSize: 16, fontWeight: 'bold' },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginVertical: 12,
    paddingVertical: 12,
    borderTopWidth: 1,
    borderBottomWidth: 1,
    borderColor: '#eee',
  },
  statItem: {
    alignItems: 'center',
    flex: 1,
  },
  statLabel: {
    fontSize: 12,
    marginBottom: 4,
    textAlign: 'center',
  },
  statValue: {
    fontSize: 16,
    fontWeight: 'bold',
    textAlign: 'center',
  },
  summaryContainer: { alignItems: 'center', marginVertical: 16 },
  summaryText: { fontSize: 16, marginBottom: 6 },
  totalAmount: { fontSize: 24, fontWeight: 'bold' },
  listHeader: {
    fontSize: 16,
    fontWeight: 'bold',
    marginTop: 16,
    marginBottom: 8,
  },
  slipItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  employeeInfo: {
    flex: 1,
  },
  employeeName: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 2,
  },
  employeePosition: {
    fontSize: 14,
  },
  netSalary: {
    fontSize: 16,
    fontWeight: 'bold',
    textAlign: 'right',
  },
});

export default TotalSalaryReportScreen;


--- END: src\screens\TotalSalaryReportScreen.js ---


--- START: src\screens\UserManagementScreen.js ---
// src/screens/UserManagementScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  Modal,
  TextInput,
  ActivityIndicator,
  Alert,
  Image,
  SafeAreaView,
  ScrollView,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import {
  collection,
  getDocs,
  doc,
  updateDoc,
  query,
  orderBy,
  getDoc,
} from 'firebase/firestore';
import { db } from '../config/firebaseConfig';
import * as ImagePicker from 'expo-image-picker';
import { getStorage, ref, uploadBytes, getDownloadURL } from 'firebase/storage';

const UserManagementScreen = () => {
  const { theme } = useTheme();
  const { currentUser } = useAuth();
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [selectedUser, setSelectedUser] = useState(null);
  const [editModalVisible, setEditModalVisible] = useState(false);
  const [editData, setEditData] = useState({
    displayName: '',
    email: '',
    role: '',
    photoURL: '',
    dailySalary: '',
    monthlySalary: '', // Added monthlySalary
    phoneNumber: '',
    address: '',
    notes: '',
  });
  const [savingUser, setSavingUser] = useState(false);
  const [uploadingImage, setUploadingImage] = useState(false);

  // Role options for dropdown
  const roleOptions = [
    { value: 'giam_doc', label: 'Gi√°m ƒë·ªëc' },
    { value: 'pho_giam_doc', label: 'Ph√≥ Gi√°m ƒë·ªëc' },
    { value: 'ke_toan', label: 'K·∫ø to√°n' },
    { value: 'ky_su', label: 'K·ªπ s∆∞' },
    { value: 'thuong_mai', label: 'Th∆∞∆°ng m·∫°i' },
    { value: 'cong_nhan', label: 'C√¥ng nh√¢n' },
    { value: 'user', label: 'Ng∆∞·ªùi d√πng' },
  ];

  // Load users
  useEffect(() => {
    const fetchUsers = async () => {
      try {
        setLoading(true);
        const usersRef = collection(db, 'users');
        const q = query(usersRef, orderBy('displayName'));
        const snapshot = await getDocs(q);
        const usersList = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        }));
        setUsers(usersList);
      } catch (error) {
        console.error('Error loading users:', error);
        Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch ng∆∞·ªùi d√πng');
      } finally {
        setLoading(false);
      }
    };

    fetchUsers();
  }, []);

  // Handle user selection for editing
  const handleEditUser = (user) => {
    setSelectedUser(user);
    setEditData({
      displayName: user.displayName || '',
      email: user.email || '',
      role: user.role || 'user',
      photoURL: user.photoURL || '',
      dailySalary: user.dailySalary ? String(user.dailySalary) : '',
      monthlySalary: user.monthlySalary ? String(user.monthlySalary) : '', // Added monthlySalary
      phoneNumber: user.phoneNumber || '',
      address: user.address || '',
      notes: user.notes || '',
    });
    setEditModalVisible(true);
  };

  // Save user changes
  const saveUserChanges = async () => {
    if (!selectedUser) return;

    try {
      setSavingUser(true);

      // Validate required fields
      if (!editData.displayName.trim()) {
        Alert.alert('L·ªói', 'T√™n ng∆∞·ªùi d√πng kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng');
        return;
      }

      // Convert salary to number if provided
      const userData = {
        ...editData,
        dailySalary: editData.dailySalary
          ? parseFloat(editData.dailySalary)
          : null,
        monthlySalary: editData.monthlySalary // Added monthlySalary
          ? parseFloat(editData.monthlySalary)
          : null,
      };

      // Update user in Firestore
      const userRef = doc(db, 'users', selectedUser.id);
      await updateDoc(userRef, userData);

      // Update local state
      setUsers((prevUsers) =>
        prevUsers.map((u) =>
          u.id === selectedUser.id ? { ...u, ...userData } : u
        )
      );

      // Close modal
      setEditModalVisible(false);
      setSelectedUser(null);
      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ c·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng');
    } catch (error) {
      console.error('Error updating user:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng');
    } finally {
      setSavingUser(false);
    }
  };

  // Pick and upload profile image
  const pickImage = async () => {
    try {
      // Request permissions first
      const { status } =
        await ImagePicker.requestMediaLibraryPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert('L·ªói', 'C·∫ßn quy·ªÅn truy c·∫≠p th∆∞ vi·ªán ·∫£nh ƒë·ªÉ upload ·∫£nh');
        return;
      }

      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        aspect: [1, 1],
        quality: 0.5, // Gi·∫£m quality ƒë·ªÉ tr√°nh file qu√° l·ªõn
        base64: false, // Kh√¥ng c·∫ßn base64
      });

      console.log('ImagePicker result:', result);

      if (!result.canceled && result.assets && result.assets[0]) {
        const asset = result.assets[0];
        console.log('Selected image:', {
          uri: asset.uri,
          width: asset.width,
          height: asset.height,
          fileSize: asset.fileSize,
        });

        uploadImage(asset.uri);
      }
    } catch (error) {
      console.error('Error picking image:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ch·ªçn ·∫£nh: ' + error.message);
    }
  };

  // Upload image to Firebase Storage
  const uploadImage = async (uri) => {
    try {
      setUploadingImage(true);
      console.log('Starting image upload for URI:', uri);

      // Validate URI
      if (!uri) {
        throw new Error('Invalid image URI');
      }

      // Convert image to blob with better error handling
      const response = await fetch(uri);
      if (!response.ok) {
        throw new Error(`Failed to fetch image: ${response.status}`);
      }

      const blob = await response.blob();
      console.log('Blob created successfully, size:', blob.size);

      // Validate blob
      if (!blob || blob.size === 0) {
        throw new Error('Invalid image data');
      }

      // Try Firebase Storage upload with timeout
      const storage = getStorage();
      const fileExtension = uri.split('.').pop() || 'jpg';
      const fileName = `profile_${
        selectedUser.id
      }_${Date.now()}.${fileExtension}`;
      const storageRef = ref(storage, `profiles/${fileName}`);

      console.log('Uploading to Firebase Storage:', fileName);
      console.log('Storage bucket:', storage.app.options.storageBucket);

      // Upload with metadata and timeout
      const metadata = {
        contentType: `image/${fileExtension}`,
        customMetadata: {
          uploadedBy: currentUser?.uid || 'unknown',
          uploadedAt: new Date().toISOString(),
        },
      };

      // Add timeout to upload
      const uploadPromise = uploadBytes(storageRef, blob, metadata);
      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Upload timeout after 30s')), 30000)
      );

      await Promise.race([uploadPromise, timeoutPromise]);
      console.log('Upload successful, getting download URL...');

      const downloadURL = await getDownloadURL(storageRef);
      console.log('Download URL obtained:', downloadURL);

      // Update edit data with new image URL
      setEditData((prev) => ({
        ...prev,
        photoURL: downloadURL,
      }));

      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ t·∫£i l√™n ·∫£nh th√†nh c√¥ng!');
    } catch (error) {
      console.error('Error uploading image:', error);

      // Try fallback method with base64
      try {
        console.log('Trying fallback method with base64...');
        await uploadImageFallback(uri);
        return;
      } catch (fallbackError) {
        console.error('Fallback method also failed:', fallbackError);
      }

      // More specific error messages
      let errorMessage = 'Kh√¥ng th·ªÉ t·∫£i l√™n ·∫£nh';
      if (error.code === 'storage/unauthorized') {
        errorMessage = 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p Firebase Storage';
      } else if (error.code === 'storage/canceled') {
        errorMessage = 'Upload b·ªã h·ªßy';
      } else if (error.code === 'storage/unknown') {
        errorMessage =
          'L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ Firebase Storage. C√≥ th·ªÉ do m·∫°ng ho·∫∑c c·∫•u h√¨nh.';
      } else if (error.message.includes('fetch')) {
        errorMessage = 'Kh√¥ng th·ªÉ ƒë·ªçc file ·∫£nh';
      } else if (error.message.includes('timeout')) {
        errorMessage = 'Upload qu√° l√¢u, vui l√≤ng th·ª≠ l·∫°i';
      }

      Alert.alert(
        'L·ªói Upload',
        errorMessage +
          '\n\nChi ti·∫øt: ' +
          error.message +
          '\n\nG·ª£i √Ω: Ki·ªÉm tra k·∫øt n·ªëi m·∫°ng v√† th·ª≠ l·∫°i'
      );
    } finally {
      setUploadingImage(false);
    }
  };

  // Fallback method: Save image as base64 directly to Firestore
  const uploadImageFallback = async (uri) => {
    try {
      console.log('Using fallback method: base64 storage');

      // Convert image to base64
      const response = await fetch(uri);
      const blob = await response.blob();

      // Convert blob to base64
      const reader = new FileReader();
      const base64Promise = new Promise((resolve, reject) => {
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });

      const base64Data = await base64Promise;
      console.log('Base64 conversion successful, length:', base64Data.length);

      // Update edit data with base64 image
      setEditData((prev) => ({
        ...prev,
        photoURL: base64Data,
      }));

      Alert.alert('Th√†nh c√¥ng', 'ƒê√£ l∆∞u ·∫£nh th√†nh c√¥ng (ph∆∞∆°ng √°n d·ª± ph√≤ng)!');
    } catch (error) {
      console.error('Fallback method failed:', error);
      throw error;
    }
  };

  // Render user item in list
  const renderUserItem = ({ item }) => {
    const isCurrentUser = item.id === currentUser?.uid;

    return (
      <TouchableOpacity
        style={[styles.userCard, { backgroundColor: theme.card }]}
        onPress={() => handleEditUser(item)}
      >
        <View style={styles.userCardLeft}>
          {item.photoURL ? (
            <Image source={{ uri: item.photoURL }} style={styles.avatar} />
          ) : (
            <View
              style={[
                styles.avatarPlaceholder,
                { backgroundColor: theme.primaryLight },
              ]}
            >
              <Text style={[styles.avatarText, { color: theme.primary }]}>
                {(item.displayName || item.email || '?')[0].toUpperCase()}
              </Text>
            </View>
          )}
        </View>

        <View style={styles.userCardMiddle}>
          <Text style={[styles.userName, { color: theme.text }]}>
            {item.displayName || item.email || 'Kh√¥ng c√≥ t√™n'}
            {isCurrentUser && ' (B·∫°n)'}
          </Text>
          <Text style={[styles.userRole, { color: theme.textSecondary }]}>
            {getRoleLabel(item.role)}
          </Text>
          {item.dailySalary && (
            <Text style={[styles.userSalary, { color: theme.textMuted }]}>
              L∆∞∆°ng ng√†y: {formatCurrency(item.dailySalary)} VND
            </Text>
          )}
          {item.monthlySalary && ( // Added monthlySalary display
            <Text style={[styles.userSalary, { color: theme.textMuted }]}>
              L∆∞∆°ng th√°ng: {formatCurrency(item.monthlySalary)} VND
            </Text>
          )}
        </View>

        <View style={styles.userCardRight}>
          <Ionicons name="chevron-forward" size={20} color={theme.textMuted} />
        </View>
      </TouchableOpacity>
    );
  };

  // Helper function to get role label
  const getRoleLabel = (role) => {
    const option = roleOptions.find((o) => o.value === role);
    return option ? option.label : 'Ng∆∞·ªùi d√πng';
  };

  // Format currency
  const formatCurrency = (value) => {
    return new Intl.NumberFormat('vi-VN').format(value);
  };

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      {/* Header */}
      <View style={[styles.header, { backgroundColor: theme.card }]}>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Qu·∫£n l√Ω Nh√¢n vi√™n
        </Text>
      </View>

      {/* User list */}
      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
            ƒêang t·∫£i danh s√°ch ng∆∞·ªùi d√πng...
          </Text>
        </View>
      ) : (
        <FlatList
          data={users}
          renderItem={renderUserItem}
          keyExtractor={(item) => item.id}
          contentContainerStyle={styles.listContent}
          ListEmptyComponent={
            <View style={styles.emptyContainer}>
              <Ionicons name="people" size={40} color={theme.textMuted} />
              <Text style={[styles.emptyText, { color: theme.textMuted }]}>
                Kh√¥ng c√≥ ng∆∞·ªùi d√πng n√†o
              </Text>
            </View>
          }
        />
      )}

      {/* Edit user modal */}
      <Modal
        visible={editModalVisible}
        transparent
        animationType="slide"
        onRequestClose={() => setEditModalVisible(false)}
      >
        <View style={styles.modalBackdrop}>
          <View style={[styles.modalContent, { backgroundColor: theme.card }]}>
            <View style={styles.modalHeader}>
              <Text style={[styles.modalTitle, { color: theme.text }]}>
                Ch·ªânh s·ª≠a th√¥ng tin
              </Text>
              <TouchableOpacity
                onPress={() => setEditModalVisible(false)}
                style={styles.closeButton}
              >
                <Ionicons name="close" size={24} color={theme.textMuted} />
              </TouchableOpacity>
            </View>

            <ScrollView style={styles.modalScrollView}>
              {/* Profile image */}
              <View style={styles.profileImageContainer}>
                {uploadingImage ? (
                  <ActivityIndicator size="large" color={theme.primary} />
                ) : editData.photoURL ? (
                  <Image
                    source={{ uri: editData.photoURL }}
                    style={styles.profileImage}
                  />
                ) : (
                  <View
                    style={[
                      styles.profileImagePlaceholder,
                      { backgroundColor: theme.primaryLight },
                    ]}
                  >
                    <Text
                      style={[
                        styles.profileImageText,
                        { color: theme.primary },
                      ]}
                    >
                      {(editData.displayName || '?')[0].toUpperCase()}
                    </Text>
                  </View>
                )}

                <TouchableOpacity
                  style={[
                    styles.changePhotoButton,
                    { backgroundColor: theme.primary },
                  ]}
                  onPress={pickImage}
                >
                  <Ionicons name="camera" size={18} color="#fff" />
                  <Text style={styles.changePhotoText}>ƒê·ªïi ·∫£nh</Text>
                </TouchableOpacity>
              </View>

              {/* Form fields */}
              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>T√™n</Text>
                <TextInput
                  style={[
                    styles.input,
                    { borderColor: theme.border, color: theme.text },
                  ]}
                  value={editData.displayName}
                  onChangeText={(text) =>
                    setEditData((prev) => ({ ...prev, displayName: text }))
                  }
                  placeholder="T√™n ng∆∞·ªùi d√πng"
                  placeholderTextColor={theme.textMuted}
                />
              </View>

              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>Email</Text>
                <TextInput
                  style={[
                    styles.input,
                    { borderColor: theme.border, color: theme.text },
                  ]}
                  value={editData.email}
                  onChangeText={(text) =>
                    setEditData((prev) => ({ ...prev, email: text }))
                  }
                  placeholder="Email"
                  placeholderTextColor={theme.textMuted}
                  keyboardType="email-address"
                />
              </View>

              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>
                  Vai tr√≤
                </Text>
                <View
                  style={[
                    styles.pickerContainer,
                    { borderColor: theme.border },
                  ]}
                >
                  {roleOptions.map((option) => (
                    <TouchableOpacity
                      key={option.value}
                      style={[
                        styles.roleOption,
                        editData.role === option.value && [
                          styles.selectedRole,
                          { backgroundColor: theme.primary + '20' },
                        ],
                      ]}
                      onPress={() =>
                        setEditData((prev) => ({ ...prev, role: option.value }))
                      }
                    >
                      <Text
                        style={[
                          styles.roleOptionText,
                          { color: theme.text },
                          editData.role === option.value && {
                            color: theme.primary,
                            fontWeight: '600',
                          },
                        ]}
                      >
                        {option.label}
                      </Text>
                    </TouchableOpacity>
                  ))}
                </View>
              </View>

              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>
                  L∆∞∆°ng theo ng√†y (VND)
                </Text>
                <TextInput
                  style={[
                    styles.input,
                    { borderColor: theme.border, color: theme.text },
                  ]}
                  value={editData.dailySalary} // Changed from monthlySalary
                  onChangeText={(text) => {
                    // Only allow numbers
                    const filtered = text.replace(/[^0-9]/g, '');
                    setEditData((prev) => ({
                      ...prev,
                      dailySalary: filtered, // Changed from monthlySalary
                    }));
                  }}
                  placeholder="L∆∞∆°ng theo ng√†y"
                  placeholderTextColor={theme.textMuted}
                  keyboardType="numeric"
                />
              </View>

              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>
                  L∆∞∆°ng c·ªë ƒë·ªãnh (th√°ng, VND)
                </Text>
                <TextInput
                  style={[
                    styles.input,
                    { borderColor: theme.border, color: theme.text },
                  ]}
                  value={editData.monthlySalary}
                  onChangeText={(text) => {
                    const filtered = text.replace(/[^0-9]/g, '');
                    setEditData((prev) => ({
                      ...prev,
                      monthlySalary: filtered,
                    }));
                  }}
                  placeholder="L∆∞∆°ng c·ªë ƒë·ªãnh nguy√™n th√°ng"
                  placeholderTextColor={theme.textMuted}
                  keyboardType="numeric"
                />
              </View>

              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>
                  S·ªë ƒëi·ªán tho·∫°i
                </Text>
                <TextInput
                  style={[
                    styles.input,
                    { borderColor: theme.border, color: theme.text },
                  ]}
                  value={editData.phoneNumber}
                  onChangeText={(text) =>
                    setEditData((prev) => ({ ...prev, phoneNumber: text }))
                  }
                  placeholder="S·ªë ƒëi·ªán tho·∫°i"
                  placeholderTextColor={theme.textMuted}
                  keyboardType="phone-pad"
                />
              </View>

              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>
                  ƒê·ªãa ch·ªâ
                </Text>
                <TextInput
                  style={[
                    styles.input,
                    { borderColor: theme.border, color: theme.text },
                  ]}
                  value={editData.address}
                  onChangeText={(text) =>
                    setEditData((prev) => ({ ...prev, address: text }))
                  }
                  placeholder="ƒê·ªãa ch·ªâ"
                  placeholderTextColor={theme.textMuted}
                />
              </View>

              <View style={styles.formGroup}>
                <Text style={[styles.label, { color: theme.text }]}>
                  Ghi ch√∫
                </Text>
                <TextInput
                  style={[
                    styles.textArea,
                    { borderColor: theme.border, color: theme.text },
                  ]}
                  value={editData.notes}
                  onChangeText={(text) =>
                    setEditData((prev) => ({ ...prev, notes: text }))
                  }
                  placeholder="Ghi ch√∫"
                  placeholderTextColor={theme.textMuted}
                  multiline
                  numberOfLines={4}
                  textAlignVertical="top"
                />
              </View>
            </ScrollView>

            <View style={styles.modalFooter}>
              <TouchableOpacity
                style={[styles.cancelButton, { borderColor: theme.border }]}
                onPress={() => setEditModalVisible(false)}
              >
                <Text style={{ color: theme.text }}>H·ªßy</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.saveButton, { backgroundColor: theme.primary }]}
                onPress={saveUserChanges}
                disabled={savingUser}
              >
                {savingUser ? (
                  <ActivityIndicator size="small" color="#fff" />
                ) : (
                  <Text style={styles.saveButtonText}>L∆∞u thay ƒë·ªïi</Text>
                )}
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    elevation: 2,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 12,
  },
  listContent: {
    padding: 12,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 40,
  },
  emptyText: {
    marginTop: 12,
    fontSize: 16,
  },
  userCard: {
    flexDirection: 'row',
    padding: 12,
    marginBottom: 8,
    borderRadius: 8,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  userCardLeft: {
    marginRight: 12,
  },
  avatar: {
    width: 50,
    height: 50,
    borderRadius: 25,
  },
  avatarPlaceholder: {
    width: 50,
    height: 50,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
  },
  avatarText: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  userCardMiddle: {
    flex: 1,
    justifyContent: 'center',
  },
  userName: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 4,
  },
  userRole: {
    fontSize: 14,
    marginBottom: 2,
  },
  userSalary: {
    fontSize: 12,
  },
  userCardRight: {
    justifyContent: 'center',
  },
  modalBackdrop: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    width: '90%',
    maxHeight: '90%',
    borderRadius: 12,
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  closeButton: {
    padding: 4,
  },
  modalScrollView: {
    padding: 16,
  },
  profileImageContainer: {
    alignItems: 'center',
    marginBottom: 20,
  },
  profileImage: {
    width: 100,
    height: 100,
    borderRadius: 50,
    marginBottom: 10,
  },
  profileImagePlaceholder: {
    width: 100,
    height: 100,
    borderRadius: 50,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 10,
  },
  profileImageText: {
    fontSize: 36,
    fontWeight: 'bold',
  },
  changePhotoButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
  },
  changePhotoText: {
    color: '#fff',
    marginLeft: 6,
    fontWeight: '500',
  },
  formGroup: {
    marginBottom: 16,
  },
  label: {
    marginBottom: 6,
    fontWeight: '500',
  },
  input: {
    borderWidth: 1,
    borderRadius: 8,
    padding: 10,
    fontSize: 16,
  },
  textArea: {
    borderWidth: 1,
    borderRadius: 8,
    padding: 10,
    fontSize: 16,
    height: 100,
  },
  pickerContainer: {
    borderWidth: 1,
    borderRadius: 8,
    padding: 6,
  },
  roleOption: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 4,
    marginBottom: 2,
  },
  selectedRole: {
    fontWeight: 'bold',
  },
  roleOptionText: {
    fontSize: 16,
  },
  modalFooter: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: '#eee',
  },
  cancelButton: {
    borderWidth: 1,
    borderRadius: 8,
    paddingVertical: 10,
    paddingHorizontal: 16,
    marginRight: 12,
  },
  saveButton: {
    borderRadius: 8,
    paddingVertical: 10,
    paddingHorizontal: 24,
  },
  saveButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
});

export default UserManagementScreen;


--- END: src\screens\UserManagementScreen.js ---


--- START: src\screens\WorkAllocationScreen.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  RefreshControl,
  Alert,
  Modal,
  ScrollView,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import { getProjects } from '../api/projectService';
import { getUsers } from '../api/userService';
import { assignWorkerToStage } from '../api/projectService';
import MediaInstructionsViewer from '../components/MediaInstructionsViewer';
import StageAssignmentModal from '../components/StageAssignmentModal';

const WorkAllocationScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const { currentUser } = useAuth();

  // State management
  const [projects, setProjects] = useState([]);
  const [workers, setWorkers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [selectedStage, setSelectedStage] = useState(null);
  const [showAssignmentModal, setShowAssignmentModal] = useState(false);
  const [showInstructionsModal, setShowInstructionsModal] = useState(false);

  // Load data
  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      setLoading(true);
      const [projectsData, workersData] = await Promise.all([
        getProjects(),
        getUsers(),
      ]);

      setProjects(projectsData);
      setWorkers(workersData.filter((user) => user.role === 'worker'));
    } catch (error) {
      console.error('Error loading data:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu');
    } finally {
      setLoading(false);
    }
  };

  const handleRefresh = async () => {
    setRefreshing(true);
    await loadData();
    setRefreshing(false);
  };

  const handleStagePress = (project, stage) => {
    setSelectedStage({
      ...stage,
      projectId: project.id,
      projectName: project.name,
    });
    setShowAssignmentModal(true);
  };

  const handleViewInstructions = (project, stage) => {
    setSelectedStage({
      ...stage,
      projectId: project.id,
      projectName: project.name,
    });
    setShowInstructionsModal(true);
  };

  const handleAssignWorker = async (workerId, workerName) => {
    try {
      if (!selectedStage) return;

      await assignWorkerToStage(
        selectedStage.projectId,
        selectedStage.stageId,
        workerId,
        workerName
      );

      Alert.alert('Th√†nh c√¥ng', `ƒê√£ giao vi·ªác cho ${workerName}`);
      setShowAssignmentModal(false);
      await loadData(); // Refresh data
    } catch (error) {
      console.error('Error assigning worker:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ giao vi·ªác');
    }
  };

  const renderStageItem = (project, stage) => {
    const hasInstructions =
      stage.instructionNotes ||
      (stage.instructionImages && stage.instructionImages.length > 0) ||
      stage.instructionAudio;

    const isAssigned =
      stage.assignedWorkers && stage.assignedWorkers.length > 0;
    const statusColor = isAssigned ? '#28a745' : '#ffc107';
    const statusText = isAssigned ? 'ƒê√£ giao' : 'Ch∆∞a giao';

    return (
      <View key={stage.stageId} style={styles.stageItem}>
        <View style={styles.stageHeader}>
          <View style={styles.stageInfo}>
            <Text style={styles.stageName}>{stage.processName}</Text>
            <Text style={styles.projectName}>{project.name}</Text>
          </View>
          <View style={[styles.statusBadge, { backgroundColor: statusColor }]}>
            <Text style={styles.statusText}>{statusText}</Text>
          </View>
        </View>

        {isAssigned && (
          <View style={styles.assignedWorkers}>
            <Text style={styles.assignedLabel}>Ng∆∞·ªùi th·ª±c hi·ªán:</Text>
            {stage.assignedWorkerNames?.map((name, index) => (
              <Text key={index} style={styles.workerName}>
                ‚Ä¢ {name}
              </Text>
            ))}
          </View>
        )}

        <View style={styles.stageActions}>
          <TouchableOpacity
            style={styles.actionBtn}
            onPress={() => handleStagePress(project, stage)}
          >
            <Ionicons name="person-add" size={16} color="#0066cc" />
            <Text style={styles.actionBtnText}>Giao vi·ªác</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={[
              styles.actionBtn,
              hasInstructions && styles.hasInstructionsBtn,
            ]}
            onPress={() => handleViewInstructions(project, stage)}
          >
            <Ionicons
              name={hasInstructions ? 'document-text' : 'document-text-outline'}
              size={16}
              color={hasInstructions ? '#28a745' : '#666'}
            />
            <Text
              style={[
                styles.actionBtnText,
                hasInstructions && styles.hasInstructionsText,
              ]}
            >
              {hasInstructions ? 'Xem h∆∞·ªõng d·∫´n' : 'Ch∆∞a c√≥ h∆∞·ªõng d·∫´n'}
            </Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.actionBtn}
            onPress={() =>
              navigation.navigate('StageDetail', {
                projectId: project.id,
                stage: stage,
              })
            }
          >
            <Ionicons name="create" size={16} color="#ff6b35" />
            <Text style={styles.actionBtnText}>Ch·ªânh s·ª≠a</Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  };

  const renderProjectItem = ({ item: project }) => {
    const stages = project.workflowStages || [];

    return (
      <View style={styles.projectCard}>
        <View style={styles.projectHeader}>
          <Text style={styles.projectTitle}>{project.name}</Text>
          <Text style={styles.customerName}>{project.customerName}</Text>
        </View>

        {stages.map((stage) => renderStageItem(project, stage))}
      </View>
    );
  };

  return (
    <View style={[styles.container, { backgroundColor: theme.background }]}>
      {/* Header */}
      <View style={[styles.header, { backgroundColor: theme.cardBackground }]}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={theme.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          Giao vi·ªác & H∆∞·ªõng d·∫´n
        </Text>
        <TouchableOpacity
          style={[styles.refreshButton, { backgroundColor: theme.primary }]}
          onPress={handleRefresh}
          disabled={refreshing}
        >
          <Ionicons
            name="refresh"
            size={20}
            color="#fff"
            style={refreshing ? { opacity: 0.5 } : {}}
          />
        </TouchableOpacity>
      </View>

      {/* Projects List */}
      <FlatList
        data={projects}
        keyExtractor={(item) => item.id}
        renderItem={renderProjectItem}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={[theme.primary]}
          />
        }
        contentContainerStyle={styles.listContainer}
        showsVerticalScrollIndicator={false}
      />

      {/* Assignment Modal */}
      <StageAssignmentModal
        visible={showAssignmentModal}
        stage={selectedStage}
        workers={workers}
        onClose={() => setShowAssignmentModal(false)}
        onAssign={handleAssignWorker}
      />

      {/* Instructions Modal */}
      <Modal
        visible={showInstructionsModal}
        animationType="slide"
        presentationStyle="pageSheet"
        onRequestClose={() => setShowInstructionsModal(false)}
      >
        <View style={styles.modalContainer}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>
              H∆∞·ªõng d·∫´n: {selectedStage?.processName}
            </Text>
            <TouchableOpacity
              style={styles.closeButton}
              onPress={() => setShowInstructionsModal(false)}
            >
              <Ionicons name="close" size={24} color="#333" />
            </TouchableOpacity>
          </View>

          <ScrollView style={styles.modalContent}>
            {selectedStage && (
              <MediaInstructionsViewer
                instructionImages={selectedStage.instructionImages}
                instructionNotes={selectedStage.instructionNotes}
                instructionAudio={selectedStage.instructionAudio}
                visible={true}
              />
            )}
          </ScrollView>
        </View>
      </Modal>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  backButton: {
    padding: 8,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    flex: 1,
    textAlign: 'center',
    marginHorizontal: 16,
  },
  refreshButton: {
    padding: 8,
    borderRadius: 20,
  },
  listContainer: {
    padding: 16,
  },
  projectCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    marginBottom: 16,
    padding: 16,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
    elevation: 5,
  },
  projectHeader: {
    marginBottom: 16,
    paddingBottom: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  projectTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 4,
  },
  customerName: {
    fontSize: 14,
    color: '#666',
  },
  stageItem: {
    backgroundColor: '#f8f9fa',
    borderRadius: 8,
    padding: 12,
    marginBottom: 12,
  },
  stageHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  stageInfo: {
    flex: 1,
  },
  stageName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 2,
  },
  projectName: {
    fontSize: 12,
    color: '#666',
  },
  statusBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  statusText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
  assignedWorkers: {
    marginBottom: 12,
    paddingTop: 8,
    borderTopWidth: 1,
    borderTopColor: '#e0e0e0',
  },
  assignedLabel: {
    fontSize: 12,
    color: '#666',
    marginBottom: 4,
  },
  workerName: {
    fontSize: 14,
    color: '#333',
    marginLeft: 8,
  },
  stageActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  actionBtn: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 6,
    paddingHorizontal: 12,
    borderRadius: 6,
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#e0e0e0',
    flex: 1,
    marginHorizontal: 2,
  },
  hasInstructionsBtn: {
    borderColor: '#28a745',
    backgroundColor: '#f8fff9',
  },
  actionBtnText: {
    fontSize: 12,
    color: '#666',
    marginLeft: 4,
    textAlign: 'center',
    flex: 1,
  },
  hasInstructionsText: {
    color: '#28a745',
    fontWeight: '500',
  },
  modalContainer: {
    flex: 1,
    backgroundColor: '#fff',
  },
  modalHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    flex: 1,
  },
  closeButton: {
    padding: 8,
  },
  modalContent: {
    flex: 1,
  },
});

export default WorkAllocationScreen;


--- END: src\screens\WorkAllocationScreen.js ---


--- START: src\screens\WorkerAttendanceScreen.js ---
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  StatusBar,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useAuth } from '../contexts/AuthContext';
import { getAttendance, getAttendanceHistory } from '../api/attendanceService';

const WorkerAttendanceScreen = ({ navigation }) => {
  const { theme, isDarkMode } = useTheme();
  const { user } = useAuth();
  const [attendance, setAttendance] = useState(null);
  const [attendanceHistory, setAttendanceHistory] = useState([]);
  const [loading, setLoading] = useState(true);
  const [selectedMonth, setSelectedMonth] = useState(new Date().getMonth());
  const [selectedYear, setSelectedYear] = useState(new Date().getFullYear());

  useEffect(() => {
    loadAttendanceData();
  }, [selectedMonth, selectedYear]);

  const loadAttendanceData = async () => {
    try {
      setLoading(true);

      // L·∫•y th√¥ng tin ch·∫•m c√¥ng hi·ªán t·∫°i
      if (user?.uid) {
        const currentAttendance = await getAttendance(user.uid);
        setAttendance(currentAttendance);

        // L·∫•y l·ªãch s·ª≠ ch·∫•m c√¥ng theo th√°ng
        const history = await getAttendanceHistory(
          user.uid,
          selectedYear,
          selectedMonth + 1
        );

        // Log ƒë·ªÉ debug
        console.log('Attendance history loaded:', history);
        console.log('User ID:', user.uid);
        console.log('Year:', selectedYear, 'Month:', selectedMonth + 1);

        // Debug t·ª´ng record
        history.forEach((record, index) => {
          console.log(`Record ${index}:`, {
            id: record.id,
            date: record.date,
            clockIn: record.clockIn,
            clockOut: record.clockOut,
            userId: record.userId,
          });
        });

        setAttendanceHistory(history);
      }
    } catch (error) {
      console.error('L·ªói khi t·∫£i d·ªØ li·ªáu ch·∫•m c√¥ng:', error);
      Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu ch·∫•m c√¥ng');
    } finally {
      setLoading(false);
    }
  };

  const getMonthName = (month) => {
    const months = [
      'Th√°ng 1',
      'Th√°ng 2',
      'Th√°ng 3',
      'Th√°ng 4',
      'Th√°ng 5',
      'Th√°ng 6',
      'Th√°ng 7',
      'Th√°ng 8',
      'Th√°ng 9',
      'Th√°ng 10',
      'Th√°ng 11',
      'Th√°ng 12',
    ];
    return months[month];
  };

  const formatDate = (timestamp) => {
    if (!timestamp) return '';
    const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
    return date.toLocaleDateString('vi-VN');
  };

  const formatTime = (timestamp) => {
    if (!timestamp) return '';
    const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
    return date.toLocaleTimeString('vi-VN', {
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  const calculateWorkHours = (clockIn, clockOut) => {
    if (!clockIn || !clockOut) return 0;
    const start = clockIn.toDate ? clockIn.toDate() : new Date(clockIn);
    const end = clockOut.toDate ? clockOut.toDate() : new Date(clockOut);
    const diffMs = end - start;
    const diffHours = diffMs / (1000 * 60 * 60);
    return Math.round(diffHours * 100) / 100;
  };

  const getTotalWorkHours = () => {
    return attendanceHistory.reduce((total, record) => {
      return total + calculateWorkHours(record.clockIn, record.clockOut);
    }, 0);
  };

  const getTotalOvertime = () => {
    return attendanceHistory.reduce((total, record) => {
      return total + (record.overtime || 0);
    }, 0);
  };

  const changeMonth = (direction) => {
    if (direction === 'prev') {
      if (selectedMonth === 0) {
        setSelectedMonth(11);
        setSelectedYear(selectedYear - 1);
      } else {
        setSelectedMonth(selectedMonth - 1);
      }
    } else {
      if (selectedMonth === 11) {
        setSelectedMonth(0);
        setSelectedYear(selectedYear + 1);
      } else {
        setSelectedMonth(selectedMonth + 1);
      }
    }
  };

  if (loading) {
    return (
      <SafeAreaView
        style={[styles.container, { backgroundColor: theme.background }]}
      >
        <StatusBar
          barStyle={isDarkMode ? 'light-content' : 'dark-content'}
          backgroundColor={theme.background}
        />
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={theme.primary} />
          <Text style={[styles.loadingText, { color: theme.textSecondary }]}>
            ƒêang t·∫£i d·ªØ li·ªáu...
          </Text>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView
      style={[styles.container, { backgroundColor: theme.background }]}
    >
      <StatusBar
        barStyle={isDarkMode ? 'light-content' : 'dark-content'}
        backgroundColor={theme.background}
      />

      {/* Header */}
      <View style={[styles.header, { backgroundColor: theme.card }]}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color={theme.text} />
        </TouchableOpacity>
        <Text style={[styles.headerTitle, { color: theme.text }]}>
          B·∫£ng Ch·∫•m C√¥ng
        </Text>
        <View style={{ width: 24 }} />
      </View>

      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.scrollContent}
      >
        {/* Th√¥ng tin t·ªïng quan */}
        <View
          style={[
            styles.summaryCard,
            { backgroundColor: theme.card, borderColor: theme.border },
          ]}
        >
          <Text style={[styles.summaryTitle, { color: theme.text }]}>
            T·ªïng quan th√°ng {getMonthName(selectedMonth)}/{selectedYear}
          </Text>

          <View style={styles.summaryGrid}>
            <View style={styles.summaryItem}>
              <Text style={[styles.summaryValue, { color: theme.primary }]}>
                {attendanceHistory.length}
              </Text>
              <Text
                style={[styles.summaryLabel, { color: theme.textSecondary }]}
              >
                Ng√†y l√†m vi·ªác
              </Text>
            </View>

            <View style={styles.summaryItem}>
              <Text style={[styles.summaryValue, { color: theme.primary }]}>
                {attendanceHistory.filter((r) => (r.overtime || 0) > 0).length}
              </Text>
              <Text
                style={[styles.summaryLabel, { color: theme.textSecondary }]}
              >
                Ng√†y tƒÉng ca
              </Text>
            </View>
          </View>
        </View>

        {/* Ch·ªçn th√°ng */}
        <View
          style={[
            styles.monthSelector,
            { backgroundColor: theme.card, borderColor: theme.border },
          ]}
        >
          <TouchableOpacity
            style={styles.monthButton}
            onPress={() => changeMonth('prev')}
          >
            <Ionicons name="chevron-back" size={24} color={theme.primary} />
          </TouchableOpacity>

          <Text style={[styles.monthText, { color: theme.text }]}>
            {getMonthName(selectedMonth)} {selectedYear}
          </Text>

          <TouchableOpacity
            style={styles.monthButton}
            onPress={() => changeMonth('next')}
          >
            <Ionicons name="chevron-forward" size={24} color={theme.primary} />
          </TouchableOpacity>
        </View>

        {/* L·ªãch s·ª≠ ch·∫•m c√¥ng */}
        <View style={styles.section}>
          <Text style={[styles.sectionTitle, { color: theme.text }]}>
            L·ªãch s·ª≠ ch·∫•m c√¥ng
          </Text>

          {attendanceHistory.length > 0 ? (
            attendanceHistory.map((record, index) => {
              // Debug: log record data
              console.log('Record data:', record);
              console.log('Record date:', record.date);
              console.log('Record clockIn:', record.clockIn);

              return (
                <View
                  key={index}
                  style={[
                    styles.attendanceCard,
                    { backgroundColor: theme.card, borderColor: theme.border },
                  ]}
                >
                  <View style={styles.attendanceHeader}>
                    <Text
                      style={[styles.attendanceDate, { color: theme.text }]}
                    >
                      {formatDate(record.clockIn)}
                    </Text>
                  </View>

                  <View style={styles.attendanceDetails}>
                    <View style={styles.dateRow}>
                      <Ionicons
                        name="calendar-outline"
                        size={16}
                        color={theme.textSecondary}
                      />
                      <Text
                        style={[
                          styles.dateLabel,
                          { color: theme.textSecondary },
                        ]}
                      >
                        ƒê√£ ƒëi l√†m ng√†y {record.date || 'Kh√¥ng x√°c ƒë·ªãnh'}
                      </Text>
                    </View>
                    <View style={styles.timeRow}>
                      <Ionicons
                        name="time-outline"
                        size={16}
                        color={theme.textSecondary}
                      />
                      <Text
                        style={[
                          styles.timeLabel,
                          { color: theme.textSecondary },
                        ]}
                      >
                        C√¥ng: 8h
                        {record.overtime > 0
                          ? `  ‚Ä¢  TƒÉng ca: ${record.overtime}h`
                          : ''}
                      </Text>
                    </View>
                  </View>
                </View>
              );
            })
          ) : (
            <View
              style={[
                styles.emptyCard,
                { backgroundColor: theme.card, borderColor: theme.border },
              ]}
            >
              <Ionicons
                name="calendar-outline"
                size={48}
                color={theme.textMuted}
              />
              <Text style={[styles.emptyText, { color: theme.textMuted }]}>
                Kh√¥ng c√≥ d·ªØ li·ªáu ch·∫•m c√¥ng
              </Text>
              <Text style={[styles.emptySubText, { color: theme.textMuted }]}>
                Th√°ng {getMonthName(selectedMonth)}/{selectedYear}
              </Text>
            </View>
          )}
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
  },
  backButton: {
    padding: 4,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    padding: 16,
    paddingBottom: 32,
  },
  summaryCard: {
    borderRadius: 12,
    padding: 20,
    marginBottom: 20,
    borderWidth: 1,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  summaryTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 16,
    textAlign: 'center',
  },
  summaryGrid: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  summaryItem: {
    alignItems: 'center',
  },
  summaryValue: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  summaryLabel: {
    fontSize: 12,
    textAlign: 'center',
  },
  monthSelector: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 20,
    paddingVertical: 16,
    borderRadius: 12,
    marginBottom: 20,
    borderWidth: 1,
  },
  monthButton: {
    padding: 8,
  },
  monthText: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  section: {
    marginBottom: 24,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  attendanceCard: {
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  attendanceHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  attendanceDate: {
    fontSize: 16,
    fontWeight: 'bold',
  },
  attendanceDetails: {
    gap: 8,
  },
  dateRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  dateLabel: {
    fontSize: 14,
  },
  timeRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  timeLabel: {
    fontSize: 14,
  },
  emptyCard: {
    borderRadius: 12,
    padding: 40,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderStyle: 'dashed',
  },
  emptyText: {
    fontSize: 16,
    marginTop: 12,
    textAlign: 'center',
  },
  emptySubText: {
    fontSize: 14,
    marginTop: 4,
    textAlign: 'center',
  },
});

export default WorkerAttendanceScreen;




--- END: src\screens\WorkerAttendanceScreen.js ---


--- START: src\utils\audioPermissionHelper.js ---
import { Audio } from 'expo-av';
import { Alert, Platform, Linking } from 'react-native';

export const requestAudioPermission = async () => {
  try {
    const { status } = await Audio.requestPermissionsAsync();

    if (status !== 'granted') {
      Alert.alert(
        'Quy·ªÅn ghi √¢m',
        '·ª®ng d·ª•ng c·∫ßn quy·ªÅn truy c·∫≠p microphone ƒë·ªÉ ghi √¢m h∆∞·ªõng d·∫´n. Vui l√≤ng c·∫•p quy·ªÅn trong C√†i ƒë·∫∑t.',
        [
          { text: 'H·ªßy', style: 'cancel' },
          {
            text: 'C√†i ƒë·∫∑t',
            onPress: () => {
              if (Platform.OS === 'ios') {
                Linking.openURL('app-settings:');
              } else {
                Linking.openURL('package:com.tanhoaphat.thpapp');
              }
            },
          },
        ]
      );
      return false;
    }

    return true;
  } catch (error) {
    console.error('Error requesting audio permission:', error);
    Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ xin quy·ªÅn ghi √¢m');
    return false;
  }
};

export const checkAudioPermission = async () => {
  try {
    const { status } = await Audio.getPermissionsAsync();
    return status === 'granted';
  } catch (error) {
    console.error('Error checking audio permission:', error);
    return false;
  }
};

export const setupAudioMode = async () => {
  try {
    await Audio.setAudioModeAsync({
      allowsRecordingIOS: true,
      playsInSilentModeIOS: true,
      staysActiveInBackground: true,
      shouldDuckAndroid: true,
      playThroughEarpieceAndroid: false,
    });
    return true;
  } catch (error) {
    console.error('Error setting up audio mode:', error);
    return false;
  }
};


--- END: src\utils\audioPermissionHelper.js ---


--- START: src\utils\buildTimeIcons.js ---
/**
 * Build-time custom icons
 * Nh·ªØng icon n√†y s·∫Ω ƒë∆∞·ª£c build s·∫µn v√†o app v√† c√≥ s·∫µn cho t·∫•t c·∫£ users
 */

// Import c√°c custom icons t·ª´ assets
const laser1Icon = require('../assets/custom-icons/laser1.png'); // Ch∆∞a th·ª±c hi·ªán v√† in progress
const laser2Icon = require('../assets/custom-icons/laser2.png'); // Completed
const bending1Icon = require('../assets/custom-icons/bending1.png'); // Ch·∫•n - ch∆∞a th·ª±c hi·ªán v√† in progress
const bending2Icon = require('../assets/custom-icons/bending2.png'); // Ch·∫•n - completed
const welding1Icon = require('../assets/custom-icons/welding1.png'); // H√†n - ch∆∞a th·ª±c hi·ªán v√† in progress
const welding2Icon = require('../assets/custom-icons/welding2.png'); // H√†n - completed
const grinder1Icon = require('../assets/custom-icons/grinder1.png'); // M√†i - ch∆∞a th·ª±c hi·ªán v√† in progress
const grinder2Icon = require('../assets/custom-icons/grinder2.png'); // M√†i - completed
const ndt1Icon = require('../assets/custom-icons/ndt1.png'); // NDT - ch∆∞a th·ª±c hi·ªán v√† in progress
const ndt2Icon = require('../assets/custom-icons/ndt2.png'); // NDT - completed
const order1Icon = require('../assets/custom-icons/order1.png'); // Order - ch∆∞a th·ª±c hi·ªán v√† in progress
const order2Icon = require('../assets/custom-icons/order2.png'); // Order - completed
const polisher1Icon = require('../assets/custom-icons/polisher1.png'); // Polisher - ch∆∞a th·ª±c hi·ªán v√† in progress
const polisher2Icon = require('../assets/custom-icons/polisher2.png'); // Polisher - completed
const pressing1Icon = require('../assets/custom-icons/pressing1.png'); // Pressing - ch∆∞a th·ª±c hi·ªán v√† in progress
const pressing2Icon = require('../assets/custom-icons/pressing2.png'); // Pressing - completed
const rolling1Icon = require('../assets/custom-icons/rolling1.png'); // Rolling - ch∆∞a th·ª±c hi·ªán v√† in progress
const rolling2Icon = require('../assets/custom-icons/rolling2.png'); // Rolling - completed
const paintBucketEmpty = require('../assets/custom-icons/paint-bucket_4228960.png');
const paintBucketFull = require('../assets/custom-icons/paint-bucket_4229235.png');

export const BUILD_TIME_CUSTOM_ICONS = {
  // Laser cutting icon - default cho ch∆∞a th·ª±c hi·ªán v√† in progress
  laser_cutting: laser1Icon,

  // Bending (Ch·∫•n) - default cho ch∆∞a th·ª±c hi·ªán v√† in progress
  bending: bending1Icon,

  // Welding (H√†n) - default cho ch∆∞a th·ª±c hi·ªán v√† in progress
  welding: welding1Icon,

  // Grinding (M√†i) - default cho ch∆∞a th·ª±c hi·ªán v√† in progress
  grinding: grinder1Icon,

  // NDT - default cho ch∆∞a th·ª±c hi·ªán v√† in progress
  ndt: ndt1Icon,

  // Order - default cho ch∆∞a th·ª±c hi·ªán v√† in progress
  order: order1Icon,

  // Polisher - default cho ch∆∞a th·ª±c hi·ªán v√† in progress
  polisher: polisher1Icon,

  // Pressing - default cho ch∆∞a th·ª±c hi·ªán v√† in progress
  pressing: pressing1Icon,

  // Rolling - default cho ch∆∞a th·ª±c hi·ªán v√† in progress
  rolling: rolling1Icon,

  // Paint icons - s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω ƒë·∫∑c bi·ªát d·ª±a tr√™n state
  painting: paintBucketEmpty, // Default cho painting
  son: paintBucketEmpty, // Default cho s∆°n

  // TODO: Th√™m icons cho c√°c process keys kh√°c khi c√≥ file icon t∆∞∆°ng ·ª©ng:
  // material_separation: 'B√≥c t√°ch v·∫≠t t∆∞',
  // quotation: 'B√°o gi√°',
  // material_purchasing: 'Mua v·∫≠t t∆∞',
  // material_cutting: 'C·∫Øt ph√¥i',
  // assembly: 'L·∫Øp r√°p',
  // shipping: 'V·∫≠n chuy·ªÉn',
  // turning: 'Ti·ªán',
  // milling: 'Phay',
  // drilling: 'Khoan',
};

// Icons cho tr·∫°ng th√°i ho√†n th√†nh
export const COMPLETED_STATE_ICONS = {
  laser_cutting: laser2Icon, // Laser completed
  bending: bending2Icon, // Ch·∫•n completed
  welding: welding2Icon, // H√†n completed
  grinding: grinder2Icon, // M√†i completed
  ndt: ndt2Icon, // NDT completed
  order: order2Icon, // Order completed
  polisher: polisher2Icon, // Polisher completed
  pressing: pressing2Icon, // Pressing completed
  rolling: rolling2Icon, // Rolling completed
  painting: paintBucketFull,
  son: paintBucketFull,
};

/**
 * Ki·ªÉm tra xem processKey c√≥ build-time custom icon kh√¥ng
 * @param {string} processKey
 * @returns {boolean}
 */
export const hasBuildTimeIcon = (processKey) => {
  return BUILD_TIME_CUSTOM_ICONS[processKey] !== undefined;
};

/**
 * L·∫•y build-time custom icon
 * @param {string} processKey
 * @returns {any} React Native Image source
 */
export const getBuildTimeIcon = (processKey) => {
  return BUILD_TIME_CUSTOM_ICONS[processKey];
};

/**
 * L·∫•y build-time custom icon d·ª±a tr√™n tr·∫°ng th√°i
 * @param {string} processKey - Kh√≥a c·ªßa c√¥ng ƒëo·∫°n
 * @param {boolean} isCompleted - Tr·∫°ng th√°i ho√†n th√†nh
 * @returns {any} React Native Image source
 */
export const getBuildTimeIconByState = (processKey, isCompleted = false) => {
  // N·∫øu ho√†n th√†nh v√† c√≥ icon ƒë·∫∑c bi·ªát cho tr·∫°ng th√°i ho√†n th√†nh
  if (isCompleted && COMPLETED_STATE_ICONS[processKey]) {
    return COMPLETED_STATE_ICONS[processKey];
  }

  // Tr·∫£ v·ªÅ icon m·∫∑c ƒë·ªãnh
  return BUILD_TIME_CUSTOM_ICONS[processKey];
};


--- END: src\utils\buildTimeIcons.js ---


--- START: src\utils\permissionChecker.js ---
import { Alert, Platform } from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import { Audio } from 'expo-av';

export const checkAllPermissions = async () => {
  const permissions = {
    camera: false,
    mediaLibrary: false,
    microphone: false,
  };

  try {
    // Ki·ªÉm tra quy·ªÅn camera
    const cameraStatus = await ImagePicker.getCameraPermissionsAsync();
    permissions.camera = cameraStatus.status === 'granted';

    // Ki·ªÉm tra quy·ªÅn th∆∞ vi·ªán media
    const mediaStatus = await ImagePicker.getMediaLibraryPermissionsAsync();
    permissions.mediaLibrary = mediaStatus.status === 'granted';

    // Ki·ªÉm tra quy·ªÅn microphone
    const audioStatus = await Audio.getPermissionsAsync();
    permissions.microphone = audioStatus.status === 'granted';

    console.log('Permission Status:', permissions);

    // Hi·ªÉn th·ªã k·∫øt qu·∫£
    let message = 'Tr·∫°ng th√°i quy·ªÅn:\n';
    message += `üì∑ Camera: ${permissions.camera ? '‚úÖ' : '‚ùå'}\n`;
    message += `üìÅ Media Library: ${permissions.mediaLibrary ? '‚úÖ' : '‚ùå'}\n`;
    message += `üé§ Microphone: ${permissions.microphone ? '‚úÖ' : '‚ùå'}\n`;

    if (!permissions.microphone) {
      message += '\n‚ö†Ô∏è Quy·ªÅn microphone ch∆∞a ƒë∆∞·ª£c c·∫•p!\n';
      message += 'C·∫ßn build l·∫°i ·ª©ng d·ª•ng ƒë·ªÉ √°p d·ª•ng quy·ªÅn m·ªõi.';
    }

    Alert.alert('Ki·ªÉm tra quy·ªÅn', message);

    return permissions;
  } catch (error) {
    console.error('Error checking permissions:', error);
    Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ ki·ªÉm tra quy·ªÅn');
    return permissions;
  }
};

export const requestMicrophonePermission = async () => {
  try {
    const { status } = await Audio.requestPermissionsAsync();
    const granted = status === 'granted';

    Alert.alert(
      'Quy·ªÅn Microphone',
      granted ? '‚úÖ ƒê√£ c·∫•p quy·ªÅn microphone' : '‚ùå Ch∆∞a c·∫•p quy·ªÅn microphone'
    );

    return granted;
  } catch (error) {
    console.error('Error requesting microphone permission:', error);
    Alert.alert('L·ªói', 'Kh√¥ng th·ªÉ xin quy·ªÅn microphone');
    return false;
  }
};


--- END: src\utils\permissionChecker.js ---


--- START: src\utils\stageIcons.js ---
/**
 * Qu·∫£n l√Ω icon cho c√°c lo·∫°i c√¥ng ƒëo·∫°n s·∫£n xu·∫•t
 * S·ª≠ d·ª•ng Ionicons - c√≥ th·ªÉ xem danh s√°ch ƒë·∫ßy ƒë·ªß t·∫°i: https://ionic.io/ionicons
 */

// Import build-time custom icons
import {
  BUILD_TIME_CUSTOM_ICONS,
  getBuildTimeIconByState,
} from './buildTimeIcons';

export const STAGE_ICONS = {
  // === C√îNG ƒêO·∫†N C·∫ÆT ===
  laser_cutting: 'flash', // C·∫Øt laser - tia ch·ªõp
  plasma_cutting: 'flash-outline', // C·∫Øt plasma - tia ch·ªõp vi·ªÅn
  cutting: 'cut-outline', // C·∫Øt th√¥ng th∆∞·ªùng - k√©o c·∫Øt
  cat_phoi: 'cut', // C·∫Øt ph√¥i - k√©o c·∫Øt ƒë·∫≠m

  // === C√îNG ƒêO·∫†N H√ÄN ===
  welding: 'flame', // H√†n - ng·ªçn l·ª≠a
  arc_welding: 'flame-outline', // H√†n h·ªì quang - ng·ªçn l·ª≠a vi·ªÅn
  han: 'bonfire', // H√†n - l·ª≠a tr·∫°i
  han_diem: 'radio-button-on', // H√†n ƒëi·ªÉm - ch·∫•m tr√≤n

  // === C√îNG ƒêO·∫†N S∆†N ===
  painting: 'color-palette', // S∆°n - b·∫£ng m√†u
  spray_painting: 'brush-outline', // S∆°n phun - c·ªç vi·ªÅn
  son: 'brush', // S∆°n - c·ªç s∆°n
  son_lot: 'color-filter', // S∆°n l√≥t - b·ªô l·ªçc m√†u

  // === C√îNG ƒêO·∫†N GIA C√îNG ===
  machining: 'hammer', // Gia c√¥ng - b√∫a
  drilling: 'radio-button-on', // Khoan - ch·∫•m tr√≤n
  milling: 'cog', // Phay - b√°nh rƒÉng
  turning: 'refresh', // Ti·ªán - xoay
  grinding: 'disc', // M√†i - ƒëƒ©a

  // === C√îNG ƒêO·∫†N L·∫ÆP R√ÅP ===
  assembly: 'build', // L·∫Øp r√°p - x√¢y d·ª±ng
  lap_rap: 'construct', // L·∫Øp r√°p - x√¢y d·ª±ng vi·ªÅn
  final_assembly: 'layers', // L·∫Øp r√°p cu·ªëi - nhi·ªÅu l·ªõp

  // === C√îNG ƒêO·∫†N KI·ªÇM TRA ===
  inspection: 'eye', // Ki·ªÉm tra - m·∫Øt
  quality_check: 'shield-checkmark', // Ki·ªÉm tra ch·∫•t l∆∞·ª£ng - khi√™n tick
  testing: 'flask', // Th·ª≠ nghi·ªám - b√¨nh th√≠ nghi·ªám
  kiem_tra: 'search', // Ki·ªÉm tra - k√≠nh l√∫p

  // === C√îNG ƒêO·∫†N V·∫¨N CHUY·ªÇN ===
  shipping: 'car', // V·∫≠n chuy·ªÉn - xe h∆°i
  van_chuyen: 'airplane', // V·∫≠n chuy·ªÉn - m√°y bay
  delivery: 'bicycle', // Giao h√†ng - xe ƒë·∫°p
  logistics: 'bus', // Logistics - xe bu√Ωt

  // === C√îNG ƒêO·∫†N ƒê√ìNG G√ìI ===
  packaging: 'cube', // ƒê√≥ng g√≥i - h√¨nh kh·ªëi
  dong_goi: 'archive', // ƒê√≥ng g√≥i - l∆∞u tr·ªØ
  wrapping: 'gift', // Bao b√¨ - qu√† t·∫∑ng

  // === C√îNG ƒêO·∫†N KH√ÅC ===
  preparation: 'clipboard', // Chu·∫©n b·ªã - b·∫£ng ghi
  setup: 'settings', // Thi·∫øt l·∫≠p - c√†i ƒë·∫∑t
  maintenance: 'construct-outline', // B·∫£o tr√¨ - s·ª≠a ch·ªØa vi·ªÅn
  cleaning: 'water', // V·ªá sinh - n∆∞·ªõc

  // === M·∫∂C ƒê·ªäNH ===
  default: 'ellipse', // M·∫∑c ƒë·ªãnh - h√¨nh elip
};

// Cache cho custom icons
let customIconsCache = {};

/**
 * Load custom icons t·ª´ AsyncStorage
 */
export const loadCustomIcons = async () => {
  try {
    const AsyncStorage =
      require('@react-native-async-storage/async-storage').default;
    const saved = await AsyncStorage.getItem('customStageIcons');
    if (saved) {
      customIconsCache = JSON.parse(saved);
    }
  } catch (error) {
    console.error('Error loading custom icons:', error);
  }
};

/**
 * L·∫•y icon cho m·ªôt lo·∫°i c√¥ng ƒëo·∫°n
 * @param {string} processKey - Kh√≥a c·ªßa c√¥ng ƒëo·∫°n
 * @param {boolean} isCompleted - Tr·∫°ng th√°i ho√†n th√†nh (optional)
 * @returns {string|Object} T√™n icon Ionicons ho·∫∑c custom icon object
 */
export const getStageIcon = (processKey, isCompleted = false) => {
  // 1. ∆Øu ti√™n custom icon t·ª´ user upload (runtime)
  const customIcon = customIconsCache[processKey];
  if (customIcon) {
    return customIcon;
  }

  // 2. Ki·ªÉm tra build-time custom icons (v·ªõi state-aware)
  const buildTimeIcon = getBuildTimeIconByState(processKey, isCompleted);
  if (buildTimeIcon) {
    return {
      type: 'asset',
      data: buildTimeIcon,
    };
  }

  // 3. Cu·ªëi c√πng m·ªõi d√πng Ionicons default
  return STAGE_ICONS[processKey] || STAGE_ICONS.default;
};

/**
 * C·∫≠p nh·∫≠t custom icons cache
 * @param {Object} customIcons - Object ch·ª©a custom icons
 */
export const updateCustomIconsCache = (customIcons) => {
  customIconsCache = { ...customIcons };
};

/**
 * Danh s√°ch c√°c icon ph·ªï bi·∫øn c√≥ th·ªÉ s·ª≠ d·ª•ng
 * Tham kh·∫£o: https://ionic.io/ionicons
 */
export const AVAILABLE_ICONS = {
  // C√¥ng c·ª•
  tools: ['hammer', 'build', 'construct', 'settings', 'cog', 'wrench'],

  // S·∫£n xu·∫•t
  manufacturing: ['flash', 'flame', 'brush', 'cut', 'layers', 'disc'],

  // Ki·ªÉm tra
  inspection: [
    'eye',
    'search',
    'checkmark-circle',
    'shield-checkmark',
    'flask',
  ],

  // V·∫≠n chuy·ªÉn
  transport: ['car', 'airplane', 'bicycle', 'bus', 'boat', 'train'],

  // ƒê√≥ng g√≥i
  packaging: ['cube', 'archive', 'gift', 'bag', 'basket'],

  // H√¨nh d·∫°ng c∆° b·∫£n
  shapes: ['circle', 'square', 'triangle', 'ellipse', 'diamond'],

  // M≈©i t√™n v√† ch·ªâ th·ªã
  arrows: ['arrow-forward', 'arrow-up', 'arrow-down', 'play', 'stop'],
};

/**
 * T·∫°o mapping t√πy ch·ªânh cho d·ª± √°n c·ª• th·ªÉ
 * @param {Object} customMapping - Object mapping processKey -> iconName
 * @returns {Object} Merged icon mapping
 */
export const createCustomIconMapping = (customMapping = {}) => {
  return { ...STAGE_ICONS, ...customMapping };
};


--- END: src\utils\stageIcons.js ---


--- START: src\utils\taskHelpers.js ---
/**
 * Gets the Vietnamese display label for a task key.
 * @param {string} taskKey The key of the task (e.g., "material_cutting").
 * @param {any} taskData The data object for the task, used for the custom "other" task.
 * @returns {string} The display label for the task.
 */
export const getTaskDisplayLabel = (taskKey, taskData) => {
  const taskLabels = {
    material_separation: 'B√≥c t√°ch v·∫≠t t∆∞',
    quotation: 'B√°o gi√°',
    material_purchasing: 'Mua v·∫≠t t∆∞',
    material_cutting: 'C·∫Øt ph√¥i',
    assembly: 'L·∫Øp r√°p',
    painting: 'S∆°n',
    shipping: 'V·∫≠n chuy·ªÉn',
    turning: 'Ti·ªán',
    milling: 'Phay',
    welding: 'H√†n',
    bending: 'Ch·∫•n',
    drilling: 'Khoan',
    grinding: 'M√†i',
    other: taskData?.name || 'C√¥ng vi·ªác kh√°c',
  };
  return taskLabels[taskKey] || taskKey.replace(/_/g, ' ');
};

/**
 * Gets the Vietnamese display label for a task status.
 * @param {string} status The status key (e.g., "in_progress").
 * @returns {string} The display label for the status.
 */
export const getStatusDisplayLabel = (status) => {
  const statusLabels = {
    completed: 'Ho√†n th√†nh',
    in_progress: 'ƒêang th·ª±c hi·ªán',
    pending: 'Ch·ªù x·ª≠ l√Ω',
  };
  return statusLabels[status] || 'Kh√¥ng x√°c ƒë·ªãnh';
};

/**
 * Gets the color code associated with a task status.
 * @param {string} status The status key (e.g., "in_progress").
 * @param {object} theme The application theme object.
 * @returns {string} The color hex code.
 */
export const getStatusColor = (status, theme = {}) => {
  switch (status) {
    case 'completed':
      return theme.statusCompleted || theme.success || '#28a745';
    case 'in_progress':
      return theme.statusInProgress || theme.info || '#17a2b8';
    case 'pending':
      return theme.statusPending || theme.warning || '#ffc107';
    default:
      return theme.textMuted || '#6c757d';
  }
};


--- END: src\utils\taskHelpers.js ---


--- START: functions\src\excelGenerator\index.ts ---
import * as functions from 'firebase-functions/v1';
import { google, sheets_v4 } from 'googleapis';
import { CallableContext } from 'firebase-functions/v1/https';
import * as admin from 'firebase-admin';

// Gi·∫£ s·ª≠ b·∫°n ƒë√£ ƒë·ªãnh nghƒ©a ki·ªÉu n√†y trong file types.ts
interface ExcelQuotationData {
  metadata: {
    projectName?: string;
    customerName?: string;
    customerAddress?: string;
    customerPhone?: string;
    customerEmail?: string;
    customerTaxCode?: string;
    customerContactPerson?: string;
    quotationNumber?: string;
    quoteValidity?: string;
    deliveryTime?: string;
  };
  materials: {
    isNote?: boolean; // Flag to identify note rows
    no: number;
    name: string;
    unit: string;
    quantity: number;
    unitPrice: number;
    total: number;
    material?: string;
    weight?: number; // Th√™m tr∆∞·ªùng weight ƒë·ªÉ l∆∞u kh·ªëi l∆∞·ª£ng v·∫≠t t∆∞
  }[];
  summary: {
    subTotal: number;
    vatPercentage: number;
    vatAmount: number;
    grandTotal: number;
  };
}

// ----- C·∫§U H√åNH -----
const TEMPLATE_FILE_ID = '18CYrE8IHHbqNBc-FWrQw5kGnyLW31VDJOA4a1tusu4M';
// @ts-ignore - Keep for backward compatibility
const DESTINATION_FOLDER_ID = '18OrAEBSuZzz-AFbqlitz5gUxpsdunXjX';
const START_ROW_MATERIALS = 10; // D·ª±a theo ·∫£nh, c√≥ v·∫ª l√† d√≤ng 10
// URL ·∫£nh ch·ªØ k√Ω t·ª´ Firebase Storage - ƒë√£ x√≥a b·ªè
// const SIGNATURE_IMAGE_URL =
//   'https://storage.googleapis.com/tanyb-fe4bf.firebasestorage.app/signature.png';

// ----- H√ÄM CH√çNH -----
export const generateExcelQuotation = functions
  .region('asia-southeast1')
  .runWith({ timeoutSeconds: 300, memory: '512MB' })
  .https.onCall(
    async (
      data: {
        formattedData: ExcelQuotationData;
        projectId: string;
        accessToken: string;
      },
      context: CallableContext
    ) => {
      // ... (Ph·∫ßn x√°c th·ª±c v√† ki·ªÉm tra data gi·ªØ nguy√™n)
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p.'
        );
      }
      const { formattedData, projectId, accessToken } = data;
      if (!formattedData) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá.'
        );
      }

      if (!projectId) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Thi·∫øu ID d·ª± √°n.'
        );
      }

      if (!accessToken) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Thi·∫øu accessToken Google c·ªßa ng∆∞·ªùi d√πng.'
        );
      }

      // S·ª≠ d·ª•ng OAuth2 client c·ªßa googleapis v·ªõi accessToken ng∆∞·ªùi d√πng
      const auth = new google.auth.OAuth2();
      auth.setCredentials({ access_token: accessToken });

      const drive = google.drive({ version: 'v3', auth });
      const sheets = google.sheets({ version: 'v4', auth });

      // L·∫•y th√¥ng tin d·ª± √°n t·ª´ Firestore ƒë·ªÉ t√¨m th∆∞ m·ª•c Drive
      const db = admin.firestore();
      const projectDoc = await db.collection('projects').doc(projectId).get();
      const projectData = projectDoc.data();

      if (!projectData || !projectData.driveFolderId) {
        throw new functions.https.HttpsError(
          'failed-precondition',
          'Kh√¥ng t√¨m th·∫•y th√¥ng tin th∆∞ m·ª•c Drive c·ªßa d·ª± √°n.'
        );
      }

      try {
        // T√¨m th∆∞ m·ª•c con 'baogia' trong th∆∞ m·ª•c d·ª± √°n
        const baogiaFolderResponse = await drive.files.list({
          q: `name='baogia' and '${projectData.driveFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
          fields: 'files(id)',
        });

        // N·∫øu kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c baogia, t·∫°o m·ªõi
        let baogiaFolderId;
        if (
          baogiaFolderResponse.data.files &&
          baogiaFolderResponse.data.files.length > 0
        ) {
          baogiaFolderId = baogiaFolderResponse.data.files[0].id;
        } else {
          // T·∫°o th∆∞ m·ª•c baogia n·∫øu ch∆∞a c√≥
          const folderResponse = await drive.files.create({
            requestBody: {
              name: 'baogia',
              mimeType: 'application/vnd.google-apps.folder',
              parents: [projectData.driveFolderId],
            },
            fields: 'id',
          });
          baogiaFolderId = folderResponse.data.id;
        }

        const newFileName = `B√°o gi√° - ${
          formattedData.metadata.projectName || 'D·ª± √°n'
        } - ${new Date().toLocaleDateString('vi-VN').replace(/\//g, '-')}`;
        const copiedFileResponse = await drive.files.copy({
          fileId: TEMPLATE_FILE_ID,
          requestBody: { name: newFileName, parents: [baogiaFolderId] },
        });

        const newFileId = copiedFileResponse.data.id;
        if (!newFileId) throw new Error('Kh√¥ng th·ªÉ sao ch√©p file template.');

        const spreadsheet = await sheets.spreadsheets.get({
          spreadsheetId: newFileId,
          fields: 'sheets.properties',
        });
        const firstSheet = spreadsheet.data.sheets?.[0];
        const sheetId = firstSheet?.properties?.sheetId;
        if (sheetId === undefined || sheetId === null) {
          throw new Error('Kh√¥ng th·ªÉ x√°c ƒë·ªãnh sheetId c·ªßa sheet ƒë·∫ßu ti√™n');
        }

        // T√≠nh to√°n v·ªã tr√≠ c√°c d√≤ng
        const lastMaterialRow =
          START_ROW_MATERIALS + Math.max(0, formattedData.materials.length - 1);
        const totalRow = lastMaterialRow + 2;
        const vatRow = totalRow + 1;
        const totalWithVatRow = vatRow + 1;
        const amountInWordsRow = totalWithVatRow + 1;
        const blankRowAfterWords = amountInWordsRow + 1; // D√≤ng tr·ªëng
        const notesRow = blankRowAfterWords + 1;
        const footerStartRow = notesRow + 1;
        const signatureRow = footerStartRow + 6;

        const requests: sheets_v4.Schema$Request[] = [];

        // H·ªßy b·ªè merge cell ·ªü v√πng c√≥ th·ªÉ g√¢y l·ªói
        requests.push({
          unmergeCells: {
            range: {
              sheetId,
              startRowIndex: START_ROW_MATERIALS - 1,
              endRowIndex: START_ROW_MATERIALS + 150, // M·ªü r·ªông v√πng l√†m vi·ªác
              startColumnIndex: 0,
              endColumnIndex: 7,
            },
          },
        });

        // X√≥a n·ªôi dung c≈© trong v√πng l√†m vi·ªác ƒë·ªông ƒë·ªÉ tr√°nh d·ªØ li·ªáu th·ª´a t·ª´ template
        requests.push({
          updateCells: {
            range: {
              sheetId,
              startRowIndex: START_ROW_MATERIALS - 1,
              endRowIndex: START_ROW_MATERIALS + 150, // Ph·∫£i kh·ªõp v·ªõi v√πng unmerge
              startColumnIndex: 0,
              endColumnIndex: 7,
            },
            fields: 'userEnteredValue', // Ch·ªâ x√≥a gi√° tr·ªã, gi·ªØ ƒë·ªãnh d·∫°ng
          },
        });

        // Unmerge header rows 4-6 to avoid partial merge errors
        requests.push({
          unmergeCells: {
            range: {
              sheetId,
              startRowIndex: 3, // rows A4, A5, A6 index
              endRowIndex: 6,
              startColumnIndex: 0,
              endColumnIndex: 7,
            },
          },
        });

        // C·∫≠p nh·∫≠t t√™n kh√°ch h√†ng v√†o √¥ A4
        // Merge cells A4-G4 for company name
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 3,
              endRowIndex: 4,
              startColumnIndex: 0,
              endColumnIndex: 7,
            },
          },
        });

        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: `K√çNH G·ª¨I: ${
                        formattedData.metadata.customerName || ''
                      }`,
                    },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      verticalAlignment: 'MIDDLE',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: 3, columnIndex: 0 }, // A4 (0-indexed)
          },
        });

        // Add border to company name
        requests.push({
          updateBorders: {
            range: {
              sheetId,
              startRowIndex: 3,
              endRowIndex: 4,
              startColumnIndex: 0,
              endColumnIndex: 7,
            },
            top: { style: 'SOLID' },
            bottom: { style: 'SOLID' },
            left: { style: 'SOLID' },
            right: { style: 'SOLID' },
          },
        });

        // KH√îNG MERGE cells A5-G5 cho ƒë·ªãa ch·ªâ n·ªØa
        // Th√™m label "ƒê·ªãa ch·ªâ:" v√†o A5
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: { stringValue: 'ƒê·ªãa ch·ªâ:' },
                    userEnteredFormat: {
                      verticalAlignment: 'MIDDLE',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: 4, columnIndex: 0 }, // A5
          },
        });

        // Ghi ƒë·ªãa ch·ªâ v√†o √¥ B5 (kh√¥ng merge)
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: formattedData.metadata.customerAddress || '',
                    },
                    userEnteredFormat: {
                      wrapStrategy: 'WRAP',
                      verticalAlignment: 'MIDDLE',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: 4, columnIndex: 1 }, // B5
          },
        });

        // Merge cells B5:G5 sau khi ƒë√£ thi·∫øt l·∫≠p gi√° tr·ªã th√†nh c√¥ng
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 4,
              endRowIndex: 5,
              startColumnIndex: 1,
              endColumnIndex: 7,
            },
          },
        });

        // Add border to address row
        requests.push({
          updateBorders: {
            range: {
              sheetId,
              startRowIndex: 4,
              endRowIndex: 5,
              startColumnIndex: 0,
              endColumnIndex: 7,
            },
            top: { style: 'SOLID' },
            bottom: { style: 'SOLID' },
            left: { style: 'SOLID' },
            right: { style: 'SOLID' },
          },
        });

        // C·∫≠p nh·∫≠t th√¥ng tin li√™n h·ªá kh√°ch h√†ng v√†o c√°c √¥ t∆∞∆°ng ·ª©ng
        // S·ªë ƒëi·ªán tho·∫°i v√†o √¥ B6
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: formattedData.metadata.customerPhone || '',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue',
            start: { sheetId, rowIndex: 5, columnIndex: 1 }, // B6 (0-indexed)
          },
        });

        // Email v√†o √¥ B7 (v·ªõi ƒë·ªãnh d·∫°ng m√†u ƒëen)
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: formattedData.metadata.customerEmail || '',
                    },
                    userEnteredFormat: {
                      textFormat: {
                        foregroundColor: { red: 0, green: 0, blue: 0 }, // M√†u ƒëen
                      },
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: 6, columnIndex: 1 }, // B7 (0-indexed)
          },
        });

        // M√£ s·ªë thu·∫ø v√†o √¥ C6
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: 'MST:',
                    },
                    userEnteredFormat: {
                      textFormat: { bold: false }, // B·ªè b√¥i ƒë·∫≠m
                      horizontalAlignment: 'LEFT',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: 5, columnIndex: 2 }, // C6
          },
        });

        // Tax code v√†o √¥ D6
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: formattedData.metadata.customerTaxCode || '',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue',
            start: { sheetId, rowIndex: 5, columnIndex: 3 }, // D6 (0-indexed)
          },
        });

        // Ng∆∞·ªùi li√™n h·ªá v√†o √¥ C7
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: 'Attn:',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue',
            start: { sheetId, rowIndex: 6, columnIndex: 2 }, // C7 (0-indexed)
          },
        });

        // Th√™m t√™n ng∆∞·ªùi li√™n h·ªá v√†o √¥ D7
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue:
                        formattedData.metadata.customerContactPerson || '',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue',
            start: { sheetId, rowIndex: 6, columnIndex: 3 }, // D7 (0-indexed)
          },
        });

        if (formattedData.materials.length > 0) {
          const materialsRows: sheets_v4.Schema$RowData[] = [];

          formattedData.materials.forEach((material) => {
            // --- New classification logic ---
            const upperName = (material.name || '').trim().toUpperCase();

            const nameIsNoteMerge = upperName.includes('GHI CH√ö');
            const startsWithPlus = upperName.startsWith('+');

            const isAccessoryRow = upperName.startsWith('PH·ª§ KI·ªÜN ƒêI K√àM');

            const isGroupHeader = /^[IVXLCDM]+$/i.test(
              String(material.no || '').trim()
            );

            const isNoteRow =
              !isAccessoryRow &&
              !isGroupHeader &&
              (material.isNote ||
                nameIsNoteMerge ||
                startsWithPlus ||
                ((!material.unit || material.unit === '') &&
                  (material.quantity === null ||
                    material.quantity === undefined ||
                    material.quantity === 0) &&
                  (!material.material || material.material === '')));

            // È¢ùÂ§ñÊ£ÄÊü•ÂÖ∂‰ªñÁâπÊÆäË°åÊ†ºÂºè
            const isSpecialRow =
              (material.name && material.name.includes('-----')) ||
              (material.name &&
                material.name.toLowerCase().includes('t·ªïng ph·ª•')) ||
              (material.name &&
                material.name.toLowerCase().includes('t·∫°m t√≠nh'));

            // ÊâÄÊúâÈúÄË¶ÅÁâπÊÆäÂ§ÑÁêÜÁöÑË°å
            const shouldFormatAsNote = isNoteRow || isSpecialRow;

            if (shouldFormatAsNote) {
              // Ê†πÊçÆË°åÁ±ªÂûãË∞ÉÊï¥Ê†ºÂºè
              if (isSpecialRow) {
                // ÂØπ‰∫éÁâπÊÆäË°åÔºàÂ¶ÇÊÄªËÆ°Â∞èËÆ°Á≠âÔºâÔºå‰ΩøÁî®ÁâπÊÆäÊ†ºÂºè
                let bgColor = { red: 1, green: 1, blue: 0.9 }; // ÈªòËÆ§ÊµÖÈªÑËâ≤
                let fontStyle = { bold: true, italic: false };
                let alignment = 'CENTER';

                // ÂèØ‰ª•Ê†πÊçÆ‰∏çÂêåÁ±ªÂûãÁöÑÁâπÊÆäË°åËÆæÁΩÆ‰∏çÂêåÁöÑÊ†∑Âºè
                if (
                  material.name &&
                  material.name.toLowerCase().includes('t·ªïng ph·ª•')
                ) {
                  bgColor = { red: 0.9, green: 0.9, blue: 1 }; // ÊµÖËìùËâ≤
                  alignment = 'RIGHT';
                } else if (
                  material.name &&
                  material.name.toLowerCase().includes('t·∫°m t√≠nh')
                ) {
                  bgColor = { red: 0.9, green: 1, blue: 0.9 }; // ÊµÖÁªøËâ≤
                  alignment = 'RIGHT';
                }

                materialsRows.push({
                  values: [
                    {
                      userEnteredValue: { stringValue: material.name || '' },
                      userEnteredFormat: {
                        textFormat: fontStyle,
                        horizontalAlignment: alignment,
                        verticalAlignment: 'MIDDLE',
                        backgroundColor: bgColor,
                      },
                    },
                    {},
                    {},
                    {},
                    {},
                    {},
                  ],
                });
              } else {
                // ÂéüÂßãÂ§áÊ≥®Ë°åÊ†ºÂºè‰øùÊåÅ‰∏çÂèò
                materialsRows.push({
                  values: [
                    {
                      userEnteredValue: { stringValue: material.name || '' },
                      userEnteredFormat: {
                        textFormat: { italic: true, bold: true },
                        horizontalAlignment: 'LEFT',
                        verticalAlignment: 'MIDDLE',
                        backgroundColor: { red: 1, green: 1, blue: 0.9 },
                      },
                    },
                    {},
                    {},
                    {},
                    {},
                    {},
                  ],
                });
              }
            } else {
              if (isAccessoryRow) {
                // Accessory rows: blank numeric columns, distinct background color
                const accessoryBg = { red: 1, green: 0.93, blue: 0.8 }; // light peach
                materialsRows.push({
                  values: [
                    {
                      userEnteredValue: { stringValue: '' }, // Blank STT
                      userEnteredFormat: {
                        backgroundColor: accessoryBg,
                        textFormat: { bold: true },
                        horizontalAlignment: 'CENTER',
                        verticalAlignment: 'MIDDLE',
                      },
                    },
                    {
                      userEnteredValue: { stringValue: material.name || '' },
                      userEnteredFormat: {
                        backgroundColor: accessoryBg,
                        textFormat: { bold: true },
                        horizontalAlignment: 'LEFT',
                        verticalAlignment: 'MIDDLE',
                      },
                    },
                    {
                      userEnteredValue: {
                        stringValue: material.material || '',
                      },
                      userEnteredFormat: {
                        backgroundColor: accessoryBg,
                        textFormat: { bold: true },
                        horizontalAlignment: 'CENTER',
                        verticalAlignment: 'MIDDLE',
                      },
                    },
                    {
                      userEnteredValue: { stringValue: material.unit || '' },
                      userEnteredFormat: {
                        backgroundColor: accessoryBg,
                        textFormat: { bold: true },
                        horizontalAlignment: 'CENTER',
                        verticalAlignment: 'MIDDLE',
                      },
                    },
                    {
                      userEnteredValue: { stringValue: '' },
                      userEnteredFormat: {
                        backgroundColor: accessoryBg,
                        textFormat: { bold: true },
                      },
                    }, // SL blank
                    {
                      userEnteredValue: { stringValue: '' },
                      userEnteredFormat: {
                        backgroundColor: accessoryBg,
                        textFormat: { bold: true },
                      },
                    }, // ƒê∆°n gi√° blank
                    {
                      userEnteredValue: { stringValue: '' },
                      userEnteredFormat: {
                        backgroundColor: accessoryBg,
                        textFormat: { bold: true },
                      },
                    }, // Th√†nh ti·ªÅn blank
                  ],
                });
              } else if (isGroupHeader) {
                // Roman numeral header rows: only STT shown, blank numeric columns, grey background
                const headerBg = { red: 0.9, green: 0.9, blue: 0.9 };
                materialsRows.push({
                  values: [
                    {
                      userEnteredValue: { stringValue: String(material.no) },
                      userEnteredFormat: {
                        backgroundColor: headerBg,
                        textFormat: { bold: true },
                        horizontalAlignment: 'CENTER',
                        verticalAlignment: 'MIDDLE',
                      },
                    },
                    {
                      userEnteredValue: { stringValue: material.name || '' },
                      userEnteredFormat: {
                        backgroundColor: headerBg,
                        textFormat: { bold: true },
                        horizontalAlignment: 'LEFT',
                        verticalAlignment: 'MIDDLE',
                      },
                    },
                    {
                      userEnteredValue: {
                        stringValue: material.material || '',
                      },
                      userEnteredFormat: {
                        backgroundColor: headerBg,
                        horizontalAlignment: 'CENTER',
                        verticalAlignment: 'MIDDLE',
                      },
                    },
                    {
                      userEnteredValue: { stringValue: material.unit || '' },
                      userEnteredFormat: {
                        backgroundColor: headerBg,
                        horizontalAlignment: 'CENTER',
                        verticalAlignment: 'MIDDLE',
                      },
                    },
                    {
                      userEnteredValue: { stringValue: '' },
                      userEnteredFormat: { backgroundColor: headerBg },
                    },
                    {
                      userEnteredValue: { stringValue: '' },
                      userEnteredFormat: { backgroundColor: headerBg },
                    },
                    {
                      userEnteredValue: { stringValue: '' },
                      userEnteredFormat: { backgroundColor: headerBg },
                    },
                  ],
                });
              } else {
                // Regular rows (unchanged logic)
                materialsRows.push({
                  values: [
                    {
                      userEnteredValue: {
                        stringValue: material.no ? String(material.no) : '',
                      },
                      userEnteredFormat: {
                        horizontalAlignment: 'CENTER',
                        verticalAlignment: 'MIDDLE',
                      },
                    },
                    {
                      userEnteredValue: { stringValue: material.name || '' },
                      userEnteredFormat: {
                        horizontalAlignment: 'LEFT',
                        verticalAlignment: 'MIDDLE',
                      },
                    },
                    {
                      userEnteredValue: {
                        stringValue: material.material || '',
                      },
                      userEnteredFormat: {
                        horizontalAlignment: 'CENTER',
                        verticalAlignment: 'MIDDLE',
                      },
                    },
                    {
                      userEnteredValue: { stringValue: material.unit || '' },
                      userEnteredFormat: {
                        horizontalAlignment: 'CENTER',
                        verticalAlignment: 'MIDDLE',
                      },
                    },
                    {
                      userEnteredValue: {
                        numberValue: material.quantity ?? 0,
                      },
                      userEnteredFormat: {
                        horizontalAlignment: 'CENTER',
                        verticalAlignment: 'MIDDLE',
                      },
                    },
                    {
                      userEnteredValue: material.unitPrice
                        ? { numberValue: material.unitPrice }
                        : { stringValue: '' },
                      userEnteredFormat: {
                        numberFormat: { type: 'NUMBER', pattern: '#,##0' },
                        textFormat: { bold: material.unitPrice ? true : false },
                        verticalAlignment: 'MIDDLE',
                      },
                    },
                    {
                      userEnteredValue: material.total
                        ? { numberValue: material.total }
                        : { stringValue: '' },
                      userEnteredFormat: {
                        numberFormat: { type: 'NUMBER', pattern: '#,##0' },
                        textFormat: { bold: material.total ? true : false },
                        verticalAlignment: 'MIDDLE',
                      },
                    },
                  ],
                });
              }
            }
          });
          requests.push({
            updateCells: {
              rows: materialsRows,
              fields: 'userEnteredValue,userEnteredFormat',
              start: {
                sheetId,
                rowIndex: START_ROW_MATERIALS - 1,
                columnIndex: 0,
              },
            },
          });

          // √Åp d·ª•ng font Times New Roman c·ª° 13 cho to√†n b·ªô b·∫£ng v·∫≠t t∆∞ (A:G)
          requests.push({
            repeatCell: {
              range: {
                sheetId,
                startRowIndex: START_ROW_MATERIALS - 1,
                endRowIndex: lastMaterialRow, // D√≤ng cu·ªëi c·ªßa v·∫≠t t∆∞ (exclusive)
                startColumnIndex: 0, // C·ªôt A
                endColumnIndex: 7, // C·ªôt G (exclusive)
              },
              cell: {
                userEnteredFormat: {
                  textFormat: {
                    fontFamily: 'Times New Roman',
                    fontSize: 13,
                  },
                },
              },
              fields:
                'userEnteredFormat.textFormat.fontFamily,userEnteredFormat.textFormat.fontSize',
            },
          });

          // Thi·∫øt l·∫≠p chi·ªÅu cao d√≤ng ~45px (‚âà33.75pt) cho b·∫£ng v·∫≠t t∆∞
          requests.push({
            updateDimensionProperties: {
              range: {
                sheetId,
                dimension: 'ROWS',
                startIndex: START_ROW_MATERIALS - 1,
                endIndex: lastMaterialRow, // exclusive
              },
              properties: { pixelSize: 45 },
              fields: 'pixelSize',
            },
          });

          // Add merge requests for note rows and special rows between notes and total
          formattedData.materials.forEach((material, index) => {
            const nameIsNoteMerge = (material.name || '')
              .toUpperCase()
              .includes('GHI CH√ö');
            const startsWithPlusMerge = (material.name || '')
              .trim()
              .startsWith('+');

            // Êñ∞Â¢ûÈÄªËæëÔºö x√°c ƒë·ªãnh ph·ª• ki·ªán & header
            const upperNameMerge = (material.name || '').trim().toUpperCase();
            const isAccessoryRowMerge =
              upperNameMerge.startsWith('PH·ª§ KI·ªÜN ƒêI K√àM');
            const isGroupHeaderMerge = /^[IVXLCDM]+$/i.test(
              String(material.no || '').trim()
            );

            // Êâ©Â±ïÂêàÂπ∂Êù°‰ª∂ÔºåÂåÖÊã¨Â§áÊ≥®Ë°åÂíåÈúÄË¶ÅÂêàÂπ∂ÁöÑÁâπÊÆäË°åÔºå‰ΩÜ b·ªè qua ph·ª• ki·ªán Âíå header
            const isNoteRowMerge =
              material.isNote ||
              nameIsNoteMerge ||
              startsWithPlusMerge ||
              ((!material.unit || material.unit === '') &&
                (material.quantity === null ||
                  material.quantity === undefined ||
                  material.quantity === 0) &&
                (!material.material || material.material === ''));

            const shouldMergeFullRow =
              (isNoteRowMerge ||
                (material.name && material.name.includes('-----')) ||
                (material.name &&
                  material.name.toLowerCase().includes('t·ªïng ph·ª•')) ||
                (material.name &&
                  material.name.toLowerCase().includes('t·∫°m t√≠nh'))) &&
              !isAccessoryRowMerge &&
              !isGroupHeaderMerge;

            if (shouldMergeFullRow) {
              const noteRowIndex = START_ROW_MATERIALS - 1 + index;
              requests.push({
                mergeCells: {
                  range: {
                    sheetId,
                    startRowIndex: noteRowIndex,
                    endRowIndex: noteRowIndex + 1,
                    startColumnIndex: 0, // Column A
                    endColumnIndex: 7, // Up to column G (7 columns total)
                  },
                  mergeType: 'MERGE_ALL',
                },
              });
            }
          });
        }

        // --- B·∫Øt ƒë·∫ßu ph·∫ßn ƒë·ªãnh d·∫°ng Footer ---
        const blueBg = { red: 200 / 255, green: 204 / 255, blue: 228 / 255 }; // #c8cce4
        const yellowBg = { red: 255 / 255, green: 255 / 255, blue: 204 / 255 };
        const boldRight = {
          horizontalAlignment: 'RIGHT',
          textFormat: { bold: true, fontSize: 11 },
          backgroundColor: blueBg,
        };
        const boldRightValue = {
          ...boldRight,
          numberFormat: { type: 'NUMBER', pattern: '#,##0' },
        };
        const boldCenterYellow = {
          horizontalAlignment: 'CENTER',
          verticalAlignment: 'MIDDLE',
          textFormat: { bold: true, italic: true, fontSize: 11 },
          backgroundColor: yellowBg,
        };

        // T·ªïng c·ªông, VAT, T·ªïng c√≥ VAT (k√©o d√†i ƒë·∫øn c·ªôt G - index 6)
        const summaryEndColumn = 7; // C·ªôt G
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: totalRow - 1,
              endRowIndex: totalRow,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn - 1,
            },
          },
        });
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: { stringValue: 'T·ªïng c·ªông' },
                    userEnteredFormat: boldRight,
                  },
                  {},
                  {},
                  {},
                  {},
                  {},
                  {
                    userEnteredValue: {
                      numberValue: formattedData.summary.subTotal,
                    },
                    userEnteredFormat: boldRightValue,
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: totalRow - 1, columnIndex: 0 },
          },
        });
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: vatRow - 1,
              endRowIndex: vatRow,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn - 1,
            },
          },
        });
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: `Thu·∫ø VAT ${formattedData.summary.vatPercentage}%`,
                    },
                    userEnteredFormat: boldRight,
                  },
                  {},
                  {},
                  {},
                  {},
                  {},
                  {
                    userEnteredValue: {
                      numberValue: formattedData.summary.vatAmount,
                    },
                    userEnteredFormat: boldRightValue,
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: vatRow - 1, columnIndex: 0 },
          },
        });
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: totalWithVatRow - 1,
              endRowIndex: totalWithVatRow,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn - 1,
            },
          },
        });
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: 'T·ªïng c·ªông ƒë√£ bao g·ªìm VAT 10%',
                    },
                    userEnteredFormat: boldRight,
                  },
                  {},
                  {},
                  {},
                  {},
                  {},
                  {
                    userEnteredValue: {
                      numberValue: formattedData.summary.grandTotal,
                    },
                    userEnteredFormat: boldRightValue,
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: totalWithVatRow - 1, columnIndex: 0 },
          },
        });

        // B·∫±ng ch·ªØ
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: amountInWordsRow - 1,
              endRowIndex: amountInWordsRow,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn,
            },
          },
        });
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: convertNumberToVnWords(
                        formattedData.summary.grandTotal
                      ),
                    },
                    userEnteredFormat: boldCenterYellow,
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: amountInWordsRow - 1, columnIndex: 0 },
          },
        });

        // **FIX 3: Merge v√† k·∫ª vi·ªÅn d√≤ng tr·ªëng**
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: blankRowAfterWords - 1,
              endRowIndex: blankRowAfterWords,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn,
            },
          },
        });

        // Ghi ch√∫
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: notesRow - 1,
              endRowIndex: notesRow,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn,
            },
          },
        });
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue:
                        'Ghi ch√∫: C√°c ƒëi·ªÅu kho·∫£n kh√°c vui l√≤ng xem b√™n d∆∞·ªõi.',
                    },
                    userEnteredFormat: {
                      textFormat: { bold: true, italic: true },
                      padding: { left: 10 },
                    },
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: notesRow - 1, columnIndex: 0 },
          },
        });

        // Ph·∫ßn ƒëi·ªÅu kho·∫£n
        const termsTextPart1 =
          `1. B√°o gi√° c√≥ hi·ªáu l·ª±c trong ${
            formattedData.metadata.quoteValidity || '7 ng√†y'
          }. H·∫øt hi·ªáu l·ª±c xin li√™n h·ªá l·∫°i cho C√¥ng ty.\n` +
          `2. Th·ªùi gian giao h√†ng: ${
            formattedData.metadata.deliveryTime || '3 ng√†y'
          } ( kh√¥ng bao g·ªìm ch·ªß nh·∫≠t, ng√†y l·ªÖ )\n` +
          `3. Gi√° ƒë√£ bao g·ªìm VAT v√† ch∆∞a bao g·ªìm v·∫≠n chuy·ªÉn\n` +
          `4. ƒê·ªãa ƒëi·ªÉm giao h√†ng: X∆∞·ªüng THP\n` +
          `5. Ph∆∞∆°ng th·ª©c thanh to√°n: Thanh to√°n b·∫±ng chuy·ªÉn kho·∫£n\n` +
          `    T√†i kho·∫£n s·ªë: 27888866\n` +
          `    T√™n t√†i kho·∫£n: C√¥ng ty TNHH SX c∆° kh√≠ TM-DV T√¢n H√≤a Ph√°t\n` +
          `    Ng√¢n h√†ng TMCP √Å Ch√¢u - Chi nh√°nh B√¨nh T√¢y\n`;
        const termsTextPart2 = `    T·∫°m ·ª©ng 50%, Thanh to√°n 50% tr∆∞·ªõc khi nh·∫≠n h√†ng`;

        // M·ªü r·ªông merge cell cho ƒëi·ªÅu kho·∫£n
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: footerStartRow - 1,
              endRowIndex: footerStartRow + 5,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn,
            },
          },
        });

        // Ph·∫ßn ƒëi·ªÅu kho·∫£n th√¥ng th∆∞·ªùng
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: termsTextPart1,
                    },
                    userEnteredFormat: {
                      wrapStrategy: 'WRAP',
                      verticalAlignment: 'TOP',
                      padding: { left: 20 },
                    },
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: footerStartRow - 1, columnIndex: 0 },
          },
        });

        // Ph·∫ßn ƒëi·ªÅu kho·∫£n m√†u ƒë·ªè (t·∫°m ·ª©ng)
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: termsTextPart2,
                    },
                    userEnteredFormat: {
                      wrapStrategy: 'WRAP',
                      verticalAlignment: 'TOP',
                      padding: { left: 20 },
                      textFormat: {
                        foregroundColor: { red: 1, green: 0, blue: 0 },
                        bold: true,
                      },
                    },
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: footerStartRow + 4, columnIndex: 0 },
          },
        });

        // V√πng ch·ªØ k√Ω
        const buyerSignatureEndCol = 4; // C·ªôt D

        // ƒê·∫ßu ti√™n x√≥a n·ªôi dung ƒëang c√≥ ·ªü v√πng ch·ªØ k√Ω ƒë·ªÉ tr√°nh l·∫∑p l·∫°i
        requests.push({
          updateCells: {
            range: {
              sheetId,
              startRowIndex: signatureRow - 1,
              endRowIndex: signatureRow + 5,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn,
            },
            fields: 'userEnteredValue',
          },
        });

        // Thi·∫øt l·∫≠p l·∫°i "X√°c Nh·∫≠n B√™n Mua"
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: signatureRow - 1,
              endRowIndex: signatureRow,
              startColumnIndex: 0,
              endColumnIndex: buyerSignatureEndCol,
            },
          },
        });

        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: { stringValue: 'X√°c Nh·∫≠n B√™n Mua' },
                    userEnteredFormat: {
                      horizontalAlignment: 'CENTER',
                      textFormat: { bold: true },
                    },
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: signatureRow - 1, columnIndex: 0 },
          },
        });

        // V√πng ƒë·ªÉ k√Ω b√™n mua
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: signatureRow,
              endRowIndex: signatureRow + 5,
              startColumnIndex: 0,
              endColumnIndex: buyerSignatureEndCol,
            },
          },
        });

        // Th√™m border cho khu v·ª±c k√Ω c·ªßa B√™n Mua
        requests.push({
          updateBorders: {
            range: {
              sheetId,
              startRowIndex: signatureRow - 1, // B·∫Øt ƒë·∫ßu t·ª´ header "X√°c Nh·∫≠n B√™n Mua"
              endRowIndex: signatureRow + 5, // K·∫øt th√∫c sau khu v·ª±c ƒë·ªÉ ch·ªØ k√Ω
              startColumnIndex: 0,
              endColumnIndex: buyerSignatureEndCol,
            },
            top: { style: 'SOLID' },
            bottom: { style: 'SOLID' },
            left: { style: 'SOLID' },
            right: { style: 'SOLID' },
            innerHorizontal: { style: 'SOLID' },
            innerVertical: { style: 'SOLID' },
          },
        });

        // Thi·∫øt l·∫≠p "X√°c Nh·∫≠n B√™n B√°n"
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: signatureRow - 1,
              endRowIndex: signatureRow,
              startColumnIndex: buyerSignatureEndCol,
              endColumnIndex: summaryEndColumn,
            },
          },
        });

        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: { stringValue: 'X√°c Nh·∫≠n B√™n B√°n' },
                    userEnteredFormat: {
                      horizontalAlignment: 'CENTER',
                      textFormat: { bold: true },
                    },
                  },
                ],
              },
            ],
            fields: '*',
            start: {
              sheetId,
              rowIndex: signatureRow - 1,
              columnIndex: buyerSignatureEndCol,
            },
          },
        });

        // V√πng ch·ªØ k√Ω b√™n b√°n v√† h√¨nh ·∫£nh ch·ªØ k√Ω
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: signatureRow,
              endRowIndex: signatureRow + 5,
              startColumnIndex: buyerSignatureEndCol,
              endColumnIndex: summaryEndColumn,
            },
          },
        });

        // **FIX 1: Ch√®n ·∫£nh ch·ªØ k√Ω t·ª´ Firebase Storage**
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: signatureRow,
              endRowIndex: signatureRow + 5,
              startColumnIndex: buyerSignatureEndCol,
              endColumnIndex: summaryEndColumn,
            },
          },
        });

        // Ch√®n ·∫£nh ch·ªØ k√Ω t·ª´ Firebase Storage URL - S·ª≠a c√∫ ph√°p d·∫•u ph·∫©y th√†nh d·∫•u ch·∫•m ph·∫©y
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      formulaValue: `=A1`, // X√≥a ·∫£nh ch·ªØ k√Ω v√† s·ª≠ d·ª•ng reference tr·ªëng A1
                    },
                    userEnteredFormat: {
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                    },
                  },
                ],
              },
            ],
            fields: '*',
            start: {
              sheetId,
              rowIndex: signatureRow,
              columnIndex: buyerSignatureEndCol,
            },
          },
        });

        // Ch√®n chu·ªói ng√†y ·ªü √¥ G2 (rowIndex 1) d·∫°ng ddMMyy- b·∫±ng text thu·∫ßn ƒë·ªÉ tr√°nh l·ªói c√¥ng th·ª©c theo locale
        const today = new Date();
        const dd = String(today.getDate()).padStart(2, '0');
        const mm = String(today.getMonth() + 1).padStart(2, '0');
        const yy = String(today.getFullYear()).slice(-2);
        const dateSlash = `${dd}/${mm}/${yy}`; // dd/MM/yy
        const dateText = `${dd}${mm}${yy}-`; // ddMMyy-

        // √î G2 (rowIndex 1): dd/MM/yy
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: { stringValue: dateSlash },
                    userEnteredFormat: {
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      textFormat: {
                        fontFamily: 'Times New Roman',
                        fontSize: 13,
                      },
                    },
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: 1, columnIndex: 6 }, // G2
          },
        });

        // √î G3 (rowIndex 2): ddMMyy-
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: { stringValue: dateText },
                    userEnteredFormat: {
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      textFormat: {
                        fontFamily: 'Times New Roman',
                        fontSize: 13,
                      },
                    },
                  },
                ],
              },
            ],
            fields: '*',
            start: { sheetId, rowIndex: 2, columnIndex: 6 }, // G3
          },
        });

        // Borders for G2 and G3
        const dateRows = [1, 2];
        dateRows.forEach((rowIdx) => {
          requests.push({
            updateBorders: {
              range: {
                sheetId,
                startRowIndex: rowIdx,
                endRowIndex: rowIdx + 1,
                startColumnIndex: 6,
                endColumnIndex: 7,
              },
              top: { style: 'SOLID' },
              bottom: { style: 'SOLID' },
              left: { style: 'SOLID' },
              right: { style: 'SOLID' },
            },
          });
        });

        // **FIX 2 & 4: K·∫ª b·∫£ng ch√≠nh x√°c, lo·∫°i b·ªè border th·ª´a**
        // Instead of one global border, apply borders individually for each row
        // to correctly handle note rows (which should not have innerVertical borders)
        if (formattedData.materials.length > 0) {
          // First apply border to the header row
          requests.push({
            updateBorders: {
              range: {
                sheetId,
                startRowIndex: START_ROW_MATERIALS - 2, // Header row
                endRowIndex: START_ROW_MATERIALS - 1,
                startColumnIndex: 0,
                endColumnIndex: summaryEndColumn,
              },
              top: { style: 'SOLID' },
              bottom: { style: 'SOLID' },
              left: { style: 'SOLID' },
              right: { style: 'SOLID' },
              innerVertical: { style: 'SOLID' },
            },
          });

          // Then apply borders for each material row individually
          formattedData.materials.forEach((material, index) => {
            const rowStartIndex = START_ROW_MATERIALS - 1 + index;
            const rowEndIndex = rowStartIndex + 1;

            const nameIsNoteBorder = (material.name || '')
              .toUpperCase()
              .includes('GHI CH√ö');
            const startsWithPlusBorder = (material.name || '')
              .trim()
              .startsWith('+');
            // (legacy note row detection removed as it's no longer required)

            const upperNameBorder = (material.name || '').trim().toUpperCase();
            const isAccessoryRowBorder =
              upperNameBorder.startsWith('PH·ª§ KI·ªÜN ƒêI K√àM');
            const isGroupHeaderBorder = /^[IVXLCDM]+$/i.test(
              String(material.no || '').trim()
            );

            const isNoteRowBorder =
              material.isNote ||
              nameIsNoteBorder ||
              startsWithPlusBorder ||
              ((!material.unit || material.unit === '') &&
                (material.quantity === null ||
                  material.quantity === undefined ||
                  material.quantity === 0) &&
                (!material.material || material.material === ''));

            const shouldMergeForBorder =
              (isNoteRowBorder ||
                (material.name && material.name.includes('-----')) ||
                (material.name &&
                  material.name.toLowerCase().includes('t·ªïng ph·ª•')) ||
                (material.name &&
                  material.name.toLowerCase().includes('t·∫°m t√≠nh'))) &&
              !isAccessoryRowBorder &&
              !isGroupHeaderBorder;

            if (shouldMergeForBorder) {
              // For note rows, only apply outer borders (no inner vertical borders)
              requests.push({
                updateBorders: {
                  range: {
                    sheetId,
                    startRowIndex: rowStartIndex,
                    endRowIndex: rowEndIndex,
                    startColumnIndex: 0,
                    endColumnIndex: summaryEndColumn,
                  },
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                  // No innerVertical for note rows
                },
              });
            } else {
              // For regular rows, apply full borders including inner vertical lines
              requests.push({
                updateBorders: {
                  range: {
                    sheetId,
                    startRowIndex: rowStartIndex,
                    endRowIndex: rowEndIndex,
                    startColumnIndex: 0,
                    endColumnIndex: summaryEndColumn,
                  },
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                  innerVertical: { style: 'SOLID' },
                },
              });
            }
          });
        }

        // K·∫ª b·∫£ng t·ªïng k·∫øt
        requests.push({
          updateBorders: {
            range: {
              sheetId,
              startRowIndex: totalRow - 1,
              endRowIndex: notesRow,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn,
            },
            top: { style: 'SOLID' },
            bottom: { style: 'SOLID' },
            left: { style: 'SOLID' },
            right: { style: 'SOLID' },
            innerHorizontal: { style: 'SOLID' },
            innerVertical: { style: 'SOLID' }, // <-- TH√äM D√íNG N√ÄY
          },
        });

        // K·∫ª b·∫£ng ƒëi·ªÅu kho·∫£n
        requests.push({
          updateBorders: {
            range: {
              sheetId,
              startRowIndex: notesRow,
              endRowIndex: signatureRow - 1,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn,
            },
            top: { style: 'SOLID' },
            bottom: { style: 'SOLID' },
            left: { style: 'SOLID' },
            right: { style: 'SOLID' },
          },
        });

        // K·∫ª b·∫£ng ch·ªØ k√Ω (quan tr·ªçng: kh√¥ng k·∫ª innerVertical)
        requests.push({
          updateBorders: {
            range: {
              sheetId,
              startRowIndex: signatureRow - 1,
              endRowIndex: signatureRow + 5,
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn,
            },
            top: { style: 'SOLID' },
            bottom: { style: 'SOLID' },
            left: { style: 'SOLID' },
            right: { style: 'SOLID' },
            innerHorizontal: { style: 'SOLID' },
          },
        });

        // X√≥a n·ªôi dung ·ªü c√°c d√≤ng ph√≠a d∆∞·ªõi ƒë·ªÉ tr√°nh hi·ªÉn th·ªã vƒÉn b·∫£n d∆∞ th·ª´a t·ª´ template
        requests.push({
          updateCells: {
            range: {
              sheetId,
              startRowIndex: signatureRow + 6,
              endRowIndex: signatureRow + 20, // X√≥a ƒë·∫øn d√≤ng +20 ƒë·ªÉ ƒë·∫£m b·∫£o x√≥a h·∫øt
              startColumnIndex: 0,
              endColumnIndex: summaryEndColumn,
            },
            fields: 'userEnteredValue',
          },
        });

        // G·ª≠i t·∫•t c·∫£ c√°c request ƒë·ªãnh d·∫°ng
        await sheets.spreadsheets.batchUpdate({
          spreadsheetId: newFileId,
          requestBody: { requests },
        });

        // C·∫•p quy·ªÅn v√† tr·∫£ v·ªÅ URL
        await drive.permissions.create({
          fileId: newFileId,
          requestBody: { role: 'reader', type: 'anyone' },
        });
        const fileResponse = await drive.files.get({
          fileId: newFileId,
          fields: 'webViewLink',
        });

        return {
          success: true,
          excelUrl: fileResponse.data.webViewLink,
          spreadsheetId: newFileId, // Th√™m spreadsheetId v√†o k·∫øt qu·∫£ tr·∫£ v·ªÅ
        };
      } catch (error: any) {
        console.error(
          'L·ªói khi t·∫°o b√°o gi√°:',
          error.response ? error.response.data.error : error.message
        );
        throw new functions.https.HttpsError(
          'internal',
          `L·ªói khi t·∫°o file tr√™n Google Drive: ${error.message}`
        );
      }
    }
  );

// H√†m convertNumberToVnWords gi·ªØ nguy√™n
function convertNumberToVnWords(n: number): string {
  if (n === null || n === undefined) return '';
  const num = Math.floor(n);
  if (num === 0) return 'B·∫±ng ch·ªØ: Kh√¥ng ƒë·ªìng ch·∫µn.';
  const units = ['', ' ngh√¨n', ' tri·ªáu', ' t·ª∑', ' ngh√¨n t·ª∑', ' tri·ªáu t·ª∑'];
  const numbers = [
    'kh√¥ng',
    'm·ªôt',
    'hai',
    'ba',
    'b·ªën',
    'nƒÉm',
    's√°u',
    'b·∫£y',
    't√°m',
    'ch√≠n',
  ];
  const convertGroup = (group: number): string => {
    let result = '';
    const tram = Math.floor(group / 100);
    const chuc = Math.floor((group % 100) / 10);
    const donvi = group % 10;
    if (tram > 0) {
      result += numbers[tram] + ' trƒÉm';
      if (chuc === 0 && donvi !== 0) result += ' linh';
    }
    if (chuc > 1) {
      result += (tram > 0 ? ' ' : '') + numbers[chuc] + ' m∆∞∆°i';
      if (donvi === 1) result += ' m·ªët';
    } else if (chuc === 1) {
      result += (tram > 0 ? ' ' : '') + 'm∆∞·ªùi';
    }
    if (donvi > 0 && chuc !== 1) {
      if (donvi === 5 && chuc > 0) {
        result += (result.length > 0 ? ' ' : '') + 'lƒÉm';
      } else if (donvi === 4 && chuc > 1) {
        result += (result.length > 0 ? ' ' : '') + 't∆∞';
      } else {
        result += (result.length > 0 ? ' ' : '') + numbers[donvi];
      }
    } else if (donvi > 0 && chuc === 1) {
      if (donvi === 5) {
        result += ' lƒÉm';
      } else {
        result += ' ' + numbers[donvi];
      }
    }
    return result;
  };
  if (num === 0) return 'Kh√¥ng';
  let result = '';
  let i = 0;
  let tempNum = num;
  while (tempNum > 0) {
    let groupValue = tempNum % 1000;
    if (groupValue > 0) {
      let groupText = convertGroup(groupValue);
      result = groupText + units[i] + (result ? ' ' + result : '');
    }
    tempNum = Math.floor(tempNum / 1000);
    i++;
  }
  result = result.trim();
  return (
    'B·∫±ng ch·ªØ: ' +
    result.charAt(0).toUpperCase() +
    result.slice(1) +
    ' ƒë·ªìng ch·∫µn.'
  );
}


--- END: functions\src\excelGenerator\index.ts ---


--- START: functions\src\excelGenerator\templateGenerator.ts ---
import * as XLSX from 'xlsx';
import { ExcelQuotationData } from './types';

/**
 * Generates an Excel file based on the quotation data and template
 * @param {ExcelQuotationData} formattedData The formatted data for Excel
 * @returns {Buffer} The Excel file as a buffer
 */
export function generateExcelFile(formattedData: ExcelQuotationData): Buffer {
  // Create a new workbook and worksheet
  const workbook = XLSX.utils.book_new();
  const worksheet = XLSX.utils.aoa_to_sheet([]);

  // Set column widths
  const colWidths = [
    { wch: 5 }, // A
    { wch: 40 }, // B
    { wch: 10 }, // C
    { wch: 10 }, // D
    { wch: 15 }, // E
    { wch: 20 }, // F
    { wch: 20 }, // G
  ];
  worksheet['!cols'] = colWidths;

  // Add company header info (column E)
  addCompanyHeader(worksheet, formattedData);

  // Add quotation information (header and basic info)
  addQuotationHeader(worksheet, formattedData);

  // Add customer information
  addCustomerInfo(worksheet, formattedData);

  // Add materials table
  const materialEndRow = addMaterialsTable(worksheet, formattedData);

  // Add financial summary section
  const summaryEndRow = addFinancialSummary(
    worksheet,
    formattedData,
    materialEndRow
  );

  // Add terms and conditions
  addTermsAndConditions(worksheet, summaryEndRow);

  // Add the worksheet to the workbook
  XLSX.utils.book_append_sheet(workbook, worksheet, 'B√°o gi√°');

  // Generate Excel file as buffer
  const excelBuffer = XLSX.write(workbook, {
    type: 'buffer',
    bookType: 'xlsx',
  });
  return excelBuffer;
}

/**
 * Add company header information to the worksheet
 */
function addCompanyHeader(
  worksheet: XLSX.WorkSheet,
  formattedData: ExcelQuotationData
): void {
  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['C√îNG TY TNHH S·∫¢N XU·∫§T C∆† KH√ç TH∆Ø∆†NG M·∫†I']],
    { origin: 'E1' }
  );

  XLSX.utils.sheet_add_aoa(worksheet, [['D·ªäCH V·ª§ T√ÇN H√íA PH√ÅT']], {
    origin: 'E2',
  });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['ƒêC: S·ªë 7 Qu·ªëc l·ªô 1A ,KP3B,Ph∆∞·ªùng Thanh L·ªôc,Qu·∫≠n']],
    { origin: 'E3' }
  );

  XLSX.utils.sheet_add_aoa(worksheet, [['12,TP.HCM']], { origin: 'E4' });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['MST: 0315155409', 'Web:cokhitanhoaphat.com.vn']],
    { origin: 'E5' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Email :chomcauinoxtanhoaphat.com.vn']],
    { origin: 'E6' }
  );

  XLSX.utils.sheet_add_aoa(worksheet, [['Hotline 24/7: 0978.268.559']], {
    origin: 'E7',
  });
}

/**
 * Add quotation title and basic information
 */
function addQuotationHeader(
  worksheet: XLSX.WorkSheet,
  formattedData: ExcelQuotationData
): void {
  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['B·∫¢NG B√ÅO GI√Å KI·ªÇM X√ÅC NH·∫¨N ƒê·∫∂T H√ÄNG']],
    { origin: 'B9' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Ng√†y'], [formattedData.metadata.quotationDate]],
    { origin: 'F10' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['S·ªê'], [formattedData.metadata.quotationNumber]],
    { origin: 'F11' }
  );
}

/**
 * Add customer information section
 */
function addCustomerInfo(
  worksheet: XLSX.WorkSheet,
  formattedData: ExcelQuotationData
): void {
  XLSX.utils.sheet_add_aoa(worksheet, [['K√çNH G·ª¨I:']], { origin: 'B12' });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['ƒê·ªãa ch·ªâ:', formattedData.metadata.customerAddress]],
    { origin: 'B13' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Tel', ':', '', '', 'MST', ':', '', 'FAX']],
    { origin: 'B14' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Email', ':', '', '', 'Attn', ':', '', 'Mobile:']],
    { origin: 'B15' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [
      [
        'Tr∆∞·ªõc h·∫øt C√¥ng Ty T√¢n H√≤a Ph√°t xin ch√¢n th√†nh c·∫£m ∆°n s·ª± quan t√¢m & h·ª£p t√°c c·ªßa Qu√Ω Kh√°ch. Ch√∫ng t√¥i xin g·ª≠i t·ªõi Qu√Ω kh√°ch b√°o gi√° c√°c ch·ªßng lo·∫°i sau:',
      ],
    ],
    { origin: 'B16' }
  );
}

/**
 * Add materials table to the worksheet
 * @returns The row number after the materials table
 */
function addMaterialsTable(
  worksheet: XLSX.WorkSheet,
  formattedData: ExcelQuotationData
): number {
  // Add table header for materials
  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['STT', 'T√™n g·ªçi', 'V·∫≠t li·ªáu', 'ƒêVT', 'SL', 'ƒê∆°n gi√°', 'Th√†nh Ti·ªÅn']],
    { origin: 'B18' }
  );

  // Add material rows
  let currentRow = 19;
  formattedData.materials.forEach((item) => {
    XLSX.utils.sheet_add_aoa(
      worksheet,
      [
        [
          item.no,
          item.name,
          '',
          item.unit,
          item.quantity,
          item.unitPrice,
          item.total,
        ],
      ],
      { origin: `B${currentRow}` }
    );
    currentRow++;
  });

  return currentRow + 2; // Add 2 rows gap
}

/**
 * Add financial summary section
 * @returns The row number after the summary section
 */
function addFinancialSummary(
  worksheet: XLSX.WorkSheet,
  formattedData: ExcelQuotationData,
  startRow: number
): number {
  // Add summary section after materials
  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['', '', '', '', 'T·ªïng c·ªông:', '', formattedData.summary.subTotal]],
    { origin: `B${startRow}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [
      [
        '',
        '',
        '',
        '',
        `Chi·∫øt kh·∫•u (${formattedData.summary.discountPercentage}%):`,
        '',
        formattedData.summary.discountAmount,
      ],
    ],
    { origin: `B${startRow + 1}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [
      [
        '',
        '',
        '',
        '',
        `Thu·∫ø VAT (${formattedData.summary.vatPercentage}%):`,
        '',
        formattedData.summary.vatAmount,
      ],
    ],
    { origin: `B${startRow + 2}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['', '', '', '', 'T·ªîNG C·ªòNG:', '', formattedData.summary.grandTotal]],
    { origin: `B${startRow + 3}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['B·∫±ng ch·ªØ:', formattedData.summary.amountInWords]],
    { origin: `B${startRow + 5}` }
  );

  return startRow + 8; // Return row after summary section
}

/**
 * Add terms and conditions section
 */
function addTermsAndConditions(
  worksheet: XLSX.WorkSheet,
  startRow: number
): void {
  XLSX.utils.sheet_add_aoa(worksheet, [['Ghi ch√∫:']], {
    origin: `B${startRow}`,
  });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [
      [
        '1. B√°o gi√° c√≥ hi·ªáu l·ª±c trong 7 ng√†y. H·∫øt hi·ªáu l·ª±c xin li√™n h·ªá l·∫°i cho C√¥ng ty.',
      ],
    ],
    { origin: `C${startRow + 2}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['2. Th·ªùi gian giao h√†ng: 3 ng√†y ( kh√¥ng bao g·ªìm ch·ªß nh·∫≠t, ng√†y l·ªÖ )']],
    { origin: `C${startRow + 3}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['3. Gi√° ƒë√£ bao g·ªìm VAT v√† kh√¥ng bao g·ªìm v·∫≠n chuy·ªÉn']],
    { origin: `C${startRow + 4}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['4. ƒê·ªãa ƒëi·ªÉm giao h√†ng: kho b√™n B√°n']],
    { origin: `C${startRow + 5}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [
      [
        '5. Ph∆∞∆°ng th·ª©c thanh to√°n: Qu√Ω Kh√°ch h√†ng vui l√≤ng thanh to√°n b·∫±ng chuy·ªÉn kho·∫£n ƒë·ªÉ xu·∫•t h√≥a ƒë∆°n:',
      ],
    ],
    { origin: `C${startRow + 6}` }
  );

  XLSX.utils.sheet_add_aoa(worksheet, [['T√†i kho·∫£n s·ªë: 27888866']], {
    origin: `C${startRow + 7}`,
  });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['T√™n t√†i kho·∫£n: C√¥ng ty TNHH SX c∆° kh√≠ TM-DV T√¢n H√≤a Ph√°t']],
    { origin: `C${startRow + 8}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Ng√¢n h√†ng TMCP √Å Ch√¢u - Chi nh√°nh: Tam H√†, Th·ªß ƒê·ª©c']],
    { origin: `C${startRow + 9}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['T·∫°m ·ª©ng 50%, Thanh to√°n 50% tr∆∞·ªõc khi nh·∫≠n h√†ng']],
    { origin: `C${startRow + 10}` }
  );
}


--- END: functions\src\excelGenerator\templateGenerator.ts ---


--- START: functions\src\excelGenerator\types.ts ---
/**
 * Interface for Excel formatted quotation data
 */
export interface ExcelQuotationData {
  metadata: {
    companyName: string;
    companyAddress: string;
    companyPhone: string;
    companyEmail: string;
    taxCode: string;
    customerName: string;
    customerAddress: string;
    quotationNumber: string;
    quotationDate: string;
    projectName: string;
    quoteValidity: string;
  };
  materials: Array<{
    no: number;
    name: string;
    unit: string;
    quantity: number;
    unitPrice: number;
    total: number;
  }>;
  summary: {
    subTotal: number;
    discountPercentage: number;
    discountAmount: number;
    vatPercentage: number;
    vatAmount: number;
    grandTotal: number;
    amountInWords: string;
  };
}


--- END: functions\src\excelGenerator\types.ts ---


--- START: functions\src\types\workflow.ts ---
// types for dynamic workflow system
export interface ProcessTemplate {
  /** Readable Vietnamese name, e.g. "C·∫Øt Laser" */
  processName: string;
  /** Unique machine-readable key, e.g. "laser_cutting" */
  processKey: string;
  /** Optional high-level category, e.g. "T·∫°o ph√¥i" */
  category?: string;
}

export interface WorkflowStage {
  /** Firestore document id of the selected template */
  stageId: string;
  processKey: string;
  processName: string;
  /** Smaller number appears first */
  order: number;
  /** pending | in_progress | completed */
  status: 'pending' | 'in_progress' | 'completed';
  /** uid of the assigned employee (can be empty) */
  assignedToId?: string;
}


--- END: functions\src\types\workflow.ts ---


--- START: functions\src\utils\driveClient.ts ---
import { google } from 'googleapis';
import * as path from 'path';
import { SERVICE_ACCOUNT_KEY_PATH } from '../config';

/**
 * Returns an authenticated Google Drive client using the unified service account.
 */
export const getDriveClient = async () => {
  const auth = new google.auth.GoogleAuth({
    keyFile: path.join(__dirname, SERVICE_ACCOUNT_KEY_PATH),
    scopes: ['https://www.googleapis.com/auth/drive'],
  });
  return google.drive({ version: 'v3', auth });
};


--- END: functions\src\utils\driveClient.ts ---


--- START: functions\src\aggregateMonthlyReport.ts ---
import * as admin from 'firebase-admin';
import * as functions from 'firebase-functions/v1';

/**
 * Cloud Function that runs on the 1st of every month at 2:01 AM
 * to aggregate financial data for the previous month
 */
export const aggregateMonthlyReport = functions.pubsub
  .schedule('1 2 1 * *') // Run at 2:01 AM on the 1st of every month
  .timeZone('Asia/Ho_Chi_Minh')
  .onRun(async (context) => {
    try {
      console.log('Starting monthly financial report aggregation...');

      const db = admin.firestore();

      // Get the previous month (1 is February, 0 is January, etc.)
      const now = new Date();
      const currentYear = now.getFullYear();
      const currentMonth = now.getMonth(); // 0-based index

      // If current month is January (0), then previous month is December (11) of the previous year
      const prevMonth = currentMonth === 0 ? 11 : currentMonth - 1;
      const prevYear = currentMonth === 0 ? currentYear - 1 : currentYear;

      console.log(`Aggregating data for ${prevYear}-${prevMonth + 1}`);

      // Create month ID in the format YYYY-MM
      const monthId = `${prevYear}-${(prevMonth + 1)
        .toString()
        .padStart(2, '0')}`;

      // Get start and end dates for the previous month
      const startDate = new Date(prevYear, prevMonth, 1);
      const endDate = new Date(prevYear, prevMonth + 1, 0, 23, 59, 59, 999); // Last day of the month

      console.log(
        `Date range: ${startDate.toISOString()} - ${endDate.toISOString()}`
      );

      // Get all paid invoices for the previous month
      const invoicesSnapshot = await db
        .collection('invoices')
        .where('status', '==', 'paid')
        .where('paidDate', '>=', startDate)
        .where('paidDate', '<=', endDate)
        .get();

      // Calculate total revenue
      let totalRevenue = 0;
      invoicesSnapshot.forEach((doc) => {
        const invoice = doc.data();
        totalRevenue += invoice.amount || 0;
      });

      console.log(`Total revenue for ${monthId}: ${totalRevenue}`);

      // Get all expenses for the previous month
      const expensesSnapshot = await db
        .collection('expenses')
        .where('date', '>=', startDate)
        .where('date', '<=', endDate)
        .get();

      // Calculate total expenses and categorize them
      let totalExpenses = 0;
      const expenseBreakdown = {
        material: 0,
        labor: 0,
        overhead: 0,
      };

      expensesSnapshot.forEach((doc) => {
        const expense = doc.data();
        const amount = expense.amount || 0;

        // Add to total expenses
        totalExpenses += amount;

        // Categorize expense
        if (expense.projectId) {
          // Direct project expense
          if (expense.type === 'material') {
            expenseBreakdown.material += amount;
          } else if (expense.type === 'labor') {
            expenseBreakdown.labor += amount;
          } else {
            // Uncategorized project expense goes to material as default
            expenseBreakdown.material += amount;
          }
        } else {
          // No projectId means overhead/indirect expense
          expenseBreakdown.overhead += amount;
        }
      });

      console.log(`Total expenses for ${monthId}: ${totalExpenses}`);

      // Calculate profit
      const profit = totalRevenue - totalExpenses;

      // Create or update the monthly summary document
      await db
        .collection('monthly_summaries')
        .doc(monthId)
        .set({
          year: prevYear,
          month: prevMonth + 1,
          totalRevenue,
          totalExpenses,
          profit,
          expenseBreakdown,
          lastUpdated: admin.firestore.FieldValue.serverTimestamp(),
        });

      console.log(`Successfully generated financial report for ${monthId}`);
      return null;
    } catch (error) {
      console.error('Error generating monthly financial report:', error);
      throw error;
    }
  });
 

--- END: functions\src\aggregateMonthlyReport.ts ---


--- START: functions\src\attendanceExcelGenerator.ts ---
import * as functions from 'firebase-functions/v1';
import { google, sheets_v4 } from 'googleapis';
import { CallableContext } from 'firebase-functions/v1/https';
import * as admin from 'firebase-admin';

// Ensure admin is initialized
try {
  admin.app();
} catch (e) {
  admin.initializeApp();
}

// Define attendance data interface
interface AttendanceRecord {
  userId: string;
  userName: string;
  date: string;
  present?: boolean;
  overtime?: number;
  clockIn?: admin.firestore.Timestamp;
  clockOut?: admin.firestore.Timestamp;
}

// ----- CONFIGURATION -----

// ----- MAIN FUNCTION -----
export const generateExcelAttendance = functions
  .region('asia-southeast1') // Using asia-southeast1 which was working before
  .runWith({
    timeoutSeconds: 300,
    memory: '1GB',
    maxInstances: 10,
  })
  .https.onCall(
    async (
      data: {
        year: number;
        month: number;
        projectId?: string;
        accessToken: string;
      },
      context: CallableContext
    ) => {
      // Add detailed logging for debugging
      console.log('Attendance Generator called with data:', {
        year: data.year,
        month: data.month,
        projectId: data.projectId,
        hasAccessToken: data.accessToken ? 'Yes' : 'No',
      });
      console.log(
        'Auth context:',
        context.auth ? 'Authenticated' : 'Not authenticated'
      );

      // Check authentication
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ s·ª≠ d·ª•ng t√≠nh nƒÉng n√†y.'
        );
      }

      // Check if we have the required data
      const { year, month, projectId, accessToken } = data;

      // Validate required parameters
      if (!year || !month) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Thi·∫øu th√¥ng tin nƒÉm v√† th√°ng.'
        );
      }

      // Check for accessToken (required for Google API access)
      if (!accessToken) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Thi·∫øu accessToken Google c·ªßa ng∆∞·ªùi d√πng.'
        );
      }

      try {
        // Initialize Google APIs with user accessToken similar to other generators
        const auth = new google.auth.OAuth2();
        auth.setCredentials({ access_token: accessToken });

        const drive = google.drive({ version: 'v3', auth });
        const sheets = google.sheets({ version: 'v4', auth });

        // Get the first and last day of the month
        const firstDayOfMonth = new Date(year, month - 1, 1);
        const lastDayOfMonth = new Date(year, month, 0);
        const daysInMonth = lastDayOfMonth.getDate();

        // Format dates for Firestore queries
        const formatDate = (date: Date) => {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          return `${year}-${month}-${day}`;
        };

        const startDate = formatDate(firstDayOfMonth);
        const endDate = formatDate(lastDayOfMonth);

        console.log(
          `ƒêang truy xu·∫•t d·ªØ li·ªáu ch·∫•m c√¥ng t·ª´ ${startDate} ƒë·∫øn ${endDate}`
        );

        // Get Firestore database reference
        const db = admin.firestore();

        // Get all employees
        const usersSnapshot = await db.collection('users').get();
        const employees = usersSnapshot.docs.map((doc) => ({
          userId: doc.id,
          name: doc.data().displayName || doc.data().email || doc.id,
          dailySalary: doc.data().dailySalary || 0,
          monthlySalary: doc.data().monthlySalary || 0, // Get monthly salary
        }));

        // Get all attendance records for the month
        const attendanceQuery = db
          .collection('attendance')
          .where('date', '>=', startDate)
          .where('date', '<=', endDate);

        const attendanceSnapshot = await attendanceQuery.get();
        const attendanceRecords: AttendanceRecord[] =
          attendanceSnapshot.docs.map((doc) => {
            const data = doc.data();
            return {
              userId: data.userId,
              userName: '', // Will be filled later
              date: data.date,
              present: data.present,
              overtime: data.overtime,
              clockIn: data.clockIn,
              clockOut: data.clockOut,
            };
          });

        // Process attendance data by employee and day
        const employeeAttendance = employees.map((employee) => {
          const attendanceByDay: {
            [day: number]: { present: boolean; overtime: boolean };
          } = {};

          // Initialize all days to absent
          for (let day = 1; day <= daysInMonth; day++) {
            attendanceByDay[day] = { present: false, overtime: false };
          }

          // Fill in actual attendance data
          attendanceRecords
            .filter((record) => record.userId === employee.userId)
            .forEach((record) => {
              const day = parseInt(record.date.split('-')[2]);
              const isPresent = record.present || record.clockIn !== undefined;
              const hasOvertime =
                record.overtime !== undefined && record.overtime > 0;

              attendanceByDay[day] = {
                present: isPresent,
                overtime: hasOvertime,
              };
            });

          return {
            userId: employee.userId,
            name: employee.name,
            attendanceByDay,
          };
        });

        // Calculate salary for each employee
        const salaryData = employeeAttendance.map((employee) => {
          // Count regular workdays (present regardless of overtime)
          const regularWorkDays = Object.entries(
            employee.attendanceByDay
          ).filter(([_, value]) => value.present).length;

          // Count overtime instances (0.5 per overtime)
          const overtimeCount = Object.entries(employee.attendanceByDay).filter(
            ([_, value]) => value.overtime
          ).length;

          // Calculate total work units (1 for each regular day + 0.5 for each overtime)
          const totalWorkUnits = regularWorkDays + overtimeCount * 0.5;

          const employeeDetails = employees.find(
            (e) => e.userId === employee.userId
          );
          const dailySalary = employeeDetails?.dailySalary || 0;
          const monthlySalary = employeeDetails?.monthlySalary || 0;

          let totalSalary = 0;
          let salaryType = '';

          // Determine salary type and calculate total salary
          if (monthlySalary > 0 && dailySalary === 0) {
            // Only monthly salary is set
            totalSalary = monthlySalary;
            salaryType = 'C·ªë ƒë·ªãnh th√°ng';
          } else if (dailySalary > 0 && monthlySalary === 0) {
            // Only daily salary is set - calculate based on total work units
            totalSalary = totalWorkUnits * dailySalary;
            salaryType = 'Theo ng√†y';
          } else if (dailySalary > 0 && monthlySalary > 0) {
            // Both are set - this shouldn't happen with the new UI, but handle it gracefully
            console.log(
              `Warning: User ${employee.name} has both salary types set. Using monthly salary.`
            );
            totalSalary = monthlySalary;
            salaryType = 'C·ªë ƒë·ªãnh th√°ng';
          } else {
            // No salary is set
            totalSalary = 0;
            salaryType = 'Ch∆∞a thi·∫øt l·∫≠p';
          }

          return {
            name: employee.name,
            regularWorkDays,
            overtimeCount,
            totalWorkUnits,
            dailySalary,
            monthlySalary,
            totalSalary,
            salaryType,
          };
        });

        // Find or create root folder in Drive
        let rootFolderId: string;

        if (projectId) {
          // If project ID is provided, use the project folder
          const projectDoc = await db
            .collection('projects')
            .doc(projectId)
            .get();
          const projectData = projectDoc.data();

          if (!projectData || !projectData.driveFolderId) {
            throw new functions.https.HttpsError(
              'failed-precondition',
              'Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c Drive c·ªßa d·ª± √°n.'
            );
          }

          rootFolderId = projectData.driveFolderId;
        } else {
          // Otherwise look for a company root folder
          const rootFolderResponse = await drive.files.list({
            q: `name='THP' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
            fields: 'files(id)',
          });

          if (
            rootFolderResponse.data.files &&
            rootFolderResponse.data.files.length > 0
          ) {
            rootFolderId = rootFolderResponse.data.files[0].id;
          } else {
            // Create root folder if it doesn't exist
            const folderResponse = await drive.files.create({
              requestBody: {
                name: 'THP',
                mimeType: 'application/vnd.google-apps.folder',
              },
              fields: 'id',
            });
            rootFolderId = folderResponse.data.id;
          }
        }

        // Create a new spreadsheet
        const monthName = new Date(year, month - 1, 1).toLocaleString('vi-VN', {
          month: 'long',
        });
        const fileName = `B·∫£ng ch·∫•m c√¥ng - ${monthName} ${year}`;

        console.log(`B·∫Øt ƒë·∫ßu t·∫°o file Excel: ${fileName}`);

        // Calculate the required number of rows and columns
        const requiredRows = employees.length + 30; // Header + employees + legend + salary table + buffer
        const requiredColumns = Math.max(daysInMonth + 10, 30); // Ensure enough columns for all data

        // Create a new spreadsheet with sufficient rows and columns
        const spreadsheetResponse = await sheets.spreadsheets.create({
          requestBody: {
            properties: {
              title: fileName,
            },
            sheets: [
              {
                properties: {
                  title: 'Ch·∫•m c√¥ng',
                  gridProperties: {
                    rowCount: requiredRows,
                    columnCount: requiredColumns,
                  },
                },
              },
            ],
          },
        });

        const spreadsheetId = spreadsheetResponse.data.spreadsheetId;
        if (!spreadsheetId) {
          throw new Error('Kh√¥ng t·∫°o ƒë∆∞·ª£c b·∫£ng t√≠nh');
        }

        // Move the file to the desired folder
        await drive.files.update({
          fileId: spreadsheetId,
          addParents: rootFolderId,
          removeParents: 'root',
          fields: 'id, parents',
        });

        const sheetId =
          spreadsheetResponse.data.sheets?.[0].properties?.sheetId;
        if (!sheetId) {
          throw new Error('Kh√¥ng t√¨m th·∫•y ID sheet');
        }

        // Prepare the spreadsheet with headers
        const requests: sheets_v4.Schema$Request[] = [];

        // Set column widths
        requests.push({
          updateDimensionProperties: {
            range: {
              sheetId,
              dimension: 'COLUMNS',
              startIndex: 0,
              endIndex: 1,
            },
            properties: {
              pixelSize: 200, // Width for column A (names)
            },
            fields: 'pixelSize',
          },
        });

        // Set header style for the entire first row
        requests.push({
          repeatCell: {
            range: {
              sheetId,
              startRowIndex: 0,
              endRowIndex: 1,
              startColumnIndex: 0,
              endColumnIndex: daysInMonth + 1,
            },
            cell: {
              userEnteredFormat: {
                backgroundColor: { red: 0.8, green: 0.8, blue: 0.8 },
                horizontalAlignment: 'CENTER',
                textFormat: { bold: true },
                borders: {
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                },
              },
            },
            fields: 'userEnteredFormat',
          },
        });

        // Add column headers (days of the month)
        const headerValues = [
          { userEnteredValue: { stringValue: 'T√™n nh√¢n vi√™n' } },
        ];

        for (let day = 1; day <= daysInMonth; day++) {
          headerValues.push({
            userEnteredValue: { stringValue: String(day) },
          });
        }

        requests.push({
          updateCells: {
            rows: [{ values: headerValues }],
            fields: 'userEnteredValue',
            start: { sheetId, rowIndex: 0, columnIndex: 0 },
          },
        });

        // Add employee rows with attendance data
        const rows: sheets_v4.Schema$RowData[] = employeeAttendance.map(
          (employee) => {
            const cells: sheets_v4.Schema$CellData[] = [
              {
                userEnteredValue: { stringValue: employee.name },
                userEnteredFormat: {
                  verticalAlignment: 'MIDDLE',
                  borders: {
                    top: { style: 'SOLID' },
                    bottom: { style: 'SOLID' },
                    left: { style: 'SOLID' },
                    right: { style: 'SOLID' },
                  },
                },
              },
            ];

            // Add attendance cells for each day
            for (let day = 1; day <= daysInMonth; day++) {
              const attendance = employee.attendanceByDay[day];
              let cellValue = '';

              if (attendance.present && attendance.overtime) {
                cellValue = 'O'; // Overtime
              } else if (attendance.present) {
                cellValue = 'X'; // Present
              } else {
                cellValue = ''; // Absent
              }

              cells.push({
                userEnteredValue: { stringValue: cellValue },
                userEnteredFormat: {
                  horizontalAlignment: 'CENTER',
                  verticalAlignment: 'MIDDLE',
                  borders: {
                    top: { style: 'SOLID' },
                    bottom: { style: 'SOLID' },
                    left: { style: 'SOLID' },
                    right: { style: 'SOLID' },
                  },
                  backgroundColor: attendance.overtime
                    ? { red: 1, green: 0.9, blue: 0.6 } // Light yellow for overtime
                    : attendance.present
                    ? { red: 0.9, green: 1, blue: 0.9 } // Light green for present
                    : undefined, // No color for absent
                },
              });
            }

            return { values: cells };
          }
        );

        // Add all rows to the sheet
        requests.push({
          updateCells: {
            rows,
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: 1, columnIndex: 0 },
          },
        });

        // Add legend at the bottom
        const legendRow = rows.length + 2; // Add some spacing after the data
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: { stringValue: 'Ch√∫ th√≠ch:' },
                    userEnteredFormat: { textFormat: { bold: true } },
                  },
                ],
              },
              {
                values: [
                  {
                    userEnteredValue: { stringValue: 'X: ƒêi l√†m 1 c√¥ng' },
                  },
                ],
              },
              {
                values: [
                  {
                    userEnteredValue: { stringValue: 'O: C√≥ tƒÉng ca' },
                  },
                ],
              },
              {
                values: [
                  {
                    userEnteredValue: { stringValue: '√î tr·ªëng: Ngh·ªâ' },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: legendRow, columnIndex: 0 },
          },
        });

        // Add salary table header
        const salaryHeaderRow = legendRow + 5; // Add some spacing
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: { stringValue: 'B·∫£ng L∆∞∆°ng' },
                    userEnteredFormat: {
                      textFormat: { bold: true, fontSize: 14 },
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: salaryHeaderRow, columnIndex: 0 },
          },
        });
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: salaryHeaderRow,
              endRowIndex: salaryHeaderRow + 1,
              startColumnIndex: 0,
              endColumnIndex: 8, // Increased column span for more columns
            },
            mergeType: 'MERGE_ALL',
          },
        });

        const salaryTableStartRow = salaryHeaderRow + 1;
        const salaryHeaderCells = [
          'T√™n Nh√¢n Vi√™n',
          'S·ªë Ng√†y C√¥ng',
          'S·ªë L·∫ßn TƒÉng Ca',
          'T·ªïng C√¥ng',
          'L∆∞∆°ng/Ng√†y',
          'L∆∞∆°ng C·ªë ƒê·ªãnh',
          'Lo·∫°i L∆∞∆°ng',
          'T·ªïng L∆∞∆°ng',
        ].map((header) => ({
          userEnteredValue: { stringValue: header },
          userEnteredFormat: {
            textFormat: { bold: true },
            backgroundColor: { red: 0.9, green: 0.9, blue: 0.9 },
          },
        }));

        requests.push({
          updateCells: {
            rows: [{ values: salaryHeaderCells }],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: salaryTableStartRow, columnIndex: 0 },
          },
        });

        // Add salary data rows
        const salaryRows = salaryData.map((data) => ({
          values: [
            { userEnteredValue: { stringValue: data.name } },
            {
              userEnteredValue: { numberValue: data.regularWorkDays },
              userEnteredFormat: { horizontalAlignment: 'CENTER' },
            },
            {
              userEnteredValue: { numberValue: data.overtimeCount },
              userEnteredFormat: { horizontalAlignment: 'CENTER' },
            },
            {
              userEnteredValue: { numberValue: data.totalWorkUnits },
              userEnteredFormat: { horizontalAlignment: 'CENTER' },
            },
            {
              userEnteredValue: { numberValue: data.dailySalary },
              userEnteredFormat: {
                numberFormat: { type: 'NUMBER', pattern: '#,##0' },
              },
            },
            {
              userEnteredValue: { numberValue: data.monthlySalary },
              userEnteredFormat: {
                numberFormat: { type: 'NUMBER', pattern: '#,##0' },
              },
            },
            {
              userEnteredValue: { stringValue: data.salaryType },
              userEnteredFormat: { horizontalAlignment: 'CENTER' },
            },
            {
              userEnteredValue: { numberValue: data.totalSalary },
              userEnteredFormat: {
                numberFormat: { type: 'NUMBER', pattern: '#,##0' },
              },
            },
          ],
        }));

        // Make sure we have enough rows for the data - this is now redundant but kept for safety
        const gridProperties = {
          rowCount: Math.max(
            salaryTableStartRow + salaryRows.length + 5,
            requiredRows
          ),
          columnCount: requiredColumns,
        };

        // Update sheet properties to ensure enough rows and columns
        requests.push({
          updateSheetProperties: {
            properties: {
              sheetId,
              gridProperties,
            },
            fields: 'gridProperties',
          },
        });

        // Then add the salary rows
        requests.push({
          updateCells: {
            rows: salaryRows,
            fields: 'userEnteredValue,userEnteredFormat',
            start: {
              sheetId,
              rowIndex: salaryTableStartRow + 1,
              columnIndex: 0,
            },
          },
        });

        // Apply all updates to the spreadsheet
        await sheets.spreadsheets.batchUpdate({
          spreadsheetId,
          requestBody: { requests },
        });

        // Make the file accessible to anyone with the link
        await drive.permissions.create({
          fileId: spreadsheetId,
          requestBody: { role: 'reader', type: 'anyone' },
        });

        // Get the file's web view link
        const fileResponse = await drive.files.get({
          fileId: spreadsheetId,
          fields: 'webViewLink',
        });

        console.log('ƒê√£ t·∫°o file Excel b√°o c√°o ch·∫•m c√¥ng th√†nh c√¥ng');

        return {
          success: true,
          fileId: spreadsheetId,
          fileUrl: fileResponse.data.webViewLink,
          message: 'ƒê√£ t·∫°o file Excel b√°o c√°o ch·∫•m c√¥ng th√†nh c√¥ng',
        };
      } catch (error: any) {
        console.error('Error details in generateExcelAttendance:', error);
        throw new functions.https.HttpsError(
          'internal',
          `L·ªói khi t·∫°o file Excel ch·∫•m c√¥ng: ${error.message}`,
          error
        );
      }
    }
  );


--- END: functions\src\attendanceExcelGenerator.ts ---


--- START: functions\src\config.ts ---
export const APP_DRIVE_ROOT_FOLDER_ID = '1ZN8CxmHgAC2yzDqDVaJWxKSrpD4OjFUT'; // TODO: Set to THP_APP_DATA_ROOT folder ID
export const SERVICE_ACCOUNT_KEY_PATH =
  '../../service-account-credentials.json';


--- END: functions\src\config.ts ---


--- START: functions\src\contractGenerator.ts ---
/**
 * @fileoverview Cloud Function to generate a contract from a Google Docs template.
 *
 * @description
 * This function implements a professional "Native Table Insertion" approach for generating
 * contracts. It creates a properly formatted table directly using Google Docs API.
 *
 * H∆Ø·ªöNG D·∫™N C·∫§U H√åNH TEMPLATE GOOGLE DOCS (QUAN TR·ªåNG):
 *
 * 1. **Chu·∫©n b·ªã Template:**
 *    - T·∫°o m·ªôt file Google Docs ƒë·ªÉ l√†m m·∫´u h·ª£p ƒë·ªìng.
 *    - ƒê·∫∑t c√°c placeholder cho c√°c tr∆∞·ªùng vƒÉn b·∫£n ƒë∆°n gi·∫£n, v√≠ d·ª•: {companyName}, {customerAddress}, {grandTotal}.
 *
 * 2. **Chu·∫©n b·ªã ph·∫ßn B·∫£ng V·∫≠t T∆∞:**
 *    - Ch·ªâ c·∫ßn ƒë·∫∑t m·ªôt placeholder ƒë∆°n gi·∫£n: {{MATERIALS_TABLE}}
 *    - Placeholder n√†y s·∫Ω ƒë∆∞·ª£c thay th·∫ø b·∫±ng m·ªôt b·∫£ng th·ª±c s·ª± ƒë∆∞·ª£c t·∫°o b·ªüi Google Docs API.
 *    - B·∫£ng s·∫Ω t·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh k√≠ch th∆∞·ªõc d·ª±a tr√™n s·ªë l∆∞·ª£ng v·∫≠t t∆∞.
 *
 * 3. **L·∫•y ID Template:**
 *    - M·ªü file template Google Docs, copy ID t·ª´ URL.
 *      (V√≠ d·ª•: trong `.../d/THIS_IS_THE_ID/edit`, `THIS_IS_THE_ID` ch√≠nh l√† ID).
 *    - C·∫≠p nh·∫≠t bi·∫øn `CONTRACT_TEMPLATE_ID` b√™n d∆∞·ªõi b·∫±ng ID n√†y.
 */
import * as functions from 'firebase-functions/v1';
// path import removed
import * as admin from 'firebase-admin';
// Import ki·ªÉu d·ªØ li·ªáu, kh√¥ng import th∆∞ vi·ªán th·ª±c t·∫ø
import type { docs_v1 } from 'googleapis';

// --- CONFIGURATION ---
// TODO: Thay th·∫ø b·∫±ng ID c·ªßa file Google Docs template c·ªßa b·∫°n
const CONTRACT_TEMPLATE_ID = '1d0ERJFmbBmhqe4CcaMi02EBi20BXYCgZeasMCbT6ULc'; // ID TEMPLATE C·∫¶N ƒê∆Ø·ª¢C C·∫¨P NH·∫¨T

// --- TYPE DEFINITIONS ---
// ƒê·ªãnh nghƒ©a c·∫•u tr√∫c cho m·ªôt h√†ng v·∫≠t t∆∞
interface MaterialItem {
  name: string;
  material: string;
  unit: string;
  quantity: number | string;
  unitPrice: number | string;
  totalPrice: number | string;
  weight?: number | string; // Th√™m tr·ªçng l∆∞·ª£ng ƒë·ªÉ t√≠nh ƒë∆°n gi√°
  [key: string]: any;
}

// ƒê·ªãnh nghƒ©a c·∫•u tr√∫c cho d·ªØ li·ªáu h·ª£p ƒë·ªìng ƒë∆∞·ª£c g·ª≠i t·ª´ client
interface ContractData {
  materials?: MaterialItem[];
  subTotal?: number;
  vatPercentage?: number;
  vatAmount?: number;
  grandTotal?: number;
  [key: string]: any; // Cho ph√©p c√°c tr∆∞·ªùng kh√°c
}

/**
 * Chuy·ªÉn s·ªë th√†nh ch·ªØ ti·∫øng Vi·ªát
 * @param n S·ªë c·∫ßn chuy·ªÉn ƒë·ªïi
 * @returns Chu·ªói bi·ªÉu di·ªÖn s·ªë b·∫±ng ch·ªØ ti·∫øng Vi·ªát
 */
function convertNumberToVnWords(n: number): string {
  if (n === null || n === undefined) return '';
  const num = Math.floor(n);
  if (num === 0) return 'B·∫±ng ch·ªØ: Kh√¥ng ƒë·ªìng ch·∫µn.';
  const units = ['', ' ngh√¨n', ' tri·ªáu', ' t·ª∑', ' ngh√¨n t·ª∑', ' tri·ªáu t·ª∑'];
  const numbers = [
    'kh√¥ng',
    'm·ªôt',
    'hai',
    'ba',
    'b·ªën',
    'nƒÉm',
    's√°u',
    'b·∫£y',
    't√°m',
    'ch√≠n',
  ];
  const convertGroup = (group: number): string => {
    let result = '';
    const tram = Math.floor(group / 100);
    const chuc = Math.floor((group % 100) / 10);
    const donvi = group % 10;
    if (tram > 0) {
      result += numbers[tram] + ' trƒÉm';
      if (chuc === 0 && donvi !== 0) result += ' linh';
    }
    if (chuc > 1) {
      result += (tram > 0 ? ' ' : '') + numbers[chuc] + ' m∆∞∆°i';
      if (donvi === 1) result += ' m·ªët';
    } else if (chuc === 1) {
      result += (tram > 0 ? ' ' : '') + 'm∆∞·ªùi';
    }
    if (donvi > 0 && chuc !== 1) {
      if (donvi === 5 && chuc > 0) {
        result += (result.length > 0 ? ' ' : '') + 'lƒÉm';
      } else if (donvi === 4 && chuc > 1) {
        result += (result.length > 0 ? ' ' : '') + 't∆∞';
      } else {
        result += (result.length > 0 ? ' ' : '') + numbers[donvi];
      }
    } else if (donvi > 0 && chuc === 1) {
      if (donvi === 5) {
        result += ' lƒÉm';
      } else {
        result += ' ' + numbers[donvi];
      }
    }
    return result;
  };
  if (num === 0) return 'Kh√¥ng';
  let result = '';
  let i = 0;
  let tempNum = num;
  while (tempNum > 0) {
    let groupValue = tempNum % 1000;
    if (groupValue > 0) {
      let groupText = convertGroup(groupValue);
      result = groupText + units[i] + (result ? ' ' + result : '');
    }
    tempNum = Math.floor(tempNum / 1000);
    i++;
  }
  result = result.trim();
  return (
    'B·∫±ng ch·ªØ: ' +
    result.charAt(0).toUpperCase() +
    result.slice(1) +
    ' ƒë·ªìng ch·∫µn.'
  );
}

/**
 * Generates a contract by populating a Google Docs template using the "Native Table Insertion" approach.
 * This approach creates a properly formatted table directly using Google Docs API.
 */
export const generateContract = functions
  .region('us-central1')
  .runWith({
    timeoutSeconds: 300,
    memory: '1GB',
  })
  .https.onCall(async (data, context) => {
    // 1. ========= INITIALIZATION & VALIDATION =========
    // Import googleapis ch·ªâ khi h√†m ƒë∆∞·ª£c g·ªçi
    const { google } = await import('googleapis');

    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'B·∫°n ph·∫£i ƒëƒÉng nh·∫≠p ƒë·ªÉ th·ª±c hi·ªán ch·ª©c nƒÉng n√†y.'
      );
    }

    const { contractData, fileName, projectId, accessToken } = data;
    const typedContractData = contractData as ContractData;

    if (!typedContractData || !fileName || !projectId) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'D·ªØ li·ªáu ƒë·∫ßu v√†o kh√¥ng h·ª£p l·ªá (thi·∫øu contractData, fileName, ho·∫∑c projectId).'
      );
    }

    if (!accessToken) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thi·∫øu accessToken Google c·ªßa ng∆∞·ªùi d√πng.'
      );
    }

    try {
      // Initialize Google APIs with user accessToken similary to generateExcelQuotation
      const auth = new google.auth.OAuth2();
      auth.setCredentials({ access_token: accessToken });

      const drive = google.drive({ version: 'v3', auth });
      const docs = google.docs({ version: 'v1', auth });

      // Get project folder info from Firestore
      const db = admin.firestore();
      const projectDoc = await db.collection('projects').doc(projectId).get();
      const projectData = projectDoc.data();

      if (!projectData || !projectData.driveFolderId) {
        throw new functions.https.HttpsError(
          'failed-precondition',
          'Kh√¥ng t√¨m th·∫•y th√¥ng tin th∆∞ m·ª•c Drive c·ªßa d·ª± √°n.'
        );
      }

      // Find 'hopdong' subfolder in project folder
      const hopdongFolderResponse = await drive.files.list({
        q: `name='hopdong' and '${projectData.driveFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
        fields: 'files(id)',
      });

      let hopdongFolderId;
      if (
        hopdongFolderResponse.data.files &&
        hopdongFolderResponse.data.files.length > 0
      ) {
        hopdongFolderId = hopdongFolderResponse.data.files[0].id;
      } else {
        // Create 'hopdong' folder if it doesn't exist
        const folderResponse = await drive.files.create({
          requestBody: {
            name: 'hopdong',
            mimeType: 'application/vnd.google-apps.folder',
            parents: [projectData.driveFolderId],
          },
          fields: 'id',
        });
        hopdongFolderId = folderResponse.data.id;
      }

      // Copy the template document
      const copiedFileResponse = await drive.files.copy({
        fileId: CONTRACT_TEMPLATE_ID,
        requestBody: {
          name: fileName,
          parents: [hopdongFolderId],
        },
      });
      const newDocId = copiedFileResponse.data.id;
      if (!newDocId) {
        throw new Error('Kh√¥ng th·ªÉ sao ch√©p file template Google Docs.');
      }

      functions.logger.info(`ƒê√£ t·∫°o file t·∫°m t·ª´ template, ID: ${newDocId}`);

      // 2. ========= TEXT REPLACEMENTS =========
      const requests: docs_v1.Schema$Request[] = [];

      // X·ª≠ l√Ω t·∫•t c·∫£ c√°c tr∆∞·ªùng th√¥ng th∆∞·ªùng (kh√¥ng bao g·ªìm b·∫£ng v·∫≠t t∆∞)
      const { materials, ...textFields } = typedContractData;

      Object.entries(textFields).forEach(([key, value]) => {
        // ƒê·∫£m b·∫£o key c√≥ d·∫°ng {key} ƒë·ªÉ ph√π h·ª£p v·ªõi placeholder trong template
        const placeholderKey =
          key.startsWith('{') && key.endsWith('}') ? key : `{${key}}`;

        // Chuy·ªÉn ƒë·ªïi value th√†nh chu·ªói, ƒë·∫£m b·∫£o null/undefined tr·ªü th√†nh chu·ªói r·ªóng
        const replacementText = value != null ? String(value) : '';

        requests.push({
          replaceAllText: {
            containsText: {
              text: placeholderKey,
              matchCase: true,
            },
            replaceText: replacementText,
          },
        });
      });

      // 3. ========= APPLY TEXT REPLACEMENTS =========
      if (requests.length > 0) {
        await docs.documents.batchUpdate({
          documentId: newDocId,
          requestBody: { requests },
        });
        functions.logger.info(
          `ƒê√£ th·ª±c hi·ªán ${requests.length} y√™u c·∫ßu thay th·∫ø vƒÉn b·∫£n.`
        );
      }

      // 4. ========= FIND TABLE PLACEHOLDER POSITION =========
      // L·∫•y n·ªôi dung t√†i li·ªáu ƒë·ªÉ t√¨m v·ªã tr√≠ c·ªßa placeholder {{MATERIALS_TABLE}}
      const document = await docs.documents.get({
        documentId: newDocId,
      });

      // T√¨m v·ªã tr√≠ c·ªßa placeholder {{MATERIALS_TABLE}}
      let placeholderIndex: number | null = null;

      if (document.data.body?.content) {
        for (const element of document.data.body.content) {
          if (element.paragraph && element.paragraph.elements) {
            for (const paraElement of element.paragraph.elements) {
              if (
                paraElement.textRun &&
                paraElement.textRun.content &&
                paraElement.textRun.content.includes('{{MATERIALS_TABLE}}')
              ) {
                placeholderIndex = paraElement.startIndex || null;
                break;
              }
            }
            if (placeholderIndex !== null) break;
          }
        }
      }

      if (placeholderIndex === null) {
        functions.logger.warn(
          'Kh√¥ng t√¨m th·∫•y placeholder {{MATERIALS_TABLE}} trong t√†i li·ªáu.'
        );
      } else {
        functions.logger.info(
          `ƒê√£ t√¨m th·∫•y placeholder {{MATERIALS_TABLE}} t·∫°i v·ªã tr√≠: ${placeholderIndex}`
        );

        // 5. ========= CREATE AND INSERT TABLE =========
        // ===== MATERIALS FILTER & CLASSIFY =====
        const rawMaterials = materials || [];

        const filteredMaterials = rawMaterials.filter((item) => {
          const name = (item.name || '').trim().toUpperCase();
          const isNote = name.startsWith('GHI CH√ö');
          const startsWithPlus = name.startsWith('+');
          return !isNote && !startsWithPlus; // Lo·∫°i b·ªè ghi ch√∫ v√† d√≤ng '+'
        });

        // +1 cho h√†ng header
        const numRows = filteredMaterials.length + 1;
        const numColumns = 7; // STT, V·∫≠t T∆∞/H√†ng H√≥a, VL, ƒêVT, SL, ƒê∆°n gi√°, Th√†nh Ti·ªÅn

        functions.logger.info(
          `Chu·∫©n b·ªã t·∫°o b·∫£ng v·ªõi ${numRows} h√†ng (ƒë√£ l·ªçc) v√† ${numColumns} c·ªôt.`
        );

        // Y√™u c·∫ßu ƒë·ªÉ x√≥a placeholder v√† t·∫°o b·∫£ng tr·ªëng
        const createTableRequests: docs_v1.Schema$Request[] = [
          {
            deleteContentRange: {
              range: {
                startIndex: placeholderIndex,
                endIndex: placeholderIndex + '{{MATERIALS_TABLE}}'.length,
              },
            },
          },
          {
            insertTable: {
              location: { index: placeholderIndex },
              rows: numRows,
              columns: numColumns,
            },
          },
        ];

        // Th·ª±c thi t·∫°o b·∫£ng
        await docs.documents.batchUpdate({
          documentId: newDocId,
          requestBody: { requests: createTableRequests },
        });
        functions.logger.info(
          'ƒê√£ x√≥a placeholder v√† t·∫°o b·∫£ng tr·ªëng th√†nh c√¥ng.'
        );

        // 6. ========= POPULATE TABLE WITH DATA (ƒê√É S·ª¨A L·ªñI) =========
        // L·∫•y l·∫°i t√†i li·ªáu ƒë·ªÉ c√≥ c·∫•u tr√∫c b·∫£ng m·ªõi nh·∫•t v√† c√°c ch·ªâ s·ªë ch√≠nh x√°c
        const docWithTable = await docs.documents.get({
          documentId: newDocId,
        });

        // T√¨m b·∫£ng v·ª´a t·∫°o
        let tableElement: docs_v1.Schema$Table | undefined;
        let tableStartLocation: number | undefined;

        if (docWithTable.data.body?.content) {
          for (const element of docWithTable.data.body.content) {
            // T√¨m b·∫£ng c√≥ startIndex g·∫ßn v·ªõi v·ªã tr√≠ placeholder ban ƒë·∫ßu
            if (
              element.table &&
              element.startIndex &&
              Math.abs(element.startIndex - placeholderIndex) < 10
            ) {
              tableElement = element.table;
              tableStartLocation = element.startIndex;
              functions.logger.info(
                `ƒê√£ t√¨m th·∫•y b·∫£ng t·∫°i v·ªã tr√≠: ${element.startIndex}`
              );
              break;
            }
          }
        }

        if (!tableElement || !tableElement.tableRows || !tableStartLocation) {
          throw new Error('Kh√¥ng t√¨m th·∫•y b·∫£ng v·ª´a t·∫°o ƒë·ªÉ ƒëi·ªÅn d·ªØ li·ªáu.');
        }

        // *** TH√äM M·ªöI: ƒê·ªãnh d·∫°ng chi·ªÅu r·ªông c·ªôt ***
        const columnWidths = [
          { index: 0, width: 30 }, // STT
          { index: 1, width: 190 }, // V·∫≠t T∆∞, H√†ng H√≥a
          { index: 2, width: 60 }, // VL
          { index: 3, width: 40 }, // ƒêVT
          { index: 4, width: 30 }, // SL
          { index: 5, width: 70 }, // ƒê∆°n gi√°
          { index: 6, width: 70 }, // Th√†nh Ti·ªÅn
        ];

        const setWidthRequests: docs_v1.Schema$Request[] = columnWidths.map(
          (col) => ({
            updateTableColumnProperties: {
              tableStartLocation: { index: tableStartLocation },
              columnIndices: [col.index],
              tableColumnProperties: {
                width: { magnitude: col.width, unit: 'PT' },
                widthType: 'FIXED_WIDTH',
              },
              fields: 'width,widthType',
            },
          })
        );

        await docs.documents.batchUpdate({
          documentId: newDocId,
          requestBody: { requests: setWidthRequests },
        });
        functions.logger.info('ƒê√£ ƒë·ªãnh d·∫°ng chi·ªÅu r·ªông c√°c c·ªôt th√†nh c√¥ng.');

        // *** THAY ƒê·ªîI: Chu·∫©n b·ªã d·ªØ li·ªáu ch·ªâ cho b·∫£ng v·∫≠t t∆∞ ***
        const headers = [
          'STT',
          'V·∫≠t T∆∞, H√†ng H√≥a',
          'VL',
          'ƒêVT',
          'SL',
          'ƒê∆°n gi√°',
          'Th√†nh Ti·ªÅn',
        ];
        const tableData: string[][] = [headers];

        interface SpecialRowInfo {
          rowIndex: number; // index in table (excluding header)
          type: 'accessory' | 'groupHeader';
        }
        const specialRows: SpecialRowInfo[] = [];

        let seqCounter = 1;
        filteredMaterials.forEach((material, idx) => {
          const nameUpper = (material.name || '').trim().toUpperCase();
          const isAccessory = nameUpper.startsWith('PH·ª§ KI·ªÜN ƒêI K√àM');
          // Nh·∫≠n di·ªán s·ªë La M√£ (c√≥ th·ªÉ k√®m d·∫•u ch·∫•m, v√≠ d·ª•: "I.")
          const romanRegex = /^[IVXLCDM]+\.?$/i;
          const isGroupHeader = romanRegex.test(
            String(material.no || material.stt || '').trim()
          );

          if (isAccessory || isGroupHeader) {
            specialRows.push({
              rowIndex: idx + 1,
              type: isAccessory ? 'accessory' : 'groupHeader',
            });
          }

          // Build row values
          let stt = '';
          if (!isAccessory) {
            if (
              material.no !== undefined &&
              material.no !== null &&
              String(material.no).trim() !== ''
            ) {
              stt = String(material.no).trim();
            } else if (
              material.stt !== undefined &&
              material.stt !== null &&
              String(material.stt).trim() !== ''
            ) {
              stt = String(material.stt).trim();
            } else {
              stt = String(seqCounter);
            }
            seqCounter++;
          }
          const quantity =
            isAccessory || isGroupHeader
              ? ''
              : material.quantity
              ? String(material.quantity)
              : '';
          const unitPrice =
            isAccessory || isGroupHeader
              ? ''
              : material.unitPrice
              ? Math.floor(Number(material.unitPrice)).toLocaleString('vi-VN')
              : '';
          const totalPrice =
            isAccessory || isGroupHeader
              ? ''
              : material.totalPrice
              ? Math.floor(Number(material.totalPrice)).toLocaleString('vi-VN')
              : '';

          tableData.push([
            stt,
            material.name || '',
            material.material || '',
            material.unit || '',
            quantity,
            unitPrice,
            totalPrice,
          ]);
        });

        functions.logger.info(
          `ƒê√£ chu·∫©n b·ªã d·ªØ li·ªáu cho ${tableData.length} h√†ng`
        );

        const dataFillRequests: docs_v1.Schema$Request[] = [];

        // Thi·∫øt l·∫≠p font ch·ªØ Times New Roman, m√†u ƒëen, c·ª° 12 cho to√†n b·ªô b·∫£ng
        if (tableStartLocation) {
          // Thay v√¨ thi·∫øt l·∫≠p font cho to√†n b·ªô b·∫£ng v·ªõi m·ªôt l·ªánh, ch√∫ng ta s·∫Ω thi·∫øt l·∫≠p font cho t·ª´ng √¥ khi ch√®n d·ªØ li·ªáu
          functions.logger.info(
            'S·∫Ω thi·∫øt l·∫≠p font ch·ªØ cho t·ª´ng √¥ khi ch√®n d·ªØ li·ªáu'
          );
        }

        // *** L·∫∂P NG∆Ø·ª¢C T·ª™ CU·ªêI L√äN ƒê·∫¶U ***
        for (let r = tableData.length - 1; r >= 0; r--) {
          const rowData = tableData[r];
          for (let c = rowData.length - 1; c >= 0; c--) {
            const cellData = rowData[c];
            if (!cellData) continue; // B·ªè qua √¥ tr·ªëng

            const cell = tableElement.tableRows[r]?.tableCells?.[c];
            if (!cell?.content?.[0]?.paragraph?.elements?.[0]?.startIndex) {
              functions.logger.warn(`Kh√¥ng t√¨m th·∫•y v·ªã tr√≠ cho √¥ [${r}, ${c}]`);
              continue;
            }

            const cellStartIndex =
              cell.content[0].paragraph.elements[0].startIndex;
            functions.logger.info(
              `ƒêi·ªÅn "${cellData}" v√†o √¥ [${r}, ${c}] t·∫°i v·ªã tr√≠ ${cellStartIndex}`
            );

            // 1. Th√™m y√™u c·∫ßu ch√®n vƒÉn b·∫£n
            dataFillRequests.push({
              insertText: {
                location: { index: cellStartIndex },
                text: cellData,
              },
            });

            // 2. Th√™m y√™u c·∫ßu ƒë·ªãnh d·∫°ng
            const textRange = {
              startIndex: cellStartIndex,
              endIndex: cellStartIndex + cellData.length,
            };

            // Thi·∫øt l·∫≠p font ch·ªØ Times New Roman, m√†u ƒëen, c·ª° 12 cho t·ª´ng √¥
            dataFillRequests.push({
              updateTextStyle: {
                range: textRange,
                textStyle: {
                  weightedFontFamily: { fontFamily: 'Times New Roman' },
                  fontSize: { magnitude: 12, unit: 'PT' },
                  foregroundColor: {
                    color: {
                      rgbColor: { red: 0, green: 0, blue: 0 },
                    },
                  },
                },
                fields: 'weightedFontFamily,fontSize,foregroundColor',
              },
            });

            // In ƒë·∫≠m cho h√†ng ti√™u ƒë·ªÅ v√† c√°c h√†ng t·ªïng c·ªông
            // In ƒë·∫≠m cho h√†ng ti√™u ƒë·ªÅ v√† c√°c h√†ng t·ªïng c·ªông
            // Ch·ªâ in ƒë·∫≠m cho h√†ng ti√™u ƒë·ªÅ
            if (r === 0) {
              // <--- ƒê√É S·ª¨A
              dataFillRequests.push({
                updateTextStyle: {
                  range: textRange,
                  textStyle: { bold: true },
                  fields: 'bold',
                },
              });
            }

            // CƒÉn gi·ªØa cho t·∫•t c·∫£ c√°c √¥ (theo y√™u c·∫ßu)
            dataFillRequests.push({
              updateParagraphStyle: {
                range: textRange,
                paragraphStyle: { alignment: 'CENTER' },
                fields: 'alignment',
              },
            });

            // CƒÉn gi·ªØa theo chi·ªÅu d·ªçc
            dataFillRequests.push({
              updateTableCellStyle: {
                tableRange: {
                  tableCellLocation: {
                    tableStartLocation: { index: tableStartLocation || 0 },
                    rowIndex: r,
                    columnIndex: c,
                  },
                  rowSpan: 1,
                  columnSpan: 1,
                },
                tableCellStyle: {
                  contentAlignment: 'MIDDLE',
                },
                fields: 'contentAlignment',
              },
            });
          }
        }

        // ===== T√î M√ÄU N·ªÄN CHO H√ÄNG ƒê·∫∂C BI·ªÜT =====
        specialRows.forEach((rowInfo) => {
          const bgColor =
            rowInfo.type === 'accessory'
              ? { red: 1, green: 0.93, blue: 0.8 } // light peach for accessories
              : { red: 0.9, green: 0.9, blue: 0.9 }; // grey for group headers

          dataFillRequests.push({
            updateTableCellStyle: {
              tableRange: {
                tableCellLocation: {
                  tableStartLocation: { index: tableStartLocation || 0 },
                  rowIndex: rowInfo.rowIndex,
                  columnIndex: 0,
                },
                rowSpan: 1,
                columnSpan: numColumns,
              },
              tableCellStyle: {
                backgroundColor: { color: { rgbColor: bgColor } },
              },
              fields: 'backgroundColor',
            },
          });
        });

        // ƒê·ªãnh d·∫°ng m√†u n·ªÅn v√† vi·ªÅn cho b·∫£ng
        if (tableStartLocation) {
          // M√†u n·ªÅn cho h√†ng ti√™u ƒë·ªÅ
          dataFillRequests.push({
            updateTableCellStyle: {
              tableRange: {
                tableCellLocation: {
                  tableStartLocation: { index: tableStartLocation },
                  rowIndex: 0,
                  columnIndex: 0,
                },
                rowSpan: 1,
                columnSpan: numColumns,
              },
              tableCellStyle: {
                backgroundColor: {
                  // M√†u xanh nh·∫°t gi·ªëng trong template
                  color: {
                    rgbColor: { red: 0.737, green: 0.867, blue: 0.898 },
                  },
                },
              },
              fields: 'backgroundColor',
            },
          });

          // Vi·ªÅn cho to√†n b·ªô b·∫£ng
          dataFillRequests.push({
            updateTableCellStyle: {
              tableRange: {
                tableCellLocation: {
                  tableStartLocation: { index: tableStartLocation },
                  rowIndex: 0,
                  columnIndex: 0,
                },
                rowSpan: numRows,
                columnSpan: numColumns,
              },
              tableCellStyle: {
                borderBottom: {
                  color: { color: { rgbColor: { red: 0, green: 0, blue: 0 } } },
                  width: { magnitude: 1, unit: 'PT' },
                  dashStyle: 'SOLID',
                },
                borderTop: {
                  color: { color: { rgbColor: { red: 0, green: 0, blue: 0 } } },
                  width: { magnitude: 1, unit: 'PT' },
                  dashStyle: 'SOLID',
                },
                borderLeft: {
                  color: { color: { rgbColor: { red: 0, green: 0, blue: 0 } } },
                  width: { magnitude: 1, unit: 'PT' },
                  dashStyle: 'SOLID',
                },
                borderRight: {
                  color: { color: { rgbColor: { red: 0, green: 0, blue: 0 } } },
                  width: { magnitude: 1, unit: 'PT' },
                  dashStyle: 'SOLID',
                },
              },
              fields: 'borderBottom,borderTop,borderLeft,borderRight',
            },
          });
        }

        // Th·ª±c thi t·∫•t c·∫£ c√°c y√™u c·∫ßu ƒëi·ªÅn v√† ƒë·ªãnh d·∫°ng d·ªØ li·ªáu
        if (dataFillRequests.length > 0) {
          await docs.documents.batchUpdate({
            documentId: newDocId,
            requestBody: { requests: dataFillRequests },
          });
          functions.logger.info(
            `ƒê√£ ƒëi·ªÅn v√† ƒë·ªãnh d·∫°ng d·ªØ li·ªáu cho ${tableData.length} h√†ng.`
          );
        }

        // 7. ========= INSERT SUMMARY SECTION (B·∫¢NG T·ªîNG K·∫æT) =========
        // L·∫•y l·∫°i t√†i li·ªáu ƒë·ªÉ x√°c ƒë·ªãnh v·ªã tr√≠ cu·ªëi c·ªßa b·∫£ng v·∫≠t t∆∞
        const docWithTableFilled = await docs.documents.get({
          documentId: newDocId,
        });

        let tableEndIndex: number | undefined;
        if (docWithTableFilled.data.body?.content) {
          for (const element of docWithTableFilled.data.body.content) {
            if (
              element.table &&
              element.startIndex &&
              element.endIndex &&
              Math.abs(element.startIndex - (tableStartLocation || 0)) < 10
            ) {
              tableEndIndex = element.endIndex;
              functions.logger.info(
                `T√¨m th·∫•y v·ªã tr√≠ k·∫øt th√∫c c·ªßa b·∫£ng v·∫≠t t∆∞: ${tableEndIndex}`
              );
              break;
            }
          }
        }

        if (!tableEndIndex) {
          throw new Error('Kh√¥ng t√¨m th·∫•y v·ªã tr√≠ k·∫øt th√∫c b·∫£ng v·∫≠t t∆∞');
        }

        // T√≠nh to√°n gi√° tr·ªã t·ªïng k·∫øt - t·ª± t√≠nh to√°n m·ªçi gi√° tr·ªã, kh√¥ng d√πng gi√° tr·ªã t·ª´ input
        // Hardcode VAT rate l√† 10%
        const vatPercentage = 10;

        // T√≠nh t·ªïng ti·ªÅn h√†ng t·ª´ danh s√°ch v·∫≠t t∆∞
        let subTotal = 0;
        filteredMaterials.forEach((material) => {
          // T√≠nh l·∫°i ƒë∆°n gi√° v√† th√†nh ti·ªÅn ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh ƒë√∫ng
          const weight = Number(material.weight || 0);
          const unitPricePerKg = Number(material.unitPrice || 0);
          const calculatedUnitPrice = weight * unitPricePerKg;
          const quantity = Number(material.quantity || 0);
          const totalPrice = quantity * calculatedUnitPrice;
          subTotal += totalPrice;
        });

        // T√≠nh thu·∫ø VAT v√† t·ªïng ti·ªÅn thanh to√°n
        const vatAmount = (subTotal * vatPercentage) / 100;
        const grandTotal = subTotal + vatAmount;

        // T√≠nh half_total SAU KHI ƒë√£ t√≠nh to√°n xong grandTotal
        const halfTotal = Math.floor(grandTotal * 0.5);
        // T·∫°o chu·ªói half_total ch·ªâ sau khi bi·∫øt ch·∫Øc ch·∫Øn halfTotal l√† s·ªë h·ª£p l·ªá
        const halfTotalFormatted = halfTotal.toLocaleString('vi-VN');
        const halfTotalText = `${halfTotalFormatted} ƒë (${convertNumberToVnWords(
          halfTotal
        )})`;

        // Th·ª±c hi·ªán thay th·∫ø half_total trong vƒÉn b·∫£n
        const halfTotalRequests: docs_v1.Schema$Request[] = [
          {
            replaceAllText: {
              containsText: { text: '{half_total}', matchCase: false },
              replaceText: halfTotalText,
            },
          },
        ];

        // √Åp d·ª•ng thay th·∫ø half_total
        if (halfTotalRequests.length > 0) {
          await docs.documents.batchUpdate({
            documentId: newDocId,
            requestBody: { requests: halfTotalRequests },
          });
          functions.logger.info('ƒê√£ thay th·∫ø half_total th√†nh c√¥ng.');
        }

        // T·ª± t·∫°o chu·ªói "b·∫±ng ch·ªØ" t·ª´ t·ªïng ti·ªÅn ƒë√£ t√≠nh (b·ªè ph·∫ßn th·∫≠p ph√¢n)
        const amountInWords = convertNumberToVnWords(Math.floor(grandTotal));

        // T·∫°o b·∫£ng t·ªïng k·∫øt (2 c·ªôt, 4 h√†ng)
        const summaryTableRequests: docs_v1.Schema$Request[] = [
          {
            insertTable: {
              location: { index: tableEndIndex },
              rows: 4,
              columns: 2,
            },
          },
        ];

        await docs.documents.batchUpdate({
          documentId: newDocId,
          requestBody: { requests: summaryTableRequests },
        });
        functions.logger.info('ƒê√£ t·∫°o b·∫£ng t·ªïng k·∫øt sau b·∫£ng v·∫≠t t∆∞');

        // L·∫•y l·∫°i t√†i li·ªáu ƒë·ªÉ ƒë·ªãnh v·ªã b·∫£ng t·ªïng k·∫øt v·ª´a t·∫°o
        const docWithSummaryTable = await docs.documents.get({
          documentId: newDocId,
        });

        let summaryTable: docs_v1.Schema$Table | undefined;
        let summaryTableStartIndex: number | undefined;

        if (docWithSummaryTable.data.body?.content) {
          for (const element of docWithSummaryTable.data.body.content) {
            if (
              element.table &&
              element.startIndex &&
              element.startIndex > (tableEndIndex || 0) - 5
            ) {
              // L·∫•y b·∫£ng ƒë·∫ßu ti√™n sau b·∫£ng v·∫≠t t∆∞
              summaryTable = element.table;
              summaryTableStartIndex = element.startIndex;
              functions.logger.info(
                `T√¨m th·∫•y b·∫£ng t·ªïng k·∫øt t·∫°i v·ªã tr√≠: ${element.startIndex}`
              );
              break;
            }
          }
        }

        if (!summaryTable || !summaryTableStartIndex) {
          throw new Error('Kh√¥ng t√¨m th·∫•y b·∫£ng t·ªïng k·∫øt sau khi t·∫°o');
        }

        // Chu·∫©n b·ªã d·ªØ li·ªáu cho b·∫£ng t·ªïng k·∫øt
        const summaryData = [
          [
            'C·ªòNG TI·ªÄN H√ÄNG:',
            Math.floor(subTotal).toLocaleString('vi-VN') + ' ƒë',
          ],
          [
            `THU·∫æ GTGT ${vatPercentage}%:`,
            Math.floor(vatAmount).toLocaleString('vi-VN') + ' ƒë',
          ],
          [
            'T·ªîNG TI·ªÄN THANH TO√ÅN:',
            Math.floor(grandTotal).toLocaleString('vi-VN') + ' ƒë',
          ],
          [amountInWords], // Ch·ªâ ch·ª©a m·ªôt ph·∫ßn t·ª≠ ƒë·ªÉ g·ªôp √¥
        ];

        // T·∫°o c√°c y√™u c·∫ßu ƒë·ªÉ ƒëi·ªÅn d·ªØ li·ªáu v√† ƒë·ªãnh d·∫°ng b·∫£ng t·ªïng k·∫øt
        const summaryFillRequests: docs_v1.Schema$Request[] = [];

        // L·∫∑p ng∆∞·ª£c ƒë·ªÉ ƒëi·ªÅn d·ªØ li·ªáu t·ª´ cu·ªëi l√™n ƒë·∫ßu (tr√°nh l·ªói v·ªã tr√≠)
        for (let r = summaryData.length - 1; r >= 0; r--) {
          for (let c = summaryData[r].length - 1; c >= 0; c--) {
            const cellData = summaryData[r][c];
            if (!cellData) continue;

            const cell = summaryTable.tableRows?.[r]?.tableCells?.[c];
            if (!cell?.content?.[0]?.paragraph?.elements?.[0]?.startIndex) {
              functions.logger.warn(
                `Kh√¥ng t√¨m th·∫•y v·ªã tr√≠ cho √¥ t·ªïng k·∫øt [${r}, ${c}]`
              );
              continue;
            }

            const cellStartIndex =
              cell.content[0].paragraph.elements[0].startIndex;
            functions.logger.info(
              `ƒêi·ªÅn d·ªØ li·ªáu "${cellData}" v√†o √¥ t·ªïng k·∫øt [${r}, ${c}] t·∫°i v·ªã tr√≠ ${cellStartIndex}`
            );

            // Ch√®n vƒÉn b·∫£n
            summaryFillRequests.push({
              insertText: {
                location: { index: cellStartIndex },
                text: cellData,
              },
            });

            const textRange = {
              startIndex: cellStartIndex,
              endIndex: cellStartIndex + cellData.length,
            };

            // ƒê·ªãnh d·∫°ng font, m√†u s·∫Øc v√† in ƒë·∫≠m
            summaryFillRequests.push({
              updateTextStyle: {
                range: textRange,
                textStyle: {
                  weightedFontFamily: { fontFamily: 'Times New Roman' },
                  fontSize: { magnitude: 12, unit: 'PT' },
                  bold: r < 3, // Ch·ªâ in ƒë·∫≠m 3 d√≤ng ƒë·∫ßu ti√™n (0, 1, 2), kh√¥ng in ƒë·∫≠m d√≤ng "B·∫±ng ch·ªØ:" (3)
                  foregroundColor: {
                    color: {
                      rgbColor: { red: 0, green: 0, blue: 0 },
                    },
                  },
                },
                fields: 'weightedFontFamily,fontSize,bold,foregroundColor',
              },
            });

            // CƒÉn l·ªÅ
            let alignment: 'END' | 'START' = 'START';
            if (c === 1) {
              // C·ªôt gi√° tr·ªã cƒÉn ph·∫£i
              alignment = 'END';
            }
            // D√≤ng "B·∫±ng ch·ªØ" cƒÉn tr√°i
            if (r === 3) {
              alignment = 'START';
            }

            summaryFillRequests.push({
              updateParagraphStyle: {
                range: textRange,
                paragraphStyle: { alignment: alignment },
                fields: 'alignment',
              },
            });
          }
        }

        // G·ªôp √¥ cho d√≤ng "B·∫±ng ch·ªØ"
        summaryFillRequests.push({
          mergeTableCells: {
            tableRange: {
              tableCellLocation: {
                tableStartLocation: { index: summaryTableStartIndex },
                rowIndex: 3, // H√†ng cu·ªëi c√πng (b·∫±ng ch·ªØ)
                columnIndex: 0,
              },
              rowSpan: 1,
              columnSpan: 2,
            },
          },
        });

        // X√≥a vi·ªÅn c·ªßa b·∫£ng t·ªïng k·∫øt ƒë·ªÉ n√≥ h√≤a v√†o vƒÉn b·∫£n
        summaryFillRequests.push({
          updateTableCellStyle: {
            tableRange: {
              tableCellLocation: {
                tableStartLocation: { index: summaryTableStartIndex },
                rowIndex: 0,
                columnIndex: 0,
              },
              rowSpan: 4,
              columnSpan: 2,
            },
            tableCellStyle: {
              borderBottom: {
                width: { magnitude: 0, unit: 'PT' },
                dashStyle: 'SOLID',
                color: { color: { rgbColor: {} } },
              },
              borderTop: {
                width: { magnitude: 0, unit: 'PT' },
                dashStyle: 'SOLID',
                color: { color: { rgbColor: {} } },
              },
              borderLeft: {
                width: { magnitude: 0, unit: 'PT' },
                dashStyle: 'SOLID',
                color: { color: { rgbColor: {} } },
              },
              borderRight: {
                width: { magnitude: 0, unit: 'PT' },
                dashStyle: 'SOLID',
                color: { color: { rgbColor: {} } },
              },
            },
            fields: 'borderBottom,borderTop,borderLeft,borderRight',
          },
        });

        // Th·ª±c thi c√°c y√™u c·∫ßu ƒëi·ªÅn v√† ƒë·ªãnh d·∫°ng cho b·∫£ng t·ªïng k·∫øt
        if (summaryFillRequests.length > 0) {
          await docs.documents.batchUpdate({
            documentId: newDocId,
            requestBody: { requests: summaryFillRequests },
          });
          functions.logger.info(
            'ƒê√£ ƒëi·ªÅn v√† ƒë·ªãnh d·∫°ng b·∫£ng t·ªïng k·∫øt th√†nh c√¥ng'
          );
        }
      }

      // 8. ========= RETURN DOCX INFO =========
      // C·∫•p quy·ªÅn xem cho Google Doc ƒë·ªÉ ng∆∞·ªùi d√πng c√≥ link c√≥ th·ªÉ xem
      await drive.permissions.create({
        fileId: newDocId,
        requestBody: { role: 'reader', type: 'anyone' },
      });

      const docUrl = `https://docs.google.com/document/d/${newDocId}/edit`;
      functions.logger.info(`T·∫°o h·ª£p ƒë·ªìng th√†nh c√¥ng. Doc URL: ${docUrl}`);

      // Tr·∫£ v·ªÅ URL c·ªßa Google Doc v√† ID
      return {
        docUrl,
        docId: newDocId,
      };
    } catch (error) {
      functions.logger.error('L·ªói nghi√™m tr·ªçng khi t·∫°o h·ª£p ƒë·ªìng:', error);
      if (error instanceof Error) {
        throw new functions.https.HttpsError(
          'internal',
          `Kh√¥ng th·ªÉ t·∫°o h·ª£p ƒë·ªìng: ${error.message}`
        );
      }
      throw new functions.https.HttpsError(
        'internal',
        'ƒê√£ x·∫£y ra l·ªói kh√¥ng x√°c ƒë·ªãnh khi t·∫°o h·ª£p ƒë·ªìng.'
      );
    }
  });


--- END: functions\src\contractGenerator.ts ---


--- START: functions\src\createProjectFolders.ts ---
import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';
import { getDriveClient } from './utils/driveClient';
import { APP_DRIVE_ROOT_FOLDER_ID } from './config';

const db = admin.firestore();

/**
 * Callable: createProjectFolders
 * - Input: { projectId: string }
 * - Creates a Drive folder for the project inside the app root and
 *   sub-folders [baogia, hopdong, PO, QC_Reports].
 * - Saves driveFolderId, driveFolderUrl back to Firestore.
 */
export const createProjectFolders = functions
  .region('asia-southeast1')
  .runWith({ timeoutSeconds: 300, memory: '1GB' })
  .https.onCall(async (data, context) => {
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p.'
      );
    }

    const { projectId } = data as { projectId?: string };
    if (!projectId) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thi·∫øu projectId'
      );
    }

    const projectRef = db.collection('projects').doc(projectId);
    const projectSnap = await projectRef.get();
    if (!projectSnap.exists) {
      throw new functions.https.HttpsError('not-found', 'Kh√¥ng t√¨m th·∫•y d·ª± √°n');
    }

    const projectData = projectSnap.data()!;
    if (projectData.driveFolderId) {
      // Folder ƒë√£ t·ªìn t·∫°i, tr·∫£ v·ªÅ ngay
      return {
        success: true,
        driveFolderId: projectData.driveFolderId,
        driveFolderUrl: projectData.driveFolderUrl,
        skipped: true,
      };
    }

    try {
      const drive = await getDriveClient();

      // Sanitize name (kh√¥ng k√Ω t·ª± ƒë·∫∑c bi·ªát m√† Drive c·∫•m)
      const cleanName = (projectData.name || projectId).replace(
        /[\\/:*?"<>|]/g,
        '_'
      );

      // 1. T·∫°o th∆∞ m·ª•c d·ª± √°n b√™n trong ROOT
      const projectFolderRes = await drive.files.create({
        requestBody: {
          name: cleanName,
          mimeType: 'application/vnd.google-apps.folder',
          parents: [APP_DRIVE_ROOT_FOLDER_ID],
        },
        fields: 'id, webViewLink',
      });

      const projectFolderId = projectFolderRes.data.id!;

      // 2. T·∫°o sub-folders
      const subNames = [
        'baogia',
        'hopdong',
        'PO',
        'QC_Reports',
        'T√†i li·ªáu',
        'Th·ªëng k√™ v·∫≠t t∆∞',
      ];
      await Promise.all(
        subNames.map((sub) =>
          drive.files.create({
            requestBody: {
              name: sub,
              mimeType: 'application/vnd.google-apps.folder',
              parents: [projectFolderId],
            },
          })
        )
      );

      // 3. Ghi Firestore
      await projectRef.update({
        driveFolderId: projectFolderId,
        driveFolderUrl: projectFolderRes.data.webViewLink,
        driveCreatedAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      return {
        success: true,
        driveFolderId: projectFolderId,
        driveFolderUrl: projectFolderRes.data.webViewLink,
        skipped: false,
      };
    } catch (err: any) {
      console.error('createProjectFolders error:', err);
      throw new functions.https.HttpsError(
        'internal',
        err.message || 'L·ªói t·∫°o th∆∞ m·ª•c d·ª± √°n'
      );
    }
  });


--- END: functions\src\createProjectFolders.ts ---


--- START: functions\src\customerImporter.ts ---
import * as functions from 'firebase-functions/v1';
import { google } from 'googleapis';
import * as XLSX from 'xlsx';

// Kh·ªüi t·∫°o Firestore
const admin = require('firebase-admin');
const db = admin.firestore();

interface CustomerData {
  companyName: string;
  taxCode: string;
  address: string;
  email: string;
}

export const importCustomersFromExcel = functions
  .region('asia-southeast1')
  .https.onCall(async (data: any, context: functions.https.CallableContext) => {
    try {
      // Ki·ªÉm tra quy·ªÅn truy c·∫≠p
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'Y√™u c·∫ßu ƒëƒÉng nh·∫≠p'
        );
      }

      const { driveFileId, accessToken } = data;
      if (!driveFileId || !accessToken) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Thi·∫øu file ID ho·∫∑c access token.'
        );
      }

      console.log('üîç B·∫Øt ƒë·∫ßu import kh√°ch h√†ng t·ª´ file:', driveFileId);

      // 1. Setup Google API client v·ªõi OAuth2
      const auth = new google.auth.OAuth2();
      auth.setCredentials({ access_token: accessToken });
      const drive = google.drive({ version: 'v3', auth });

      // 2. T·∫£i v√† parse file
      const response = await drive.files.get(
        { fileId: driveFileId, alt: 'media' },
        { responseType: 'arraybuffer' }
      );

      if (!response.data) {
        throw new functions.https.HttpsError(
          'not-found',
          'Kh√¥ng t√¨m th·∫•y file'
        );
      }

      // 3. ƒê·ªçc file Excel
      const workbook = XLSX.read(Buffer.from(response.data as any), {
        type: 'buffer',
      });
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];

      // 4. Chuy·ªÉn ƒë·ªïi th√†nh JSON
      const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

      console.log('üìä D·ªØ li·ªáu Excel:', jsonData.length, 'd√≤ng');

      // 5. X·ª≠ l√Ω d·ªØ li·ªáu (b·ªè qua header)
      const customers: CustomerData[] = [];
      for (let i = 1; i < jsonData.length; i++) {
        const row = jsonData[i] as any[];
        if (row && row.length >= 4) {
          const customer: CustomerData = {
            companyName: String(row[0] || '').trim(),
            taxCode: String(row[1] || '').trim(),
            address: String(row[2] || '').trim(),
            email: String(row[3] || '').trim(),
          };

          // Ch·ªâ th√™m n·∫øu c√≥ t√™n c√¥ng ty
          if (customer.companyName) {
            customers.push(customer);
          }
        }
      }

      console.log('‚úÖ ƒê√£ parse ƒë∆∞·ª£c', customers.length, 'kh√°ch h√†ng');

      // 6. L∆∞u v√†o Firestore
      const batch = db.batch();
      let successCount = 0;
      let errorCount = 0;

      for (const customer of customers) {
        try {
          const customerRef = db.collection('customers').doc();
          batch.set(customerRef, {
            // L∆∞u ƒë·ªìng nh·∫•t c·∫£ name v√† companyName ƒë·ªÉ UI hi·ªán ƒë√∫ng
            name: customer.companyName,
            companyName: customer.companyName,
            taxCode: customer.taxCode,
            address: customer.address,
            email: customer.email,
            createdAt: new Date(),
            updatedAt: new Date(),
            createdBy: context.auth.uid,
          });
          successCount++;
        } catch (error) {
          console.error(
            '‚ùå L·ªói khi l∆∞u kh√°ch h√†ng:',
            customer.companyName,
            error
          );
          errorCount++;
        }
      }

      // Commit batch
      await batch.commit();

      console.log('üíæ ƒê√£ l∆∞u th√†nh c√¥ng:', successCount, 'kh√°ch h√†ng');
      if (errorCount > 0) {
        console.log('‚ö†Ô∏è L·ªói:', errorCount, 'kh√°ch h√†ng');
      }

      return {
        success: true,
        totalProcessed: customers.length,
        successCount,
        errorCount,
        customers: customers.slice(0, 10), // Tr·∫£ v·ªÅ 10 kh√°ch h√†ng ƒë·∫ßu ƒë·ªÉ preview
      };
    } catch (error: any) {
      console.error('‚ùå L·ªói import kh√°ch h√†ng:', error);

      // L·ªói t·ª´ Google API, c√≥ th·ªÉ do accessToken h·∫øt h·∫°n
      if (error.code === 401 || error.code === 403) {
        throw new functions.https.HttpsError(
          'permission-denied',
          'Token truy c·∫≠p Google Drive kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n.'
        );
      }

      throw new functions.https.HttpsError(
        'internal',
        'L·ªói khi import kh√°ch h√†ng'
      );
    }
  });

// L·∫•y danh s√°ch file customer t·ª´ Google Drive
export const getCustomerFiles = functions
  .region('asia-southeast1')
  .https.onCall(async (data: any, context: functions.https.CallableContext) => {
    try {
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'Y√™u c·∫ßu ƒëƒÉng nh·∫≠p'
        );
      }

      const { accessToken } = data;
      if (!accessToken) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Thi·∫øu access token.'
        );
      }

      // 1. Setup Google API client v·ªõi OAuth2
      const auth = new google.auth.OAuth2();
      auth.setCredentials({ access_token: accessToken });
      const drive = google.drive({ version: 'v3', auth });

      // 2. T√¨m file c√≥ t√™n ch·ª©a "customer"
      const response = await drive.files.list({
        q: "name contains 'customer' and mimeType contains 'spreadsheet' and trashed=false",
        fields: 'files(id,name,modifiedTime,size)',
        orderBy: 'modifiedTime desc',
      });

      const files = response.data.files || [];
      console.log('üìÅ T√¨m th·∫•y', files.length, 'file customer');

      return {
        success: true,
        files: files.map((file) => ({
          id: file.id,
          name: file.name,
          modifiedTime: file.modifiedTime,
          size: file.size,
        })),
      };
    } catch (error: any) {
      console.error('‚ùå L·ªói l·∫•y danh s√°ch file customer:', error);

      // L·ªói t·ª´ Google API, c√≥ th·ªÉ do accessToken h·∫øt h·∫°n
      if (error.code === 401 || error.code === 403) {
        throw new functions.https.HttpsError(
          'permission-denied',
          'Token truy c·∫≠p Google Drive kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n.'
        );
      }

      throw new functions.https.HttpsError(
        'internal',
        'L·ªói khi l·∫•y danh s√°ch file'
      );
    }
  });


--- END: functions\src\customerImporter.ts ---


--- START: functions\src\deliveryNoteExcelGenerator.ts ---
import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';
import * as XlsxPopulate from 'xlsx-populate';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { google } from 'googleapis';
import { CallableContext } from 'firebase-functions/v1/https';

// Ensure admin is initialized only once
if (admin.apps.length === 0) {
  admin.initializeApp();
}

const db = admin.firestore();
// const storage = admin.storage();
// const bucket = storage.bucket();

interface DeliveryNoteItem {
  no: number;
  name: string; // V·∫≠t T∆∞, H√†ng H√≥a
  material: string; // V·∫≠t li·ªáu
  unit: string; // ƒêVT
  quantity: number; // S·ªë l∆∞·ª£ng
}

interface ExcelDeliveryNoteData {
  metadata: {
    deliveryNoteNumber: string;
    deliveryDate: string;
    customerName: string;
    customerTaxCode: string;
    customerAddress: string;
    customerRepresentative: string;
    customerRepresentativePosition: string;
  };
  items: DeliveryNoteItem[];
}

async function generateDeliveryNoteExcelFile(
  formattedData: ExcelDeliveryNoteData
): Promise<Buffer> {
  const workbook = await XlsxPopulate.fromBlankAsync();
  const sheet = workbook.sheet(0).name('BienBanGiaoHang');

  // Set default font for a large range of the sheet
  sheet.range('A1:L100').style({
    fontFamily: 'Times New Roman',
    fontSize: 13,
  });

  // Set column widths
  sheet.column('A').width(5);
  sheet.column('B').width(10);
  sheet.column('C').width(15);
  sheet.column('D').width(20);
  sheet.column('E').width(15);
  sheet.column('F').width(10); // STT
  sheet.column('G').width(55); // V·∫≠t t∆∞, h√†ng h√≥a - increased from 40 to 55
  sheet.column('H').width(20); // V·∫≠t li·ªáu
  sheet.column('I').width(10); // ƒêVT - decreased from 15 to 10
  sheet.column('J').width(10); // S·ªë l∆∞·ª£ng - decreased from 15 to 10
  sheet.column('K').width(15);

  // --- HEADER SECTION ---
  sheet
    .range('F1:G1')
    .merged(true)
    .value('C√îNG TY TNHH SX CK TM DV')
    .style({ bold: true, horizontalAlignment: 'center' });
  sheet
    .range('F2:G2')
    .merged(true)
    .value('T√ÇN H√íA PH√ÅT')
    .style({ bold: true, horizontalAlignment: 'center' });
  sheet
    .range('F3:G3')
    .merged(true)
    .value([['S·ªë:'], [`/BBGH ${formattedData.metadata.deliveryNoteNumber}`]]);

  sheet
    .range('I1:K1')
    .merged(true)
    .value('C·ªòNG H√íA X√É H·ªòI CH·ª¶ NGHƒ®A VI·ªÜT NAM')
    .style({ bold: true, horizontalAlignment: 'center' });
  sheet
    .range('I2:K2')
    .merged(true)
    .value('ƒê·ªôc l·∫≠p ‚Äì T·ª± do ‚Äì H·∫°nh ph√∫c')
    .style({ bold: true, horizontalAlignment: 'center', underline: true });
  sheet
    .range('I4:K4')
    .merged(true)
    .value(`TPHCM, ${formattedData.metadata.deliveryDate}`)
    .style({ italic: true, horizontalAlignment: 'center' });

  sheet
    .range('F6:J6')
    .merged(true)
    .value('BI√äN B·∫¢N GIAO H√ÄNG')
    .style({ bold: true, fontSize: 16, horizontalAlignment: 'center' });

  // --- INFO SECTION ---
  sheet
    .cell('F9')
    .value('H√¥m nay, t·∫°i X∆∞·ªüng T√¢n H√≤a Ph√°t, ƒë·∫°i di·ªán 2 b√™n g·ªìm c√≥:');

  // Party A
  sheet
    .cell('F11')
    .value(
      'B√äN A: (B√™n b√°n): C√îNG TY TNHH S·∫¢N XU·∫§T C∆† KH√ç TM ‚Äì DV T√ÇN H√íA PH√ÅT'
    )
    .style('bold', true);
  sheet.cell('G12').value('- M√£ s·ªë thu·∫ø: 0315155409');
  sheet
    .cell('G13')
    .value(
      '- ƒê·ªãa ch·ªâ: 7 Qu·ªëc l·ªô 1A, Khu ph·ªë 3B, Ph∆∞·ªùng Th·∫°nh L·ªôc, Qu·∫≠n 12, TPHCM.'
    );
  sheet.cell('G14').value('- √îng/B√†: ƒêinh VƒÉn H√≤a');
  sheet.cell('I14').value('Ch·ª©c v·ª•: Gi√°m ƒë·ªëc');

  // Party B
  sheet.cell('F16').value('B√äN B: (B√™n mua):').style('bold', true);
  sheet
    .cell('G17')
    .value(`- T√™n ƒë∆°n v·ªã: ${formattedData.metadata.customerName}`);
  sheet
    .cell('G18')
    .value(`- M√£ s·ªë thu·∫ø: ${formattedData.metadata.customerTaxCode}`);
  sheet
    .cell('G19')
    .value(`- ƒê·ªãa ch·ªâ: ${formattedData.metadata.customerAddress}`);
  sheet
    .cell('G20')
    .value(`- √îng/B√†: ${formattedData.metadata.customerRepresentative}`);
  sheet
    .cell('I20')
    .value(`Ch·ª©c v·ª•: ${formattedData.metadata.customerRepresentativePosition}`);

  sheet.cell('F22').value('Hai b√™n th·ªëng nh·∫•t giao h√†ng, c·ª• th·ªÉ nh∆∞ sau:');

  // --- ITEMS TABLE ---
  // Table Headers
  const tableHeaders = [
    'STT',
    'V·∫≠t t∆∞, h√†ng h√≥a',
    'V·∫≠t li·ªáu',
    'ƒêVT',
    'S·ªë l∆∞·ª£ng',
  ];
  const headerRow = sheet.range('F24:J24');
  headerRow.value([tableHeaders]).style({
    fill: 'B4C6E7', // Light blue color
    bold: true,
    horizontalAlignment: 'center',
    verticalAlignment: 'center',
    border: {
      top: { style: 'thin' },
      bottom: { style: 'thin' },
      left: { style: 'thin' },
      right: { style: 'thin' },
    },
    wrapText: true,
  });

  // Add a utility function to convert numbers to Roman numerals
  function toRoman(num: number): string {
    const romanNumerals = [
      { value: 1000, numeral: 'M' },
      { value: 900, numeral: 'CM' },
      { value: 500, numeral: 'D' },
      { value: 400, numeral: 'CD' },
      { value: 100, numeral: 'C' },
      { value: 90, numeral: 'XC' },
      { value: 50, numeral: 'L' },
      { value: 40, numeral: 'XL' },
      { value: 10, numeral: 'X' },
      { value: 9, numeral: 'IX' },
      { value: 5, numeral: 'V' },
      { value: 4, numeral: 'IV' },
      { value: 1, numeral: 'I' },
    ];

    let roman = '';
    let n = num;

    for (let i = 0; i < romanNumerals.length; i++) {
      while (n >= romanNumerals[i].value) {
        roman += romanNumerals[i].numeral;
        n -= romanNumerals[i].value;
      }
    }

    return roman;
  }

  // Add items and borders
  let currentRow = 25;
  formattedData.items.forEach((item, index) => {
    sheet
      .range(`F${currentRow}:J${currentRow}`)
      .value([
        [
          toRoman(index + 1),
          item.name,
          item.material,
          item.unit,
          item.quantity,
        ],
      ]);

    // Apply wrap text for all cells to prevent overflow
    sheet.range(`F${currentRow}:J${currentRow}`).style({
      wrapText: true,
      border: {
        top: { style: 'thin' },
        bottom: { style: 'thin' },
        left: { style: 'thin' },
        right: { style: 'thin' },
      },
    });

    // Special styling for material name column to prevent overflow
    sheet.cell(`G${currentRow}`).style({
      wrapText: true,
      shrinkToFit: false,
      verticalAlignment: 'top',
    });

    // Center align STT, V·∫≠t li·ªáu, ƒêVT and S·ªë l∆∞·ª£ng columns
    sheet
      .cell(`F${currentRow}`)
      .style({ horizontalAlignment: 'center', verticalAlignment: 'center' }); // STT
    sheet
      .cell(`H${currentRow}`)
      .style({ horizontalAlignment: 'center', verticalAlignment: 'center' }); // V·∫≠t li·ªáu
    sheet
      .cell(`I${currentRow}`)
      .style({ horizontalAlignment: 'center', verticalAlignment: 'center' }); // ƒêVT
    sheet
      .cell(`J${currentRow}`)
      .style({ horizontalAlignment: 'center', verticalAlignment: 'center' }); // S·ªë l∆∞·ª£ng
    currentRow++;
  });

  // --- TOTAL ROW ---
  const totalQuantity = formattedData.items.reduce(
    (sum, item) => sum + (Number(item.quantity) || 0),
    0
  );

  // Merge cells for the label and set value
  sheet.range(`F${currentRow}:I${currentRow}`).merged(true).value('T·ªïng c·ªông');

  // Add the total quantity
  sheet.cell(`J${currentRow}`).value(totalQuantity);

  // Style the entire total row
  sheet.range(`F${currentRow}:J${currentRow}`).style({
    fill: 'B4C6E7', // Light blue color
    bold: true,
    horizontalAlignment: 'center',
    verticalAlignment: 'center',
  });

  // Apply border to the entire table, including header and total row
  const tableRange = sheet.range(`F24:J${currentRow}`);
  tableRange.style({
    border: {
      top: { style: 'thin' },
      bottom: { style: 'thin' },
      left: { style: 'thin' },
      right: { style: 'thin' },
    },
  });

  // --- FOOTER SECTION ---
  const footerStartRow = currentRow + 2;
  sheet
    .cell(`F${footerStartRow}`)
    .value(
      '- B√™n A ƒë√£ ho√†n th√†nh v√† b√†n giao t·∫•t c·∫£ c√°c h√†ng h√≥a tr√™n cho B√™n B t·∫°i X∆∞·ªüng THP'
    );
  sheet
    .cell(`F${footerStartRow + 1}`)
    .value(
      '- Bi√™n b·∫£n ƒë∆∞·ª£c l·∫≠p th√†nh 02 b·∫£n, m·ªói b√™n gi·ªØ 01 b·∫£n c√≥ gi√° tr·ªã ph√°p l√Ω nh∆∞ nhau.'
    );

  sheet
    .cell(`G${footerStartRow + 4}`)
    .value('ƒê·∫†I DI·ªÜN B√äN A')
    .style({ bold: true, horizontalAlignment: 'center' });
  sheet
    .cell(`G${footerStartRow + 5}`)
    .value('(K√Ω, ghi r√µ h·ªç t√™n)')
    .style({ italic: true, horizontalAlignment: 'center' });

  sheet
    .cell(`J${footerStartRow + 4}`)
    .value('ƒê·∫†I DI·ªÜN B√äN B')
    .style({ bold: true, horizontalAlignment: 'center' });
  sheet
    .cell(`J${footerStartRow + 5}`)
    .value('(K√Ω, ghi r√µ h·ªç t√™n)')
    .style({ italic: true, horizontalAlignment: 'center' });

  return workbook.outputAsync() as Promise<Buffer>;
}

export const generateDeliveryNoteExcel = functions
  .region('us-central1') // Explicitly set region
  .runWith({
    timeoutSeconds: 300,
    memory: '512MB',
  })
  .https.onCall(
    async (
      data: {
        formattedData: ExcelDeliveryNoteData;
        projectId: string;
        deliveryNoteId: string;
        accessToken: string;
      },
      context: CallableContext
    ) => {
      console.log('Function called with projectId:', data.projectId);

      if (!context.auth) {
        console.error('Authentication required');
        throw new functions.https.HttpsError(
          'unauthenticated',
          'B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ s·ª≠ d·ª•ng t√≠nh nƒÉng n√†y.'
        );
      }

      const { formattedData, projectId, deliveryNoteId, accessToken } = data;

      if (!formattedData) {
        console.error('Missing formattedData');
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu bi√™n b·∫£n.'
        );
      }
      if (!projectId) {
        console.error('Missing projectId');
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Kh√¥ng t√¨m th·∫•y ID d·ª± √°n.'
        );
      }
      if (!deliveryNoteId) {
        console.error('Missing deliveryNoteId');
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Kh√¥ng t√¨m th·∫•y ID bi√™n b·∫£n.'
        );
      }
      if (!accessToken) {
        console.error('Missing accessToken');
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Kh√¥ng t√¨m th·∫•y access token.'
        );
      }

      try {
        console.log('Generating Excel file with xlsx-populate...');
        const excelBuffer = await generateDeliveryNoteExcelFile(formattedData);

        console.log('Creating temp file...');
        const tempExcelPath = path.join(os.tmpdir(), `${deliveryNoteId}.xlsx`);
        fs.writeFileSync(tempExcelPath, excelBuffer);

        // Get project information to find the appropriate Drive folder
        const projectSnap = await db
          .collection('projects')
          .doc(projectId)
          .get();
        const projectData = projectSnap.data();

        if (!projectData || !projectData.driveFolderId) {
          console.error(`Project folder not found for project ${projectId}`);
          throw new functions.https.HttpsError(
            'failed-precondition',
            'Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c Drive c·ªßa d·ª± √°n.'
          );
        }

        // Use the user's access token to authenticate with Google Drive
        const auth = new google.auth.OAuth2();
        auth.setCredentials({ access_token: accessToken });
        const drive = google.drive({ version: 'v3', auth });

        // Verify access token works by getting user info
        try {
          console.log('Verifying access token validity');
          const aboutResponse = await drive.about.get({
            fields: 'user',
          });
          console.log(
            `Access token valid for user: ${
              aboutResponse.data.user?.displayName || 'Unknown'
            }`
          );
        } catch (tokenError) {
          console.error('Access token verification failed:', tokenError);
          throw new functions.https.HttpsError(
            'unauthenticated',
            'Google access token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n.'
          );
        }

        // Upload file to project folder in Drive
        const fileName = `Bi√™n b·∫£n giao h√†ng - ${formattedData.metadata.deliveryNoteNumber}.xlsx`;
        console.log(
          `Uploading file to Drive folder: ${projectData.driveFolderId}`
        );

        // Create file metadata and media
        const fileMetadata = {
          name: fileName,
          parents: [projectData.driveFolderId],
          mimeType:
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        };

        // Create a readable stream from the temp file
        const fileStream = fs.createReadStream(tempExcelPath);

        // Upload the file to Drive
        const driveResponse = await drive.files.create({
          requestBody: fileMetadata,
          media: {
            mimeType:
              'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            body: fileStream,
          },
          fields: 'id, webViewLink',
        });

        console.log('File uploaded to Drive:', driveResponse.data);

        // Make the file publicly accessible
        await drive.permissions.create({
          fileId: driveResponse.data.id!,
          requestBody: {
            role: 'reader',
            type: 'anyone',
          },
        });

        // Also upload to Firebase Storage as a backup
        /* console.log('Uploading to Firebase Storage as backup...');
        const fileName2 = `delivery_notes/${projectId}/${deliveryNoteId}.xlsx`;
        const file = bucket.file(fileName2);

        await file.save(fs.readFileSync(tempExcelPath), {
          metadata: {
            contentType:
              'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
          },
        });

        console.log('Cleaning up temp file...');
        fs.unlinkSync(tempExcelPath);

        console.log('Making firebase file public...');
        await file.makePublic(); */

        const excelUrl = driveResponse.data.webViewLink;
        console.log('Excel URL generated:', excelUrl);
        return { excelUrl, driveFileId: driveResponse.data.id };
      } catch (error: any) {
        console.error('Error generating delivery note Excel:', error);
        throw new functions.https.HttpsError(
          'internal',
          `L·ªói t·∫°o file Excel: ${error.message || 'Unknown error'}`,
          error
        );
      }
    }
  );


--- END: functions\src\deliveryNoteExcelGenerator.ts ---


--- START: functions\src\financialProcessor.ts ---
import * as functions from 'firebase-functions/v2';
import * as admin from 'firebase-admin';
import { google } from 'googleapis';
import * as path from 'path';
import * as XLSX from 'xlsx';
import { Timestamp } from 'firebase-admin/firestore';

const db = admin.firestore();
const SECRET_TOKEN = 'THP_FINANCE_SECRET_TOKEN'; // Should match Apps Script token

// Function to format currency for display
function formatCurrency(amount: number): string {
  return new Intl.NumberFormat('vi-VN', {
    style: 'currency',
    currency: 'VND',
  }).format(amount);
}

// Column mapping for Excel file
const colMap = {
  date: 0, // A - Ng√†y CT
  docNumber: 1, // B - BB S·ªê
  invoiceNumber: 2, // C - H√≥a ƒë∆°n
  supplier: 3, // D - T√äN ƒê∆†N V·ªä
  description: 4, // E - DI·ªÑN GI·∫¢I
  unit: 5, // F - ƒêVT
  quantity: 6, // G - S·ªê L∆Ø·ª¢NG
  price: 7, // H - ƒê∆†N GI√Å
  vat: 8, // I - VAT
  totalAmount: 9, // J - TH√ÄNH TI·ªÄN
  paidAmount: 10, // K - ƒê√É THANH TO√ÅN
  remainingAmount: 11, // L - C√íN L·∫†I
};

// Function to convert Excel date serial number to JS Date
function excelDateToJSDate(excelDate: number): Date {
  // Excel's epoch starts on 1/1/1900
  const millisecondsPerDay = 24 * 60 * 60 * 1000;
  // Excel incorrectly assumes 1900 is a leap year, so we adjust by 1 day for dates after 2/28/1900
  const dayAdjust = excelDate > 59 ? 1 : 0;
  const jsDate = new Date(
    Math.round((excelDate - dayAdjust - 25569) * millisecondsPerDay)
  );
  return jsDate;
}

// Function to clean text values
function cleanText(text: any): string {
  if (!text) return '';
  return String(text).trim().replace(/\s+/g, ' ');
}

// Function to extract numeric value from cell
function extractNumber(value: any): number {
  if (typeof value === 'number') return value;
  if (!value) return 0;

  const numStr = String(value).replace(/[^\d.-]/g, '');
  return numStr ? parseFloat(numStr) : 0;
}

// Function to check if a row is a transaction row
function isTransactionRow(row: any[], currentSupplier: string | null): boolean {
  // Check if date column has a value and we have a current supplier
  return row[colMap.date] && currentSupplier !== null;
}

// Function to check if a row is a supplier header row
function isSupplierRow(row: any[]): boolean {
  const supplierValue = row[colMap.supplier];
  return (
    supplierValue &&
    (String(supplierValue).startsWith('NCC - ') ||
      String(supplierValue).startsWith('KH - '))
  );
}

// Function to check if a row is a total row
function isTotalRow(row: any[]): boolean {
  return row[0] === 'C·ªòNG';
}

// Function to extract supplier name from cell
function extractSupplierName(cell: any): string {
  if (!cell) return '';
  const text = String(cell);
  if (text.startsWith('NCC - ')) {
    return text.substring(6).trim();
  } else if (text.startsWith('KH - ')) {
    return text.substring(5).trim();
  }
  return text.trim();
}

/**
 * Cloud Function to process payable ledger Excel file from Google Drive
 */
export const processPayableLedgerFromDrive = functions.https.onRequest(
  {
    region: 'asia-southeast1',
    timeoutSeconds: 300, // 5 minutes timeout for large files
  },
  async (req, res) => {
    try {
      // Verify authorization token
      const authHeader = req.headers.authorization;
      if (!authHeader || authHeader !== `Bearer ${SECRET_TOKEN}`) {
        console.error('Invalid or missing authorization token');
        res.status(401).send({ error: 'Unauthorized' });
        return;
      }

      // Get fileId from request body
      const { fileId } = req.body;
      if (!fileId) {
        console.error('No fileId provided in request body');
        res.status(400).send({ error: 'Missing fileId parameter' });
        return;
      }

      console.log(`Processing file with ID: ${fileId}`);

      // Initialize Google Drive API
      const auth = new google.auth.GoogleAuth({
        keyFile: path.join(__dirname, '../tanyb-fe4bf-4fbd5c01b6c7.json'),
        scopes: ['https://www.googleapis.com/auth/drive'],
      });
      const drive = google.drive({ version: 'v3', auth });

      // Download file from Google Drive
      const response = await drive.files.get(
        {
          fileId: fileId,
          alt: 'media',
        },
        { responseType: 'arraybuffer' }
      );

      // Get file metadata to extract filename
      const fileMetadata = await drive.files.get({
        fileId: fileId,
        fields: 'name,createdTime,modifiedTime',
      });

      const fileName = fileMetadata.data.name || 'Unknown File';
      console.log(`Downloaded file: ${fileName}`);

      // Parse Excel file
      const workbook = XLSX.read(response.data, { type: 'array' });
      const firstSheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[firstSheetName];

      // Convert to array of arrays
      const rows = XLSX.utils.sheet_to_json(worksheet, {
        header: 1,
      }) as any[][];

      console.log(`Total rows in Excel file: ${rows.length}`);

      // Process rows
      const transactions = [];
      let currentSupplier: string | null = null;
      let isPayable = true; // Default to payable (ph·∫£i tr·∫£)

      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        if (!row || row.length === 0) continue;

        // Check if this is a header row that indicates the type of ledger
        if (
          row.some(
            (cell) =>
              cell && String(cell).includes('S·ªî CHI TI·∫æT C√îNG N·ª¢ PH·∫¢I THU')
          )
        ) {
          isPayable = false;
          currentSupplier = null;
          continue;
        } else if (
          row.some(
            (cell) =>
              cell && String(cell).includes('S·ªî CHI TI·∫æT C√îNG N·ª¢ PH·∫¢I TR·∫¢')
          )
        ) {
          isPayable = true;
          currentSupplier = null;
          continue;
        }

        // Check if this is a supplier row
        if (isSupplierRow(row)) {
          currentSupplier = extractSupplierName(row[colMap.supplier]);
          continue;
        }

        // Check if this is a total row
        if (isTotalRow(row)) {
          currentSupplier = null;
          continue;
        }

        // Skip header rows
        if (row[0] === 'Ng√†y CT' || row[0] === 'Ng√†y') continue;

        // Process transaction row
        if (isTransactionRow(row, currentSupplier)) {
          let transactionDate: Date;

          // Handle date format (could be Excel serial date or string)
          if (typeof row[colMap.date] === 'number') {
            transactionDate = excelDateToJSDate(row[colMap.date]);
          } else if (typeof row[colMap.date] === 'string') {
            // Try to parse date string (DD/MM/YYYY format)
            const dateParts = String(row[colMap.date]).split('/');
            if (dateParts.length === 3) {
              transactionDate = new Date(
                parseInt(dateParts[2]),
                parseInt(dateParts[1]) - 1,
                parseInt(dateParts[0])
              );
            } else {
              // Default to current date if parsing fails
              transactionDate = new Date();
            }
          } else {
            // Default to current date if no valid date
            transactionDate = new Date();
          }

          const transaction = {
            type: isPayable ? 'payable' : 'receivable',
            supplier: currentSupplier || '',
            transactionDate: Timestamp.fromDate(transactionDate),
            docNumber: cleanText(row[colMap.docNumber]),
            invoiceNumber: cleanText(row[colMap.invoiceNumber]),
            description: cleanText(row[colMap.description]),
            amount: extractNumber(row[colMap.totalAmount]),
            paidAmount: extractNumber(row[colMap.paidAmount]),
            remainingAmount: extractNumber(row[colMap.remainingAmount]),
            unit: cleanText(row[colMap.unit]),
            quantity: extractNumber(row[colMap.quantity]),
            price: extractNumber(row[colMap.price]),
            vat: extractNumber(row[colMap.vat]),
            fileId: fileId,
            fileName: fileName,
            processedAt: Timestamp.now(),
          };

          transactions.push(transaction);
        }
      }

      console.log(`Extracted ${transactions.length} transactions`);

      // Save transactions to Firestore using batch write
      const batch = db.batch();

      for (const transaction of transactions) {
        // Generate a unique ID based on supplier, date, and document number
        const idComponents = [
          transaction.supplier,
          transaction.transactionDate.toDate().toISOString().split('T')[0],
          transaction.docNumber || 'nodoc',
          transaction.description
            ? transaction.description.substring(0, 20)
            : 'nodesc',
        ];
        const uniqueId = idComponents.join('_').replace(/[^a-zA-Z0-9_]/g, '');

        const docRef = db.collection('payable_transactions').doc(uniqueId);
        batch.set(docRef, transaction, { merge: true });
      }

      await batch.commit();
      console.log(
        `Successfully saved ${transactions.length} transactions to Firestore`
      );

      // Update the last processed timestamp in a metadata document
      await db.collection('system').doc('financialProcessorMetadata').set(
        {
          lastProcessedAt: Timestamp.now(),
          lastProcessedFile: fileName,
          lastProcessedFileId: fileId,
          transactionsProcessed: transactions.length,
        },
        { merge: true }
      );

      res.status(200).send({
        success: true,
        message: `Successfully processed ${transactions.length} transactions from ${fileName}`,
      });
    } catch (error: any) {
      console.error('Error processing payable ledger:', error);
      res.status(500).send({
        error: 'Failed to process payable ledger',
        details: error.message,
      });
    }
  }
);

/**
 * Orchestrator function to trigger Excel processing from a folder
 * This is a callable function that can be invoked from the client
 */
export const triggerExcelProcessing = functions.https.onCall(
  {
    region: 'asia-southeast1',
    timeoutSeconds: 300, // 5 ph√∫t timeout cho file l·ªõn
  },
  async () => {
    try {
      console.log('triggerExcelProcessing called');

      // Initialize Google Drive API
      const auth = new google.auth.GoogleAuth({
        keyFile: path.join(__dirname, '../tanyb-fe4bf-4fbd5c01b6c7.json'),
        scopes: ['https://www.googleapis.com/auth/drive'],
      });
      const drive = google.drive({ version: 'v3', auth });

      // Define the folder ID where Excel files are stored
      const FOLDER_ID = '1Ci_BHZx0-Uhv2xg5IzwLPn05yPAUXOOU';

      // Search for Excel files in the specified folder
      const response = await drive.files.list({
        q: `'${FOLDER_ID}' in parents and (mimeType='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' or mimeType='application/vnd.ms-excel') and trashed=false`,
        orderBy: 'modifiedTime desc',
        pageSize: 1, // Get only the latest file
        fields: 'files(id,name,modifiedTime)',
      });

      const files = response.data.files;
      if (!files || files.length === 0) {
        throw new functions.https.HttpsError(
          'not-found',
          'No Excel files found in the specified folder'
        );
      }

      const latestFile = files[0];
      console.log(
        `Found latest file: ${latestFile.name} (ID: ${latestFile.id})`
      );

      // Download file from Google Drive
      const fileResponse = await drive.files.get(
        {
          fileId: latestFile.id!,
          alt: 'media',
        },
        { responseType: 'arraybuffer' }
      );

      console.log(`Downloaded file Excel: ${latestFile.name}`);

      // Parse Excel file
      const workbook = XLSX.read(fileResponse.data, { type: 'buffer' });

      let totalReceivable = 0; // T·ªïng ph·∫£i thu
      let totalPayable = 0; // T·ªïng ph·∫£i tr·∫£

      // Process "PH·∫¢I TR·∫¢" sheet
      const payableSheetName = findSheetByPattern(workbook, [
        'PH·∫¢I TR·∫¢',
        'PHAI TRA',
        'PAYABLE',
      ]);
      if (payableSheetName) {
        console.log(`Processing PH·∫¢I TR·∫¢ sheet: ${payableSheetName}`);
        totalPayable = processSheetForTotal(workbook, payableSheetName);
        console.log(`Total PAYABLE: ${totalPayable}`);
      } else {
        console.log('No PH·∫¢I TR·∫¢ sheet found');
      }

      // Process "PH·∫¢I THU" sheet
      const receivableSheetName = findSheetByPattern(workbook, [
        'PH·∫¢I THU',
        'PHAI THU',
        'RECEIVABLE',
      ]);
      if (receivableSheetName) {
        console.log(`Processing PH·∫¢I THU sheet: ${receivableSheetName}`);
        totalReceivable = processSheetForTotal(workbook, receivableSheetName);
        console.log(`Total RECEIVABLE: ${totalReceivable}`);
      } else {
        console.log('No PH·∫¢I THU sheet found');
      }

      // Calculate net position
      const netPosition = totalReceivable - totalPayable;

      // Create summary object
      const summary = {
        totalReceivable,
        totalPayable,
        netPosition,
        lastUpdated: Timestamp.now(),
        fileName: latestFile.name!,
        fileId: latestFile.id!,
        formattedTotals: {
          totalReceivable: formatCurrency(totalReceivable),
          totalPayable: formatCurrency(totalPayable),
          netPosition: formatCurrency(netPosition),
        },
      };

      // Save summary to Firestore
      console.log('Saving data to Firestore...');
      await db
        .collection('summaries')
        .doc('directorDashboard')
        .set(summary, { merge: true });

      // Update metadata
      await db.collection('system').doc('financialProcessorMetadata').set(
        {
          lastProcessedAt: Timestamp.now(),
          lastProcessedFile: latestFile.name,
          lastProcessedFileId: latestFile.id,
          summaryDataProcessed: true,
          totalReceivable,
          totalPayable,
        },
        { merge: true }
      );

      console.log('Excel processing completed successfully!');

      // Return success result
      return {
        success: true,
        message: `Successfully processed data from file ${latestFile.name}`,
        fileName: latestFile.name,
        fileId: latestFile.id,
        summary,
      };
    } catch (error: any) {
      console.error('Error in triggerExcelProcessing:', error);

      // Re-throw HttpsError as-is, convert others to internal error
      if (error instanceof functions.https.HttpsError) {
        throw error;
      }

      throw new functions.https.HttpsError(
        'internal',
        `Failed to process Excel file: ${error.message}`
      );
    }
  }
);

/**
 * Find sheet name based on pattern
 * @param workbook - XLSX workbook
 * @param patterns - Array of patterns to look for
 * @returns Sheet name if found, undefined otherwise
 */
function findSheetByPattern(
  workbook: XLSX.WorkBook,
  patterns: string[]
): string | undefined {
  for (const sheetName of workbook.SheetNames) {
    const normalizedName = sheetName.normalize('NFC').toUpperCase();
    for (const pattern of patterns) {
      if (normalizedName.includes(pattern)) {
        return sheetName;
      }
    }
  }
  return undefined;
}

/**
 * Process a sheet to get total value based on column B = "C·ªòNG" and get value from column L
 * @param workbook - XLSX workbook
 * @param sheetName - Sheet name to process
 * @returns Total value
 */
function processSheetForTotal(
  workbook: XLSX.WorkBook,
  sheetName: string
): number {
  const sheet = workbook.Sheets[sheetName];
  const data = XLSX.utils.sheet_to_json<any>(sheet, { header: 'A' });

  let total = 0;
  let sums: number[] = [];

  console.log(`Total rows in sheet ${sheetName}: ${data.length}`);

  // Loop through each row to find rows with column B as "C·ªòNG"
  for (const row of data) {
    // Check if column B (mapped to key 'B') is "C·ªòNG"
    if (row['B'] === 'C·ªòNG') {
      // Get value from column L
      const value = parseFloat(row['L'] || 0);
      if (!isNaN(value)) {
        sums.push(value);
        console.log(`Found C·ªòNG value: ${value}`);
      }
    }
  }

  // Calculate total from all found values
  total = sums.reduce((acc, curr) => acc + curr, 0);
  console.log(`Values found: ${sums.join(', ')}`);
  console.log(`Total: ${total}`);

  return total;
}


--- END: functions\src\financialProcessor.ts ---


--- START: functions\src\index.ts ---
//functions/src/index.ts
/* eslint-disable max-len */
/**
 * Import function triggers from their respective submodules:
 *
 * import {onCall} from "firebase-functions/v2/https";
 * import {onDocumentWritten} from "firebase-functions/v2/firestore";
 *
 * See a full list of supported triggers at https://firebase.google.com/docs/functions
 */

import * as admin from 'firebase-admin';
import * as functions from 'firebase-functions/v1';

// Initialize Firebase Admin FIRST
admin.initializeApp({
  storageBucket: 'tanyb-fe4bf.appspot.com',
});

// Export functions from other files
export * from './materialImporter';
export * from './customerImporter';
export * from './projectTriggers';
export * from './taskTriggers';
// Lo·∫°i b·ªè export t·ª´ excelGenerator v√¨ ƒëang xung ƒë·ªôt v·ªõi quotationExcelGenerator
// export * from './excelGenerator';
export * from './pdfGenerator';
export * from './contractGenerator';
export * from './financialProcessor';
export * from './scheduledFunctions';
export * from './poExcelGenerator';
export * from './poReceiptConfirmation';
export * from './savePOReceiptConfirmation';
export * from './createProjectFolders';
export * from './deliveryNoteExcelGenerator';
// Export tr·ª±c ti·∫øp t·ª´ quotationExcelGenerator
export * from './quotationExcelGenerator';
export * from './attendanceExcelGenerator';
export * from './salaryExcelGenerator';
export * from './processWorkAllocations';
export * from './aggregateMonthlyReport';
export * from './notificationTriggers';
export * from './publicApi';

// Kh√¥ng export t·ª´ excelGenerator n·ªØa v√¨ ƒë√£ c√≥ export t·ª´ quotationExcelGenerator

// Import v√† export c√°c h√†m qu·∫£n l√Ω kho
export * from './inventoryManager';

// Th√™m importInventoryFromExcel
export const importInventoryFromExcel = functions
  .region('asia-southeast1')
  .https.onCall(async (data: any, context: functions.https.CallableContext) => {
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Ng∆∞·ªùi d√πng c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y.'
      );
    }

    const { driveFileId, accessToken } = data;
    if (!driveFileId || !accessToken) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thi·∫øu file ID ho·∫∑c access token.'
      );
    }

    try {
      // 1. Kh·ªüi t·∫°o Google API client
      const { google } = require('googleapis');
      const auth = new google.auth.OAuth2();
      auth.setCredentials({ access_token: accessToken });
      const drive = google.drive({ version: 'v3', auth });

      // 2. T·∫£i file t·ª´ Google Drive
      const response = await drive.files.get(
        { fileId: driveFileId, alt: 'media' },
        { responseType: 'arraybuffer' }
      );

      // 3. Parse file Excel v·ªõi XLSX
      const XLSX = require('xlsx');
      const workbook = XLSX.read(Buffer.from(response.data), {
        type: 'buffer',
      });

      // L·∫•y sheet ƒë·∫ßu ti√™n
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      const rawData = XLSX.utils.sheet_to_json(worksheet, {
        header: 1,
        defval: null,
      });

      // 4. T√¨m h√†ng ti√™u ƒë·ªÅ (th∆∞·ªùng l√† h√†ng ƒë·∫ßu ti√™n)
      let headerRow = rawData[0];
      let startRow = 1;

      // N·∫øu h√†ng ƒë·∫ßu kh√¥ng c√≥ d·ªØ li·ªáu ƒë√∫ng, th·ª≠ t√¨m h√†ng ti√™u ƒë·ªÅ h·ª£p l·ªá
      if (!headerRow || headerRow.length < 2) {
        for (let i = 0; i < 5; i++) {
          if (rawData[i] && rawData[i].length >= 2) {
            headerRow = rawData[i];
            startRow = i + 1;
            break;
          }
        }
      }

      if (!headerRow) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Kh√¥ng t√¨m th·∫•y h√†ng ti√™u ƒë·ªÅ trong file Excel.'
        );
      }

      // 5. √Ånh x·∫° c√°c c·ªôt d·ª±a tr√™n ti√™u ƒë·ªÅ
      const findColumnIndex = (names: string[]) => {
        for (let i = 0; i < headerRow.length; i++) {
          const cell = headerRow[i];
          if (cell && typeof cell === 'string') {
            const cellValue = cell.toLowerCase();
            if (names.some((name) => cellValue.includes(name.toLowerCase()))) {
              return i;
            }
          }
        }
        return -1;
      };

      const columnMap = {
        code: findColumnIndex(['M√£ v·∫≠t t∆∞', 'M√£', 'Code']),
        name: findColumnIndex(['T√™n v·∫≠t t∆∞', 'T√™n', 'Name']),
        description: findColumnIndex(['M√¥ t·∫£', 'Description']),
        category: findColumnIndex(['Danh m·ª•c', 'Category']),
        unit: findColumnIndex(['ƒê∆°n v·ªã t√≠nh', 'Unit']),
        stockQuantity: findColumnIndex(['S·ªë l∆∞·ª£ng', 'Quantity']),
        minQuantity: findColumnIndex(['S·ªë l∆∞·ª£ng t·ªëi thi·ªÉu', 'Min Quantity']),
        price: findColumnIndex(['ƒê∆°n gi√°', 'Price']),
        material: findColumnIndex(['V·∫≠t li·ªáu', 'Material']),
        weight: findColumnIndex(['Kh·ªëi l∆∞·ª£ng', 'Weight']),
      };

      // 6. Chu·∫©n b·ªã k·∫øt qu·∫£
      const result = {
        total: 0,
        added: 0,
        updated: 0,
        skipped: 0,
        errors: [] as Array<{ row: number; message: string }>,
      };

      // 7. L·∫•y danh s√°ch danh m·ª•c ƒë·ªÉ √°nh x·∫°
      const categoriesSnapshot = await admin
        .firestore()
        .collection('inventory_categories')
        .get();

      const categoriesMap: Record<string, string> = {};
      categoriesSnapshot.docs.forEach((doc) => {
        const category = doc.data();
        if (category.name) {
          categoriesMap[category.name.toLowerCase()] = doc.id;
        }
      });

      // 8. X·ª≠ l√Ω t·ª´ng h√†ng d·ªØ li·ªáu
      for (let i = startRow; i < rawData.length; i++) {
        const row = rawData[i];

        // B·ªè qua h√†ng tr·ªëng
        if (!row || row.length === 0) continue;

        // Ki·ªÉm tra code v√† name
        const code = row[columnMap.code];
        const name = row[columnMap.name];

        if (!code || !name) {
          result.skipped++;
          continue;
        }

        try {
          // Chu·∫©n b·ªã d·ªØ li·ªáu v·∫≠t t∆∞
          const itemData: any = {
            code: String(code),
            name: String(name),
          };

          // Th√™m c√°c tr∆∞·ªùng t√πy ch·ªçn n·∫øu c√≥
          if (columnMap.description !== -1 && row[columnMap.description]) {
            itemData.description = String(row[columnMap.description]);
          }

          // X·ª≠ l√Ω danh m·ª•c
          if (columnMap.category !== -1 && row[columnMap.category]) {
            const categoryName = String(row[columnMap.category]).toLowerCase();
            if (categoriesMap[categoryName]) {
              itemData.categoryId = categoriesMap[categoryName];
            }
          }

          if (columnMap.unit !== -1 && row[columnMap.unit]) {
            itemData.unit = String(row[columnMap.unit]);
          }

          if (
            columnMap.stockQuantity !== -1 &&
            row[columnMap.stockQuantity] !== null
          ) {
            const quantity = parseFloat(String(row[columnMap.stockQuantity]));
            if (!isNaN(quantity)) {
              itemData.stockQuantity = quantity;
            }
          }

          if (
            columnMap.minQuantity !== -1 &&
            row[columnMap.minQuantity] !== null
          ) {
            const minQty = parseFloat(String(row[columnMap.minQuantity]));
            if (!isNaN(minQty)) {
              itemData.minQuantity = minQty;
            }
          }

          if (columnMap.price !== -1 && row[columnMap.price] !== null) {
            const price = parseFloat(String(row[columnMap.price]));
            if (!isNaN(price)) {
              itemData.price = price;
            }
          }

          if (columnMap.material !== -1 && row[columnMap.material]) {
            itemData.material = String(row[columnMap.material]);
          }

          if (columnMap.weight !== -1 && row[columnMap.weight] !== null) {
            const weight = parseFloat(String(row[columnMap.weight]));
            if (!isNaN(weight)) {
              itemData.weight = weight;
            }
          }

          // T√≠nh t·ªïng gi√° tr·ªã n·∫øu c√≥ s·ªë l∆∞·ª£ng v√† ƒë∆°n gi√°
          if (itemData.stockQuantity && itemData.price) {
            itemData.totalPrice = itemData.stockQuantity * itemData.price;
          }

          // 9. Ki·ªÉm tra v·∫≠t t∆∞ ƒë√£ t·ªìn t·∫°i ch∆∞a
          const db = admin.firestore();
          const querySnapshot = await db
            .collection('inventory')
            .where('code', '==', itemData.code)
            .get();

          if (!querySnapshot.empty) {
            // C·∫≠p nh·∫≠t v·∫≠t t∆∞ ƒë√£ t·ªìn t·∫°i
            const docId = querySnapshot.docs[0].id;
            await db
              .collection('inventory')
              .doc(docId)
              .update({
                ...itemData,
                updatedAt: admin.firestore.FieldValue.serverTimestamp(),
              });
            result.updated++;
          } else {
            // Th√™m v·∫≠t t∆∞ m·ªõi
            await db.collection('inventory').add({
              ...itemData,
              createdAt: admin.firestore.FieldValue.serverTimestamp(),
              updatedAt: admin.firestore.FieldValue.serverTimestamp(),
            });
            result.added++;
          }

          result.total++;
        } catch (err: any) {
          console.error(`L·ªói khi x·ª≠ l√Ω h√†ng ${i}:`, err);
          result.errors.push({
            row: i + 1,
            message: err.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh',
          });
          result.skipped++;
        }
      }

      return result;
    } catch (error: any) {
      console.error('Error importing inventory from Excel:', error);

      if (error.code === 401 || error.code === 403) {
        throw new functions.https.HttpsError(
          'permission-denied',
          'Token truy c·∫≠p Google Drive kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n.'
        );
      }

      throw new functions.https.HttpsError(
        'internal',
        'L·ªói khi x·ª≠ l√Ω file Excel.',
        error.message
      );
    }
  });

// Lo·∫°i b·ªè export tr√πng l·∫∑p v√¨ ƒë√£ c√≥ export t·ª´ './quotationExcelGenerator' ·ªü tr√™n
export { generateDeliveryNoteExcel } from './deliveryNoteExcelGenerator';
export { exportSheetToPdf } from './pdfGenerator';
export { generateExcelQuotation } from './excelGenerator';


--- END: functions\src\index.ts ---


--- START: functions\src\inventoryManager.ts ---
import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';
import { CallableContext } from 'firebase-functions/v1/https';

// Interface ƒë·ªãnh nghƒ©a c·∫•u tr√∫c v·∫≠t t∆∞ trong kho
export interface InventoryItem {
  id?: string;
  name: string;
  code: string;
  description?: string;
  categoryId: string;
  unit: string;
  stockQuantity: number;
  minQuantity?: number;
  price?: number;
  lastUpdated: admin.firestore.Timestamp;
  updatedAt?: admin.firestore.Timestamp; // Th√™m field n√†y ƒë·ªÉ t∆∞∆°ng th√≠ch
  createdAt?: admin.firestore.Timestamp; // Th√™m field n√†y ƒë·ªÉ t∆∞∆°ng th√≠ch
  locationId?: string;
  weight?: number; // Kh·ªëi l∆∞·ª£ng (kg)
  material?: string; // V·∫≠t li·ªáu
  imageUrl?: string; // URL h√¨nh ·∫£nh
  imageBase64?: string; // Base64 data c·ªßa h√¨nh ·∫£nh
  supplier?: string; // Nh√† cung c·∫•p ch√≠nh
  properties?: { [key: string]: any }; // Thu·ªôc t√≠nh tu·ª≥ ch·ªânh
}

// Interface ƒë·ªãnh nghƒ©a giao d·ªãch nh·∫≠p/xu·∫•t kho
export interface InventoryTransaction {
  id?: string;
  type: 'IN' | 'OUT' | 'ADJUST' | 'TRANSFER'; // Lo·∫°i giao d·ªãch
  itemId: string;
  quantity: number;
  date: admin.firestore.Timestamp;
  note?: string;
  documentNumber?: string; // S·ªë phi·∫øu/ch·ª©ng t·ª´
  projectId?: string; // ID d·ª± √°n (n·∫øu xu·∫•t cho d·ª± √°n)
  supplierId?: string; // ID nh√† cung c·∫•p (n·∫øu nh·∫≠p t·ª´ NCC)
  price?: number; // Gi√° t·∫°i th·ªùi ƒëi·ªÉm giao d·ªãch
  userId: string; // Ng∆∞·ªùi t·∫°o giao d·ªãch
  locationId?: string; // V·ªã tr√≠ kho
  destinationLocationId?: string; // V·ªã tr√≠ ƒë√≠ch (n·∫øu chuy·ªÉn kho)
  status: 'PENDING' | 'COMPLETED' | 'CANCELLED';
  approvedBy?: string; // Ng∆∞·ªùi ph√™ duy·ªát
  attachmentUrls?: string[]; // T√†i li·ªáu ƒë√≠nh k√®m
}

// Interface ƒë·ªãnh nghƒ©a danh m·ª•c v·∫≠t t∆∞
export interface InventoryCategory {
  id?: string;
  name: string;
  description?: string;
  parentId?: string; // Danh m·ª•c cha (n·∫øu c√≥)
}

// Interface ƒë·ªãnh nghƒ©a v·ªã tr√≠ kho
export interface InventoryLocation {
  id?: string;
  name: string;
  address?: string;
  description?: string;
  isActive: boolean;
}

/**
 * Th√™m v·∫≠t t∆∞ m·ªõi v√†o kho
 */
export const addInventoryItem = functions
  .region('asia-southeast1')
  .https.onCall(async (data: InventoryItem, context: CallableContext) => {
    console.log('=== CLOUD FUNCTION: B·∫ÆT ƒê·∫¶U TH√äM V·∫¨T T∆Ø ===');
    console.log('data nh·∫≠n ƒë∆∞·ª£c:', JSON.stringify(data, null, 2));
    console.log('context.auth:', context.auth);

    // Ki·ªÉm tra x√°c th·ª±c
    if (!context.auth) {
      console.error('=== CLOUD FUNCTION: L·ªñI X√ÅC TH·ª∞C ===');
      console.error('User ch∆∞a ƒëƒÉng nh·∫≠p');
      throw new functions.https.HttpsError(
        'unauthenticated',
        'B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ th·ª±c hi·ªán ch·ª©c nƒÉng n√†y.'
      );
    }

    try {
      console.log('=== CLOUD FUNCTION: KI·ªÇM TRA D·ªÆ LI·ªÜU ===');
      // Ki·ªÉm tra d·ªØ li·ªáu ƒë·∫ßu v√†o
      if (!data.name || !data.code || !data.categoryId || !data.unit) {
        console.error('=== CLOUD FUNCTION: L·ªñI D·ªÆ LI·ªÜU ===');
        console.error('Thi·∫øu th√¥ng tin b·∫Øt bu·ªôc:');
        console.error('name:', data.name);
        console.error('code:', data.code);
        console.error('categoryId:', data.categoryId);
        console.error('unit:', data.unit);

        throw new functions.https.HttpsError(
          'invalid-argument',
          'Thi·∫øu th√¥ng tin v·∫≠t t∆∞ b·∫Øt bu·ªôc.'
        );
      }

      console.log('=== CLOUD FUNCTION: KI·ªÇM TRA M√É V·∫¨T T∆Ø TR√ôNG ===');
      // Ki·ªÉm tra m√£ v·∫≠t t∆∞ ƒë√£ t·ªìn t·∫°i ch∆∞a
      const codeSnapshot = await admin
        .firestore()
        .collection('inventory')
        .where('code', '==', data.code)
        .get();

      if (!codeSnapshot.empty) {
        console.error('=== CLOUD FUNCTION: M√É V·∫¨T T∆Ø ƒê√É T·ªíN T·∫†I ===');
        console.error('M√£ v·∫≠t t∆∞:', data.code, 'ƒë√£ t·ªìn t·∫°i');
        throw new functions.https.HttpsError(
          'already-exists',
          'M√£ v·∫≠t t∆∞ ƒë√£ t·ªìn t·∫°i trong h·ªá th·ªëng.'
        );
      }

      console.log('=== CLOUD FUNCTION: CHU·∫®N B·ªä D·ªÆ LI·ªÜU ===');
      // Chu·∫©n b·ªã d·ªØ li·ªáu ƒë·ªÉ l∆∞u
      const newItem: InventoryItem = {
        ...data,
        stockQuantity: data.stockQuantity || 0,
        lastUpdated: admin.firestore.Timestamp.now(),
        updatedAt: admin.firestore.Timestamp.now(), // Th√™m field n√†y ƒë·ªÉ t∆∞∆°ng th√≠ch
      };
      console.log('newItem chu·∫©n b·ªã l∆∞u:', JSON.stringify(newItem, null, 2));

      console.log('=== CLOUD FUNCTION: L∆ØU V√ÄO FIRESTORE ===');
      // L∆∞u v√†o Firestore
      const docRef = await admin
        .firestore()
        .collection('inventory')
        .add(newItem);

      console.log('=== CLOUD FUNCTION: ƒê√É L∆ØU TH√ÄNH C√îNG ===');
      console.log('Document ID:', docRef.id);

      // N·∫øu c√≥ s·ªë l∆∞·ª£ng ban ƒë·∫ßu > 0, t·∫°o giao d·ªãch nh·∫≠p kho
      if (data.stockQuantity > 0) {
        console.log('=== CLOUD FUNCTION: T·∫†O GIAO D·ªäCH NH·∫¨P KHO ===');
        await admin.firestore().collection('inventory_transactions').add({
          type: 'IN',
          itemId: docRef.id,
          quantity: data.stockQuantity,
          date: admin.firestore.Timestamp.now(),
          note: 'Nh·∫≠p kho ban ƒë·∫ßu',
          userId: context.auth.uid,
          status: 'COMPLETED',
        });
        console.log('=== CLOUD FUNCTION: ƒê√É T·∫†O GIAO D·ªäCH NH·∫¨P KHO ===');
      }

      const result = {
        success: true,
        id: docRef.id,
        message: 'Th√™m v·∫≠t t∆∞ th√†nh c√¥ng',
      };

      console.log('=== CLOUD FUNCTION: TR·∫¢ V·ªÄ K·∫æT QU·∫¢ ===');
      console.log('result:', JSON.stringify(result, null, 2));

      return result;
    } catch (error: any) {
      console.error('=== CLOUD FUNCTION: L·ªñI CHUNG ===');
      console.error('Error object:', error);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
      console.error('=== END L·ªñI CLOUD FUNCTION ===');

      throw new functions.https.HttpsError(
        'internal',
        `L·ªói th√™m v·∫≠t t∆∞: ${error.message}`
      );
    }
  });

/**
 * C·∫≠p nh·∫≠t th√¥ng tin v·∫≠t t∆∞
 */
export const updateInventoryItem = functions
  .region('asia-southeast1')
  .https.onCall(
    async (
      data: { itemId: string; itemData: Partial<InventoryItem> },
      context: CallableContext
    ) => {
      // Ki·ªÉm tra x√°c th·ª±c
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ th·ª±c hi·ªán ch·ª©c nƒÉng n√†y.'
        );
      }

      try {
        const { itemId, itemData } = data;

        // Ki·ªÉm tra d·ªØ li·ªáu ƒë·∫ßu v√†o
        if (!itemId) {
          throw new functions.https.HttpsError(
            'invalid-argument',
            'Thi·∫øu ID v·∫≠t t∆∞ c·∫ßn c·∫≠p nh·∫≠t.'
          );
        }

        // Kh√¥ng cho ph√©p c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng tr·ª±c ti·∫øp
        if ('stockQuantity' in itemData) {
          delete itemData.stockQuantity;
        }

        // C·∫≠p nh·∫≠t th·ªùi gian
        const updateData = {
          ...itemData,
          lastUpdated: admin.firestore.Timestamp.now(),
          updatedAt: admin.firestore.Timestamp.now(), // Th√™m field n√†y ƒë·ªÉ t∆∞∆°ng th√≠ch
        };

        // C·∫≠p nh·∫≠t v√†o Firestore
        await admin
          .firestore()
          .collection('inventory')
          .doc(itemId)
          .update(updateData);

        return {
          success: true,
          message: 'C·∫≠p nh·∫≠t v·∫≠t t∆∞ th√†nh c√¥ng',
        };
      } catch (error: any) {
        console.error('L·ªói c·∫≠p nh·∫≠t v·∫≠t t∆∞:', error);
        throw new functions.https.HttpsError(
          'internal',
          `L·ªói c·∫≠p nh·∫≠t v·∫≠t t∆∞: ${error.message}`
        );
      }
    }
  );

/**
 * T·∫°o giao d·ªãch nh·∫≠p/xu·∫•t kho
 */
export const createInventoryTransaction = functions
  .region('asia-southeast1')
  .https.onCall(
    async (data: InventoryTransaction, context: CallableContext) => {
      // Ki·ªÉm tra x√°c th·ª±c
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ th·ª±c hi·ªán ch·ª©c nƒÉng n√†y.'
        );
      }

      // B·∫Øt ƒë·∫ßu transaction ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh nh·∫•t qu√°n d·ªØ li·ªáu
      const db = admin.firestore();

      try {
        return await db.runTransaction(async (transaction) => {
          // Ki·ªÉm tra d·ªØ li·ªáu ƒë·∫ßu v√†o
          if (
            !data.itemId ||
            !data.quantity ||
            !data.type ||
            data.quantity <= 0
          ) {
            throw new functions.https.HttpsError(
              'invalid-argument',
              'D·ªØ li·ªáu giao d·ªãch kh√¥ng h·ª£p l·ªá.'
            );
          }

          // L·∫•y th√¥ng tin v·∫≠t t∆∞ hi·ªán t·∫°i
          const itemRef = db.collection('inventory').doc(data.itemId);
          const itemDoc = await transaction.get(itemRef);

          if (!itemDoc.exists) {
            throw new functions.https.HttpsError(
              'not-found',
              'Kh√¥ng t√¨m th·∫•y v·∫≠t t∆∞ trong kho.'
            );
          }

          const currentItem = itemDoc.data() as InventoryItem;
          let newQuantity = currentItem.stockQuantity;

          // T√≠nh to√°n s·ªë l∆∞·ª£ng m·ªõi d·ª±a tr√™n lo·∫°i giao d·ªãch
          if (data.type === 'IN') {
            newQuantity += data.quantity;
          } else if (data.type === 'OUT') {
            if (currentItem.stockQuantity < data.quantity) {
              throw new functions.https.HttpsError(
                'failed-precondition',
                'S·ªë l∆∞·ª£ng trong kho kh√¥ng ƒë·ªß ƒë·ªÉ xu·∫•t.'
              );
            }
            newQuantity -= data.quantity;
          } else if (data.type === 'ADJUST') {
            newQuantity = data.quantity; // ƒêi·ªÅu ch·ªânh tr·ª±c ti·∫øp
          } else if (data.type === 'TRANSFER') {
            // ƒê·ªëi v·ªõi chuy·ªÉn kho, s·ªë l∆∞·ª£ng kh√¥ng ƒë·ªïi t·ªïng nh∆∞ng c·∫ßn ki·ªÉm tra
            if (!data.destinationLocationId) {
              throw new functions.https.HttpsError(
                'invalid-argument',
                'Thi·∫øu th√¥ng tin v·ªã tr√≠ kho ƒë√≠ch.'
              );
            }

            if (currentItem.stockQuantity < data.quantity) {
              throw new functions.https.HttpsError(
                'failed-precondition',
                'S·ªë l∆∞·ª£ng trong kho kh√¥ng ƒë·ªß ƒë·ªÉ chuy·ªÉn.'
              );
            }
            // S·ªë l∆∞·ª£ng x·ª≠ l√Ω trong c√°c b∆∞·ªõc ti·∫øp theo
          }

          // Chu·∫©n b·ªã d·ªØ li·ªáu giao d·ªãch ƒë·ªÉ l∆∞u
          const transactionData: InventoryTransaction = {
            ...data,
            userId: context.auth.uid,
            date: data.date || admin.firestore.Timestamp.now(),
            status: data.status || 'COMPLETED',
          };

          // L∆∞u giao d·ªãch v√†o Firestore
          const transactionRef = db.collection('inventory_transactions').doc();
          transaction.set(transactionRef, transactionData);

          // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng trong kho (tr·ª´ tr∆∞·ªùng h·ª£p chuy·ªÉn kho)
          if (data.type !== 'TRANSFER') {
            transaction.update(itemRef, {
              stockQuantity: newQuantity,
              lastUpdated: admin.firestore.Timestamp.now(),
              updatedAt: admin.firestore.Timestamp.now(), // Th√™m field n√†y ƒë·ªÉ t∆∞∆°ng th√≠ch
            });
          } else {
            // X·ª≠ l√Ω chuy·ªÉn kho - logic ph·ª©c t·∫°p h∆°n c√≥ th·ªÉ th√™m sau
            console.log('X·ª≠ l√Ω chuy·ªÉn kho - c·∫ßn b·ªï sung logic');
          }

          return {
            success: true,
            transactionId: transactionRef.id,
            message: 'Giao d·ªãch kho th√†nh c√¥ng',
            newQuantity,
          };
        });
      } catch (error: any) {
        console.error('L·ªói t·∫°o giao d·ªãch kho:', error);
        throw new functions.https.HttpsError(
          'internal',
          `L·ªói t·∫°o giao d·ªãch kho: ${error.message}`
        );
      }
    }
  );

/**
 * L·∫•y b√°o c√°o t·ªìn kho
 */
export const getInventoryReport = functions
  .region('asia-southeast1')
  .https.onCall(
    async (
      data: {
        categoryId?: string;
        locationId?: string;
        lowStock?: boolean;
      },
      context: CallableContext
    ) => {
      // Ki·ªÉm tra x√°c th·ª±c
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ th·ª±c hi·ªán ch·ª©c nƒÉng n√†y.'
        );
      }

      try {
        // T·∫°o truy v·∫•n c∆° b·∫£n
        let query: FirebaseFirestore.Query<FirebaseFirestore.DocumentData> =
          admin.firestore().collection('inventory');

        // √Åp d·ª•ng c√°c b·ªô l·ªçc
        if (data.categoryId) {
          query = query.where('categoryId', '==', data.categoryId);
        }

        if (data.locationId) {
          query = query.where('locationId', '==', data.locationId);
        }

        const snapshot = await query.get();
        const items = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        }));

        // L·ªçc h√†ng t·ªìn th·∫•p n·∫øu y√™u c·∫ßu
        let result = items;
        if (data.lowStock) {
          result = items.filter((item) => {
            const typedItem = item as unknown as InventoryItem;
            return typedItem.stockQuantity <= (typedItem.minQuantity || 0);
          });
        }

        return {
          success: true,
          items: result,
        };
      } catch (error: any) {
        console.error('L·ªói l·∫•y b√°o c√°o t·ªìn kho:', error);
        throw new functions.https.HttpsError(
          'internal',
          `L·ªói l·∫•y b√°o c√°o t·ªìn kho: ${error.message}`
        );
      }
    }
  );

/**
 * Qu·∫£n l√Ω danh m·ª•c v·∫≠t t∆∞
 */
export const manageInventoryCategory = functions
  .region('asia-southeast1')
  .https.onCall(
    async (
      data: {
        action: 'add' | 'update' | 'delete';
        categoryData?: InventoryCategory;
        categoryId?: string;
      },
      context: CallableContext
    ) => {
      // Ki·ªÉm tra x√°c th·ª±c
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ th·ª±c hi·ªán ch·ª©c nƒÉng n√†y.'
        );
      }

      try {
        const { action, categoryData, categoryId } = data;
        const db = admin.firestore();

        if (action === 'add' && categoryData) {
          // Th√™m danh m·ª•c m·ªõi
          const docRef = await db
            .collection('inventory_categories')
            .add(categoryData);
          return {
            success: true,
            id: docRef.id,
            message: 'Th√™m danh m·ª•c th√†nh c√¥ng',
          };
        } else if (action === 'update' && categoryData && categoryId) {
          // C·∫≠p nh·∫≠t danh m·ª•c
          // Chuy·ªÉn ƒë·ªïi categoryData th√†nh object v·ªõi c√°c c·∫∑p key-value th√¥ng th∆∞·ªùng
          const updateData: { [key: string]: any } = {};

          if (categoryData.name !== undefined)
            updateData.name = categoryData.name;
          if (categoryData.description !== undefined)
            updateData.description = categoryData.description;
          if (categoryData.parentId !== undefined)
            updateData.parentId = categoryData.parentId;

          await db
            .collection('inventory_categories')
            .doc(categoryId)
            .update(updateData);
          return {
            success: true,
            message: 'C·∫≠p nh·∫≠t danh m·ª•c th√†nh c√¥ng',
          };
        } else if (action === 'delete' && categoryId) {
          // Ki·ªÉm tra xem danh m·ª•c c√≥ ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng kh√¥ng
          const itemsUsingCategory = await db
            .collection('inventory')
            .where('categoryId', '==', categoryId)
            .limit(1)
            .get();

          // Ki·ªÉm tra xem c√≥ danh m·ª•c con n√†o kh√¥ng
          const childCategories = await db
            .collection('inventory_categories')
            .where('parentId', '==', categoryId)
            .limit(1)
            .get();

          if (!itemsUsingCategory.empty) {
            throw new functions.https.HttpsError(
              'failed-precondition',
              'Kh√¥ng th·ªÉ x√≥a danh m·ª•c ƒëang c√≥ v·∫≠t t∆∞ s·ª≠ d·ª•ng.'
            );
          }

          if (!childCategories.empty) {
            throw new functions.https.HttpsError(
              'failed-precondition',
              'Kh√¥ng th·ªÉ x√≥a danh m·ª•c c√≥ ch·ª©a danh m·ª•c con.'
            );
          }

          // X√≥a danh m·ª•c
          await db.collection('inventory_categories').doc(categoryId).delete();
          return {
            success: true,
            message: 'X√≥a danh m·ª•c th√†nh c√¥ng',
          };
        } else {
          throw new functions.https.HttpsError(
            'invalid-argument',
            'D·ªØ li·ªáu ƒë·∫ßu v√†o kh√¥ng h·ª£p l·ªá.'
          );
        }
      } catch (error: any) {
        console.error('L·ªói qu·∫£n l√Ω danh m·ª•c:', error);
        throw new functions.https.HttpsError(
          'internal',
          `L·ªói qu·∫£n l√Ω danh m·ª•c: ${error.message}`
        );
      }
    }
  );

/**
 * Th·ªëng k√™ s·ª≠ d·ª•ng v·∫≠t t∆∞ theo d·ª± √°n
 */
export const getProjectMaterialUsage = functions
  .region('asia-southeast1')
  .https.onCall(
    async (
      data: {
        projectId: string;
        startDate?: string;
        endDate?: string;
      },
      context: CallableContext
    ) => {
      // Ki·ªÉm tra x√°c th·ª±c
      if (!context.auth) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ th·ª±c hi·ªán ch·ª©c nƒÉng n√†y.'
        );
      }

      try {
        const { projectId, startDate, endDate } = data;
        if (!projectId) {
          throw new functions.https.HttpsError(
            'invalid-argument',
            'Thi·∫øu ID d·ª± √°n.'
          );
        }

        // T·∫°o truy v·∫•n c∆° b·∫£n - ch·ªâ l·∫•y giao d·ªãch xu·∫•t kho cho d·ª± √°n
        let query = admin
          .firestore()
          .collection('inventory_transactions')
          .where('type', '==', 'OUT')
          .where('projectId', '==', projectId);

        // √Åp d·ª•ng l·ªçc ng√†y n·∫øu c√≥
        if (startDate) {
          const startTimestamp = admin.firestore.Timestamp.fromDate(
            new Date(startDate)
          );
          query = query.where('date', '>=', startTimestamp);
        }

        if (endDate) {
          const endTimestamp = admin.firestore.Timestamp.fromDate(
            new Date(endDate)
          );
          query = query.where('date', '<=', endTimestamp);
        }

        // Th·ª±c hi·ªán truy v·∫•n
        const snapshot = await query.get();
        const transactions = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        }));

        // Nh√≥m theo v·∫≠t t∆∞ v√† t√≠nh t·ªïng
        const materialUsage: Record<string, any> = {};
        for (const transaction of transactions) {
          const typedTrans = transaction as unknown as InventoryTransaction;
          if (!materialUsage[typedTrans.itemId]) {
            // L·∫•y th√¥ng tin chi ti·∫øt v·ªÅ v·∫≠t t∆∞
            const itemDoc = await admin
              .firestore()
              .collection('inventory')
              .doc(typedTrans.itemId)
              .get();

            if (!itemDoc.exists) continue;

            const itemData = itemDoc.data() as InventoryItem;
            materialUsage[typedTrans.itemId] = {
              itemId: typedTrans.itemId,
              name: itemData.name,
              code: itemData.code,
              unit: itemData.unit,
              material: itemData.material,
              totalQuantity: 0,
              totalCost: 0,
              transactions: [],
            };
          }

          // C·ªông s·ªë l∆∞·ª£ng v√† chi ph√≠
          materialUsage[typedTrans.itemId].totalQuantity +=
            typedTrans.quantity || 0;
          materialUsage[typedTrans.itemId].totalCost +=
            (typedTrans.price || 0) * (typedTrans.quantity || 0);

          // Th√™m giao d·ªãch v√†o danh s√°ch
          materialUsage[typedTrans.itemId].transactions.push({
            id: typedTrans.id,
            date: typedTrans.date,
            quantity: typedTrans.quantity,
            price: typedTrans.price,
            note: typedTrans.note,
          });
        }

        return {
          success: true,
          projectId,
          materials: Object.values(materialUsage),
        };
      } catch (error: any) {
        console.error('L·ªói th·ªëng k√™ s·ª≠ d·ª•ng v·∫≠t t∆∞:', error);
        throw new functions.https.HttpsError(
          'internal',
          `L·ªói th·ªëng k√™ s·ª≠ d·ª•ng v·∫≠t t∆∞: ${error.message}`
        );
      }
    }
  );


--- END: functions\src\inventoryManager.ts ---


--- START: functions\src\materialImporter.ts ---
import * as functions from 'firebase-functions/v1';
import { google } from 'googleapis';
import * as XLSX from 'xlsx';
import { CallableContext } from 'firebase-functions/v1/https';

// Ki·ªÉm tra xem m·ªôt chu·ªói c√≥ ph·∫£i l√† s·ªë La M√£ kh√¥ng
function isRomanNumeral(str: string): boolean {
  if (!str) return false;
  const romanPattern = /^[IVXLCDM]+$/i;
  return romanPattern.test(str.toString().trim());
}

// Chu·∫©n h√≥a chu·ªói ti·∫øng Vi·ªát ƒë·ªÉ so kh·ªõp kh√¥ng d·∫•u
function normalizeVi(str: string): string {
  return (str || '')
    .toString()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .toUpperCase()
    .trim();
}

// admin ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o ·ªü file index.ts ch√≠nh

export const importMaterialsFromDrive = functions
  .region('asia-southeast1')
  .https.onCall(async (data: any, context: CallableContext) => {
    // === QUAY L·∫†I C√ÅCH X√ÅC TH·ª∞C CHU·∫®N ===
    if (!context.auth) {
      // N·∫øu context.auth kh√¥ng t·ªìn t·∫°i, c√≥ nghƒ©a l√† Firebase kh√¥ng th·ªÉ x√°c th·ª±c ng∆∞·ªùi d√πng.
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Y√™u c·∫ßu ph·∫£i ƒë∆∞·ª£c th·ª±c hi·ªán khi ƒë√£ ƒëƒÉng nh·∫≠p.'
      );
    }
    // T·ª´ ƒë√¢y, b·∫°n c√≥ th·ªÉ tin t∆∞·ªüng context.auth.uid
    console.log(`Request from authenticated user: ${context.auth.uid}`);

    const { driveFileId, accessToken } = data;
    if (!driveFileId || !accessToken) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thi·∫øu file ID ho·∫∑c access token.'
      );
    }

    try {
      // 1. Setup Google API client
      const auth = new google.auth.OAuth2();
      auth.setCredentials({ access_token: accessToken });
      const drive = google.drive({ version: 'v3', auth });

      // 2. T·∫£i v√† parse file
      const response = await drive.files.get(
        { fileId: driveFileId, alt: 'media' },
        { responseType: 'arraybuffer' }
      );
      const workbook = XLSX.read(Buffer.from(response.data as any), {
        type: 'buffer',
      });
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      const rawData: any[][] = XLSX.utils.sheet_to_json(worksheet, {
        header: 1,
        defval: null,
      });

      const parsedMaterials: any[] = [];
      // B·∫Øt ƒë·∫ßu t·ª´ d√≤ng 3 (index 2) ƒë·ªÉ kh√¥ng b·ªè l·ª° d√≤ng t·ªïng h·ª£p ƒë·∫ßu b·∫£ng n·∫øu c√≥
      for (let i = 2; i < rawData.length; i++) {
        const row: any[] = rawData[i];

        // B·ªè qua h√†ng tr·ªëng ho√†n to√†n
        if (!row || row.length === 0) {
          continue;
        }

        // Ki·ªÉm tra STT (c·ªôt ƒë·∫ßu ti√™n) v√† t√™n v·∫≠t t∆∞ (c·ªôt th·ª© hai)
        const hasSTT = row[0] !== undefined && row[0] !== null && row[0] !== '';
        const hasName =
          row[1] !== undefined && row[1] !== null && row[1] !== '';
        const isRoman =
          hasSTT && typeof row[0] === 'string' && isRomanNumeral(row[0]);

        // ƒêi·ªÅu ki·ªán l·ªçc: c√≥ t√™n v·∫≠t t∆∞ HO·∫∂C l√† h√†ng c√≥ s·ªë La M√£
        if (!hasName && !isRoman) {
          console.log(
            `B·ªè qua h√†ng ${i}: Kh√¥ng c√≥ t√™n v·∫≠t t∆∞ ho·∫∑c kh√¥ng ph·∫£i s·ªë La M√£`
          );
          continue;
        }

        // Debug log ƒë·ªÉ ki·ªÉm tra
        console.log(
          `Row ${i}, STT value: ${
            row[0]
          }, Is Roman: ${isRoman}, Type: ${typeof row[0]}`
        );

        // N·∫øu l√† d√≤ng t·ªïng h·ª£p/t·ªïng c·ªông (STT La M√£ ho·∫∑c t√™n ch·ª©a t·ª´ kho√°), t·∫°o m·ªôt item ƒë·∫∑c bi·ªát
        const rawName = (row[1] || '').toString();
        const nameNormalized = normalizeVi(rawName);
        if (
          isRoman ||
          nameNormalized.includes('TONG CONG') ||
          nameNormalized.includes('TONG HOP') ||
          nameNormalized.includes('TONG KET')
        ) {
          const summaryItem = {
            stt: String(row[0] || '').trim(),
            name: rawName,
            material: '',
            quyCach: '',
            unit: String(row[6] || '').trim(),
            quantity: parseFloat(String(row[7] || '0')) || 0,
            weight: parseFloat(String(row[8] || '0')) || 0, // KL/c√°i
            totalWeight: parseFloat(String(row[9] || '0')) || 0, // KL t·ªïng
            unitPrice: 0,
            totalPrice: 0,
            isSummary: true,
          };
          parsedMaterials.push(summaryItem);
          continue; // kh√¥ng x·ª≠ l√Ω ti·∫øp nh∆∞ v·∫≠t t∆∞ th∆∞·ªùng
        }

        // ƒê·∫£m b·∫£o STT ƒë∆∞·ª£c l∆∞u d∆∞·ªõi d·∫°ng chu·ªói
        let sttValue = '';
        if (hasSTT) {
          sttValue = String(row[0]).trim();
        }

        // X·ª≠ l√Ω th√¥ng tin v·∫≠t t∆∞, m·∫∑c ƒë·ªãnh gi√° tr·ªã l√† 0 ho·∫∑c chu·ªói r·ªóng n·∫øu kh√¥ng c√≥ d·ªØ li·ªáu
        const materialItem = {
          stt: sttValue,
          name: rawName || '',
          material: row[2] || '',
          quyCach: row[3] && row[4] ? `${row[3]}x${row[4]}` : row[3] || '',
          unit: String(row[6] || '').trim(),
          quantity: parseFloat(String(row[7] || '0')) || 0,
          weight: parseFloat(String(row[8] || '0')) || 0, // KL/c√°i
          totalWeight: parseFloat(String(row[9] || '0')) || 0, // KL t·ªïng (c·ªôt J)
          unitPrice: 0,
          totalPrice: 0,
        };
        parsedMaterials.push(materialItem);
      }

      // Tr·∫£ v·ªÅ duy nh·∫•t m·∫£ng materials (ƒë√£ bao g·ªìm item isSummary n·∫øu c√≥)
      return { materials: parsedMaterials };
    } catch (error: any) {
      console.error('Error importing materials from Drive:', error);
      // L·ªói t·ª´ Google API, c√≥ th·ªÉ do accessToken h·∫øt h·∫°n
      if (error.code === 401 || error.code === 403) {
        throw new functions.https.HttpsError(
          'permission-denied',
          'Token truy c·∫≠p Google Drive kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n.'
        );
      }
      throw new functions.https.HttpsError(
        'internal',
        'L·ªói kh√¥ng x√°c ƒë·ªãnh khi x·ª≠ l√Ω file.',
        error.message
      );
    }
  });


--- END: functions\src\materialImporter.ts ---


--- START: functions\src\migration.ts ---
import * as admin from 'firebase-admin';

// Initialize Firebase Admin SDK
// Make sure to replace with your actual service account credentials
// const serviceAccount = require('../service-account-credentials.json');
// admin.initializeApp({
//   credential: admin.credential.cert(serviceAccount)
// });

const db = admin.firestore();

export async function updateUserSchema() {
  const usersSnapshot = await db.collection('users').get();
  const batch = db.batch();

  usersSnapshot.forEach((doc) => {
    const userRef = db.collection('users').doc(doc.id);
    batch.update(userRef, {
      annualLeaveBalance: 12, // Default value
      insuranceContributionBase: 5500000, // Default value, adjust as needed
    });
  });

  await batch.commit();
  console.log('Users schema updated successfully.');
}

                            export async function createGlobalSettings() {
  const settingsRef = db.collection('settings').doc('companyConfig');
  await settingsRef.set({
    standardWorkingDays: 26, // Example value, adjust as needed
    overtimeMultipliers: {
      normal: 1.5,
      sunday: 2.0,
      holiday: 3.0,
    },
  });
  console.log('Global settings created successfully.');
}

export async function runMigrations() {
  try {
    await updateUserSchema();
    await createGlobalSettings();
    console.log('All migrations completed successfully.');
  } catch (error) {
    console.error('Error running migrations:', error);
  }
}

// To run this script, you would typically call runMigrations()
// For example, from a CLI or another function.
// runMigrations();


--- END: functions\src\migration.ts ---


--- START: functions\src\notificationTriggers.ts ---
// Trong file functions/src/notificationTriggers.ts
import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';

// Gi·∫£ ƒë·ªãnh admin ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o ·ªü file index.ts ch√≠nh
const db = admin.firestore();

export const sendDiscussionNotification = functions
  .region('asia-southeast1')
  .firestore.document('projectDiscussions/{messageId}')
  .onCreate(async (snap, context) => {
    const messageData = snap.data();
    if (!messageData) {
      console.log('No data associated with the event');
      return null;
    }

    const {
      projectId,
      userId: senderId,
      userName: senderName,
      message,
      attachments,
    } = messageData;

    // 1. L·∫•y th√¥ng tin d·ª± √°n ƒë·ªÉ hi·ªÉn th·ªã t√™n d·ª± √°n
    const projectRef = db.collection('projects').doc(projectId);
    const projectDoc = await projectRef.get();
    if (!projectDoc.exists) {
      console.log(`Project ${projectId} not found.`);
      return null;
    }
    const projectData = projectDoc.data();
    if (!projectData) {
      console.log(`No data for project ${projectId}.`);
      return null;
    }

    const projectName = projectData.name || 'M·ªôt d·ª± √°n';

    // 2. L·∫•y user theo c√°c role c·ª• th·ªÉ thay v√¨ ch·ªâ workers trong d·ª± √°n
    const rolesToNotify = ['giam_doc', 'pho_giam_doc', 'ky_su', 'thuong_mai'];
    const usersSnapshot = await db
      .collection('users')
      .where('role', 'in', rolesToNotify)
      .get();
    const userIdsByRole = usersSnapshot.docs.map((doc) => doc.id);

    // 3. L·ªçc ra ng∆∞·ªùi g·ª≠i
    const recipientsIds = userIdsByRole.filter((id: string) => id !== senderId);
    if (recipientsIds.length === 0) {
      console.log('No recipients to notify.');
      return null;
    }

    // 4. L·∫•y FCM tokens c·ªßa nh·ªØng ng∆∞·ªùi nh·∫≠n
    const usersRef = db.collection('users');
    const tokensPromises = recipientsIds.map((id: string) =>
      usersRef.doc(id).get()
    );
    const usersDocs = await Promise.all(tokensPromises);

    const tokens = usersDocs
      .map((doc) => doc.data()?.fcmToken)
      .filter((token) => typeof token === 'string' && token.length > 0);

    if (tokens.length === 0) {
      console.log('No FCM tokens found for recipients.');
      return null;
    }

    // 5. T·∫°o payload cho notification
    let notificationBody = message || '';
    if (attachments && attachments.length > 0) {
      if (attachments[0].type?.startsWith('image/')) {
        notificationBody = 'ƒë√£ g·ª≠i m·ªôt ·∫£nh.';
      } else {
        notificationBody = 'ƒë√£ g·ª≠i m·ªôt t√†i li·ªáu.';
      }
    } else {
      // Gi·ªõi h·∫°n ƒë·ªô d√†i tin nh·∫Øn
      if (notificationBody.length > 100) {
        notificationBody = notificationBody.substring(0, 97) + '...';
      }
    }

    const payload = {
      notification: {
        title: `Tin nh·∫Øn m·ªõi: ${projectName}`,
        body: `${senderName}: ${notificationBody}`,
        sound: 'default',
      },
      data: {
        type: 'project_discussion',
        projectId: projectId,
        projectName: projectName,
      },
    };

    // 6. G·ª≠i notification
    console.log(
      `Sending notification to ${tokens.length} tokens for project ${projectName}.`
    );
    return admin.messaging().sendToDevice(tokens, payload);
  });


--- END: functions\src\notificationTriggers.ts ---


--- START: functions\src\pdfGenerator.ts ---
import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';
import * as path from 'path';

// Ch·ªâ import 'googleapis' b√™n trong h√†m khi c·∫ßn
// import { google } from 'googleapis';

// Firebase Storage bucket (not used after switching to Drive-only upload)
// const storage = admin.storage().bucket();

/**
 * Callable function that takes a Google Sheet ID and exports it as PDF using Google Drive API
 * then uploads the PDF to Firebase Storage and returns a public URL
 */
export const exportSheetToPdf = functions
  .region('us-central1') // Explicitly specify the region
  .runWith({
    timeoutSeconds: 300,
    memory: '1GB',
  })
  .https.onCall(async (data, context) => {
    // Lazy load the googleapis library
    const { google } = await import('googleapis');

    // Check authentication
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ s·ª≠ d·ª•ng t√≠nh nƒÉng n√†y.'
      );
    }

    // Validate input parameters
    const { spreadsheetId, fileName, projectId, accessToken } = data;
    if (!spreadsheetId) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thi·∫øu ID c·ªßa Google Sheet.'
      );
    }

    if (!fileName) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thi·∫øu t√™n file cho PDF.'
      );
    }

    if (!projectId) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thi·∫øu ID d·ª± √°n.'
      );
    }

    try {
      let auth: any;
      // Build auth/sheets depending on whether we have an end-user token
      if (accessToken) {
        const userAuth = new google.auth.OAuth2();
        userAuth.setCredentials({ access_token: accessToken });
        auth = userAuth;
      } else {
        auth = new google.auth.GoogleAuth({
          keyFile: path.join(__dirname, '../tanyb-fe4bf-4fbd5c01b6c7.json'),
          scopes: [
            'https://www.googleapis.com/auth/drive.readonly',
            'https://www.googleapis.com/auth/spreadsheets.readonly',
          ],
        });
      }

      const sheets = google.sheets({ version: 'v4', auth });

      // Step 1: Get the data from column A to determine the last row with content
      const sheetsResponse = await sheets.spreadsheets.values.get({
        spreadsheetId,
        range: 'A:A', // Only examine column A to determine the last row
      });

      // Calculate the last row with content
      const values = sheetsResponse.data.values || [];
      let lastRow = 0;

      // Find the last non-empty row
      for (let i = 0; i < values.length; i++) {
        if (values[i] && values[i][0]) {
          lastRow = i + 1; // Convert to 1-indexed
        }
      }

      // Add buffer rows to ensure we capture all content
      const bufferRows = 6;
      const dynamicRange = `A1:G${lastRow + bufferRows}`;

      functions.logger.info(
        `Calculated dynamic range: ${dynamicRange} (last row: ${lastRow})`
      );

      // Step 2: Build a custom export URL that limits the print area to columns A:G and rows 1 ‚Üí lastRow + buffer.
      // Google Sheets accepts the parameters r1, r2, c1, c2 (0-based, r2/c2 are exclusive) together with a gid that identifies the sheet.
      const sheetMeta = await sheets.spreadsheets.get({
        spreadsheetId,
        fields: 'sheets(properties(sheetId))',
      });

      const sheetId = sheetMeta.data.sheets?.[0]?.properties?.sheetId ?? 0;

      const r1 = 0; // start row (0-based)
      // Guarantee export always reaches at least the bottom of the template (row 36)
      const MIN_TEMPLATE_ROWS = 36;
      const r2 = Math.max(lastRow + bufferRows, MIN_TEMPLATE_ROWS); // end row (exclusive)
      const c1 = 0; // column A (0-based)
      // Include column H (index 7) so the right-hand border of the template is preserved
      const c2 = 8; // exclusive end index

      const exportUrl =
        `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export` +
        `?format=pdf` +
        `&gid=${sheetId}` +
        `&portrait=true` +
        `&size=a4` +
        `&scale=2` +
        `&gridlines=false` +
        `&sheetnames=false` +
        `&printtitle=true` +
        `&pagenum=UNDEFINED` +
        `&r1=${r1}&r2=${r2}&c1=${c1}&c2=${c2}`;

      functions.logger.info(`Export URL: ${exportUrl}`);

      // Use the authenticated HTTP client to download the PDF as a stream
      const authClient =
        typeof auth.getClient === 'function' ? await auth.getClient() : auth;
      const pdfResponse = await authClient.request({
        url: exportUrl,
        method: 'GET',
        responseType: 'stream',
      });

      const pdfStream = (pdfResponse as any).data as NodeJS.ReadableStream;

      if (!pdfStream) {
        throw new functions.https.HttpsError(
          'internal',
          'Kh√¥ng th·ªÉ xu·∫•t file PDF t·ª´ Google Sheet.'
        );
      }

      // Get project folder info from Firestore
      const projectDoc = await admin
        .firestore()
        .collection('projects')
        .doc(projectId)
        .get();
      const projectData = projectDoc.data();

      if (!projectData || !projectData.driveFolderId) {
        throw new functions.https.HttpsError(
          'failed-precondition',
          'Kh√¥ng t√¨m th·∫•y th√¥ng tin th∆∞ m·ª•c Drive c·ªßa d·ª± √°n.'
        );
      }

      // Find 'baogia' subfolder in project folder
      const baogiaFolderResponse = await authClient.request({
        url: 'https://www.googleapis.com/drive/v3/files',
        method: 'GET',
        params: {
          q: `name='baogia' and '${projectData.driveFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
          fields: 'files(id)',
        },
      });

      // Type casting for the response
      interface DriveFilesResponse {
        files?: { id: string }[];
      }

      const responseData = baogiaFolderResponse.data as DriveFilesResponse;

      let baogiaFolderId;
      if (responseData.files && responseData.files.length > 0) {
        baogiaFolderId = responseData.files[0].id;
      } else {
        // Create 'baogia' folder if it doesn't exist
        const driveClient = google.drive({
          version: 'v3',
          auth: authClient,
        });
        const folderResponse = await driveClient.files.create({
          requestBody: {
            name: 'baogia',
            mimeType: 'application/vnd.google-apps.folder',
            parents: [projectData.driveFolderId],
          },
          fields: 'id',
        });
        baogiaFolderId = folderResponse.data.id;
      }

      // Define sanitized filename first
      const sanitizedFileName = fileName.replace(/[^a-z0-9.]/gi, '_');

      // Upload PDF tr·ª±c ti·∫øp l√™n Google Drive v√† tr·∫£ v·ªÅ link, tr√°nh ph·ª• thu·ªôc Firebase Storage (tr√°nh l·ªói bucket 404)
      try {
        const driveClient = google.drive({ version: 'v3', auth: authClient });
        const uploadRes = await driveClient.files.create({
          requestBody: {
            name: `${sanitizedFileName}.pdf`,
            mimeType: 'application/pdf',
            parents: baogiaFolderId ? [baogiaFolderId] : undefined,
          },
          media: {
            mimeType: 'application/pdf',
            body: pdfStream,
          },
          fields: 'id, webViewLink, webContentLink',
        });

        const fileId = uploadRes.data.id as string;

        // M·ªü quy·ªÅn xem cho b·∫•t k·ª≥ ai c√≥ link
        try {
          await driveClient.permissions.create({
            fileId,
            requestBody: { role: 'reader', type: 'anyone' },
          });
        } catch (permErr) {
          functions.logger.warn(
            'Failed to set Drive file permission:',
            permErr
          );
        }

        const pdfUrl = (uploadRes.data.webContentLink ||
          uploadRes.data.webViewLink) as string;

        return {
          pdfUrl,
          lastRow,
          dynamicRange,
          usedUrl: exportUrl,
        };
      } catch (uploadErr: any) {
        functions.logger.error('Error uploading PDF to Drive:', uploadErr);
        throw new functions.https.HttpsError(
          'internal',
          `Kh√¥ng th·ªÉ upload PDF l√™n Google Drive: ${
            uploadErr?.message || 'Unknown error'
          }`
        );
      }
    } catch (error) {
      functions.logger.error('Error in exportSheetToPdf:', error);
      throw new functions.https.HttpsError(
        'internal',
        `L·ªói khi xu·∫•t file PDF: ${
          error instanceof Error ? error.message : 'Unknown error'
        }`
      );
    }
  });


--- END: functions\src\pdfGenerator.ts ---


--- START: functions\src\poExcelGenerator.ts ---
import * as functions from 'firebase-functions/v1';
import { google, sheets_v4 } from 'googleapis';
import { CallableContext } from 'firebase-functions/v1/https';
import * as admin from 'firebase-admin';

// Define PO data interface
interface ExcelPurchaseOrderData {
  metadata: {
    projectName?: string;
    supplierName?: string;
    supplierAddress?: string;
    supplierPhone?: string;
    supplierEmail?: string;
    supplierTaxCode?: string;
    supplierContactPerson?: string;
    poNumber?: string;
    proposalNumber?: string;
    poDate?: string;
    deliveryTime?: string;
    paymentTerms?: string;
  };
  materials: {
    no: number;
    name: string;
    unit: string;
    quantity: number;
    unitPrice: number;
    total: number;
    material?: string;
    specs?: string;
  }[];
  summary: {
    subTotal: number;
    vatPercentage: number;
    vatAmount: number;
    grandTotal: number;
  };
}

// ----- CONFIGURATION -----
const TEMPLATE_FILE_ID = '1z0MBboGASBZ8rE68x-_ykMVt4YjFcuTZG9RcVWBcZF0'; // Updated PO template ID
const START_ROW_MATERIALS = 18; // Data starts at row 18 in the new template

// ----- MAIN FUNCTION -----
export const generateExcelPurchaseOrder = functions
  .region('asia-southeast1')
  .runWith({ timeoutSeconds: 300, memory: '512MB' })
  .https.onCall(
    async (
      data: {
        formattedData: ExcelPurchaseOrderData;
        projectId: string;
        accessToken: string;
      },
      context: CallableContext
    ) => {
      // Add detailed logging for debugging
      console.log('PO Generator called with projectId:', data.projectId);
      console.log(
        'Auth context:',
        context.auth ? 'Authenticated' : 'Not authenticated'
      );
      console.log('Access token provided:', data.accessToken ? 'Yes' : 'No');

      // Check if we have the required data
      const { formattedData, projectId, accessToken } = data;

      // Validate required parameters
      if (!formattedData) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Invalid data.'
        );
      }
      if (!projectId) {
        throw new functions.https.HttpsError(
          'invalid-argument',
          'Project ID is required.'
        );
      }

      // Check for accessToken (required for Google API access)
      if (!accessToken) {
        throw new functions.https.HttpsError(
          'unauthenticated',
          'Google access token is required.'
        );
      }

      console.log(
        'PO Generator: Received valid request for project:',
        projectId
      );

      try {
        // Use the provided access token for Google API authentication
        const auth = new google.auth.OAuth2();
        auth.setCredentials({ access_token: accessToken });

        const drive = google.drive({ version: 'v3', auth });
        const sheets = google.sheets({ version: 'v4', auth });

        const db = admin.firestore();
        const projectDoc = await db.collection('projects').doc(projectId).get();
        const projectData = projectDoc.data();

        if (!projectData || !projectData.driveFolderId) {
          throw new functions.https.HttpsError(
            'failed-precondition',
            'Project Drive folder information not found.'
          );
        }

        // Find or create 'PO' subfolder in the project folder
        const poFolderResponse = await drive.files.list({
          q: `name='PO' and '${projectData.driveFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
          fields: 'files(id)',
        });

        let poFolderId;
        if (
          poFolderResponse.data.files &&
          poFolderResponse.data.files.length > 0
        ) {
          poFolderId = poFolderResponse.data.files[0].id;
        } else {
          const folderResponse = await drive.files.create({
            requestBody: {
              name: 'PO',
              mimeType: 'application/vnd.google-apps.folder',
              parents: [projectData.driveFolderId],
            },
            fields: 'id',
          });
          poFolderId = folderResponse.data.id;
        }

        const newFileName = `ƒê·∫∑t h√†ng - ${
          formattedData.metadata.supplierName || 'NCC'
        } - ${new Date().toLocaleDateString('vi-VN').replace(/\//g, '-')}`;

        const copiedFileResponse = await drive.files.copy({
          fileId: TEMPLATE_FILE_ID,
          requestBody: { name: newFileName, parents: [poFolderId] },
        });

        const newFileId = copiedFileResponse.data.id;
        if (!newFileId) throw new Error('Cannot copy template file.');

        const spreadsheet = await sheets.spreadsheets.get({
          spreadsheetId: newFileId,
          fields: 'sheets.properties',
        });
        const firstSheet = spreadsheet.data.sheets?.[0];
        const sheetId = firstSheet?.properties?.sheetId;
        if (sheetId === undefined || sheetId === null) {
          throw new Error('Cannot determine sheetId of the first sheet');
        }

        const requests: sheets_v4.Schema$Request[] = [];

        // ---- NEW METADATA MAPPING TO MATCH THE TEMPLATE ----
        const poDate = new Date();
        const dateString = `HCM, Ng√†y ${poDate.getDate()} th√°ng ${
          poDate.getMonth() + 1
        } nƒÉm ${poDate.getFullYear()}`;

        // Helper to create update requests
        const createCellUpdateRequest = (
          value: any,
          rowIndex: number,
          columnIndex: number
        ) => ({
          updateCells: {
            rows: [
              {
                values: [{ userEnteredValue: { stringValue: String(value) } }],
              },
            ],
            fields: 'userEnteredValue',
            start: { sheetId, rowIndex, columnIndex },
          },
        });

        // Project and Date
        requests.push(
          createCellUpdateRequest(
            formattedData.metadata.projectName || '',
            1,
            9 // Column J (index 9) for cell J2
          )
        );
        requests.push(createCellUpdateRequest(dateString, 5, 4)); // E6

        // Supplier Info - Updated to write to the correct cells
        requests.push(
          createCellUpdateRequest(
            formattedData.metadata.supplierName || '',
            8,
            3
          )
        ); // D9

        // Merge cells for supplier name D9:F10
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 8,
              endRowIndex: 10,
              startColumnIndex: 3,
              endColumnIndex: 6,
            },
            mergeType: 'MERGE_ALL',
          },
        });

        // Address in D11:F11
        requests.push(
          createCellUpdateRequest(
            formattedData.metadata.supplierAddress || '',
            10,
            3
          )
        ); // D11

        // Merge cells for address D11:F11
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 10,
              endRowIndex: 11,
              startColumnIndex: 3,
              endColumnIndex: 6,
            },
            mergeType: 'MERGE_ALL',
          },
        });

        // Tax code in D12:F12
        requests.push(
          createCellUpdateRequest(
            formattedData.metadata.supplierTaxCode || '',
            11,
            3
          )
        ); // D12

        // Merge cells for tax code D12:F12
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 11,
              endRowIndex: 12,
              startColumnIndex: 3,
              endColumnIndex: 6,
            },
            mergeType: 'MERGE_ALL',
          },
        });

        // Contact person in D13:F13
        requests.push(
          createCellUpdateRequest(
            formattedData.metadata.supplierContactPerson || '',
            12,
            3
          )
        ); // D13

        // Merge cells for contact person D13:F13
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 12,
              endRowIndex: 13,
              startColumnIndex: 3,
              endColumnIndex: 6,
            },
            mergeType: 'MERGE_ALL',
          },
        });

        // Email stays in original location
        requests.push(
          createCellUpdateRequest(
            formattedData.metadata.supplierEmail || '',
            13,
            2
          )
        ); // C14

        // Phone in D15:F15
        requests.push(
          createCellUpdateRequest(
            formattedData.metadata.supplierPhone || '',
            14,
            3
          )
        ); // D15

        // Merge cells for phone D15:F15
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 14,
              endRowIndex: 15,
              startColumnIndex: 3,
              endColumnIndex: 6,
            },
            mergeType: 'MERGE_ALL',
          },
        });

        // PO Info - I9
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: formattedData.metadata.poNumber || '',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue',
            start: { sheetId, rowIndex: 8, columnIndex: 8 }, // I9
          },
        });
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 8,
              endRowIndex: 9,
              startColumnIndex: 8, // I
              endColumnIndex: 10, // J
            }, // I9:J9
            mergeType: 'MERGE_ALL',
          },
        });

        // Proposal Number - I10
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: formattedData.metadata.proposalNumber || '',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue',
            start: { sheetId, rowIndex: 9, columnIndex: 8 }, // I10
          },
        });
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 9,
              endRowIndex: 10,
              startColumnIndex: 8, // I
              endColumnIndex: 10, // J
            }, // I10:J10
            mergeType: 'MERGE_ALL',
          },
        });

        // Delivery time moved to I12
        requests.push(
          createCellUpdateRequest(
            formattedData.metadata.deliveryTime || '',
            11,
            8
          )
        ); // I12
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: 11,
              endRowIndex: 12,
              startColumnIndex: 8,
              endColumnIndex: 10,
            }, // I12:J12
            mergeType: 'MERGE_ALL',
          },
        });

        requests.push(
          createCellUpdateRequest(
            formattedData.metadata.paymentTerms || '',
            12,
            9
          )
        ); // J13

        // ---- MATERIALS TABLE ----
        // Add table header for materials - starting from column C (index 2)
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: { stringValue: 'STT' },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      borders: {
                        top: { style: 'SOLID' },
                        bottom: { style: 'SOLID' },
                        left: { style: 'SOLID' },
                        right: { style: 'SOLID' },
                      },
                    },
                  },
                  {
                    userEnteredValue: { stringValue: 'M√¥ T·∫£ H√†ng H√≥a' },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      borders: {
                        top: { style: 'SOLID' },
                        bottom: { style: 'SOLID' },
                        left: { style: 'SOLID' },
                        right: { style: 'SOLID' },
                      },
                    },
                  },
                  {
                    userEnteredValue: { stringValue: 'Y√™u C·∫ßu K·ªπ Thu·∫≠t' },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      borders: {
                        top: { style: 'SOLID' },
                        bottom: { style: 'SOLID' },
                        left: { style: 'SOLID' },
                        right: { style: 'SOLID' },
                      },
                    },
                  },
                  {
                    userEnteredValue: { stringValue: 'ƒêVT' },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      borders: {
                        top: { style: 'SOLID' },
                        bottom: { style: 'SOLID' },
                        left: { style: 'SOLID' },
                        right: { style: 'SOLID' },
                      },
                    },
                  },
                  {
                    userEnteredValue: { stringValue: 'S·ªë L∆∞·ª£ng' },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      borders: {
                        top: { style: 'SOLID' },
                        bottom: { style: 'SOLID' },
                        left: { style: 'SOLID' },
                        right: { style: 'SOLID' },
                      },
                    },
                  },
                  {
                    userEnteredValue: { stringValue: 'ƒê∆°n gi√° (VND)' },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      borders: {
                        top: { style: 'SOLID' },
                        bottom: { style: 'SOLID' },
                        left: { style: 'SOLID' },
                        right: { style: 'SOLID' },
                      },
                    },
                  },
                  {
                    userEnteredValue: { stringValue: 'Th√†nh Ti·ªÅn (VND)' },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      borders: {
                        top: { style: 'SOLID' },
                        bottom: { style: 'SOLID' },
                        left: { style: 'SOLID' },
                        right: { style: 'SOLID' },
                      },
                    },
                  },
                  {
                    userEnteredValue: { stringValue: 'Ghi ch√∫' },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                      verticalAlignment: 'MIDDLE',
                      borders: {
                        top: { style: 'SOLID' },
                        bottom: { style: 'SOLID' },
                        left: { style: 'SOLID' },
                        right: { style: 'SOLID' },
                      },
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: {
              sheetId,
              rowIndex: START_ROW_MATERIALS - 2,
              columnIndex: 2,
            },
          },
        });

        const materialRows = formattedData.materials.map((material) => ({
          values: [
            {
              userEnteredValue: { numberValue: material.no },
              userEnteredFormat: {
                horizontalAlignment: 'CENTER',
                verticalAlignment: 'MIDDLE',
                borders: {
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                },
              },
            },
            {
              // Description
              userEnteredValue: { stringValue: material.name },
              userEnteredFormat: {
                horizontalAlignment: 'LEFT',
                verticalAlignment: 'MIDDLE',
                borders: {
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                },
              },
            },
            {
              // Technical spec
              userEnteredValue: { stringValue: material.specs || '' },
              userEnteredFormat: {
                horizontalAlignment: 'CENTER',
                verticalAlignment: 'MIDDLE',
                borders: {
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                },
              },
            },
            {
              // Unit
              userEnteredValue: { stringValue: material.unit },
              userEnteredFormat: {
                horizontalAlignment: 'CENTER',
                verticalAlignment: 'MIDDLE',
                borders: {
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                },
              },
            },
            {
              // Quantity
              userEnteredValue: { numberValue: material.quantity },
              userEnteredFormat: {
                horizontalAlignment: 'RIGHT',
                verticalAlignment: 'MIDDLE',
                borders: {
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                },
              },
            },
            {
              // Unit price
              userEnteredValue: { numberValue: material.unitPrice },
              userEnteredFormat: {
                numberFormat: { type: 'NUMBER', pattern: '#,##0' },
                horizontalAlignment: 'RIGHT',
                verticalAlignment: 'MIDDLE',
                borders: {
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                },
              },
            },
            {
              // Total
              userEnteredValue: { numberValue: material.total },
              userEnteredFormat: {
                numberFormat: { type: 'NUMBER', pattern: '#,##0' },
                horizontalAlignment: 'RIGHT',
                verticalAlignment: 'MIDDLE',
                borders: {
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                },
              },
            },
            {
              // Note column blank
              userEnteredValue: { stringValue: '' },
              userEnteredFormat: {
                borders: {
                  top: { style: 'SOLID' },
                  bottom: { style: 'SOLID' },
                  left: { style: 'SOLID' },
                  right: { style: 'SOLID' },
                },
              },
            },
          ],
        }));

        if (materialRows.length > 0) {
          requests.push({
            insertDimension: {
              range: {
                sheetId,
                dimension: 'ROWS',
                startIndex: START_ROW_MATERIALS - 1,
                endIndex: START_ROW_MATERIALS - 1 + materialRows.length,
              },
              inheritFromBefore: true,
            },
          });
          requests.push({
            updateCells: {
              rows: materialRows,
              fields: 'userEnteredValue,userEnteredFormat',
              start: {
                sheetId,
                rowIndex: START_ROW_MATERIALS - 1,
                columnIndex: 2,
              },
            },
          });
        }

        // ---- SUMMARY SECTION ----
        const summaryStartRow =
          START_ROW_MATERIALS + formattedData.materials.length + 3; // Add some spacing
        const createSummaryRow = (
          label: string,
          value: number | null,
          isBold: boolean,
          rowOffset: number
        ) => {
          // 1. Write Label to Column B
          requests.push({
            updateCells: {
              rows: [
                {
                  values: [
                    {
                      userEnteredValue: { stringValue: label },
                      userEnteredFormat: {
                        textFormat: { bold: isBold },
                        horizontalAlignment: 'RIGHT',
                        verticalAlignment: 'MIDDLE',
                      },
                    },
                  ],
                },
              ],
              fields: 'userEnteredValue,userEnteredFormat',
              start: {
                sheetId,
                rowIndex: summaryStartRow + rowOffset,
                columnIndex: 1, // Column B
              },
            },
          });

          // 2. Write Value to Column I
          if (value !== null) {
            requests.push({
              updateCells: {
                rows: [
                  {
                    values: [
                      {
                        userEnteredValue: { numberValue: value },
                        userEnteredFormat: {
                          numberFormat: { type: 'NUMBER', pattern: '#,##0' },
                          textFormat: { bold: isBold },
                          horizontalAlignment: 'RIGHT',
                          verticalAlignment: 'MIDDLE',
                        },
                      },
                    ],
                  },
                ],
                fields: 'userEnteredValue,userEnteredFormat',
                start: {
                  sheetId,
                  rowIndex: summaryStartRow + rowOffset,
                  columnIndex: 8, // Column I
                },
              },
            });
          }

          // 3. Merge label cells (B to H)
          requests.push({
            mergeCells: {
              range: {
                sheetId,
                startRowIndex: summaryStartRow + rowOffset,
                endRowIndex: summaryStartRow + rowOffset + 1,
                startColumnIndex: 1, // Column B
                endColumnIndex: 8, // Column H
              },
              mergeType: 'MERGE_ALL',
            },
          });

          // 4. Merge value cells (I to J)
          requests.push({
            mergeCells: {
              range: {
                sheetId,
                startRowIndex: summaryStartRow + rowOffset,
                endRowIndex: summaryStartRow + rowOffset + 1,
                startColumnIndex: 8, // Column I
                endColumnIndex: 10, // Column J
              },
              mergeType: 'MERGE_ALL',
            },
          });
        };

        createSummaryRow(
          'T·ªïng S·ªë Ti·ªÅn Ch∆∞a Bao G·ªìm thu·∫ø GTGT (VAT)',
          formattedData.summary.subTotal,
          false,
          0
        );
        createSummaryRow(
          `Thu·∫ø VAT ${formattedData.summary.vatPercentage}%`,
          formattedData.summary.vatAmount,
          false,
          1
        );
        createSummaryRow(
          'T·ªïng S·ªë Ti·ªÅn Bao G·ªìm thu·∫ø GTGT (VAT)',
          formattedData.summary.grandTotal,
          true,
          2
        );

        // Amount in words row (merge B:J)
        const amountInWordsRow = summaryStartRow + 3;
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: `(B·∫±ng ch·ªØ: ${convertNumberToVnWords(
                        formattedData.summary.grandTotal
                      )})`,
                    },
                    userEnteredFormat: {
                      textFormat: { bold: true, italic: true },
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: amountInWordsRow, columnIndex: 1 },
          },
        });
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: amountInWordsRow,
              endRowIndex: amountInWordsRow + 2, // Span 2 rows
              startColumnIndex: 1,
              endColumnIndex: 10,
            },
            mergeType: 'MERGE_ALL',
          },
        });

        // ---- TERMS AND CONDITIONS SECTION ----
        const termsStartRow = amountInWordsRow + 3;
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: '* ƒêI·ªÄU KHO·∫¢N V√Ä Y√äU C·∫¶U B·ªî SUNG:',
                    },
                    userEnteredFormat: { textFormat: { bold: true } },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: termsStartRow, columnIndex: 1 },
          },
        });
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: termsStartRow,
              endRowIndex: termsStartRow + 1,
              startColumnIndex: 1,
              endColumnIndex: 10,
            },
            mergeType: 'MERGE_ALL',
          },
        });

        const termsConditions = [
          {
            no: 1,
            text: 'ƒê∆°n gi√° kh√¥ng bao g·ªìm ph√≠ v·∫≠n chuy·ªÉn theo ƒë·ªãa ch·ªâ giao h√†ng ƒë·ªÅ c·∫≠p trong ƒê∆°n ƒê·∫∑t H√†ng n√†y.',
          },
          {
            no: 2,
            text: 'Nh√† cung c·∫•p chu·∫©n b·ªã v√† k√≠ bi√™n b·∫£n giao nh·∫≠n, c√πng v·ªõi ƒê∆°n ƒë·∫∑t h√†ng n√†y khi giao h√†ng.',
          },
          {
            no: 3,
            text: 'T·∫•t c·∫£ h√†ng h√≥a m·ªõi 100%. Nh√† cung c·∫•p ph·∫£i tr√¨nh ch·ª©ng ch·ªâ ch·∫•t l∆∞·ª£ng v√† xu·∫•t x·ª© (copy) khi ƒë∆∞·ª£c y√™u c·∫ßu',
          },
        ];

        termsConditions.forEach((term, idx) => {
          requests.push({
            updateCells: {
              rows: [
                {
                  values: [
                    {
                      userEnteredValue: { numberValue: term.no },
                      userEnteredFormat: {
                        textFormat: { bold: true },
                        horizontalAlignment: 'CENTER',
                      },
                    },
                    {
                      userEnteredValue: { stringValue: term.text },
                      userEnteredFormat: {
                        textFormat: {
                          foregroundColor: { red: 1, green: 0, blue: 0 },
                        },
                        horizontalAlignment: 'LEFT',
                      },
                    },
                  ],
                },
              ],
              fields: 'userEnteredValue,userEnteredFormat',
              start: {
                sheetId,
                rowIndex: termsStartRow + 1 + idx,
                columnIndex: 1,
              },
            },
          });
          requests.push({
            mergeCells: {
              range: {
                sheetId,
                startRowIndex: termsStartRow + 1 + idx,
                endRowIndex: termsStartRow + 2 + idx,
                startColumnIndex: 2,
                endColumnIndex: 10,
              },
              mergeType: 'MERGE_ALL',
            },
          });
        });

        // Add space between terms and signatures
        const signatureStartRow = termsStartRow + termsConditions.length + 3;

        // ---- SIGNATURES SECTION (CORRECT & ROBUST IMPLEMENTATION) ----

        // --- B√äN MUA H√ÄNG (B√äN A) ---
        // 1. Ghi ch·ªØ "ƒê·∫°i di·ªán b√™n Mua h√†ng (B√™n A)" v√†o c·ªôt B
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: 'ƒê·∫°i di·ªán b√™n Mua h√†ng (B√™n A)',
                    },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: signatureStartRow, columnIndex: 1 }, // C·ªôt B
          },
        });

        // 2. G·ªôp √¥ cho B√™n A (B ƒë·∫øn F)
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: signatureStartRow,
              endRowIndex: signatureStartRow + 1,
              startColumnIndex: 1, // T·ª´ C·ªôt B
              endColumnIndex: 6, // ƒê·∫øn C·ªôt F
            },
            mergeType: 'MERGE_ALL',
          },
        });

        // --- B√äN B√ÅN H√ÄNG (B√äN B) ---
        // 3. Ghi ch·ªØ "ƒê·∫°i di·ªán b√™n B√°n h√†ng (B√™n B)" v√†o c·ªôt G
        requests.push({
          updateCells: {
            rows: [
              {
                values: [
                  {
                    userEnteredValue: {
                      stringValue: 'ƒê·∫°i di·ªán b√™n B√°n h√†ng (B√™n B)',
                    },
                    userEnteredFormat: {
                      textFormat: { bold: true },
                      horizontalAlignment: 'CENTER',
                    },
                  },
                ],
              },
            ],
            fields: 'userEnteredValue,userEnteredFormat',
            start: { sheetId, rowIndex: signatureStartRow, columnIndex: 6 }, // C·ªôt G
          },
        });

        // 4. G·ªôp √¥ cho B√™n B (G ƒë·∫øn K)
        requests.push({
          mergeCells: {
            range: {
              sheetId,
              startRowIndex: signatureStartRow,
              endRowIndex: signatureStartRow + 1,
              startColumnIndex: 6, // T·ª´ C·ªôt G
              endColumnIndex: 11, // ƒê·∫øn C·ªôt K
            },
            mergeType: 'MERGE_ALL',
          },
        });

        // Add empty space for signatures (about 7 rows)
        for (let i = 0; i < 7; i++) {
          requests.push({
            updateCells: {
              rows: [{ values: [{ userEnteredValue: { stringValue: '' } }] }],
              fields: 'userEnteredValue',
              start: {
                sheetId,
                rowIndex: signatureStartRow + 1 + i,
                columnIndex: 0,
              },
            },
          });
        }

        // Apply all updates to the spreadsheet
        await sheets.spreadsheets.batchUpdate({
          spreadsheetId: newFileId,
          requestBody: { requests },
        });

        // Set permissions to make the file accessible
        await drive.permissions.create({
          fileId: newFileId,
          requestBody: { role: 'reader', type: 'anyone' },
        });

        // ----- SAVE PO METADATA TO FIRESTORE -----
        await admin
          .firestore()
          .collection('purchase_orders')
          .add({
            projectId,
            supplierName: formattedData.metadata.supplierName || '',
            poNumber: formattedData.metadata.poNumber || '',
            deliveryTime: formattedData.metadata.deliveryTime || '',
            fileId: newFileId,
            fileUrl: `https://docs.google.com/spreadsheets/d/${newFileId}/edit`,
            status: 'created',
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            formattedData,
          });

        return {
          success: true,
          fileId: newFileId,
          fileUrl: `https://docs.google.com/spreadsheets/d/${newFileId}/edit`,
          message: 'Purchase Order generated successfully',
        };
      } catch (error) {
        console.error('Error details in generateExcelPurchaseOrder:', error);
        throw new functions.https.HttpsError(
          'internal',
          'Error creating purchase order. Check logs for details.',
          error
        );
      }
    }
  );

// ----- HELPER FUNCTIONS -----
function convertNumberToVnWords(n: number): string {
  const t = [
    'kh√¥ng',
    'm·ªôt',
    'hai',
    'ba',
    'b·ªën',
    'nƒÉm',
    's√°u',
    'b·∫£y',
    't√°m',
    'ch√≠n',
  ];
  const r = (num: number): string => {
    if (num === 0) return '';
    if (num < 10) return t[num];
    if (num < 100) {
      return (
        t[Math.floor(num / 10)] +
        ' m∆∞∆°i ' +
        (num % 10 === 1
          ? 'm·ªët'
          : num % 10 === 5
          ? 'lƒÉm'
          : num % 10 !== 0
          ? t[num % 10]
          : '')
      );
    }
    if (num < 1000) {
      return (
        t[Math.floor(num / 100)] +
        ' trƒÉm ' +
        (num % 100 < 10 && num % 100 > 0 ? 'l·∫ª ' + t[num % 100] : r(num % 100))
      );
    }
    if (num < 1000000) {
      return (
        r(Math.floor(num / 1000)) +
        ' ngh√¨n ' +
        (num % 1000 < 100 && num % 1000 > 0
          ? 'kh√¥ng trƒÉm ' + r(num % 1000)
          : r(num % 1000))
      );
    }
    if (num < 1000000000) {
      return (
        r(Math.floor(num / 1000000)) +
        ' tri·ªáu ' +
        (num % 1000000 === 0 ? '' : r(num % 1000000))
      );
    }
    return (
      r(Math.floor(num / 1000000000)) +
      ' t·ª∑ ' +
      (num % 1000000000 === 0 ? '' : r(num % 1000000000))
    );
  };

  return r(Math.floor(n)) + ' ƒë·ªìng';
}


--- END: functions\src\poExcelGenerator.ts ---


--- START: functions\src\poReceiptConfirmation.ts ---
import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';
import { google } from 'googleapis';
import * as path from 'path';
import { Readable } from 'stream';

// Helper to detect quota/rate-limit errors
function isQuotaError(error: any): boolean {
  if (!error) return false;
  const status = error.code || error.status;
  const message = (error.message || '').toLowerCase();
  return (
    status === 403 ||
    status === 429 ||
    message.includes('quota') ||
    message.includes('rate limit') ||
    message.includes('user rate limit exceeded') ||
    message.includes('quota exceeded')
  );
}

// Exponential-backoff retry helper
async function withRetry<T>(
  fn: () => Promise<T>,
  retries = 5,
  delay = 1000
): Promise<T> {
  try {
    return await fn();
  } catch (err) {
    if (retries > 0 && isQuotaError(err)) {
      console.log(
        `Quota error ‚Äì retrying in ${delay} ms, attempts left ${retries}`
      );
      await new Promise((res) => setTimeout(res, delay));
      return withRetry(fn, retries - 1, delay * 2);
    }
    throw err;
  }
}

// Build Drive client either with service account or user OAuth token
const buildDriveClient = async (accessToken?: string) => {
  if (accessToken) {
    const auth = new google.auth.OAuth2();
    auth.setCredentials({ access_token: accessToken });
    return google.drive({ version: 'v3', auth });
  }
  const auth = new google.auth.GoogleAuth({
    keyFile: path.join(__dirname, '../tanyb-fe4bf-4fbd5c01b6c7.json'),
    scopes: ['https://www.googleapis.com/auth/drive'],
  });
  return google.drive({ version: 'v3', auth });
};

/**
 * confirmPOReceipt
 * Allows QA/QC to upload photos confirming that materials in a PO have been received.
 * - Uploads images to Drive under <Project>/PO_Receipts/<PO_ID>
 * - Updates purchase_orders doc: status -> "received", receivedAt, receiptPhotos[]
 */
export const confirmPOReceipt = functions
  .region('asia-southeast1')
  .runWith({ timeoutSeconds: 300, memory: '1GB' })
  .https.onCall(async (data, context) => {
    const {
      poId,
      projectId,
      files,
      remarks = '',
      accessToken,
    } = data as {
      poId?: string;
      projectId?: string;
      files?: Array<{ fileName: string; mimeType: string; base64Data: string }>;
      remarks?: string;
      accessToken?: string;
    };

    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p'
      );
    }

    if (!poId || !projectId || !files || files.length === 0) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thi·∫øu tham s·ªë b·∫Øt bu·ªôc'
      );
    }

    try {
      const db = admin.firestore();
      const poRef = db.collection('purchase_orders').doc(poId);
      const poSnap = await poRef.get();
      if (!poSnap.exists) {
        throw new functions.https.HttpsError('not-found', 'Kh√¥ng t√¨m th·∫•y PO');
      }

      const projectSnap = await db.collection('projects').doc(projectId).get();
      const projectData = projectSnap.data();
      if (!projectData || !projectData.driveFolderId) {
        throw new functions.https.HttpsError(
          'failed-precondition',
          'Kh√¥ng t√¨m th·∫•y folder Drive d·ª± √°n'
        );
      }

      const drive = await buildDriveClient(accessToken);

      // Find or create QC_Reports folder inside project folder
      const receiptFolderRes = await withRetry(() =>
        drive.files.list({
          q: `name='QC_Reports' and '${projectData.driveFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
          fields: 'files(id)',
          spaces: 'drive',
        })
      );

      let qcFolderId = receiptFolderRes.data.files?.[0]?.id;
      if (!qcFolderId) {
        const createFolder = await withRetry(() =>
          drive.files.create({
            requestBody: {
              name: 'QC_Reports',
              mimeType: 'application/vnd.google-apps.folder',
              parents: [projectData.driveFolderId],
            },
            fields: 'id',
          })
        );
        qcFolderId = createFolder.data.id!;
      }

      // Upload each file
      const uploaded: Array<{
        fileId: string;
        webViewLink: string;
        mimeType: string;
      }> = [];
      for (const f of files) {
        // Add PO ID prefix to filename for better identification
        const poFileName = `PO_${poId}_${f.fileName}`;
        const buffer = Buffer.from(f.base64Data, 'base64');
        const stream = Readable.from(buffer);
        const fileRes = await withRetry(() =>
          drive.files.create({
            requestBody: {
              name: poFileName,
              mimeType: f.mimeType,
              parents: [qcFolderId],
            },
            media: { mimeType: f.mimeType, body: stream },
            fields: 'id,webViewLink,mimeType,webContentLink',
          })
        );

        await withRetry(() =>
          drive.permissions.create({
            fileId: fileRes.data.id!,
            requestBody: { role: 'reader', type: 'anyone' },
          })
        );

        uploaded.push({
          fileId: fileRes.data.id!,
          webViewLink: fileRes.data.webViewLink!,
          mimeType: fileRes.data.mimeType!,
        });
      }

      // Update PO document
      await poRef.update({
        status: 'received',
        receivedAt: admin.firestore.FieldValue.serverTimestamp(),
        receiptPhotos: uploaded,
        receiptRemarks: remarks,
      });

      return { success: true, uploaded };
    } catch (err: any) {
      console.error('confirmPOReceipt error', err);
      throw new functions.https.HttpsError(
        'internal',
        err.message || 'L·ªói x·ª≠ l√Ω x√°c nh·∫≠n PO'
      );
    }
  });


--- END: functions\src\poReceiptConfirmation.ts ---


--- START: functions\src\processWorkAllocations.ts ---
import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';

/**
 * Scheduled Cloud Function that runs nightly to process
 * daily work allocations and convert them to labor expenses.
 *
 * This function:
 * 1. Retrieves all unprocessed daily work allocations
 * 2. For each allocation, creates expense records for all worker hours
 * 3. Marks allocations as processed once complete
 */
export const processWorkAllocations = functions
  .region('asia-southeast1')
  .runWith({
    timeoutSeconds: 540, // 9 minutes
    memory: '1GB',
  })
  .pubsub.schedule('0 2 * * *') // Run at 2:00 AM daily
  .timeZone('Asia/Ho_Chi_Minh')
  .onRun(async (context) => {
    const db = admin.firestore();
    console.log('Starting processWorkAllocations scheduled function');

    try {
      // Get all unprocessed work allocations
      const unprocessedAllocationsSnapshot = await db
        .collection('daily_work_allocations')
        .where('isProcessed', '==', false)
        .get();

      console.log(
        `Found ${unprocessedAllocationsSnapshot.size} unprocessed allocations`
      );

      if (unprocessedAllocationsSnapshot.empty) {
        console.log('No unprocessed allocations found. Exiting.');
        return null;
      }

      // Process each allocation
      for (const allocDoc of unprocessedAllocationsSnapshot.docs) {
        const allocation = allocDoc.data();
        const allocId = allocDoc.id;
        const allocDate = allocation.date;

        console.log(`Processing allocation ${allocId} for date ${allocDate}`);

        // Skip if there are no allocations data
        if (
          !allocation.allocations ||
          Object.keys(allocation.allocations).length === 0
        ) {
          console.log(
            `No worker allocations found in document ${allocId}. Marking as processed.`
          );
          await allocDoc.ref.update({ isProcessed: true });
          continue;
        }

        // Create a set to track all projects involved
        const projectIds = new Set<string>();

        // Create a map to store project names for lookup
        const projectNames: Record<string, string> = {};

        // First pass - collect all project IDs
        for (const [, workerAllocations] of Object.entries(
          allocation.allocations
        )) {
          if (Array.isArray(workerAllocations)) {
            for (const projectAllocation of workerAllocations) {
              if (projectAllocation.projectId) {
                projectIds.add(projectAllocation.projectId);
              }
            }
          }
        }

        // Batch fetch project data
        if (projectIds.size > 0) {
          const projectPromises = Array.from(projectIds).map(async (pid) => {
            const projectDoc = await db.collection('projects').doc(pid).get();
            if (projectDoc.exists) {
              const projectData = projectDoc.data();
              projectNames[pid] = projectData?.name || 'D·ª± √°n kh√¥ng t√™n';
            }
            return pid;
          });

          await Promise.all(projectPromises);
          console.log(
            `Fetched names for ${Object.keys(projectNames).length} projects`
          );
        }

        // Fetch worker data in batch
        const workerIds = Object.keys(allocation.allocations);
        const workerData: Record<
          string,
          { name: string; dailySalary: number }
        > = {};

        const workerBatchPromises = workerIds.map(async (wid) => {
          const userDoc = await db.collection('users').doc(wid).get();
          if (userDoc.exists) {
            const userData = userDoc.data();
            workerData[wid] = {
              name:
                userData?.displayName ||
                userData?.email ||
                'C√¥ng nh√¢n kh√¥ng t√™n',
              dailySalary: userData?.dailySalary || 0,
            };
          }
          return wid;
        });

        await Promise.all(workerBatchPromises);
        console.log(
          `Fetched data for ${Object.keys(workerData).length} workers`
        );

        // Process each worker allocation
        const expensePromises = [];

        for (const [workerId, workerAllocations] of Object.entries(
          allocation.allocations
        )) {
          const worker = workerData[workerId];

          // Skip if worker not found or has no daily salary
          if (!worker || worker.dailySalary <= 0) {
            console.log(
              `Skipping worker ${workerId}: no data or no daily salary.`
            );
            continue;
          }

          if (!Array.isArray(workerAllocations)) {
            console.log(
              `Skipping worker ${workerId}: invalid allocations format.`
            );
            continue;
          }

          console.log(
            `Processing worker ${worker.name} (${workerId}) with daily salary: ${worker.dailySalary}`
          );

          // Process each project allocation
          for (const projectAllocation of workerAllocations) {
            const { projectId, hours } = projectAllocation;

            // Skip if no projectId or hours
            if (!projectId || typeof hours !== 'number' || hours <= 0) {
              console.log(
                `Skipping invalid project allocation for worker ${workerId}`
              );
              continue;
            }

            // Calculate cost based on 8-hour workday
            const dailySalary = worker.dailySalary;
            const hourlyRate = dailySalary / 8;
            const cost = hours * hourlyRate;

            // Skip if cost is zero
            if (cost <= 0) {
              console.log(
                `Skipping zero-cost allocation for worker ${workerId} on project ${projectId}`
              );
              continue;
            }

            // Create expense record
            const expenseData = {
              projectId: projectId,
              projectName: projectNames[projectId] || 'D·ª± √°n kh√¥ng t√™n',
              type: 'labor',
              amount: cost,
              description: `Chi ph√≠ nh√¢n c√¥ng cho ${worker.name} (${hours} gi·ªù)`,
              date: admin.firestore.Timestamp.fromDate(
                typeof allocDate === 'string'
                  ? new Date(allocDate)
                  : allocDate instanceof admin.firestore.Timestamp
                  ? allocDate.toDate()
                  : new Date()
              ),
              relatedDocId: allocId,
              createdBy: allocation.allocatedBy_userId || 'system',
              createdAt: admin.firestore.FieldValue.serverTimestamp(),
            };

            // Add to batch of promises
            const promise = db
              .collection('expenses')
              .add(expenseData)
              .then((ref) => {
                console.log(
                  `Created expense record ${ref.id} for worker ${
                    worker.name
                  } on project ${projectId}: ${cost.toLocaleString('vi')} ƒë`
                );
                return {
                  id: ref.id,
                  workerId,
                  projectId,
                  amount: cost,
                  hours,
                };
              });

            expensePromises.push(promise);
          }
        }

        // Wait for all expense creations to complete
        const expenseResults = await Promise.all(expensePromises);
        console.log(
          `Created ${expenseResults.length} expense records for allocation ${allocId}`
        );

        // Mark allocation as processed
        await allocDoc.ref.update({
          isProcessed: true,
          processedAt: admin.firestore.FieldValue.serverTimestamp(),
          expensesCreated: expenseResults,
        });

        console.log(`Marked allocation ${allocId} as processed`);
      }

      console.log('Finished processing all work allocations');
      return null;
    } catch (error) {
      console.error('Error in processWorkAllocations:', error);
      return null;
    }
  });


--- END: functions\src\processWorkAllocations.ts ---


--- START: functions\src\projectTriggers.ts ---
import {
  onDocumentDeleted,
  onDocumentCreated,
  onDocumentUpdated,
} from 'firebase-functions/v2/firestore';
import * as admin from 'firebase-admin';
import { google } from 'googleapis';
import * as path from 'path';
import { v4 as uuidv4 } from 'uuid';

const db = admin.firestore();
const ROOT_FOLDER_ID = '18OrAEBSuZzz-AFbqlitz5gUxpsdunXjX'; // Baogia root folder ID

/**
 * Creates a Google Drive folder structure for a new project
 */
export const onProjectCreate = onDocumentCreated(
  {
    document: 'projects/{projectId}',
    region: 'asia-southeast1',
  },
  async (event) => {
    const { projectId } = event.params;
    const projectData = event.data?.data();
    if (!projectData) {
      console.log(`No data found for project ${projectId}.`);
      return;
    }

    console.log(`Processing new project: ${projectData.name}`);

    try {
      // Step 1: Create public tracking token IMMEDIATELY (kh√¥ng ph·ª• thu·ªôc Google Drive)
      const publicTrackingToken = uuidv4().replace(/-/g, '');

      // Step 2: Update project with token first
      await db.collection('projects').doc(projectId).update({
        publicTrackingToken: publicTrackingToken,
      });

      console.log(
        `Created tracking token for project ${projectId}: ${publicTrackingToken}`
      );

      // Step 3: Try to create Google Drive folders (optional, kh√¥ng block token creation)
      try {
        await createGoogleDriveFolders(projectId, projectData);
      } catch (driveError) {
        console.error(
          `Google Drive folder creation failed for project ${projectId}:`,
          driveError
        );
        // Continue execution even if Drive fails
      }

      console.log(`Successfully processed project ${projectId}.`);
    } catch (error) {
      console.error(`Error processing project ${projectId}:`, error);
    }
  }
);

// T√°ch ri√™ng function t·∫°o Google Drive folders
async function createGoogleDriveFolders(projectId: string, projectData: any) {
  console.log(`Creating Drive folders for project: ${projectData.name}`);

  // Initialize Google Drive API
  const auth = new google.auth.GoogleAuth({
    keyFile: path.join(__dirname, '../tanyb-fe4bf-4fbd5c01b6c7.json'),
    scopes: ['https://www.googleapis.com/auth/drive'],
  });
  const drive = google.drive({ version: 'v3', auth });

  // Get current date for folder structure (YYYY/MM/DD)
  const createdDate = projectData.createdAt?.toDate() || new Date();
  const year = createdDate.getFullYear().toString();
  const month = (createdDate.getMonth() + 1).toString().padStart(2, '0');
  const day = createdDate.getDate().toString().padStart(2, '0');

  // Clean project name for use in folder name (remove invalid chars)
  const cleanProjectName = projectData.name.replace(/[\/\\:*?"<>|]/g, '_');

  // Step 1: Find or create year folder
  const yearFolder = await findOrCreateFolder(drive, year, ROOT_FOLDER_ID);
  if (!yearFolder) {
    throw new Error(`Failed to create year folder ${year}`);
  }

  // Step 2: Find or create month folder
  const monthFolder = await findOrCreateFolder(drive, month, yearFolder.id);
  if (!monthFolder) {
    throw new Error(`Failed to create month folder ${month}`);
  }

  // Step 3: Find or create day folder
  const dayFolder = await findOrCreateFolder(drive, day, monthFolder.id);
  if (!dayFolder) {
    throw new Error(`Failed to create day folder ${day}`);
  }

  // Step 4: Create project folder
  const projectFolder = await createFolder(
    drive,
    cleanProjectName,
    dayFolder.id
  );
  if (!projectFolder) {
    throw new Error(`Failed to create project folder ${cleanProjectName}`);
  }

  // Step 5: Create subfolders (baogia, hopdong)
  const baogiaFolder = await createFolder(drive, 'baogia', projectFolder.id);
  const hopdongFolder = await createFolder(drive, 'hopdong', projectFolder.id);

  console.log(
    `Created subfolders: baogia (${baogiaFolder.id}) and hopdong (${hopdongFolder.id})`
  );

  // Step 6: Update project document with Drive folder info
  await db.collection('projects').doc(projectId).update({
    driveFolderId: projectFolder.id,
    driveFolderUrl: projectFolder.webViewLink,
    driveCreatedAt: admin.firestore.FieldValue.serverTimestamp(),
  });

  console.log(`Successfully created Drive folders for project ${projectId}.`);
}

/**
 * Automatically deducts materials from inventory when a project is marked as "completed".
 */
export const onProjectComplete = onDocumentUpdated(
  {
    document: 'projects/{projectId}',
    region: 'asia-southeast1',
  },
  async (event) => {
    const beforeData = event.data?.before.data();
    const afterData = event.data?.after.data();

    // Proceed only if the status changes TO "completed"
    if (
      !beforeData ||
      !afterData ||
      beforeData.status === 'completed' ||
      afterData.status !== 'completed'
    ) {
      return null;
    }

    const { projectId } = event.params;
    const projectName = afterData.name || 'D·ª± √°n kh√¥ng t√™n';
    console.log(
      `Project "${projectName}" (${projectId}) completed. Starting inventory deduction.`
    );

    // 1. Find the approved quotation for this project to get the material list
    const quotationsRef = db.collection('quotations');
    const q = quotationsRef
      .where('projectId', '==', projectId)
      .orderBy('createdAt', 'desc')
      .limit(1);

    const quotationSnapshot = await q.get();

    if (quotationSnapshot.empty) {
      console.log(
        `No quotation found for project ${projectId}. No materials to deduct.`
      );
      return null;
    }

    const quotationData = quotationSnapshot.docs[0].data();
    const materialsToDeduct = quotationData.materials;

    if (!materialsToDeduct || materialsToDeduct.length === 0) {
      console.log(
        `Quotation for project ${projectId} has no materials listed.`
      );
      return null;
    }

    // 2. Process each material
    const promises = materialsToDeduct.map(async (material) => {
      const neededQty = Number(material.quantity) || 0;
      if (neededQty <= 0) {
        return; // Skip if quantity is zero or invalid
      }

      const name = String(material.name || '').trim();
      const code = String(material.code || '').trim();

      if (!name && !code) {
        return; // Skip if no identifier
      }

      // Find the item in inventory
      let itemQuery: admin.firestore.Query = db.collection('inventory');
      if (code) {
        itemQuery = itemQuery.where('code', '==', code);
      } else {
        itemQuery = itemQuery.where('name', '==', name);
      }

      const inventorySnapshot = await itemQuery.limit(1).get();

      if (inventorySnapshot.empty) {
        console.log(
          `Material "${name}" (Code: ${code}) not found in inventory. Skipping deduction.`
        );
        return;
      }

      // Item found, proceed with deduction
      const itemDoc = inventorySnapshot.docs[0];
      const itemData = itemDoc.data();
      const currentQty = Number(itemData.stockQuantity) || 0;
      const newQty = currentQty - neededQty;

      console.log(
        `Deducting ${neededQty} of "${name}" from inventory. Current: ${currentQty}, New: ${newQty}`
      );

      // Use a transaction to ensure atomicity
      await db.runTransaction(async (transaction) => {
        // Update inventory stock
        transaction.update(itemDoc.ref, {
          stockQuantity: newQty,
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        });

        // Create a transaction log
        const transactionRef = db.collection('inventory_transactions').doc();
        transaction.set(transactionRef, {
          itemId: itemDoc.id,
          type: 'out',
          quantity: neededQty,
          reason: `S·ª≠ d·ª•ng cho d·ª± √°n: ${projectName}`,
          date: admin.firestore.FieldValue.serverTimestamp(),
          projectId: projectId,
          // Assuming there's a system or admin user for this action.
          // In a real app, you might want to attribute this to a specific user.
          createdBy: 'SYSTEM_AUTO_DEDUCT',
          createdByName: 'H·ªá th·ªëng',
        });
      });
    });

    await Promise.all(promises);
    console.log(
      `Finished inventory deduction process for project ${projectId}.`
    );

    return null;
  }
);

/**
 * Deletes all tasks associated with a project when the project is deleted.
 */
export const onProjectDeleted = onDocumentDeleted(
  {
    document: 'projects/{projectId}',
    region: 'asia-southeast1',
  },
  async (event) => {
    const { projectId } = event.params;
    console.log(`Project ${projectId} deleted. Deleting associated tasks...`);

    const tasksRef = db.collection('tasks');
    const query = tasksRef.where('projectId', '==', projectId);

    try {
      const snapshot = await query.get();
      if (snapshot.empty) {
        console.log(`No tasks found for project ${projectId}.`);
        return;
      }

      const batch = db.batch();
      snapshot.docs.forEach((doc) => {
        batch.delete(doc.ref);
      });

      await batch.commit();
      console.log(
        `Successfully deleted ${snapshot.size} tasks for project ${projectId}.`
      );
    } catch (error) {
      console.error(`Error deleting tasks for project ${projectId}:`, error);
    }
  }
);

/**
 * Helper function to find a folder by name in a parent folder or create it if it doesn't exist
 */
async function findOrCreateFolder(drive, folderName, parentFolderId) {
  // Search for folder
  const response = await drive.files.list({
    q: `name='${folderName}' and '${parentFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
    fields: 'files(id, name, webViewLink)',
  });

  // If folder exists, return it
  if (response.data.files && response.data.files.length > 0) {
    return response.data.files[0];
  }

  // Otherwise create new folder
  return createFolder(drive, folderName, parentFolderId);
}

/**
 * Helper function to create a new folder
 */
async function createFolder(drive, folderName, parentFolderId) {
  const folderMetadata = {
    name: folderName,
    mimeType: 'application/vnd.google-apps.folder',
    parents: [parentFolderId],
  };

  const folder = await drive.files.create({
    requestBody: folderMetadata,
    fields: 'id, name, webViewLink',
  });

  return folder.data;
}


--- END: functions\src\projectTriggers.ts ---


--- START: functions\src\publicApi.ts ---
import { onRequest } from 'firebase-functions/v2/https';
import * as admin from 'firebase-admin';
import cors from 'cors';

const db = admin.firestore();
const corsHandler = cors({ origin: true });

/**
 * Public API endpoint for project status tracking
 * Allows customers to view project progress using a tracking token
 */
export const getProjectStatusByToken = onRequest(
  {
    region: 'asia-southeast1',
    cors: true,
  },
  async (request, response) => {
    // Handle CORS preflight requests
    return corsHandler(request, response, async () => {
      try {
        // Only allow GET requests
        if (request.method !== 'GET') {
          response.status(405).json({
            error: 'Method not allowed',
            message: 'Only GET requests are supported',
          });
          return;
        }

        // Get token from query parameters
        const { token } = request.query;

        if (!token || typeof token !== 'string') {
          response.status(400).json({
            error: 'Bad Request',
            message: 'Token parameter is required',
          });
          return;
        }

        // Query project by public tracking token
        const projectsRef = db.collection('projects');
        const query = projectsRef.where('publicTrackingToken', '==', token);
        const snapshot = await query.limit(1).get();

        if (snapshot.empty) {
          response.status(404).json({
            error: 'Not Found',
            message: 'Project not found with the provided token',
          });
          return;
        }

        const projectDoc = snapshot.docs[0];
        const projectData = projectDoc.data();

        // Extract only safe data for public viewing
        const safeProjectData = {
          projectName: projectData.name || 'D·ª± √°n kh√¥ng t√™n',
          customerName: projectData.customerName || 'Kh√°ch h√†ng kh√¥ng x√°c ƒë·ªãnh',
          status: projectData.status || 'pending',
          startDate: projectData.startDate,
          endDate: projectData.endDate,
          workflowStages: [],
        };

        // Process workflow stages if they exist
        if (
          projectData.workflowStages &&
          Array.isArray(projectData.workflowStages)
        ) {
          // Sort by order field and extract only safe fields
          safeProjectData.workflowStages = projectData.workflowStages
            .sort((a, b) => (a.order || 0) - (b.order || 0))
            .map((stage) => ({
              processName: stage.processName || 'C√¥ng ƒëo·∫°n kh√¥ng x√°c ƒë·ªãnh',
              status: stage.status || 'pending',
              order: stage.order || 0,
              completionTime: stage.completionTime || null,
              requirement: stage.requirement || null,
              qcImages: stage.qcImages || [],
            }));
        }

        // Return safe project data
        response.status(200).json({
          success: true,
          data: safeProjectData,
        });
      } catch (error) {
        console.error('Error in getProjectStatusByToken:', error);
        response.status(500).json({
          error: 'Internal Server Error',
          message: 'An unexpected error occurred',
        });
      }
    });
  }
);


--- END: functions\src\publicApi.ts ---


--- START: functions\src\quotationExcelGenerator.ts ---
import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';
import * as XLSX from 'xlsx';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { CallableContext } from 'firebase-functions/v1/https';

// Get references to services (but don't reinitialize admin)
const storage = admin.storage();
const bucket = storage.bucket();

// Interface for the Excel formatted data
interface ExcelQuotationData {
  metadata: {
    companyName: string;
    companyAddress: string;
    companyPhone: string;
    companyEmail: string;
    taxCode: string;
    customerName: string;
    customerAddress: string;
    quotationNumber: string;
    quotationDate: string;
    projectName: string;
    quoteValidity: string;
  };
  materials: Array<{
    no: string | any; // Changed from number to string or any to support Roman numerals
    name: string;
    unit: string;
    quantity: number;
    unitPrice: number;
    total: number;
  }>;
  summary: {
    subTotal: number;
    discountPercentage: number;
    discountAmount: number;
    vatPercentage: number;
    vatAmount: number;
    grandTotal: number;
    amountInWords: string;
  };
}

/**
 * Generates an Excel file based on the quotation data and template
 * @param {ExcelQuotationData} formattedData The formatted data for Excel
 * @returns {Buffer} The Excel file as a buffer
 */
function generateExcelFile(formattedData: ExcelQuotationData): Buffer {
  // Create a new workbook and worksheet
  const workbook = XLSX.utils.book_new();
  const worksheet = XLSX.utils.aoa_to_sheet([]);

  // Set column widths
  const colWidths = [
    { wch: 5 }, // A - STT
    { wch: 40 }, // B - T√™n g·ªçi
    { wch: 15 }, // C - V·∫≠t li·ªáu
    { wch: 10 }, // D - ƒêVT
    { wch: 10 }, // E - SL
    { wch: 15 }, // F - ƒê∆°n gi√°
    { wch: 20 }, // G - Th√†nh Ti·ªÅn
    { wch: 15 }, // H
  ];
  worksheet['!cols'] = colWidths;

  // Add company logo placeholder in cell A1-B8
  // Logo would be added manually or could be implemented with additional code

  // Populate header section based on the template screenshot - Right side header (Company info)
  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['C√îNG TY TNHH S·∫¢N XU·∫§T C∆† KH√ç TH∆Ø∆†NG M·∫†I']],
    { origin: 'D1' }
  );

  XLSX.utils.sheet_add_aoa(worksheet, [['D·ªäCH V·ª§ T√ÇN H√íA PH√ÅT']], {
    origin: 'D2',
  });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['ƒêC: S·ªë 7 Qu·ªëc l·ªô 1A ,KP3B,Ph∆∞·ªùng Thanh L·ªôc,Qu·∫≠n']],
    { origin: 'D3' }
  );

  XLSX.utils.sheet_add_aoa(worksheet, [['12,TP.HCM']], { origin: 'D4' });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['MST: 0315155409', 'Web:cokhitanhoaphat.com.vn']],
    { origin: 'D5' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Email :chomcauinoxtanhoaphat.com.vn']],
    { origin: 'D6' }
  );

  XLSX.utils.sheet_add_aoa(worksheet, [['Hotline 24/7: 0978.268.559']], {
    origin: 'D7',
  });

  // Add quotation title
  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['B·∫¢NG B√ÅO GI√Å KI·ªÇM X√ÅC NH·∫¨N ƒê·∫∂T H√ÄNG']],
    { origin: 'B3' }
  );

  // Add quotation info - Date and number
  XLSX.utils.sheet_add_aoa(worksheet, [['Ng√†y']], { origin: 'F4' });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [[formattedData.metadata.quotationDate]],
    { origin: 'G4' }
  );

  XLSX.utils.sheet_add_aoa(worksheet, [['S·ªê']], { origin: 'F5' });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [[formattedData.metadata.quotationNumber]],
    { origin: 'G5' }
  );

  // Add customer info section starting at B10
  XLSX.utils.sheet_add_aoa(worksheet, [['K√çNH G·ª¨I:']], { origin: 'B9' });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['ƒê·ªãa ch·ªâ:', formattedData.metadata.customerAddress]],
    { origin: 'B10' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Tel', ':', '', '', 'MST', ':', '', 'FAX']],
    { origin: 'B11' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Email', ':', '', '', 'Attn', ':', '', 'Mobile:']],
    { origin: 'B12' }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [
      [
        'Tr∆∞·ªõc h·∫øt C√¥ng Ty T√¢n H√≤a Ph√°t xin ch√¢n th√†nh c·∫£m ∆°n s·ª± quan t√¢m & h·ª£p t√°c c·ªßa Qu√Ω Kh√°ch. Ch√∫ng t√¥i xin g·ª≠i t·ªõi Qu√Ω kh√°ch b√°o gi√° c√°c ch·ªßng lo·∫°i sau:',
      ],
    ],
    { origin: 'B14' }
  );

  // Add table header for materials
  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['STT', 'T√™n g·ªçi', 'V·∫≠t li·ªáu', 'ƒêVT', 'SL', 'ƒê∆°n gi√°', 'Th√†nh Ti·ªÅn']],
    { origin: 'B16' }
  );

  // Log m·ªôt v√†i item ƒë·∫ßu ti√™n ƒë·ªÉ ki·ªÉm tra
  functions.logger.info('Generating Excel with materials (first 5):', {
    materials: (formattedData.materials || [])
      .slice(0, 5)
      .map((item) => ({ no: item.no, name: item.name })),
  });

  // Add material rows
  let currentRow = 17;
  formattedData.materials.forEach((item) => {
    const cellData = [
      { v: item.no, t: 's' }, // √âp ki·ªÉu th√†nh Text (s)
      item.name,
      '', // V·∫≠t li·ªáu
      item.unit,
      item.quantity,
      item.unitPrice,
      item.total,
    ];
    XLSX.utils.sheet_add_aoa(worksheet, [cellData], {
      origin: `B${currentRow}`,
    });

    currentRow++;
  });

  // Add summary section after materials
  // Calculate appropriate summary row position based on materials
  const summaryStartRow = Math.max(currentRow + 1, 17); // Ensure at least some space after last material

  // Add summary rows with borders
  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['T·ªïng c·ªông', formattedData.summary.subTotal]],
    { origin: `F${summaryStartRow}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Thu·∫ø VAT 10%', formattedData.summary.vatAmount]],
    { origin: `F${summaryStartRow + 1}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['T·ªïng c·ªông ƒë√£ bao g·ªìm VAT 10%', formattedData.summary.grandTotal]],
    { origin: `F${summaryStartRow + 2}` }
  );

  // Add borders to summary cells
  const summaryCells = [
    `F${summaryStartRow}`,
    `G${summaryStartRow}`, // T·ªïng c·ªông
    `F${summaryStartRow + 1}`,
    `G${summaryStartRow + 1}`, // Thu·∫ø VAT 10%
    `F${summaryStartRow + 2}`,
    `G${summaryStartRow + 2}`, // T·ªïng c·ªông ƒë√£ bao g·ªìm VAT 10%
  ];

  summaryCells.forEach((cellRef) => {
    if (!worksheet[cellRef]) {
      worksheet[cellRef] = {};
    }
    worksheet[cellRef].s = {
      border: {
        top: { style: 'thin', color: { rgb: '000000' } },
        bottom: { style: 'thin', color: { rgb: '000000' } },
        left: { style: 'thin', color: { rgb: '000000' } },
        right: { style: 'thin', color: { rgb: '000000' } },
      },
      fill: {
        fgColor: { rgb: 'E6E6FA' }, // Light purple background
      },
      alignment: {
        horizontal: 'right',
        vertical: 'center',
      },
    };
  });

  // Add amount in words
  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['B·∫±ng ch·ªØ:', formattedData.summary.amountInWords]],
    { origin: `B${summaryStartRow + 4}` }
  );

  // Add ghi ch√∫ section
  XLSX.utils.sheet_add_aoa(worksheet, [['Ghi ch√∫:']], {
    origin: `B${summaryStartRow + 6}`,
  });

  // Add terms and conditions
  let termsRow = summaryStartRow + 8;

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [
      [
        '1. B√°o gi√° c√≥ hi·ªáu l·ª±c trong 7 ng√†y. H·∫øt hi·ªáu l·ª±c xin li√™n h·ªá l·∫°i cho C√¥ng ty.',
      ],
    ],
    { origin: `C${termsRow}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['2. Th·ªùi gian giao h√†ng: 3 ng√†y ( kh√¥ng bao g·ªìm ch·ªß nh·∫≠t, ng√†y l·ªÖ )']],
    { origin: `C${termsRow + 1}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['3. Gi√° ƒë√£ bao g·ªìm VAT v√† kh√¥ng bao g·ªìm v·∫≠n chuy·ªÉn']],
    { origin: `C${termsRow + 2}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['4. ƒê·ªãa ƒëi·ªÉm giao h√†ng: kho b√™n B√°n']],
    { origin: `C${termsRow + 3}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [
      [
        '5. Ph∆∞∆°ng th·ª©c thanh to√°n: Qu√Ω Kh√°ch h√†ng vui l√≤ng thanh to√°n b·∫±ng chuy·ªÉn kho·∫£n ƒë·ªÉ xu·∫•t h√≥a ƒë∆°n:',
      ],
    ],
    { origin: `C${termsRow + 4}` }
  );

  XLSX.utils.sheet_add_aoa(worksheet, [['T√†i kho·∫£n s·ªë: 27888866']], {
    origin: `C${termsRow + 5}`,
  });

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['T√™n t√†i kho·∫£n: C√¥ng ty TNHH SX c∆° kh√≠ TM-DV T√¢n H√≤a Ph√°t']],
    { origin: `C${termsRow + 6}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['Ng√¢n h√†ng TMCP √Å Ch√¢u - Chi nh√°nh: Tam H√†, Th·ªß ƒê·ª©c']],
    { origin: `C${termsRow + 7}` }
  );

  XLSX.utils.sheet_add_aoa(
    worksheet,
    [['T·∫°m ·ª©ng 50%, Thanh to√°n 50% tr∆∞·ªõc khi nh·∫≠n h√†ng']],
    { origin: `C${termsRow + 8}` }
  );

  // Add the worksheet to the workbook
  XLSX.utils.book_append_sheet(workbook, worksheet, 'B√°o gi√°');

  // Generate Excel file as buffer
  const excelBuffer = XLSX.write(workbook, {
    type: 'buffer',
    bookType: 'xlsx',
  });
  return excelBuffer;
}

/**
 * Firebase Callable Function that generates an Excel quotation
 * Uploads the Excel to Firebase Storage and returns a public URL
 */
export const generateExcelQuotation = functions
  .runWith({
    timeoutSeconds: 300, // Increased timeout
    memory: '512MB', // Increased memory
  })
  .https.onCall(
    async (
      data: {
        formattedData: ExcelQuotationData;
        projectId: string;
        accessToken?: string; // Th√™m tham s·ªë accessToken v√†o ƒë√¢y
      },
      context: CallableContext
    ) => {
      try {
        // B·∫Øt ƒë·∫ßu try...catch ·ªü ƒë√¢y
        if (!context.auth) {
          throw new functions.https.HttpsError(
            'unauthenticated',
            'B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ s·ª≠ d·ª•ng t√≠nh nƒÉng n√†y.'
          );
        }

        const { formattedData, projectId } = data;

        // Log d·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c
        functions.logger.info(
          'Received data in generateExcelQuotation function.',
          {
            projectId,
            materialsCount: formattedData?.materials?.length || 0,
            firstFiveMaterials: (formattedData?.materials || [])
              .slice(0, 5)
              .map((item) => ({ no: item.no, name: item.name })),
          }
        );

        if (!formattedData) {
          throw new functions.https.HttpsError(
            'invalid-argument',
            'Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu b√°o gi√°.'
          );
        }

        if (!projectId) {
          throw new functions.https.HttpsError(
            'invalid-argument',
            'Kh√¥ng t√¨m th·∫•y ID d·ª± √°n.'
          );
        }

        console.log('B·∫Øt ƒë·∫ßu t·∫°o file Excel v·ªõi d·ªØ li·ªáu:', {
          projectId,
          quotationNumber: formattedData.metadata.quotationNumber,
          materialsCount: formattedData.materials?.length || 0,
        });

        // Generate Excel buffer
        const excelBuffer = generateExcelFile(formattedData);

        // Save to temp file
        const quotationNumber = formattedData.metadata.quotationNumber.replace(
          /\//g,
          '-'
        );
        const tempExcelPath = path.join(os.tmpdir(), `${quotationNumber}.xlsx`);
        fs.writeFileSync(tempExcelPath, excelBuffer);

        // Upload to Firebase Storage
        const fileName = `excel_quotations/${projectId}/${quotationNumber}.xlsx`;
        const file = bucket.file(fileName);

        await file.save(fs.readFileSync(tempExcelPath), {
          metadata: {
            contentType:
              'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
          },
        });

        // Clean up temp file
        fs.unlinkSync(tempExcelPath);

        // Make the file publicly accessible
        await file.makePublic();

        // Return the public URL
        const excelUrl = `https://storage.googleapis.com/${bucket.name}/${fileName}`;
        functions.logger.info('ƒê√£ t·∫°o file Excel th√†nh c√¥ng:', { excelUrl });
        return { excelUrl };
      } catch (error: any) {
        functions.logger.error('Unhandled error in generateExcelQuotation:', {
          errorMessage: error.message,
          errorCode: error.code,
          errorDetails: error.details,
          data, // Log c·∫£ d·ªØ li·ªáu ƒë·∫ßu v√†o
        });
        throw new functions.https.HttpsError(
          'internal',
          error.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh khi t·∫°o file Excel.',
          error
        );
      } // K·∫øt th√∫c try...catch ·ªü ƒë√¢y
    }
  );


--- END: functions\src\quotationExcelGenerator.ts ---


--- START: functions\src\salaryExcelGenerator.ts ---
import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';
import * as XLSX from 'xlsx';
import { google } from 'googleapis';
import { PassThrough } from 'stream';

// ƒê·ªãnh nghƒ©a interface m·ªõi cho SalarySlip ƒë·ªÉ kh·ªõp v·ªõi c·∫•u tr√∫c d·ªØ li·ªáu ƒë√£ n√¢ng c·∫•p
interface SalarySlip {
  id: string;
  employeeName: string;
  month: number;
  year: number;
  notes?: string;
  employeeInfo: {
    monthlySalary: number;
    insuranceContributionBase: number;
  };
  attendanceSummary: {
    actualWorkDays: number;
    paidLeaveDays: number;
    overtimeHours: { normal: number; sunday: number; holiday: number };
  };
  calculatedSalary: {
    baseSalary: number;
    totalOvertimePay: number;
    totalAllowances: number;
    totalBonuses: number;
    grossSalary: number;
    totalDeductions: number;
    netSalary: number;
    hourlyRate: number;
    effectiveWorkingDays: number;
    overtimePay: { normal: number; sunday: number; holiday: number };
    autoDeductions: Array<{ name: string; amount: number }>;
    manualDeductions: Array<{ name: string; amount: number }>;
    advancePayments: Array<{ reason?: string; date?: any; amount: number }>;
    totalAdvancePayments: number;
  };
  manualInputs: {
    allowances: Array<{ name: string; amount: number }>;
    bonuses: Array<{ name: string; amount: number }>;
  };
}

// Excel number formats
const CURRENCY_FMT = '#,##0 "VNƒê"';
const CURRENCY_PER_HOUR_FMT = '#,##0 "VNƒê/gi·ªù"';
const HOURS_FMT = '#,##0.00 "gi·ªù"';

/**
 * (VI·∫æT L·∫†I) Cloud Function ƒë·ªÉ xu·∫•t phi·∫øu l∆∞∆°ng Excel v·ªõi c·∫•u tr√∫c m·ªõi (d√πng ƒë·ªãnh d·∫°ng s·ªë)
 */
export const exportSalarySlipToDrive = functions
  .region('asia-southeast1')
  .https.onCall(async (data: any, context: any) => {
    if (!context.auth) {
      throw new functions.https.HttpsError(
        'unauthenticated',
        'Y√™u c·∫ßu ƒëƒÉng nh·∫≠p.'
      );
    }

    const { salarySlipId, accessToken } = data;
    if (!salarySlipId || !accessToken) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thi·∫øu salarySlipId ho·∫∑c accessToken.'
      );
    }

    try {
      // 1. L·∫•y d·ªØ li·ªáu phi·∫øu l∆∞∆°ng t·ª´ Firestore
      const salarySlipDoc = await admin
        .firestore()
        .collection('salarySlips')
        .doc(salarySlipId)
        .get();
      if (!salarySlipDoc.exists) {
        throw new functions.https.HttpsError(
          'not-found',
          'Phi·∫øu l∆∞∆°ng kh√¥ng t·ªìn t·∫°i.'
        );
      }
      const salarySlip = {
        id: salarySlipDoc.id,
        ...salarySlipDoc.data(),
      } as SalarySlip;

      // 2. T·∫°o file Excel theo template ƒë∆°n gi·∫£n (1 sheet duy nh·∫•t)
      const workbook = XLSX.utils.book_new();

      // T·∫°o d·ªØ li·ªáu theo template nh∆∞ trong h√¨nh
      const ws_data: any[][] = [
        // Header row
        ['H·ªç t√™n:', salarySlip.employeeName, 'Ch·ª©c V·ª•:', 'K·ªπ thu·∫≠t'],
        ['S·ªë ng√†y c√¥ng:', salarySlip.attendanceSummary.actualWorkDays],
        [],
        // L∆∞∆°ng c·ª©ng
        [
          '1. L∆∞∆°ng c·ª©ng:',
          { v: salarySlip.employeeInfo.monthlySalary, t: 'n', z: CURRENCY_FMT },
        ],
        [
          '2. L∆∞∆°ng theo ng√†y c√¥ng:',
          {
            v: salarySlip.calculatedSalary.baseSalary,
            t: 'n',
            z: CURRENCY_FMT,
          },
        ],
        [
          '3. Ph·ª• c·∫•p:',
          {
            v: salarySlip.calculatedSalary.totalAllowances,
            t: 'n',
            z: CURRENCY_FMT,
          },
        ],
        [],
        // TƒÉng ca
        ['4. S·ªë gi·ªù tƒÉng ca:'],
        [
          'Ng√†y th∆∞·ªùng (x1,5):',
          {
            v: salarySlip.attendanceSummary.overtimeHours.normal,
            t: 'n',
            z: HOURS_FMT,
          },
          'Ti·ªÅn tƒÉng ca tr√™n 1 gi·ªù:',
          {
            v: salarySlip.calculatedSalary.hourlyRate,
            t: 'n',
            z: CURRENCY_PER_HOUR_FMT,
          },
        ],
        [
          'Ng√†y CN (x1,5):',
          {
            v: salarySlip.attendanceSummary.overtimeHours.sunday,
            t: 'n',
            z: HOURS_FMT,
          },
        ],
        [
          'Ng√†y l·ªÖ (x1,5):',
          {
            v: salarySlip.attendanceSummary.overtimeHours.holiday,
            t: 'n',
            z: HOURS_FMT,
          },
        ],
        [
          '6. T·ªïng l∆∞∆°ng tƒÉng ca:',
          {
            v: salarySlip.calculatedSalary.totalOvertimePay,
            t: 'n',
            z: CURRENCY_FMT,
          },
        ],
        ['7. Ph√©p nƒÉm ch∆∞a d√πng:', ''],
        ['8. Ph√©p nƒÉm c·ªông v√†o l∆∞∆°ng:', ''],
        [
          '9. T·ªïng thu nh·∫≠p tr∆∞·ªõc BHXH',
          {
            v: salarySlip.calculatedSalary.grossSalary,
            t: 'n',
            z: CURRENCY_FMT,
          },
        ],
        [],
        // Kh·∫•u tr·ª´
        ['C√°c kho·∫£n tr√≠ch theo l∆∞∆°ng'],
        [
          'BHXH (8%):',
          {
            v:
              salarySlip.calculatedSalary.autoDeductions.find(
                (d) =>
                  d.name.includes('B·∫£o hi·ªÉm x√£ h·ªôi') || d.name.includes('BHXH')
              )?.amount || 0,
            t: 'n',
            z: CURRENCY_FMT,
          },
        ],
        [
          'BHYT (1.5%):',
          {
            v:
              salarySlip.calculatedSalary.autoDeductions.find(
                (d) =>
                  d.name.includes('B·∫£o hi·ªÉm y t·∫ø') || d.name.includes('BHYT')
              )?.amount || 0,
            t: 'n',
            z: CURRENCY_FMT,
          },
        ],
        [
          'BHTN (1%):',
          {
            v:
              salarySlip.calculatedSalary.autoDeductions.find(
                (d) =>
                  d.name.includes('B·∫£o hi·ªÉm th·∫•t nghi·ªáp') ||
                  d.name.includes('BHTN')
              )?.amount || 0,
            t: 'n',
            z: CURRENCY_FMT,
          },
        ],
        [
          '10. T·ªïng tr·ª´ BH (10,5%):',
          {
            v: salarySlip.calculatedSalary.autoDeductions.reduce(
              (sum, d) => sum + d.amount,
              0
            ),
            t: 'n',
            z: CURRENCY_FMT,
          },
        ],
        [],
        [
          '11. T·ªïng thu nh·∫≠p sau BHXH (9-10):',
          {
            v:
              salarySlip.calculatedSalary.grossSalary -
              salarySlip.calculatedSalary.autoDeductions.reduce(
                (sum, d) => sum + d.amount,
                0
              ),
            t: 'n',
            z: CURRENCY_FMT,
          },
        ],
        [
          '12. Tr·ª´ T·∫°m ·ª®ng:',
          {
            v: salarySlip.calculatedSalary.advancePayments.reduce(
              (sum, p) => sum + p.amount,
              0
            ),
            t: 'n',
            z: CURRENCY_FMT,
          },
          'Ghi ch√∫:',
          '',
        ],
        [],
        [
          '13. Th·ª±c lƒ©nh (11-12):',
          { v: salarySlip.calculatedSalary.netSalary, t: 'n', z: CURRENCY_FMT },
        ],
        [],
        // Footer
        [
          new Date().toLocaleDateString('vi-VN'),
          'Ng∆∞·ªùi l·∫≠p:',
          '',
          'Ng∆∞·ªùi nh·∫≠n:',
        ],
      ];

      const ws = XLSX.utils.aoa_to_sheet(ws_data);

      // Thi·∫øt l·∫≠p ƒë·ªô r·ªông c·ªôt D l√† 120 pixel
      ws['!cols'] = [
        { wch: 20 }, // C·ªôt A
        { wch: 20 }, // C·ªôt B
        { wch: 20 }, // C·ªôt C
        { wpx: 120 }, // C·ªôt D - 120 pixel
        { wch: 20 }, // C·ªôt E
        { wch: 20 }, // C·ªôt F
        { wch: 20 }, // C·ªôt G
      ];

      // ƒê·∫∑t t√™n sheet
      XLSX.utils.book_append_sheet(workbook, ws, 'Phi·∫øu L∆∞∆°ng');

      // 3. Chuy·ªÉn ƒë·ªïi workbook th√†nh buffer
      const excelBuffer = XLSX.write(workbook, {
        type: 'buffer',
        bookType: 'xlsx',
      });

      // 4. Upload file l√™n Google Drive
      const auth = new google.auth.OAuth2();
      auth.setCredentials({ access_token: accessToken });
      const drive = google.drive({ version: 'v3', auth });

      // T√¨m ho·∫∑c t·∫°o th∆∞ m·ª•c 'PHIEU LUONG'
      const rootFolderId = '1Ci_BHZx0-Uhv2xg5IzwLPn05yPAUXOOU'; // C·∫ßn ƒë·∫£m b·∫£o ID n√†y ƒë√∫ng
      const folderQuery = `'${rootFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and name='PHIEU LUONG' and trashed=false`;
      const folderResponse = await drive.files.list({
        q: folderQuery,
        fields: 'files(id)',
      });

      let targetFolderId: string | null | undefined = null;
      if (folderResponse.data.files && folderResponse.data.files.length > 0) {
        targetFolderId = folderResponse.data.files[0].id;
      } else {
        const newFolder = await drive.files.create({
          requestBody: {
            name: 'PHIEU LUONG',
            mimeType: 'application/vnd.google-apps.folder',
            parents: [rootFolderId],
          },
          fields: 'id',
        });
        targetFolderId = newFolder.data.id;
      }

      if (!targetFolderId) {
        throw new Error(
          'Kh√¥ng th·ªÉ t√¨m ho·∫∑c t·∫°o th∆∞ m·ª•c ƒë√≠ch tr√™n Google Drive.'
        );
      }

      const fileName = `Phi·∫øu l∆∞∆°ng - ${salarySlip.employeeName} - ${salarySlip.month}-${salarySlip.year}.xlsx`;
      const bufferStream = new PassThrough();
      bufferStream.end(excelBuffer);

      const uploadedFile = await drive.files.create({
        requestBody: { name: fileName, parents: [targetFolderId] },
        media: {
          mimeType:
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
          body: bufferStream,
        },
        fields: 'id,name,webViewLink',
      });

      // 5. C·∫≠p nh·∫≠t l·∫°i phi·∫øu l∆∞∆°ng v·ªõi th√¥ng tin file Excel
      await admin
        .firestore()
        .collection('salarySlips')
        .doc(salarySlipId)
        .update({
          excelFileId: uploadedFile.data.id,
          excelFileUrl: uploadedFile.data.webViewLink,
          exportedAt: admin.firestore.FieldValue.serverTimestamp(),
        });

      return {
        success: true,
        message: 'Xu·∫•t phi·∫øu l∆∞∆°ng th√†nh c√¥ng!',
        fileUrl: uploadedFile.data.webViewLink,
      };
    } catch (error) {
      console.error('L·ªói khi xu·∫•t phi·∫øu l∆∞∆°ng:', error);
      const errorMessage =
        error instanceof Error ? error.message : 'L·ªói kh√¥ng x√°c ƒë·ªãnh.';
      throw new functions.https.HttpsError(
        'internal',
        `L·ªói khi xu·∫•t phi·∫øu l∆∞∆°ng: ${errorMessage}`
      );
    }
  });


--- END: functions\src\salaryExcelGenerator.ts ---


--- START: functions\src\salaryService.ts ---
// This service will house the new, comprehensive salary calculation logic.
// We will build out the functions here as we progress through the tasks.

export {};
















--- END: functions\src\salaryService.ts ---


--- START: functions\src\savePOReceiptConfirmation.ts ---
import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';

/**
 * savePOReceiptConfirmation
 * Updates the purchase order document with receipt confirmation data
 * This function only updates the Firestore document, it doesn't upload any files
 * It now also automatically adds received items to inventory
 * and creates expense records for materials
 */
export const savePOReceiptConfirmation = functions
  .region('asia-southeast1')
  .runWith({ timeoutSeconds: 60, memory: '256MB' })
  .https.onCall(async (data, context) => {
    console.log(
      'savePOReceiptConfirmation called with data:',
      JSON.stringify(data)
    );

    // Authentication check
    if (!context.auth) {
      console.log('Authentication failed - no auth context');
      throw new functions.https.HttpsError(
        'unauthenticated',
        'B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p'
      );
    }

    const {
      poId,
      projectId,
      filesToSave,
      remarks = '',
    } = data as {
      poId?: string;
      projectId?: string;
      filesToSave?: Array<{
        id: string;
        name: string;
        url: string;
        mimeType?: string;
      }>;
      remarks?: string;
    };

    console.log(
      `Processing confirmation for PO: ${poId}, Project: ${projectId}`
    );

    // Validate required parameters
    if (!poId || !projectId || !filesToSave) {
      console.log('Missing required parameters', {
        poId,
        projectId,
        filesCount: filesToSave?.length,
      });
      throw new functions.https.HttpsError(
        'invalid-argument',
        'Thi·∫øu tham s·ªë b·∫Øt bu·ªôc'
      );
    }

    try {
      const db = admin.firestore();
      console.log('Getting PO document:', poId);
      const poRef = db.collection('purchase_orders').doc(poId);
      const poSnap = await poRef.get();

      if (!poSnap.exists) {
        console.log(`PO not found: ${poId}`);
        throw new functions.https.HttpsError('not-found', 'Kh√¥ng t√¨m th·∫•y PO');
      }

      const poData = poSnap.data();

      // --- IDEMPOTENCY CHECK ---
      // Check if this PO has already been processed to prevent double-counting.
      if (poData?.inventoryProcessed) {
        console.log(`PO ${poId} has already been processed. Skipping.`);
        return {
          success: true,
          message: 'PO ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω v√†o kho tr∆∞·ªõc ƒë√≥. Kh√¥ng c√≥ g√¨ thay ƒë·ªïi.',
        };
      }

      // ----- Extract materials regardless of PO data structure -----
      // Older POs had materials at the root level, while newer ones have them
      // nested inside formattedData.materials. Unify them into one array.
      const materialsList: any[] = Array.isArray(poData?.materials)
        ? poData!.materials
        : Array.isArray(poData?.formattedData?.materials)
        ? poData!.formattedData.materials
        : [];

      console.log(
        `PO data retrieved, materials detected: ${materialsList.length}`
      );
      if (materialsList.length) {
        console.log(`First material sample:`, JSON.stringify(materialsList[0]));
      }

      // Get current user info for transaction records
      const userDoc = await db.collection('users').doc(context.auth.uid).get();
      const userName = userDoc.exists
        ? userDoc.data()?.displayName || 'Ng∆∞·ªùi d√πng'
        : 'Ng∆∞·ªùi d√πng';

      // Update PO document
      console.log('Updating PO document with status: received');
      await poRef.update({
        status: 'received',
        receivedAt: admin.firestore.FieldValue.serverTimestamp(),
        receiptPhotos: filesToSave,
        receiptRemarks: remarks,
        updatedBy: context.auth.uid,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      });
      console.log('PO document updated successfully');

      // Get project data for expense creation
      const projectSnap = await db.collection('projects').doc(projectId).get();
      const projectName = projectSnap.exists
        ? projectSnap.data()?.name || 'Unknown Project'
        : 'Unknown Project';

      // Track expenses to be created
      const expensesCreated = [];

      // Automatically add received items to inventory
      if (materialsList.length > 0) {
        console.log(
          `Processing ${materialsList.length} materials for inventory`
        );

        for (const material of materialsList) {
          try {
            console.log('--- Processing Material ---');
            console.log(
              'Raw material data:',
              JSON.stringify(material, null, 2)
            );

            const name = material.name ? String(material.name).trim() : '';
            const code = material.code ? String(material.code).trim() : '';

            if (!name) {
              console.log('Skipping material: name is missing.');
              continue;
            }

            // Check all possible field names for price
            // Try multiple field names: unitPrice, price, unit_price
            const quantity = Number(material.quantity) || 0;
            const price =
              Number(material.unitPrice) ||
              Number(material.unit_price) ||
              Number(material.price) ||
              0;

            console.log(
              `Parsed values -> Name: "${name}", Code: "${code}", Quantity: ${quantity}, Price: ${price}`
            );

            // Skip if quantity is not a valid number or is zero
            if (isNaN(quantity) || quantity <= 0) {
              console.log(
                `Skipping material with invalid quantity: ${material.name}, raw quantity: ${material.quantity}`
              );
              continue;
            }

            // First, check if the item already exists in inventory by code or name
            let inventoryQuery: FirebaseFirestore.Query<FirebaseFirestore.DocumentData> =
              db.collection('inventory');

            // If the material has a code, search by code which is more reliable
            if (code) {
              console.log(`Searching inventory by code: "${code}"`);
              inventoryQuery = inventoryQuery.where('code', '==', code);
            } else {
              console.log(`Searching inventory by name: "${name}"`);
              inventoryQuery = inventoryQuery.where('name', '==', name);
            }

            const inventorySnap = await inventoryQuery.get();
            console.log(
              `Inventory search results: ${inventorySnap.size} items found`
            );

            if (inventorySnap.empty) {
              // Item doesn't exist - create new inventory item
              console.log(`Creating new inventory item: "${name}"`);

              const newItemData = {
                name: name, // Use trimmed name
                code:
                  code ||
                  `AUTO-${Date.now()}-${Math.round(Math.random() * 1000)}`,
                description: material.description || '',
                material: material.material || '',
                categoryId: material.categoryId || '',
                unit: material.unit || 'c√°i',
                stockQuantity: quantity,
                minQuantity: 0, // Set min quantity to 0 for PO-added items
                price: price,
                weight: material.weight || 0,
                totalPrice: quantity * price,
                createdAt: admin.firestore.FieldValue.serverTimestamp(),
                updatedAt: admin.firestore.FieldValue.serverTimestamp(),
              };

              console.log(
                `New inventory data: ${JSON.stringify(newItemData, null, 2)}`
              );
              const newItemRef = await db
                .collection('inventory')
                .add(newItemData);
              console.log(
                `New inventory item created with ID: ${newItemRef.id}`
              );

              // Create a transaction record for this new item
              await db.collection('inventory_transactions').add({
                itemId: newItemRef.id,
                type: 'in',
                quantity: quantity,
                date: admin.firestore.FieldValue.serverTimestamp(),
                reason: `Nh·∫≠n h√†ng t·ª´ PO: ${poData.poNumber || poId}`,
                createdBy: context.auth.uid,
                createdByName: userName,
                projectId: projectId,
                poId: poId,
              });
              console.log(`Inventory transaction record created for new item`);
            } else {
              // Item exists - update quantity
              const itemDoc = inventorySnap.docs[0];
              const itemData = itemDoc.data();
              const currentQuantity = Number(itemData.stockQuantity) || 0;
              const newQuantity = currentQuantity + quantity;

              console.log(
                `Updating existing inventory item ${itemDoc.id}: "${itemData.name}", adding ${quantity} to current ${currentQuantity}`
              );

              // Update the inventory item with new quantity
              await db
                .collection('inventory')
                .doc(itemDoc.id)
                .update({
                  stockQuantity: newQuantity,
                  updatedAt: admin.firestore.FieldValue.serverTimestamp(),
                  // Update price if the new one is provided and different
                  ...(price && price !== itemData.price
                    ? { price: price }
                    : {}),
                  // Update totalPrice based on new quantity and price
                  totalPrice: newQuantity * (price || itemData.price || 0),
                });
              console.log(
                `Inventory item updated with new quantity: ${newQuantity}`
              );

              // Create a transaction record for this update
              await db.collection('inventory_transactions').add({
                itemId: itemDoc.id,
                type: 'in',
                quantity: quantity,
                date: admin.firestore.FieldValue.serverTimestamp(),
                reason: `Nh·∫≠n h√†ng t·ª´ PO: ${poData.poNumber || poId}`,
                createdBy: context.auth.uid,
                createdByName: userName,
                projectId: projectId,
                poId: poId,
              });
              console.log(
                `Inventory transaction record created for existing item`
              );
            }

            // Calculate total cost for this material
            const totalCost = quantity * price;

            // Create expense record for this material
            if (totalCost > 0) {
              const expenseData = {
                projectId: projectId,
                projectName: projectName,
                type: 'material',
                amount: totalCost,
                description: `${name} (${quantity} ${material.unit || 'c√°i'})`,
                date: admin.firestore.FieldValue.serverTimestamp(),
                relatedDocId: poId,
                createdBy: context.auth.uid,
                createdAt: admin.firestore.FieldValue.serverTimestamp(),
              };

              const expenseRef = await db
                .collection('expenses')
                .add(expenseData);
              console.log(
                `Expense record created with ID: ${expenseRef.id} for material: ${name}`
              );

              // Keep track of created expenses
              expensesCreated.push({
                id: expenseRef.id,
                description: expenseData.description,
                amount: expenseData.amount,
              });
            } else {
              console.log(
                `No expense record created for material ${name} - cost is zero`
              );
            }
          } catch (itemError) {
            // Log error but continue with other items
            console.error(
              `Error processing inventory item ${material.name}:`,
              itemError
            );
          }
        }

        console.log(`Finished processing all materials for inventory`);

        // Mark the PO as processed to prevent it from being run again.
        await poRef.update({
          inventoryProcessed: true,
          inventoryProcessedAt: admin.firestore.FieldValue.serverTimestamp(),
          expensesCreated: expensesCreated,
        });
        console.log(`PO ${poId} has been marked as processed for inventory.`);
      } else {
        console.log(`No materials found in PO data to add to inventory`);
      }

      return {
        success: true,
        message: 'PO ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n v√† v·∫≠t t∆∞ ƒë√£ ƒë∆∞·ª£c th√™m v√†o kho t·ª± ƒë·ªông.',
        expenses: {
          count: expensesCreated.length,
          total: expensesCreated.reduce((sum, exp) => sum + exp.amount, 0),
          items: expensesCreated,
        },
      };
    } catch (err: any) {
      console.error('savePOReceiptConfirmation error', err);
      throw new functions.https.HttpsError(
        'internal',
        err.message || 'L·ªói x·ª≠ l√Ω x√°c nh·∫≠n PO'
      );
    }
  });


--- END: functions\src\savePOReceiptConfirmation.ts ---


--- START: functions\src\scheduledFunctions.ts ---
import * as functions from 'firebase-functions/v2';
import * as admin from 'firebase-admin';
import { Timestamp } from 'firebase-admin/firestore';

const db = admin.firestore();

/**
 * Scheduled function to aggregate financial data for the director's dashboard
 * Runs daily at 1:00 AM Vietnam time
 */
export const aggregateDashboardData = functions.scheduler.onSchedule(
  {
    schedule: '0 1 * * *',
    timeZone: 'Asia/Ho_Chi_Minh',
    region: 'asia-southeast1',
  },
  async (context) => {
    try {
      console.log('Starting dashboard data aggregation');

      // Get all payable transactions
      const payableSnapshot = await db.collection('payable_transactions').get();
      const transactions = payableSnapshot.docs.map((doc) => doc.data());

      // Calculate total accounts payable (ph·∫£i tr·∫£)
      const payableTransactions = transactions.filter(
        (t) => t.type === 'payable'
      );
      const totalAccountsPayable = payableTransactions.reduce(
        (sum, t) => sum + (t.remainingAmount || 0),
        0
      );

      // Calculate total accounts receivable (ph·∫£i thu)
      const receivableTransactions = transactions.filter(
        (t) => t.type === 'receivable'
      );
      const totalAccountsReceivable = receivableTransactions.reduce(
        (sum, t) => sum + (t.remainingAmount || 0),
        0
      );

      // Calculate net debt position (negative means company owes more than it's owed)
      const netDebtPosition = totalAccountsReceivable - totalAccountsPayable;

      // Calculate top 5 suppliers by outstanding amount (ph·∫£i tr·∫£)
      const supplierTotals: Record<string, number> = {};
      payableTransactions.forEach((t) => {
        if (!supplierTotals[t.supplier]) {
          supplierTotals[t.supplier] = 0;
        }
        supplierTotals[t.supplier] += t.remainingAmount || 0;
      });

      const top5Payable = Object.entries(supplierTotals)
        .map(([supplier, amount]) => ({ supplier, amount }))
        .sort((a, b) => b.amount - a.amount)
        .slice(0, 5)
        .map((item) => ({
          ...item,
          // Convert to millions for display
          amountInMillions:
            Math.round((Number(item.amount) / 1000000) * 100) / 100,
        }));

      // Calculate top 5 customers by outstanding amount (ph·∫£i thu)
      const customerTotals: Record<string, number> = {};
      receivableTransactions.forEach((t) => {
        if (!customerTotals[t.supplier]) {
          // supplier field is used for both suppliers and customers
          customerTotals[t.supplier] = 0;
        }
        customerTotals[t.supplier] += t.remainingAmount || 0;
      });

      const top5Receivable = Object.entries(customerTotals)
        .map(([customer, amount]) => ({ customer, amount }))
        .sort((a, b) => b.amount - a.amount)
        .slice(0, 5)
        .map((item) => ({
          ...item,
          // Convert to millions for display
          amountInMillions:
            Math.round((Number(item.amount) / 1000000) * 100) / 100,
        }));

      // Save aggregated data to Firestore
      await db
        .collection('summaries')
        .doc('directorDashboard')
        .set({
          totalAccountsPayable,
          totalAccountsReceivable,
          netDebtPosition,
          top5Payable,
          top5Receivable,
          lastUpdated: Timestamp.now(),
          formattedTotals: {
            totalAccountsPayable: formatCurrency(totalAccountsPayable),
            totalAccountsReceivable: formatCurrency(totalAccountsReceivable),
            netDebtPosition: formatCurrency(netDebtPosition),
          },
        });

      console.log('Dashboard data aggregation completed successfully');
    } catch (error) {
      console.error('Error aggregating dashboard data:', error);
      throw error;
    }
  }
);

/**
 * Format currency for display (VND)
 */
function formatCurrency(amount: number): string {
  return new Intl.NumberFormat('vi-VN', {
    style: 'currency',
    currency: 'VND',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(amount);
}


--- END: functions\src\scheduledFunctions.ts ---


--- START: functions\src\taskTriggers.ts ---
//functions/src/taskTriggers.ts
import { onDocumentWritten } from 'firebase-functions/v2/firestore';
import * as admin from 'firebase-admin';

const db = admin.firestore();

// --- Helper Functions ---

/**
 * Fetches users from Firestore based on their role.
 * @param {string | string[]} roles The role or roles to query for.
 * @returns {Promise<any[]>} An array of user objects.
 */
const getUsersByRole = async (roles: string | string[]): Promise<any[]> => {
  const rolesArray = Array.isArray(roles) ? roles : [roles];
  if (rolesArray.length === 0) return [];
  try {
    const usersRef = db.collection('users');
    // Firestore "in" query supports up to 10 elements. If more are needed,
    // multiple queries would be required. For now, this is sufficient.
    const querySnapshot = await usersRef.where('role', 'in', rolesArray).get();
    return querySnapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
  } catch (error) {
    console.error(`Error fetching users by role: ${roles}`, error);
    return [];
  }
};

/**
 * Sends a push notification to a list of users.
 * @param {any[]} users An array of user objects, must include fcmToken.
 * @param {string} title The notification title.
 * @param {string} body The notification body.
 * @returns {Promise<any>} A promise that resolves when all messages are sent.
 */
const sendNotificationToUsers = (
  users: any[],
  title: string,
  body: string
): Promise<any> => {
  const tokens = users.map((user) => user.fcmToken).filter((token) => token); // Filter out users without tokens

  if (tokens.length === 0) {
    return Promise.resolve();
  }
  // FCM"s sendToDevice supports up to 1000 tokens.
  return admin.messaging().sendToDevice(tokens, {
    notification: { title, body, sound: 'default' },
  });
};

/**
 * Fetches a user"s display name from their UID.
 * @param {string} uid The user"s ID.
 * @returns {Promise<string>} The user"s name or a fallback string.
 */
const getUserName = async (uid: string): Promise<string> => {
  if (!uid) return 'H·ªá th·ªëng';
  try {
    const userRecord = await admin.auth().getUser(uid);
    return userRecord.displayName || userRecord.email || 'Ng∆∞·ªùi d√πng kh√¥ng t√™n';
  } catch (error) {
    console.error(`Error fetching user data for UID: ${uid}`, error);
    return 'Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i';
  }
};

/**
 * Gets the human-readable label for a task key.
 * @param {string} taskKey The key of the task (e.g., "material_cutting").
 * @param {any} taskData The data object for the task, used for custom task names.
 * @returns {string} The display label for the task.
 */
const getTaskLabel = (taskKey: string, taskData: any): string => {
  const taskLabels: { [key: string]: string } = {
    material_separation: 'B√≥c t√°ch v·∫≠t t∆∞',
    quotation: 'B√°o gi√°',
    material_purchasing: 'Mua v·∫≠t t∆∞',
    material_cutting: 'C·∫Øt ph√¥i',
    assembly: 'L·∫Øp r√°p',
    painting: 'S∆°n',
    shipping: 'V·∫≠n chuy·ªÉn',
    turning: 'Ti·ªán',
    milling: 'Phay',
    welding: 'H√†n',
    bending: 'Ch·∫•n',
    drilling: 'Khoan',
    grinding: 'M√†i',
    other: taskData?.name || 'C√¥ng vi·ªác kh√°c',
  };
  return taskLabels[taskKey] || 'C√¥ng vi·ªác kh√¥ng x√°c ƒë·ªãnh';
};

/**
 * Denormalizes a single task into the top-level "tasks" collection.
 * @param {string} projectId The project ID.
 * @param {string} projectName The project name.
 * @param {string} projectStatus The project status.
 * @param {string} taskKey The key of the task.
 * @param {any} taskData The data of the task.
 * @returns {Promise<any>} A promise that resolves when the write is complete.
 */
const denormalizeTask = async (
  projectId: string,
  projectName: string,
  projectStatus: string,
  taskKey: string,
  taskData: any
) => {
  const assignedToId = taskData.assignedTo || null;
  const assignedToName = await getUserName(assignedToId);
  const denormalizedTask = {
    projectId,
    projectName,
    projectStatus,
    taskKey,
    taskLabel: getTaskLabel(taskKey, taskData),
    status: taskData.status || 'pending',
    assignedToId,
    assignedToName,
    startDate: taskData.startDate || null,
    endDate: taskData.endDate || null,
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
  };
  const docId = `${projectId}_${taskKey}`;
  return db
    .collection('tasks')
    .doc(docId)
    .set(denormalizedTask, { merge: true });
};

// --- Main Cloud Function Trigger ---

export const projectWorkflowManager = onDocumentWritten(
  {
    document: 'projects/{projectId}',
    region: 'asia-southeast1',
  },
  async (event) => {
    const { projectId } = event.params;
    const beforeData = event.data?.before.data();
    const afterData = event.data?.after.data();

    if (!afterData) {
      console.log(`Project ${projectId} deleted. No action taken.`);
      return null;
    }

    const projectName = afterData.name || 'D·ª± √°n kh√¥ng t√™n';
    const updates: { [key: string]: any } = {};
    const notificationPromises: Promise<any>[] = [];

    // --- Workflow Triggers ---

    // Trigger 1: Project Creation
    if (!beforeData) {
      const engineers = await getUsersByRole('ky_su');
      if (engineers.length > 0) {
        const engineerToAssign = engineers[0];
        updates['tasks.material_separation.assignedTo'] = engineerToAssign.id;
        notificationPromises.push(
          sendNotificationToUsers(
            [engineerToAssign],
            'Nhi·ªám v·ª• m·ªõi',
            `B·∫°n ƒë∆∞·ª£c giao nhi·ªám v·ª• "T√°ch v·∫≠t li·ªáu" cho d·ª± √°n m·ªõi: ${projectName}.`
          )
        );
      }
    }

    // ---- NEW WORKFLOW LOGIC ----
    const beforeStages: any[] = beforeData?.workflowStages || [];
    const afterStages: any[] = afterData.workflowStages || [];

    // Detect status change to completed for material_separation
    const justCompleted = afterStages.find((stageAfter) => {
      if (stageAfter.processKey !== 'material_separation') return false;
      const beforeStage = beforeStages.find(
        (s) => s.stageId === stageAfter.stageId
      );
      return (
        beforeStage?.status !== 'completed' && stageAfter.status === 'completed'
      );
    });

    if (justCompleted) {
      // Find next stage by order
      const nextStage = afterStages
        .filter((s) => s.order > justCompleted.order)
        .sort((a, b) => a.order - b.order)[0];

      if (nextStage && nextStage.processKey === 'quotation') {
        const usersToNotify = await getUsersByRole(['thuong_mai', 'giam_doc']);
        const salesUser = usersToNotify.find((u) => u.role === 'thuong_mai');

        if (salesUser) {
          // update array element
          const newStages = afterStages.map((s) =>
            s.stageId === nextStage.stageId
              ? { ...s, assignedToId: salesUser.id }
              : s
          );
          updates['workflowStages'] = newStages;
        }

        notificationPromises.push(
          sendNotificationToUsers(
            usersToNotify,
            'Y√™u c·∫ßu b√°o gi√°',
            `K·ªπ s∆∞ ƒë√£ ho√†n th√†nh b√≥c t√°ch v·∫≠t li·ªáu cho d·ª± √°n ${projectName}. Vui l√≤ng ti·∫øn h√†nh b√°o gi√°.`
          )
        );
      }
    }

    // Trigger 3: Project Approved -> Assign Purchasing & Cutting
    if (
      beforeData?.status === 'pending' &&
      afterData.status === 'in-progress'
    ) {
      // a. Assign Material Purchasing
      const purchasingUsers = await getUsersByRole(['thuong_mai', 'ke_toan']);
      const salesUser = purchasingUsers.find((u) => u.role === 'thuong_mai');
      if (salesUser) {
        updates['tasks.material_purchasing.assignedTo'] = salesUser.id;
      }
      notificationPromises.push(
        sendNotificationToUsers(
          purchasingUsers,
          'Y√™u c·∫ßu mua v·∫≠t t∆∞',
          `D·ª± √°n ${projectName} ƒë√£ ƒë∆∞·ª£c duy·ªát. Vui l√≤ng ti·∫øn h√†nh mua v·∫≠t t∆∞.`
        )
      );

      // b. Assign Material Cutting
      const cuttingEngineers = await getUsersByRole('ky_su_cat_phoi');
      if (cuttingEngineers.length > 0) {
        const engineerToAssign = cuttingEngineers[0];
        updates['tasks.material_cutting.assignedTo'] = engineerToAssign.id;
        notificationPromises.push(
          sendNotificationToUsers(
            [engineerToAssign],
            'Nhi·ªám v·ª• m·ªõi',
            `B·∫°n ƒë∆∞·ª£c giao nhi·ªám v·ª• "C·∫Øt ph√¥i" cho d·ª± √°n ${projectName}.`
          )
        );
      }
    }

    // Trigger 4: Material Cutting Completed -> Assign Assembly & Painting
    if (
      beforeData?.tasks.material_cutting?.status !== 'completed' &&
      afterData.tasks.material_cutting?.status === 'completed'
    ) {
      const viceDirectors = await getUsersByRole('pho_giam_doc');
      if (viceDirectors.length > 0) {
        const userToAssign = viceDirectors[0];
        updates['tasks.assembly.assignedTo'] = userToAssign.id;
        updates['tasks.painting.assignedTo'] = userToAssign.id;
        notificationPromises.push(
          sendNotificationToUsers(
            viceDirectors,
            'Y√™u c·∫ßu gi√°m s√°t',
            `C√¥ng ƒëo·∫°n C·∫Øt ph√¥i ƒë√£ xong. Vui l√≤ng gi√°m s√°t v√† th·ª±c hi·ªán L·∫Øp r√°p & S∆°n cho d·ª± √°n ${projectName}.`
          )
        );
      }
    }

    // Trigger 5: Assembly & Painting Completed -> Assign Shipping
    if (
      afterData.tasks.assembly?.status === 'completed' &&
      afterData.tasks.painting?.status === 'completed' &&
      (beforeData?.tasks.assembly?.status !== 'completed' ||
        beforeData?.tasks.painting?.status !== 'completed')
    ) {
      const usersToNotify = await getUsersByRole(['ke_toan', 'pho_giam_doc']);
      const accountant = usersToNotify.find((u) => u.role === 'ke_toan');

      if (accountant) {
        updates['tasks.shipping.assignedTo'] = accountant.id;
      }
      notificationPromises.push(
        sendNotificationToUsers(
          usersToNotify,
          'Y√™u c·∫ßu v·∫≠n chuy·ªÉn',
          `D·ª± √°n ${projectName} ƒë√£ s·∫µn s√†ng. Vui l√≤ng s·∫Øp x·∫øp v·∫≠n chuy·ªÉn.`
        )
      );
    }

    // --- Denormalization Logic (runs on any task change) ---
    const denormalizationPromises: Promise<any>[] = [];
    const beforeTasks = beforeData?.tasks || {};
    const afterTasks = afterData.tasks || {};

    for (const taskKey in afterTasks) {
      if (
        Object.prototype.hasOwnProperty.call(afterTasks, taskKey) &&
        JSON.stringify(beforeTasks[taskKey]) !==
          JSON.stringify(afterTasks[taskKey])
      ) {
        denormalizationPromises.push(
          denormalizeTask(
            projectId,
            projectName,
            afterData.status,
            taskKey,
            afterTasks[taskKey]
          )
        );
      }
    }

    // --- Execute Updates and Notifications ---
    const allPromises: Promise<any>[] = [
      ...notificationPromises,
      ...denormalizationPromises,
    ];

    if (Object.keys(updates).length > 0 && event.data) {
      // Add timestamp to avoid recursive triggers for the same update
      updates['workflowUpdatedAt'] =
        admin.firestore.FieldValue.serverTimestamp();
      allPromises.push(event.data.after.ref.update(updates));
    }

    return Promise.all(allPromises);
  }
);


--- END: functions\src\taskTriggers.ts ---


--- START: functions\src\uploadInstructionMedia.ts ---
 

--- END: functions\src\uploadInstructionMedia.ts ---


